[{"bug_name": "Chart_1", "report_text": "> #983 Potential NPE in AbstractCategoryItemRender.getLegendItems()\n> \n> Setting up a working copy of the current JFreeChart trunk in Eclipse I got a warning about a null pointer access in this bit of code from AbstractCategoryItemRender.java:\n> public LegendItemCollection getLegendItems() {  \n> LegendItemCollection result = new LegendItemCollection();  \n> if (this.plot == null) {  \n> return result;  \n> }  \n> int index = this.plot.getIndexOf(this);  \n> CategoryDataset dataset = this.plot.getDataset(index);  \n> if (dataset != null) {  \n> return result;  \n> }  \n> int seriesCount = dataset.getRowCount();  \n> ...  \n> }\n> The warning is in the last code line where seriesCount is assigned. The variable dataset is guaranteed to be null in this location, I suppose that the check before that should actually read \"if (dataset == null)\", not \"if (dataset != null)\".\n> This is trunk as of 2010-02-08.", "test_name": "org.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests::test2947660", "test_method": "    public void test2947660() {\n        AbstractCategoryItemRenderer r = new LineAndShapeRenderer();\n\n        DefaultCategoryDataset dataset = new DefaultCategoryDataset();\n        CategoryPlot plot = new CategoryPlot();\n        plot.setDataset(dataset);\n        plot.setRenderer(r);\n\n        dataset.addValue(1.0, \"S1\", \"C1\");\n        LegendItemCollection lic = r.getLegendItems();\n        assertEquals(1, lic.getItemCount()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\torg.jfree.chart.renderer.category.junit.AbstractCategoryItemRendererTests.test2947660(AbstractCategoryItemRendererTests.java:409)", "buggy_method": "1790 public LegendItemCollection getLegendItems() {\r\n1791         LegendItemCollection result = new LegendItemCollection();\r\n1792         if (this.plot == null) {\r\n1793             return result;\r\n1794         }\r\n1795         int index = this.plot.getIndexOf(this);\r\n1796         CategoryDataset dataset = this.plot.getDataset(index);\r\n1797         if (dataset != null) {\r\n1798             return result;\r\n1799         }\r\n1800         int seriesCount = dataset.getRowCount();\r\n1801         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\r\n1802             for (int i = 0; i < seriesCount; i++) {\r\n1803                 if (isSeriesVisibleInLegend(i)) {\r\n1804                     LegendItem item = getLegendItem(index, i);\r\n1805                     if (item != null) {\r\n1806                         result.add(item);\r\n1807                     }\r\n1808                 }\r\n1809             }\r\n1810         }\r\n1811         else {\r\n1812             for (int i = seriesCount - 1; i >= 0; i--) {\r\n1813                 if (isSeriesVisibleInLegend(i)) {\r\n1814                     LegendItem item = getLegendItem(index, i);\r\n1815                     if (item != null) {\r\n1816                         result.add(item);\r\n1817                     }\r\n1818                 }\r\n1819             }\r\n1820         }\r\n1821         return result;\r\n1822     }", "bm_classpath": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer"}, {"bug_name": "Chart_2", "report_text": "> #959 Bugs in DatasetUtilities.iterateRangeBounds() methods\n> \n> All explained in this forum post:\n> <http://www.jfree.org/phpBB2/viewtopic.php?f=3&t=29171>", "test_name": "org.jfree.data.general.junit.DatasetUtilitiesTests::testBug2849731_2", "test_method": "    public void testBug2849731_2() {\n        XYIntervalSeriesCollection d = new XYIntervalSeriesCollection();\n        XYIntervalSeries s = new XYIntervalSeries(\"S1\");\n        s.add(1.0, Double.NaN, Double.NaN, Double.NaN, 1.5, Double.NaN);\n        d.addSeries(s);\n        Range r = DatasetUtilities.iterateDomainBounds(d);\n        assertEquals(1.0, r.getLowerBound(), EPSILON); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jfree.data.general.junit.DatasetUtilitiesTests.testBug2849731_2(DatasetUtilitiesTests.java:1276)", "buggy_method": "740 public static Range iterateDomainBounds(XYDataset dataset,\r\n741                                             boolean includeInterval) {\r\n742         if (dataset == null) {\r\n743             throw new IllegalArgumentException(\"Null 'dataset' argument.\");\r\n744         }\r\n745         double minimum = Double.POSITIVE_INFINITY;\r\n746         double maximum = Double.NEGATIVE_INFINITY;\r\n747         int seriesCount = dataset.getSeriesCount();\r\n748         double lvalue;\r\n749         double uvalue;\r\n750         if (includeInterval && dataset instanceof IntervalXYDataset) {\r\n751             IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\r\n752             for (int series = 0; series < seriesCount; series++) {\r\n753                 int itemCount = dataset.getItemCount(series);\r\n754                 for (int item = 0; item < itemCount; item++) {\r\n755                     lvalue = intervalXYData.getStartXValue(series, item);\r\n756                     uvalue = intervalXYData.getEndXValue(series, item);\r\n757                     if (!Double.isNaN(lvalue)) {\r\n758                         minimum = Math.min(minimum, lvalue);\r\n759                     }\r\n760                     if (!Double.isNaN(uvalue)) {\r\n761                         maximum = Math.max(maximum, uvalue);\r\n762                     }\r\n763                 }\r\n764             }\r\n765         }\r\n766         else {\r\n767             for (int series = 0; series < seriesCount; series++) {\r\n768                 int itemCount = dataset.getItemCount(series);\r\n769                 for (int item = 0; item < itemCount; item++) {\r\n770                     lvalue = dataset.getXValue(series, item);\r\n771                     uvalue = lvalue;\r\n772                     if (!Double.isNaN(lvalue)) {\r\n773                         minimum = Math.min(minimum, lvalue);\r\n774                         maximum = Math.max(maximum, uvalue);\r\n775                     }\r\n776                 }\r\n777             }\r\n778         }\r\n779         if (minimum > maximum) {\r\n780             return null;\r\n781         }\r\n782         else {\r\n783             return new Range(minimum, maximum);\r\n784         }\r\n785     }", "bm_classpath": "org.jfree.data.general.DatasetUtilities"}, {"bug_name": "Chart_3", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.time.junit.TimeSeriesTests::testCreateCopy3", "test_method": "    public void testCreateCopy3() throws CloneNotSupportedException {\n        TimeSeries s1 = new TimeSeries(\"S1\");\n        s1.add(new Year(2009), 100.0);\n        s1.add(new Year(2010), 101.0);\n        s1.add(new Year(2011), 102.0);\n\n        TimeSeries s2 = s1.createCopy(0, 1);\n        assertEquals(101.0, s2.getMaxY(), EPSILON); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<101.0> but was:<102.0>\n\torg.jfree.data.time.junit.TimeSeriesTests.testCreateCopy3(TimeSeriesTests.java:607)", "buggy_method": "1048 public TimeSeries createCopy(int start, int end)\r\n1049             throws CloneNotSupportedException {\r\n1050         if (start < 0) {\r\n1051             throw new IllegalArgumentException(\"Requires start >= 0.\");\r\n1052         }\r\n1053         if (end < start) {\r\n1054             throw new IllegalArgumentException(\"Requires start <= end.\");\r\n1055         }\r\n1056         TimeSeries copy = (TimeSeries) super.clone();\r\n1057         copy.data = new java.util.ArrayList();\r\n1058         if (this.data.size() > 0) {\r\n1059             for (int index = start; index <= end; index++) {\r\n1060                 TimeSeriesDataItem item\r\n1061                         = (TimeSeriesDataItem) this.data.get(index);\r\n1062                 TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\r\n1063                 try {\r\n1064                     copy.add(clone);\r\n1065                 }\r\n1066                 catch (SeriesException e) {\r\n1067                     e.printStackTrace();\r\n1068                 }\r\n1069             }\r\n1070         }\r\n1071         return copy;\r\n1072     }", "bm_classpath": "org.jfree.data.time.TimeSeries"}, {"bug_name": "Chart_4", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.axis.junit.LogAxisTests::testXYAutoRange1", "test_method": "    public void testXYAutoRange1() {\n        XYSeries series = new XYSeries(\"Series 1\");\n        series.add(1.0, 1.0);\n        series.add(2.0, 2.0);\n        series.add(3.0, 3.0);\n        XYSeriesCollection dataset = new XYSeriesCollection();\n        dataset.addSeries(series);\n        JFreeChart chart = ChartFactory.createScatterPlot(\n            \"Test\",\n            \"X\",\n            \"Y\",\n            dataset,\n            PlotOrientation.VERTICAL,\n            false,\n            false,\n            false\n        ); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jfree.chart.plot.XYPlot.getDataRange(XYPlot.java:4493)\n\torg.jfree.chart.axis.NumberAxis.autoAdjustRange(NumberAxis.java:434)\n\torg.jfree.chart.axis.NumberAxis.configure(NumberAxis.java:417)\n\torg.jfree.chart.axis.Axis.setPlot(Axis.java:1044)\n\torg.jfree.chart.plot.XYPlot.<init>(XYPlot.java:660)\n\torg.jfree.chart.ChartFactory.createScatterPlot(ChartFactory.java:1490)\n\torg.jfree.chart.axis.junit.LogAxisTests.testXYAutoRange1(LogAxisTests.java:260)", "buggy_method": "4425 public Range getDataRange(ValueAxis axis) {\r\n4426 \r\n4427         Range result = null;\r\n4428         List mappedDatasets = new ArrayList();\r\n4429         List includedAnnotations = new ArrayList();\r\n4430         boolean isDomainAxis = true;\r\n4431 \r\n4432         // is it a domain axis?\r\n4433         int domainIndex = getDomainAxisIndex(axis);\r\n4434         if (domainIndex >= 0) {\r\n4435             isDomainAxis = true;\r\n4436             mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\r\n4437                     new Integer(domainIndex)));\r\n4438             if (domainIndex == 0) {\r\n4439                 // grab the plot's annotations\r\n4440                 Iterator iterator = this.annotations.iterator();\r\n4441                 while (iterator.hasNext()) {\r\n4442                     XYAnnotation annotation = (XYAnnotation) iterator.next();\r\n4443                     if (annotation instanceof XYAnnotationBoundsInfo) {\r\n4444                         includedAnnotations.add(annotation);\r\n4445                     }\r\n4446                 }\r\n4447             }\r\n4448         }\r\n4449 \r\n4450         // or is it a range axis?\r\n4451         int rangeIndex = getRangeAxisIndex(axis);\r\n4452         if (rangeIndex >= 0) {\r\n4453             isDomainAxis = false;\r\n4454             mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\r\n4455                     new Integer(rangeIndex)));\r\n4456             if (rangeIndex == 0) {\r\n4457                 Iterator iterator = this.annotations.iterator();\r\n4458                 while (iterator.hasNext()) {\r\n4459                     XYAnnotation annotation = (XYAnnotation) iterator.next();\r\n4460                     if (annotation instanceof XYAnnotationBoundsInfo) {\r\n4461                         includedAnnotations.add(annotation);\r\n4462                     }\r\n4463                 }\r\n4464             }\r\n4465         }\r\n4466 \r\n4467         // iterate through the datasets that map to the axis and get the union\r\n4468         // of the ranges.\r\n4469         Iterator iterator = mappedDatasets.iterator();\r\n4470         while (iterator.hasNext()) {\r\n4471             XYDataset d = (XYDataset) iterator.next();\r\n4472             if (d != null) {\r\n4473                 XYItemRenderer r = getRendererForDataset(d);\r\n4474                 if (isDomainAxis) {\r\n4475                     if (r != null) {\r\n4476                         result = Range.combine(result, r.findDomainBounds(d));\r\n4477                     }\r\n4478                     else {\r\n4479                         result = Range.combine(result,\r\n4480                                 DatasetUtilities.findDomainBounds(d));\r\n4481                     }\r\n4482                 }\r\n4483                 else {\r\n4484                     if (r != null) {\r\n4485                         result = Range.combine(result, r.findRangeBounds(d));\r\n4486                     }\r\n4487                     else {\r\n4488                         result = Range.combine(result,\r\n4489                                 DatasetUtilities.findRangeBounds(d));\r\n4490                     }\r\n4491                 }\r\n4492                 \r\n4493                     Collection c = r.getAnnotations();\r\n4494                     Iterator i = c.iterator();\r\n4495                     while (i.hasNext()) {\r\n4496                         XYAnnotation a = (XYAnnotation) i.next();\r\n4497                         if (a instanceof XYAnnotationBoundsInfo) {\r\n4498                             includedAnnotations.add(a);\r\n4499                         }\r\n4500                     }\r\n4501             }\r\n4502         }\r\n4503 \r\n4504         Iterator it = includedAnnotations.iterator();\r\n4505         while (it.hasNext()) {\r\n4506             XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\r\n4507             if (xyabi.getIncludeInDataBounds()) {\r\n4508                 if (isDomainAxis) {\r\n4509                     result = Range.combine(result, xyabi.getXRange());\r\n4510                 }\r\n4511                 else {\r\n4512                     result = Range.combine(result, xyabi.getYRange());\r\n4513                 }\r\n4514             }\r\n4515         }\r\n4516 \r\n4517         return result;\r\n4518 \r\n4519     }", "bm_classpath": "org.jfree.chart.plot.XYPlot"}, {"bug_name": "Chart_5", "report_text": "> #862 XYSeries.addOrUpdate() should add if duplicates are allowed\n> \n> Copied from this post (by Ted Schwartz) in the forum:\n> <http://www.jfree.org/phpBB2/viewtopic.php?t=24523>\n> I've found a bug in jfreechart-1.0.9 code for org.jfree.data.xy.XYSeries. There was a change some time ago which introduced the notion of allowing duplicate X values in XYSeries data. The method addOrUpdate(Number x, Number y) was never modified to support this, and therefore duplicate data were overwriting existing data. This is the fix I've made, but I don't know how to submit a patch...\n> $ diff original/jfreechart-1.0.9/source/org/jfree/data/xy/XYSeries.java fixed/org/jfree/data/xy/XYSeries.java  \n> 537c537  \n> < if (index >= 0) {  \n> ---  \n> > if (index >= 0 && !allowDuplicateXValues) {  \n> 545a546,559  \n> > } else if (index >= 0){  \n> > XYDataItem item = new XYDataItem(x, y);  \n> > // need to make sure we are adding \\*after\\* any duplicates  \n> > int size = this.data.size();  \n> > while (index < size  \n> > && item.compareTo(this.data.get(index)) == 0) {  \n> > index++;  \n> > }  \n> > if (index < this.data.size()) {  \n> > this.data.add(index, item);  \n> > }  \n> > else {  \n> > this.data.add(item);  \n> > }  \n> 558,561d571  \n> < // check if this addition will exceed the maximum item count...  \n> < if (getItemCount() > this.maximumItemCount) {  \n> < this.data.remove(0);  \n> < }  \n> 562a573,576  \n> > // check if this addition will exceed the maximum item count...  \n> > if (getItemCount() > this.maximumItemCount) {  \n> > this.data.remove(0);  \n> > }", "test_name": "org.jfree.data.xy.junit.XYSeriesTests::testBug1955483", "test_method": "    public void testBug1955483() {\n        XYSeries series = new XYSeries(\"Series\", true, true);\n        series.addOrUpdate(1.0, 1.0);\n        series.addOrUpdate(1.0, 2.0); // <-- fails here\n    }", "error_message": "java.lang.IndexOutOfBoundsException: Index: -1, Size: 1\n\tjava.util.ArrayList.rangeCheckForAdd(ArrayList.java:667)\n\tjava.util.ArrayList.add(ArrayList.java:479)\n\torg.jfree.data.xy.XYSeries.addOrUpdate(XYSeries.java:564)\n\torg.jfree.data.xy.XYSeries.addOrUpdate(XYSeries.java:527)\n\torg.jfree.data.xy.junit.XYSeriesTests.testBug1955483(XYSeriesTests.java:479)", "buggy_method": "540 public XYDataItem addOrUpdate(Number x, Number y) {\r\n541         if (x == null) {\r\n542             throw new IllegalArgumentException(\"Null 'x' argument.\");\r\n543         }\r\n544 \r\n545         // if we get to here, we know that duplicate X values are not permitted\r\n546         XYDataItem overwritten = null;\r\n547         int index = indexOf(x);\r\n548         if (index >= 0 && !this.allowDuplicateXValues) {\r\n549             XYDataItem existing = (XYDataItem) this.data.get(index);\r\n550             try {\r\n551                 overwritten = (XYDataItem) existing.clone();\r\n552             }\r\n553             catch (CloneNotSupportedException e) {\r\n554                 throw new SeriesException(\"Couldn't clone XYDataItem!\");\r\n555             }\r\n556             existing.setY(y);\r\n557         }\r\n558         else {\r\n559             // if the series is sorted, the negative index is a result from\r\n560             // Collections.binarySearch() and tells us where to insert the\r\n561             // new item...otherwise it will be just -1 and we should just\r\n562             // append the value to the list...\r\n563             if (this.autoSort) {\r\n564                 this.data.add(-index - 1, new XYDataItem(x, y));\r\n565             }\r\n566             else {\r\n567                 this.data.add(new XYDataItem(x, y));\r\n568             }\r\n569             // check if this addition will exceed the maximum item count...\r\n570             if (getItemCount() > this.maximumItemCount) {\r\n571                 this.data.remove(0);\r\n572             }\r\n573         }\r\n574         fireSeriesChanged();\r\n575         return overwritten;\r\n576     }", "bm_classpath": "org.jfree.data.xy.XYSeries"}, {"bug_name": "Chart_6", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.util.junit.ShapeListTests::testSerialization", "test_method": "    public void testSerialization() {\r\n\r\n        ShapeList l1 = new ShapeList();\r\n        l1.setShape(0, new Rectangle(1, 2, 3, 4));\r\n        l1.setShape(1, new Line2D.Double(1.0, 2.0, 3.0, 4.0));\r\n        l1.setShape(2, null);\r\n\r\n        ShapeList l2 = null;\r\n\r\n        try {\r\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n            ObjectOutput out = new ObjectOutputStream(buffer);\r\n            out.writeObject(l1);\r\n            out.close();\r\n\r\n            ObjectInput in = new ObjectInputStream(new ByteArrayInputStream(\r\n            \t\tbuffer.toByteArray()));\r\n            l2 = (ShapeList) in.readObject();\r\n            in.close();\r\n        }\r\n        catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        assertEquals(l1, l2); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<org.jfree.chart.util.ShapeList@b190e392> but was:<org.jfree.chart.util.ShapeList@b1170841>\n\torg.jfree.chart.util.junit.ShapeListTests.testSerialization(ShapeListTests.java:151)", "buggy_method": "103 public boolean equals(Object obj) {\n104 \n105         if (obj == this) {\n106             return true;\n107         }\n108         if (!(obj instanceof ShapeList)) {\n109             return false;\n110         }\n111         return super.equals(obj);\n112 \n113     }", "bm_classpath": "org.jfree.chart.util.ShapeList"}, {"bug_name": "Chart_7", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.time.junit.TimePeriodValuesTests::testGetMaxMiddleIndex", "test_method": "    public void testGetMaxMiddleIndex() {\n        TimePeriodValues s = new TimePeriodValues(\"Test\");\n        s.add(new SimpleTimePeriod(100L, 200L), 1.0);\n        s.add(new SimpleTimePeriod(300L, 400L), 2.0);\n        s.add(new SimpleTimePeriod(0L, 50L), 3.0);\n        s.add(new SimpleTimePeriod(150L, 200L), 4.0);\n        assertEquals(1, s.getMaxMiddleIndex()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<3>\n\torg.jfree.data.time.junit.TimePeriodValuesTests.testGetMaxMiddleIndex(TimePeriodValuesTests.java:377)", "buggy_method": "257 private void updateBounds(TimePeriod period, int index) {\r\n258         \r\n259         long start = period.getStart().getTime();\r\n260         long end = period.getEnd().getTime();\r\n261         long middle = start + ((end - start) / 2);\r\n262 \r\n263         if (this.minStartIndex >= 0) {\r\n264             long minStart = getDataItem(this.minStartIndex).getPeriod()\r\n265                 .getStart().getTime();\r\n266             if (start < minStart) {\r\n267                 this.minStartIndex = index;           \r\n268             }\r\n269         }\r\n270         else {\r\n271             this.minStartIndex = index;\r\n272         }\r\n273         \r\n274         if (this.maxStartIndex >= 0) {\r\n275             long maxStart = getDataItem(this.maxStartIndex).getPeriod()\r\n276                 .getStart().getTime();\r\n277             if (start > maxStart) {\r\n278                 this.maxStartIndex = index;           \r\n279             }\r\n280         }\r\n281         else {\r\n282             this.maxStartIndex = index;\r\n283         }\r\n284         \r\n285         if (this.minMiddleIndex >= 0) {\r\n286             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n287                 .getTime();\r\n288             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n289                 .getTime();\r\n290             long minMiddle = s + (e - s) / 2;\r\n291             if (middle < minMiddle) {\r\n292                 this.minMiddleIndex = index;           \r\n293             }\r\n294         }\r\n295         else {\r\n296             this.minMiddleIndex = index;\r\n297         }\r\n298         \r\n299         if (this.maxMiddleIndex >= 0) {\r\n300             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\r\n301                 .getTime();\r\n302             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\r\n303                 .getTime();\r\n304             long maxMiddle = s + (e - s) / 2;\r\n305             if (middle > maxMiddle) {\r\n306                 this.maxMiddleIndex = index;           \r\n307             }\r\n308         }\r\n309         else {\r\n310             this.maxMiddleIndex = index;\r\n311         }\r\n312         \r\n313         if (this.minEndIndex >= 0) {\r\n314             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\r\n315                 .getTime();\r\n316             if (end < minEnd) {\r\n317                 this.minEndIndex = index;           \r\n318             }\r\n319         }\r\n320         else {\r\n321             this.minEndIndex = index;\r\n322         }\r\n323        \r\n324         if (this.maxEndIndex >= 0) {\r\n325             long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\r\n326                 .getTime();\r\n327             if (end > maxEnd) {\r\n328                 this.maxEndIndex = index;           \r\n329             }\r\n330         }\r\n331         else {\r\n332             this.maxEndIndex = index;\r\n333         }\r\n334         \r\n335     }", "bm_classpath": "org.jfree.data.time.TimePeriodValues"}, {"bug_name": "Chart_8", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.time.junit.WeekTests::testConstructor", "test_method": "    public void testConstructor() {\n        Locale savedLocale = Locale.getDefault();\n        TimeZone savedZone = TimeZone.getDefault();\n        Locale.setDefault(new Locale(\"da\", \"DK\"));\n        TimeZone.setDefault(TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n        GregorianCalendar cal = (GregorianCalendar) Calendar.getInstance(\n                TimeZone.getDefault(), Locale.getDefault());\n\n        // first day of week is monday\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        Date t = cal.getTime();\n        Week w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n\n        Locale.setDefault(Locale.US);\n        TimeZone.setDefault(TimeZone.getTimeZone(\"US/Detroit\"));\n        cal = (GregorianCalendar) Calendar.getInstance(TimeZone.getDefault());\n        // first day of week is Sunday\n        cal.set(2007, Calendar.AUGUST, 26, 1, 0, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        t = cal.getTime();\n        w = new Week(t, TimeZone.getTimeZone(\"Europe/Copenhagen\"));\n        assertEquals(35, w.getWeek()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<35> but was:<34>\n\torg.jfree.data.time.junit.WeekTests.testConstructor(WeekTests.java:530)", "buggy_method": "173 public Week(Date time, TimeZone zone) {\r\n174         // defer argument checking...\r\n175         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\r\n176     }", "bm_classpath": "org.jfree.data.time.Week"}, {"bug_name": "Chart_9", "report_text": "> #818 Error on TimeSeries createCopy() method\n> \n> The test case at the end fails with :\n> java.lang.IllegalArgumentException: Requires start <= end.\n> The problem is in that the int start and end indexes corresponding to given timePeriod are computed incorectly. Here I would expect an empty serie to be returned, not an exception. This is with jfreechart 1.0.7\n> public class foo {  \n> static public void main(String args[]) {  \n> TimeSeries foo = new TimeSeries(\"foo\",Day.class);  \n> foo.add(new Day(19,4,2005),1);  \n> foo.add(new Day(25,5,2005),1);  \n> foo.add(new Day(28,5,2005),1);  \n> foo.add(new Day(30,5,2005),1);  \n> foo.add(new Day(1,6,2005),1);  \n> foo.add(new Day(3,6,2005),1);  \n> foo.add(new Day(19,8,2005),1);  \n> foo.add(new Day(31,1,2006),1);\n> ```\n>     try \\{\n>         TimeSeries bar = foo.createCopy\\(new Day\\(1,12,2005\\),new Day\\(18,1,2006\\)\\);\n>     \\} catch \\(CloneNotSupportedException e\\) \\{\n>         e.printStackTrace\\(\\);\n> ```\n> }  \n> }", "test_name": "org.jfree.data.time.junit.TimeSeriesTests::testBug1864222", "test_method": "    public void testBug1864222() {\n        TimeSeries s = new TimeSeries(\"S\");\n        s.add(new Day(19, 8, 2005), 1);\n        s.add(new Day(31, 1, 2006), 1);\n        boolean pass = true;\n        try {\n            s.createCopy(new Day(1, 12, 2005), new Day(18, 1, 2006));\n        }\n        catch (CloneNotSupportedException e) {\n            pass = false;\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Requires start <= end.\n\torg.jfree.data.time.TimeSeries.createCopy(TimeSeries.java:883)\n\torg.jfree.data.time.TimeSeries.createCopy(TimeSeries.java:953)\n\torg.jfree.data.time.junit.TimeSeriesTests.testBug1864222(TimeSeriesTests.java:829)", "buggy_method": "918 public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\r\n919         throws CloneNotSupportedException {\r\n920 \r\n921         if (start == null) {\r\n922             throw new IllegalArgumentException(\"Null 'start' argument.\");\r\n923         }\r\n924         if (end == null) {\r\n925             throw new IllegalArgumentException(\"Null 'end' argument.\");\r\n926         }\r\n927         if (start.compareTo(end) > 0) {\r\n928             throw new IllegalArgumentException(\r\n929                     \"Requires start on or before end.\");\r\n930         }\r\n931         boolean emptyRange = false;\r\n932         int startIndex = getIndex(start);\r\n933         if (startIndex < 0) {\r\n934             startIndex = -(startIndex + 1);\r\n935             if (startIndex == this.data.size()) {\r\n936                 emptyRange = true;  // start is after last data item\r\n937             }\r\n938         }\r\n939         int endIndex = getIndex(end);\r\n940         if (endIndex < 0) {             // end period is not in original series\r\n941             endIndex = -(endIndex + 1); // this is first item AFTER end period\r\n942             endIndex = endIndex - 1;    // so this is last item BEFORE end\r\n943         }\r\n944         if (endIndex < 0) {\r\n945             emptyRange = true;\r\n946         }\r\n947         if (emptyRange) {\r\n948             TimeSeries copy = (TimeSeries) super.clone();\r\n949             copy.data = new java.util.ArrayList();\r\n950             return copy;\r\n951         }\r\n952         else {\r\n953             return createCopy(startIndex, endIndex);\r\n954         }\r\n955 \r\n956     }", "bm_classpath": "org.jfree.data.time.TimeSeries"}, {"bug_name": "Chart_10", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.imagemap.junit.StandardToolTipTagFragmentGeneratorTests::testGenerateURLFragment", "test_method": "    public void testGenerateURLFragment() {\r\n        StandardToolTipTagFragmentGenerator g\r\n                = new StandardToolTipTagFragmentGenerator();\r\n        assertEquals(\" title=\\\"Series &quot;A&quot;, 100.0\\\" alt=\\\"\\\"\",\r\n                g.generateToolTipFragment(\"Series \\\"A\\\", 100.0\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:< title=\"Series [&quot;A&quot;], 100.0\" alt=\"\"> but was:< title=\"Series [\"A\"], 100.0\" alt=\"\">\n\torg.jfree.chart.imagemap.junit.StandardToolTipTagFragmentGeneratorTests.testGenerateURLFragment(StandardToolTipTagFragmentGeneratorTests.java:80)", "buggy_method": "64 public String generateToolTipFragment(String toolTipText) {\r\n65         return \" title=\\\"\" + toolTipText\r\n66             + \"\\\" alt=\\\"\\\"\";\r\n67     }", "bm_classpath": "org.jfree.chart.imagemap.StandardToolTipTagFragmentGenerator"}, {"bug_name": "Chart_11", "report_text": "> #868 JCommon 1.0.12 ShapeUtilities.equal(path1,path2)\n> \n> The comparison of two GeneralPath objects uses the same PathIterator for both objects. equal(GeneralPath path1, GeneralPath path2) will thus return true for any pair of non-null GeneralPath instances having the same windingRule.", "test_name": "org.jfree.chart.util.junit.ShapeUtilitiesTests::testEqualGeneralPaths", "test_method": "    public void testEqualGeneralPaths() {\r\n        GeneralPath g1 = new GeneralPath();\r\n        g1.moveTo(1.0f, 2.0f);\r\n        g1.lineTo(3.0f, 4.0f);\r\n        g1.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\r\n        g1.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\r\n        g1.closePath();\r\n        GeneralPath g2 = new GeneralPath();\r\n        g2.moveTo(1.0f, 2.0f);\r\n        g2.lineTo(3.0f, 4.0f);\r\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\r\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\r\n        g2.closePath();\r\n\r\n        g2 = new GeneralPath();\r\n        g2.moveTo(11.0f, 22.0f);\r\n        g2.lineTo(3.0f, 4.0f);\r\n        g2.curveTo(5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f);\r\n        g2.quadTo(1.0f, 2.0f, 3.0f, 4.0f);\r\n        g2.closePath();\r\n        assertFalse(ShapeUtilities.equal(g1, g2)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.util.junit.ShapeUtilitiesTests.testEqualGeneralPaths(ShapeUtilitiesTests.java:212)", "buggy_method": "264 public static boolean equal(GeneralPath p1, GeneralPath p2) {\n265         if (p1 == null) {\n266             return (p2 == null);\n267         }\n268         if (p2 == null) {\n269             return false;\n270         }\n271         if (p1.getWindingRule() != p2.getWindingRule()) {\n272             return false;\n273         }\n274         PathIterator iterator1 = p1.getPathIterator(null);\n275         PathIterator iterator2 = p1.getPathIterator(null);\n276         double[] d1 = new double[6];\n277         double[] d2 = new double[6];\n278         boolean done = iterator1.isDone() && iterator2.isDone();\n279         while (!done) {\n280             if (iterator1.isDone() != iterator2.isDone()) {\n281                 return false;\n282             }\n283             int seg1 = iterator1.currentSegment(d1);\n284             int seg2 = iterator2.currentSegment(d2);\n285             if (seg1 != seg2) {\n286                 return false;\n287             }\n288             if (!Arrays.equals(d1, d2)) {\n289                 return false;\n290             }\n291             iterator1.next();\n292             iterator2.next();\n293             done = iterator1.isDone() && iterator2.isDone();\n294         }\n295         return true;\n296     }", "bm_classpath": "org.jfree.chart.util.ShapeUtilities"}, {"bug_name": "Chart_12", "report_text": "> #213 Fix for MultiplePiePlot\n> \n> When dataset is passed into constructor for MultiplePiePlot, the dataset is not wired to a listener, as it would be if setDataset is called.", "test_name": "org.jfree.chart.plot.junit.MultiplePiePlotTests::testConstructor", "test_method": "    public void testConstructor() {\n    \tMultiplePiePlot plot = new MultiplePiePlot();\n\n    \t// the following checks that the plot registers itself as a listener\n    \t// with the dataset passed to the constructor - see patch 1943021\n    \tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n    \tplot = new MultiplePiePlot(dataset);\n    \tassertTrue(dataset.hasListener(plot)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.plot.junit.MultiplePiePlotTests.testConstructor(MultiplePiePlotTests.java:112)", "buggy_method": "143 public MultiplePiePlot(CategoryDataset dataset) {\r\n144         super();\r\n145         this.dataset = dataset;\r\n146         PiePlot piePlot = new PiePlot(null);\r\n147         this.pieChart = new JFreeChart(piePlot);\r\n148         this.pieChart.removeLegend();\r\n149         this.dataExtractOrder = TableOrder.BY_COLUMN;\r\n150         this.pieChart.setBackgroundPaint(null);\r\n151         TextTitle seriesTitle = new TextTitle(\"Series Title\",\r\n152                 new Font(\"SansSerif\", Font.BOLD, 12));\r\n153         seriesTitle.setPosition(RectangleEdge.BOTTOM);\r\n154         this.pieChart.setTitle(seriesTitle);\r\n155         this.aggregatedItemsKey = \"Other\";\r\n156         this.aggregatedItemsPaint = Color.lightGray;\r\n157         this.sectionPaints = new HashMap();\r\n158     }", "bm_classpath": "org.jfree.chart.plot.MultiplePiePlot"}, {"bug_name": "Chart_13", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.block.junit.BorderArrangementTests::testSizingWithWidthConstraint", "test_method": "    public void testSizingWithWidthConstraint() {\n        RectangleConstraint constraint = new RectangleConstraint(\n            10.0, new Range(10.0, 10.0), LengthConstraintType.FIXED,\n            0.0, new Range(0.0, 0.0), LengthConstraintType.NONE\n        );\n                \n        BlockContainer container = new BlockContainer(new BorderArrangement());\n        BufferedImage image = new BufferedImage(\n            200, 100, BufferedImage.TYPE_INT_RGB\n        );\n        Graphics2D g2 = image.createGraphics();\n        \n        // TBLRC\n        // 00001 - center item only\n        container.add(new EmptyBlock(5.0, 6.0));\n        Size2D size = container.arrange(g2, constraint);\n        \n        container.clear();\n        container.add(new EmptyBlock(15.0, 16.0));\n        size = container.arrange(g2, constraint);\n\n        // TBLRC\n        // 00010 - right item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        \n        // TBLRC\n        // 00011 - right and center items\n        container.clear();\n        container.add(new EmptyBlock(7.0, 20.0));\n        container.add(new EmptyBlock(8.0, 45.6), RectangleEdge.RIGHT);\n        size = container.arrange(g2, constraint);\n        \n        // TBLRC\n        // 00100 - left item only\n        container.clear();\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        \n        // TBLRC\n        // 00101 - left and center items\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0));\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint);\n        \n        // TBLRC\n        // 00110 - left and right items\n        container.clear();\n        container.add(new EmptyBlock(10.0, 20.0), RectangleEdge.RIGHT);\n        container.add(new EmptyBlock(12.3, 45.6), RectangleEdge.LEFT);\n        size = container.arrange(g2, constraint); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Range(double, double): require lower (0.0) <= upper (-2.3000000000000007).\n\torg.jfree.data.Range.<init>(Range.java:87)\n\torg.jfree.chart.block.BorderArrangement.arrangeFF(BorderArrangement.java:454)\n\torg.jfree.chart.block.BorderArrangement.arrange(BorderArrangement.java:152)\n\torg.jfree.chart.block.BorderArrangement.arrangeFN(BorderArrangement.java:323)\n\torg.jfree.chart.block.BorderArrangement.arrange(BorderArrangement.java:149)\n\torg.jfree.chart.block.BlockContainer.arrange(BlockContainer.java:182)\n\torg.jfree.chart.block.junit.BorderArrangementTests.testSizingWithWidthConstraint(BorderArrangementTests.java:560)", "buggy_method": "422 protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\r\n423                                RectangleConstraint constraint) {\r\n424         double[] w = new double[5];\r\n425         double[] h = new double[5];\r\n426         w[0] = constraint.getWidth();\r\n427         if (this.topBlock != null) {\r\n428             RectangleConstraint c1 = new RectangleConstraint(w[0], null,\r\n429                     LengthConstraintType.FIXED, 0.0,\r\n430                     new Range(0.0, constraint.getHeight()),\r\n431                     LengthConstraintType.RANGE);\r\n432             Size2D size = this.topBlock.arrange(g2, c1);\r\n433             h[0] = size.height;\r\n434         }\r\n435         w[1] = w[0];\r\n436         if (this.bottomBlock != null) {\r\n437             RectangleConstraint c2 = new RectangleConstraint(w[0], null,\r\n438                     LengthConstraintType.FIXED, 0.0, new Range(0.0,\r\n439                     constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\r\n440             Size2D size = this.bottomBlock.arrange(g2, c2);\r\n441             h[1] = size.height;\r\n442         }\r\n443         h[2] = constraint.getHeight() - h[1] - h[0];\r\n444         if (this.leftBlock != null) {\r\n445             RectangleConstraint c3 = new RectangleConstraint(0.0,\r\n446                     new Range(0.0, constraint.getWidth()),\r\n447                     LengthConstraintType.RANGE, h[2], null,\r\n448                     LengthConstraintType.FIXED);\r\n449             Size2D size = this.leftBlock.arrange(g2, c3);\r\n450             w[2] = size.width;\r\n451         }\r\n452         h[3] = h[2];\r\n453         if (this.rightBlock != null) {\r\n454             RectangleConstraint c4 = new RectangleConstraint(0.0,\r\n455                     new Range(0.0, constraint.getWidth() - w[2]),\r\n456                     LengthConstraintType.RANGE, h[2], null,\r\n457                     LengthConstraintType.FIXED);\r\n458             Size2D size = this.rightBlock.arrange(g2, c4);\r\n459             w[3] = size.width;\r\n460         }\r\n461         h[4] = h[2];\r\n462         w[4] = constraint.getWidth() - w[3] - w[2];\r\n463         RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\r\n464         if (this.centerBlock != null) {\r\n465             this.centerBlock.arrange(g2, c5);\r\n466         }\r\n467 \r\n468         if (this.topBlock != null) {\r\n469             this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\r\n470                     h[0]));\r\n471         }\r\n472         if (this.bottomBlock != null) {\r\n473             this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\r\n474                     w[1], h[1]));\r\n475         }\r\n476         if (this.leftBlock != null) {\r\n477             this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\r\n478                     h[2]));\r\n479         }\r\n480         if (this.rightBlock != null) {\r\n481             this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\r\n482                     w[3], h[3]));\r\n483         }\r\n484         if (this.centerBlock != null) {\r\n485             this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\r\n486                     h[4]));\r\n487         }\r\n488         return new Size2D(constraint.getWidth(), constraint.getHeight());\r\n489     }", "bm_classpath": "org.jfree.chart.block.BorderArrangement"}, {"bug_name": "Chart_14", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.plot.junit.CategoryPlotTests::testRemoveRangeMarker", "test_method": "    public void testRemoveRangeMarker() {\n    \tCategoryPlot plot = new CategoryPlot();\n    \tassertFalse(plot.removeRangeMarker(new ValueMarker(0.5))); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jfree.chart.plot.CategoryPlot.removeRangeMarker(CategoryPlot.java:2448)\n\torg.jfree.chart.plot.CategoryPlot.removeRangeMarker(CategoryPlot.java:2415)\n\torg.jfree.chart.plot.CategoryPlot.removeRangeMarker(CategoryPlot.java:2396)\n\torg.jfree.chart.plot.CategoryPlot.removeRangeMarker(CategoryPlot.java:2378)\n\torg.jfree.chart.plot.junit.CategoryPlotTests.testRemoveRangeMarker(CategoryPlotTests.java:780)", "buggy_method": "2155 public boolean removeDomainMarker(int index, Marker marker, Layer layer,\r\n2156     \t\tboolean notify) {\r\n2157         ArrayList markers;\r\n2158         if (layer == Layer.FOREGROUND) {\r\n2159             markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\r\n2160                     index));\r\n2161         }\r\n2162         else {\r\n2163             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\r\n2164                     index));\r\n2165         }\r\n2166         boolean removed = markers.remove(marker);\r\n2167         if (removed && notify) {\r\n2168             fireChangeEvent();\r\n2169         }\r\n2170         return removed;\r\n2171     }", "bm_classpath": "org.jfree.chart.plot.CategoryPlot"}, {"bug_name": "Chart_15", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.plot.junit.PiePlot3DTests::testDrawWithNullDataset", "test_method": "    public void testDrawWithNullDataset() {\n        JFreeChart chart = ChartFactory.createPieChart3D(\"Test\", null, true, \n                false, false);\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.plot.junit.PiePlot3DTests.testDrawWithNullDataset(PiePlot3DTests.java:151)", "buggy_method": "1377 public double getMaximumExplodePercent() {\r\n1378         double result = 0.0;\r\n1379         Iterator iterator = this.dataset.getKeys().iterator();\r\n1380         while (iterator.hasNext()) {\r\n1381             Comparable key = (Comparable) iterator.next();\r\n1382             Number explode = (Number) this.explodePercentages.get(key);\r\n1383             if (explode != null) {\r\n1384                 result = Math.max(result, explode.doubleValue());   \r\n1385             }\r\n1386         }\r\n1387         return result;\r\n1388     }", "bm_classpath": "org.jfree.chart.plot.PiePlot"}, {"bug_name": "Chart_16", "report_text": "> #834 Bug propgated from v1.0.5 on to present\n> \n> The method getRowCount() in class org.jfree.data.category.DefaultIntervalCategoryDataset says that it \"Returns the number of series in the dataset (possibly zero).\" \n> The implementation from v1.0.5 on no longer checks for a null condition (which would then return a zero) on the seriesKeys as it did in v1.0.4 and previous. This now throws a Null Pointer if seriesKeys never got initialized and the getRowCount() method is called.", "test_name": "org.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests::testGetCategoryIndex", "test_method": "    public void testGetCategoryIndex() {\n    \t// check an empty dataset\n    \tDefaultIntervalCategoryDataset empty \n    \t        = new DefaultIntervalCategoryDataset(new double[0][0], \n    \t        \t\tnew double[0][0]);\n    \tassertEquals(-1, empty.getCategoryIndex(\"ABC\")); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jfree.data.category.DefaultIntervalCategoryDataset.getCategoryIndex(DefaultIntervalCategoryDataset.java:574)\n\torg.jfree.data.category.junit.DefaultIntervalCategoryDatasetTests.testGetCategoryIndex(DefaultIntervalCategoryDatasetTests.java:415)", "buggy_method": "142 public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\r\n143                                           Comparable[] categoryKeys,\r\n144                                           Number[][] starts,\r\n145                                           Number[][] ends) {\r\n146 \r\n147         this.startData = starts;\r\n148         this.endData = ends;\r\n149 \r\n150         if (starts != null && ends != null) {\r\n151 \r\n152             String baseName = \"org.jfree.data.resources.DataPackageResources\";\r\n153             ResourceBundle resources = ResourceBundle.getBundle(baseName);\r\n154 \r\n155             int seriesCount = starts.length;\r\n156             if (seriesCount != ends.length) {\r\n157                 String errMsg = \"DefaultIntervalCategoryDataset: the number \"\r\n158                     + \"of series in the start value dataset does \"\r\n159                     + \"not match the number of series in the end \"\r\n160                     + \"value dataset.\";\r\n161                 throw new IllegalArgumentException(errMsg);\r\n162             }\r\n163             if (seriesCount > 0) {\r\n164 \r\n165                 // set up the series names...\r\n166                 if (seriesKeys != null) {\r\n167 \r\n168                     if (seriesKeys.length != seriesCount) {\r\n169                         throw new IllegalArgumentException(\r\n170                                 \"The number of series keys does not \"\r\n171                                 + \"match the number of series in the data.\");\r\n172                     }\r\n173 \r\n174                     this.seriesKeys = seriesKeys;\r\n175                 }\r\n176                 else {\r\n177                     String prefix = resources.getString(\r\n178                             \"series.default-prefix\") + \" \";\r\n179                     this.seriesKeys = generateKeys(seriesCount, prefix);\r\n180                 }\r\n181 \r\n182                 // set up the category names...\r\n183                 int categoryCount = starts[0].length;\r\n184                 if (categoryCount != ends[0].length) {\r\n185                     String errMsg = \"DefaultIntervalCategoryDataset: the \"\r\n186                                 + \"number of categories in the start value \"\r\n187                                 + \"dataset does not match the number of \"\r\n188                                 + \"categories in the end value dataset.\";\r\n189                     throw new IllegalArgumentException(errMsg);\r\n190                 }\r\n191                 if (categoryKeys != null) {\r\n192                     if (categoryKeys.length != categoryCount) {\r\n193                         throw new IllegalArgumentException(\r\n194                                 \"The number of category keys does not match \"\r\n195                                 + \"the number of categories in the data.\");\r\n196                     }\r\n197                     this.categoryKeys = categoryKeys;\r\n198                 }\r\n199                 else {\r\n200                     String prefix = resources.getString(\r\n201                             \"categories.default-prefix\") + \" \";\r\n202                     this.categoryKeys = generateKeys(categoryCount, prefix);\r\n203                 }\r\n204 \r\n205             }\r\n206             else {\r\n207                 this.seriesKeys = null;\r\n208                 this.categoryKeys = null;\r\n209             }\r\n210         }\r\n211 \r\n212     }", "bm_classpath": "org.jfree.data.category.DefaultIntervalCategoryDataset"}, {"bug_name": "Chart_17", "report_text": "> #803 cloning of TimeSeries\n> \n> It's just a minor bug!\n> When I clone a TimeSeries which has no items, I get an IllegalArgumentException (\"Requires start <= end\").  \n> But I don't think the user should be responsible for checking whether the TimeSeries has any items or not.", "test_name": "org.jfree.data.time.junit.TimeSeriesTests::testBug1832432", "test_method": "    public void testBug1832432() {\n        TimeSeries s1 = new TimeSeries(\"Series\");\n        TimeSeries s2 = null;\n        try {\n            s2 = (TimeSeries) s1.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Requires start <= end.\n\torg.jfree.data.time.TimeSeries.createCopy(TimeSeries.java:880)\n\torg.jfree.data.time.TimeSeries.clone(TimeSeries.java:857)\n\torg.jfree.data.time.junit.TimeSeriesTests.testBug1832432(TimeSeriesTests.java:619)", "buggy_method": "856 public Object clone() throws CloneNotSupportedException {\r\n857         Object clone = createCopy(0, getItemCount() - 1);\r\n858         return clone;\r\n859     }", "bm_classpath": "org.jfree.data.time.TimeSeries"}, {"bug_name": "Chart_18", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.category.junit.DefaultCategoryDatasetTests::testBug1835955", "test_method": "    public void testBug1835955() {\n    \tDefaultCategoryDataset d = new DefaultCategoryDataset();\n    \td.addValue(1.0, \"R1\", \"C1\");\n    \td.addValue(2.0, \"R2\", \"C2\");\n    \td.removeColumn(\"C2\");\n    \td.addValue(3.0, \"R2\", \"C2\"); // <-- fails here\n    }", "error_message": "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n\tjava.util.ArrayList.rangeCheck(ArrayList.java:659)\n\tjava.util.ArrayList.set(ArrayList.java:450)\n\torg.jfree.data.DefaultKeyedValues.setValue(DefaultKeyedValues.java:234)\n\torg.jfree.data.DefaultKeyedValues2D.setValue(DefaultKeyedValues2D.java:337)\n\torg.jfree.data.DefaultKeyedValues2D.addValue(DefaultKeyedValues2D.java:303)\n\torg.jfree.data.category.DefaultCategoryDataset.addValue(DefaultCategoryDataset.java:218)\n\torg.jfree.data.category.DefaultCategoryDataset.addValue(DefaultCategoryDataset.java:233)\n\torg.jfree.data.category.junit.DefaultCategoryDatasetTests.testBug1835955(DefaultCategoryDatasetTests.java:350)", "buggy_method": "332 public void removeValue(Comparable key) {\n333         int index = getIndex(key);\n334         if (index < 0) {\n335 \t\t\treturn;\n336         }\n337         removeValue(index);\n338     }", "bm_classpath": "org.jfree.data.DefaultKeyedValues"}, {"bug_name": "Chart_19", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.plot.junit.CategoryPlotTests::testGetRangeAxisIndex", "test_method": "    public void testGetRangeAxisIndex() {\n        CategoryAxis domainAxis1 = new CategoryAxis(\"X1\");\n        NumberAxis rangeAxis1 = new NumberAxis(\"Y1\");\n        NumberAxis rangeAxis2 = new NumberAxis(\"Y2\");\n        CategoryPlot plot = new CategoryPlot(null, domainAxis1, rangeAxis1, \n                null);\n        plot.setRangeAxis(1, rangeAxis2);\n        boolean pass = false;\n        try {\n            plot.getRangeAxisIndex(null);\n        }\n        catch (IllegalArgumentException e) {\n            pass = true;\n        }\n        assertTrue(pass); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.plot.junit.CategoryPlotTests.testGetRangeAxisIndex(CategoryPlotTests.java:761)", "buggy_method": "697 public int getDomainAxisIndex(CategoryAxis axis) {\r\n698         return this.domainAxes.indexOf(axis);\r\n699     }", "bm_classpath": "org.jfree.chart.plot.CategoryPlot"}, {"bug_name": "Chart_20", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.plot.junit.ValueMarkerTests::test1808376", "test_method": "    public void test1808376() {\n        Stroke stroke = new BasicStroke(1.0f);\n        Stroke outlineStroke = new BasicStroke(2.0f);\n        ValueMarker m = new ValueMarker(1.0, Color.red, stroke, Color.blue, \n                outlineStroke, 0.5f);\n        assertEquals(Color.blue, m.getOutlinePaint()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<java.awt.Color[r=0,g=0,b=255]> but was:<java.awt.Color[r=255,g=0,b=0]>\n\torg.jfree.chart.plot.junit.ValueMarkerTests.test1808376(ValueMarkerTests.java:297)", "buggy_method": "93 public ValueMarker(double value, Paint paint, Stroke stroke, \r\n94                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\r\n95         super(paint, stroke, paint, stroke, alpha);\r\n96         this.value = value;\r\n97     }", "bm_classpath": "org.jfree.chart.plot.ValueMarker"}, {"bug_name": "Chart_21", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.statistics.junit.DefaultBoxAndWhiskerCategoryDatasetTests::testGetRangeBounds", "test_method": "    public void testGetRangeBounds() {\n        DefaultBoxAndWhiskerCategoryDataset d1 \n                = new DefaultBoxAndWhiskerCategoryDataset();\n        d1.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, \n                new ArrayList()), \"R1\", \"C1\");\n        \n        d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, \n                new ArrayList()), \"R1\", \"C1\");\n        \n        d1.add(new BoxAndWhiskerItem(2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, \n                new ArrayList()), \"R2\", \"C1\");\n        \n        // this replaces the entry with the current minimum value, but the new\n        // minimum value is now in a different item\n        d1.add(new BoxAndWhiskerItem(1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 8.6, 9.6, \n                new ArrayList()), \"R1\", \"C1\");\n        assertEquals(new Range(8.5, 9.6), d1.getRangeBounds(false)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Range[8.5,9.6]> but was:<Range[8.6,9.6]>\n\torg.jfree.data.statistics.junit.DefaultBoxAndWhiskerCategoryDatasetTests.testGetRangeBounds(DefaultBoxAndWhiskerCategoryDatasetTests.java:292)", "buggy_method": "144 public void add(BoxAndWhiskerItem item, Comparable rowKey, \r\n145             Comparable columnKey) {\r\n146 \r\n147         this.data.addObject(item, rowKey, columnKey);\r\n148         \r\n149         // update cached min and max values\r\n150         int r = this.data.getRowIndex(rowKey);\r\n151         int c = this.data.getColumnIndex(columnKey);\r\n152         if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn \r\n153                 == c) || (this.minimumRangeValueRow == r \r\n154                 && this.minimumRangeValueColumn == c))  {\r\n155             updateBounds();\r\n156         }\r\n157         \r\n158             double minval = Double.NaN;\r\n159             if (item.getMinOutlier() != null) {\r\n160                 minval = item.getMinOutlier().doubleValue();\r\n161             }\r\n162             double maxval = Double.NaN;\r\n163             if (item.getMaxOutlier() != null) {\r\n164                 maxval = item.getMaxOutlier().doubleValue();\r\n165             }\r\n166         \r\n167             if (Double.isNaN(this.maximumRangeValue)) {\r\n168                 this.maximumRangeValue = maxval;\r\n169                 this.maximumRangeValueRow = r;\r\n170                 this.maximumRangeValueColumn = c;\r\n171             }\r\n172             else if (maxval > this.maximumRangeValue) {\r\n173                 this.maximumRangeValue = maxval;\r\n174                 this.maximumRangeValueRow = r;\r\n175                 this.maximumRangeValueColumn = c;\r\n176             }\r\n177         \r\n178             if (Double.isNaN(this.minimumRangeValue)) {\r\n179                 this.minimumRangeValue = minval;\r\n180                 this.minimumRangeValueRow = r;\r\n181                 this.minimumRangeValueColumn = c;\r\n182             }\r\n183             else if (minval < this.minimumRangeValue) {\r\n184                 this.minimumRangeValue = minval;\r\n185                 this.minimumRangeValueRow = r;\r\n186                 this.minimumRangeValueColumn = c;\r\n187             }\r\n188         \r\n189         this.rangeBounds = new Range(this.minimumRangeValue,\r\n190               this.maximumRangeValue);\r\n191         fireDatasetChanged();\r\n192 \r\n193     }", "bm_classpath": "org.jfree.data.statistics.DefaultBoxAndWhiskerCategoryDataset"}, {"bug_name": "Chart_22", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.data.junit.KeyedObjects2DTests::testRemoveColumnByKey", "test_method": "    public void testRemoveColumnByKey() {\n        KeyedObjects2D data = new KeyedObjects2D();\n        data.setObject(\"Obj1\", \"R1\", \"C1\");\n        data.setObject(\"Obj2\", \"R2\", \"C2\");\n        data.removeColumn(\"C2\"); // <-- fails here\n    }", "error_message": "org.jfree.data.UnknownKeyException: The key (C2) is not recognised.\n\torg.jfree.data.KeyedObjects.removeValue(KeyedObjects.java:268)\n\torg.jfree.data.KeyedObjects2D.removeColumn(KeyedObjects2D.java:378)\n\torg.jfree.data.junit.KeyedObjects2DTests.testRemoveColumnByKey(KeyedObjects2DTests.java:391)", "buggy_method": "214 public Object getObject(Comparable rowKey, Comparable columnKey) {\r\n215         if (rowKey == null) {\r\n216             throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\r\n217         }\r\n218         if (columnKey == null) {\r\n219             throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\r\n220         }\r\n221         int row = this.rowKeys.indexOf(rowKey);\r\n222         if (row < 0) {\r\n223             throw new UnknownKeyException(\"Row key (\" + rowKey \r\n224                     + \") not recognised.\");\r\n225         }\r\n226         int column = this.columnKeys.indexOf(columnKey);\r\n227         if (column < 0) {\r\n228             throw new UnknownKeyException(\"Column key (\" + columnKey \r\n229                     + \") not recognised.\");\r\n230         }\r\n231         if (row >= 0) {\r\n232         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\r\n233             return rowData.getObject(columnKey);\r\n234         }\r\n235         else {\r\n236             return null;\r\n237         }\r\n238     }", "bm_classpath": "org.jfree.data.KeyedObjects2D"}, {"bug_name": "Chart_24", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.renderer.junit.GrayPaintScaleTests::testGetPaint", "test_method": "    public void testGetPaint() {\n        GrayPaintScale gps = new GrayPaintScale();\n        Color c = (Color) gps.getPaint(0.0);\n        c = (Color) gps.getPaint(1.0);\n        \n        // check lookup values that are outside the bounds - see bug report\n        // 1767315\n        c = (Color) gps.getPaint(-0.5); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Color parameter outside of expected range: Red Green Blue\n\tjava.awt.Color.testColorValueRange(Color.java:310)\n\tjava.awt.Color.<init>(Color.java:395)\n\tjava.awt.Color.<init>(Color.java:369)\n\torg.jfree.chart.renderer.GrayPaintScale.getPaint(GrayPaintScale.java:128)\n\torg.jfree.chart.renderer.junit.GrayPaintScaleTests.testGetPaint(GrayPaintScaleTests.java:107)", "buggy_method": "123 public Paint getPaint(double value) {\r\n124         double v = Math.max(value, this.lowerBound);\r\n125         v = Math.min(v, this.upperBound);\r\n126         int g = (int) ((value - this.lowerBound) / (this.upperBound \r\n127                 - this.lowerBound) * 255.0);\r\n128         return new Color(g, g, g);\r\n129     }", "bm_classpath": "org.jfree.chart.renderer.GrayPaintScale"}, {"bug_name": "Chart_25", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests::testDrawWithNullMeanVertical", "test_method": "    public void testDrawWithNullMeanVertical() {\n        boolean success = false;\n        try {\n            DefaultStatisticalCategoryDataset dataset \n                    = new DefaultStatisticalCategoryDataset();\n            dataset.add(1.0, 2.0, \"S1\", \"C1\");\n            dataset.add(null, new Double(4.0), \"S1\", \"C2\");\n            CategoryPlot plot = new CategoryPlot(dataset, \n                    new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), \n                    new StatisticalBarRenderer());\n            JFreeChart chart = new JFreeChart(plot);\n            /* BufferedImage image = */ chart.createBufferedImage(300, 200, \n                    null);\n            success = true;\n        }\n        catch (NullPointerException e) {\n            e.printStackTrace();\n            success = false;\n        }\n        assertTrue(success); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.renderer.category.junit.StatisticalBarRendererTests.testDrawWithNullMeanVertical(StatisticalBarRendererTests.java:208)", "buggy_method": "230 protected void drawHorizontalItem(Graphics2D g2,\r\n231                                       CategoryItemRendererState state,\r\n232                                       Rectangle2D dataArea,\r\n233                                       CategoryPlot plot,\r\n234                                       CategoryAxis domainAxis,\r\n235                                       ValueAxis rangeAxis,\r\n236                                       StatisticalCategoryDataset dataset,\r\n237                                       int row,\r\n238                                       int column) {\r\n239                                      \r\n240         RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\r\n241         \r\n242         // BAR Y\r\n243         double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \r\n244                 dataArea, xAxisLocation);\r\n245 \r\n246         int seriesCount = getRowCount();\r\n247         int categoryCount = getColumnCount();\r\n248         if (seriesCount > 1) {\r\n249             double seriesGap = dataArea.getHeight() * getItemMargin()\r\n250                                / (categoryCount * (seriesCount - 1));\r\n251             rectY = rectY + row * (state.getBarWidth() + seriesGap);\r\n252         }\r\n253         else {\r\n254             rectY = rectY + row * state.getBarWidth();\r\n255         }\r\n256 \r\n257         // BAR X\r\n258         Number meanValue = dataset.getMeanValue(row, column);\r\n259 \r\n260         double value = meanValue.doubleValue();\r\n261         double base = 0.0;\r\n262         double lclip = getLowerClip();\r\n263         double uclip = getUpperClip();\r\n264 \r\n265         if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\r\n266             if (value >= uclip) {\r\n267                 return; // bar is not visible\r\n268             }\r\n269             base = uclip;\r\n270             if (value <= lclip) {\r\n271                 value = lclip;\r\n272             }\r\n273         }\r\n274         else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\r\n275             if (value >= uclip) {\r\n276                 value = uclip;\r\n277             }\r\n278             else {\r\n279                 if (value <= lclip) {\r\n280                     value = lclip;\r\n281                 }\r\n282             }\r\n283         }\r\n284         else { // cases 9, 10, 11 and 12\r\n285             if (value <= lclip) {\r\n286                 return; // bar is not visible\r\n287             }\r\n288             base = getLowerClip();\r\n289             if (value >= uclip) {\r\n290                value = uclip;\r\n291             }\r\n292         }\r\n293 \r\n294         RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\r\n295         double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\r\n296         double transY2 = rangeAxis.valueToJava2D(value, dataArea, \r\n297                 yAxisLocation);\r\n298         double rectX = Math.min(transY2, transY1);\r\n299 \r\n300         double rectHeight = state.getBarWidth();\r\n301         double rectWidth = Math.abs(transY2 - transY1);\r\n302 \r\n303         Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \r\n304                 rectHeight);\r\n305         Paint seriesPaint = getItemPaint(row, column);\r\n306         g2.setPaint(seriesPaint);\r\n307         g2.fill(bar);\r\n308         if (isDrawBarOutline() && state.getBarWidth() > 3) {\r\n309             g2.setStroke(getItemStroke(row, column));\r\n310             g2.setPaint(getItemOutlinePaint(row, column));\r\n311             g2.draw(bar);\r\n312         }\r\n313 \r\n314         // standard deviation lines\r\n315             double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\r\n316             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n317                     + valueDelta, dataArea, yAxisLocation);\r\n318             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \r\n319                     - valueDelta, dataArea, yAxisLocation);\r\n320 \r\n321             if (this.errorIndicatorStroke != null) {\r\n322                 g2.setStroke(this.errorIndicatorStroke);\r\n323             }\r\n324             else {\r\n325                 g2.setStroke(getItemOutlineStroke(row, column));\r\n326             }\r\n327             if (this.errorIndicatorPaint != null) {\r\n328                 g2.setPaint(this.errorIndicatorPaint);  \r\n329             }\r\n330             else {\r\n331                 g2.setPaint(getItemOutlinePaint(row, column));   \r\n332             }\r\n333         \r\n334             Line2D line = null;\r\n335             line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \r\n336                                      highVal, rectY + rectHeight / 2.0d);\r\n337             g2.draw(line);\r\n338             line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \r\n339                                      highVal, rectY + rectHeight * 0.75);\r\n340             g2.draw(line);\r\n341             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \r\n342                                      lowVal, rectY + rectHeight * 0.75);\r\n343             g2.draw(line);\r\n344         \r\n345         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \r\n346                 column);\r\n347         if (generator != null && isItemLabelVisible(row, column)) {\r\n348             drawItemLabel(g2, dataset, row, column, plot, generator, bar, \r\n349                     (value < 0.0));\r\n350         }        \r\n351 \r\n352         // add an item entity, if this information is being collected\r\n353         EntityCollection entities = state.getEntityCollection();\r\n354         if (entities != null) {\r\n355             addItemEntity(entities, dataset, row, column, bar);\r\n356         }\r\n357 \r\n358     }", "bm_classpath": "org.jfree.chart.renderer.category.StatisticalBarRenderer"}, {"bug_name": "Chart_26", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jfree.chart.junit.AreaChartTests::testDrawWithNullInfo", "test_method": "    public void testDrawWithNullInfo() {\n        boolean success = false;\n        try {\n            BufferedImage image = new BufferedImage(200 , 100, \n                    BufferedImage.TYPE_INT_RGB);\n            Graphics2D g2 = image.createGraphics();\n            this.chart.draw(g2, new Rectangle2D.Double(0, 0, 200, 100), null, \n                    null);\n            g2.dispose();\n            success = true;\n        }\n        catch (Exception e) {\n            success = false;\n        }\n        assertTrue(success); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.jfree.chart.junit.AreaChartTests.testDrawWithNullInfo(AreaChartTests.java:149)", "buggy_method": "1092 protected AxisState drawLabel(String label, Graphics2D g2, \r\n1093             Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \r\n1094             AxisState state, PlotRenderingInfo plotState) {\r\n1095 \r\n1096         // it is unlikely that 'state' will be null, but check anyway...\r\n1097         if (state == null) {\r\n1098             throw new IllegalArgumentException(\"Null 'state' argument.\");\r\n1099         }\r\n1100         \r\n1101         if ((label == null) || (label.equals(\"\"))) {\r\n1102             return state;\r\n1103         }\r\n1104 \r\n1105         Font font = getLabelFont();\r\n1106         RectangleInsets insets = getLabelInsets();\r\n1107         g2.setFont(font);\r\n1108         g2.setPaint(getLabelPaint());\r\n1109         FontMetrics fm = g2.getFontMetrics();\r\n1110         Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\r\n1111         Shape hotspot = null;\r\n1112         \r\n1113         if (edge == RectangleEdge.TOP) {\r\n1114             AffineTransform t = AffineTransform.getRotateInstance(\r\n1115                     getLabelAngle(), labelBounds.getCenterX(), \r\n1116                     labelBounds.getCenterY());\r\n1117             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n1118             labelBounds = rotatedLabelBounds.getBounds2D();\r\n1119             float w = (float) labelBounds.getWidth();\r\n1120             float h = (float) labelBounds.getHeight();\r\n1121             float labelx = (float) dataArea.getCenterX();\r\n1122             float labely = (float) (state.getCursor() - insets.getBottom() \r\n1123                     - h / 2.0);\r\n1124             TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n1125                     TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n1126             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n1127                     labely - h / 2.0f, w, h);\r\n1128             state.cursorUp(insets.getTop() + labelBounds.getHeight() \r\n1129                     + insets.getBottom());\r\n1130         }\r\n1131         else if (edge == RectangleEdge.BOTTOM) {\r\n1132             AffineTransform t = AffineTransform.getRotateInstance(\r\n1133                     getLabelAngle(), labelBounds.getCenterX(), \r\n1134                     labelBounds.getCenterY());\r\n1135             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n1136             labelBounds = rotatedLabelBounds.getBounds2D();\r\n1137             float w = (float) labelBounds.getWidth();\r\n1138             float h = (float) labelBounds.getHeight();\r\n1139             float labelx = (float) dataArea.getCenterX();\r\n1140             float labely = (float) (state.getCursor() + insets.getTop() \r\n1141                     + h / 2.0);\r\n1142             TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n1143                     TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\r\n1144             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n1145                     labely - h / 2.0f, w, h);\r\n1146             state.cursorDown(insets.getTop() + labelBounds.getHeight() \r\n1147                     + insets.getBottom());\r\n1148         }\r\n1149         else if (edge == RectangleEdge.LEFT) {\r\n1150             AffineTransform t = AffineTransform.getRotateInstance(\r\n1151                     getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \r\n1152                     labelBounds.getCenterY());\r\n1153             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n1154             labelBounds = rotatedLabelBounds.getBounds2D();\r\n1155             float w = (float) labelBounds.getWidth();\r\n1156             float h = (float) labelBounds.getHeight();\r\n1157             float labelx = (float) (state.getCursor() - insets.getRight() \r\n1158                     - w / 2.0);\r\n1159             float labely = (float) dataArea.getCenterY();\r\n1160             TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n1161                     TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \r\n1162                     TextAnchor.CENTER);\r\n1163             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n1164                     labely - h / 2.0f, w, h);\r\n1165             state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \r\n1166                     + insets.getRight());\r\n1167         }\r\n1168         else if (edge == RectangleEdge.RIGHT) {\r\n1169 \r\n1170             AffineTransform t = AffineTransform.getRotateInstance(\r\n1171                     getLabelAngle() + Math.PI / 2.0, \r\n1172                     labelBounds.getCenterX(), labelBounds.getCenterY());\r\n1173             Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\r\n1174             labelBounds = rotatedLabelBounds.getBounds2D();\r\n1175             float w = (float) labelBounds.getWidth();\r\n1176             float h = (float) labelBounds.getHeight();\r\n1177             float labelx = (float) (state.getCursor() \r\n1178                             + insets.getLeft() + w / 2.0);\r\n1179             float labely = (float) (dataArea.getY() + dataArea.getHeight() \r\n1180                     / 2.0);\r\n1181             TextUtilities.drawRotatedString(label, g2, labelx, labely, \r\n1182                     TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \r\n1183                     TextAnchor.CENTER);\r\n1184             hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \r\n1185                     labely - h / 2.0f, w, h);\r\n1186             state.cursorRight(insets.getLeft() + labelBounds.getWidth() \r\n1187                     + insets.getRight());\r\n1188 \r\n1189         }\r\n1190         if (plotState != null && hotspot != null) {\r\n1191             ChartRenderingInfo owner = plotState.getOwner();\r\n1192                 EntityCollection entities = owner.getEntityCollection();\r\n1193                 if (entities != null) {\r\n1194                     entities.add(new AxisLabelEntity(this, hotspot, \r\n1195                             this.labelToolTip, this.labelURL));\r\n1196                 }\r\n1197         }\r\n1198         return state;\r\n1199 \r\n1200     }", "bm_classpath": "org.jfree.chart.axis.Axis"}, {"bug_name": "Cli_1", "report_text": "> [cli] CommandLine.getOptionValue() behaves contrary to docs\n> \n> Hi\n> If I have:\n> final String debugOpt = \"debug\";  \n>  Option debug = OptionBuilder  \n>  .withArgName(debugOpt)  \n>  .withDescription(\"turn on debugging\")  \n>  .withLongOpt(debugOpt)  \n>  .create('d');\n> and then later I do:\n> String dbg = commandLine.getOptionValue(debugOpt);\n> then dbg will be null. Instead, I have to use getOptionValue('d'). This seems  \n> contrary to the docs (see bottom of  \n> <http://jakarta.apache.org/commons/cli/usage.html>), which implies that I should  \n> be able to query the commandLine object using a full string, rather than just  \n> the string's first character.\n> Can I suggest that the API of OptionBuilder be made clearer so that it is  \n> obvious that you can have long and short option names---perhaps make the  \n> create() method take no arguments (thus forcing long and short arg names to be  \n> set explicitly). (Also, there seems to be some confusion between the terms  \n> 'argument' and 'option' in the API, but perhaps that is just me).\n> Also, I would hop to be able to query commandLine by either a single char or an  \n> entire string, as suggested by the docs.\n> Thanks,\n> Chris", "test_name": "org.apache.commons.cli.bug.BugCLI13Test::testCLI13", "test_method": "    public void testCLI13()\n        throws ParseException\n    {\n        final String debugOpt = \"debug\";\n        Option debug = OptionBuilder\n            .withArgName( debugOpt )\n            .withDescription( \"turn on debugging\" )\n            .withLongOpt( debugOpt )\n            .hasArg()\n            .create( 'd' );\n        Options options = new Options();\n        options.addOption( debug );\n        CommandLine commandLine = new PosixParser().parse( options, new String[]{\"-d\", \"true\"} );\n\n        assertTrue(commandLine.hasOption( debugOpt)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.cli.bug.BugCLI13Test.testCLI13(BugCLI13Test.java:50)", "buggy_method": "67 public boolean hasOption(String opt)\n68     {\n69         return options.containsKey(opt);\n70     }", "bm_classpath": "org.apache.commons.cli.CommandLine"}, {"bug_name": "Cli_2", "report_text": "> [cli] Parameter value \"-something\" misinterpreted as a parameter\n> \n> If a parameter value is passed that contains a hyphen as the (delimited) first   \n> character, CLI parses this a parameter. For example using the call  \n> java myclass -t \"-something\"  \n> Results in the parser creating the invalid parameter -o (noting that it is   \n> skipping the 's')\n> My code is using the Posix parser as follows  \n> Options options = buildCommandLineOptions();  \n> CommandLineParser parser = new PosixParser();  \n> CommandLine commandLine = null;  \n> try {\n>  commandLine = parser.parse(options, args);  \n> }  \n> catch (ParseException e) {\n>  System.out.println(\"Invalid parameters. \" + e.getMessage() + NEW\\_LINE);  \n>  System.exit(EXIT\\_CODE\\_ERROR);  \n> }\n> This has been tested against the nightly build dated 20050503.", "test_name": "org.apache.commons.cli.bug.BugCLI51Test::test", "test_method": "    public void test() throws Exception\n    {\n        Options options = buildCommandLineOptions();\n        CommandLineParser parser = new PosixParser();\n        String[] args = new String[] {\"-t\", \"-something\" };\n        CommandLine commandLine;\n        commandLine = parser.parse( options, args ); // <-- fails here\n    }", "error_message": "org.apache.commons.cli.UnrecognizedOptionException: Unrecognized option: -o\n\torg.apache.commons.cli.Parser.processOption(Parser.java:368)\n\torg.apache.commons.cli.Parser.parse(Parser.java:185)\n\torg.apache.commons.cli.Parser.parse(Parser.java:70)\n\torg.apache.commons.cli.bug.BugCLI51Test.test(BugCLI51Test.java:40)", "buggy_method": "278 protected void burstToken(String token, boolean stopAtNonOption)\n279     {\n280         int tokenLength = token.length();\n281 \n282         for (int i = 1; i < tokenLength; i++)\n283         {\n284             String ch = String.valueOf(token.charAt(i));\n285             boolean hasOption = options.hasOption(ch);\n286 \n287             if (hasOption)\n288             {\n289                 tokens.add(\"-\" + ch);\n290                 currentOption = options.getOption(ch);\n291 \n292                 if (currentOption.hasArg() && (token.length() != (i + 1)))\n293                 {\n294                     tokens.add(token.substring(i + 1));\n295 \n296                     break;\n297                 }\n298             }\n299             else if (stopAtNonOption)\n300             {\n301                 process(token.substring(i));\n302             }\n303             else\n304             {\n305                 tokens.add(\"-\" + ch);\n306             }\n307         }\n308     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_3", "report_text": "> PosixParser interupts \"-target opt\" as \"-t arget opt\"\n> \n> This was posted on the Commons-Developer list and confirmed as a bug.\n> > Is this a bug? Or am I using this incorrectly?  \n> > I have an option with short and long values. Given code that is   \n> > essentially what is below, with a PosixParser I see results as   \n> > follows:  \n> >   \n> > A command line with just \"-t\" prints out the results of the catch   \n> > block  \n> > (OK)  \n> > A command line with just \"-target\" prints out the results of the catch  \n> > block (OK)  \n> > A command line with just \"-t foobar.com\" prints out \"processing selected  \n> > target: foobar.com\" (OK)  \n> > A command line with just \"-target foobar.com\" prints out \"processing  \n> > selected target: arget\" (ERROR?)  \n> >   \n> > ======================================================================  \n> > ==  \n> > =======================  \n> > private static final String OPTION\\_TARGET = \"t\";  \n> > private static final String OPTION\\_TARGET\\_LONG = \"target\";  \n> > // ...  \n> > Option generateTarget = new Option(OPTION\\_TARGET,   \n> > OPTION\\_TARGET\\_LONG,   \n> > true,   \n> > \"Generate files for the specified  \n> > target machine\");  \n> > // ...  \n> > try \n> {\n> > parsedLine = parser.parse(cmdLineOpts, args);\n> > }\n>  catch (ParseException pe) \n> {\n> > System.out.println(\"Invalid command: \" + pe.getMessage() +\n> > \"\\n\");\n> > HelpFormatter hf = new HelpFormatter();\n> > hf.printHelp(USAGE, cmdLineOpts);\n> > System.exit(-1);\n> > }\n> >   \n> > if (parsedLine.hasOption(OPTION\\_TARGET)) \n> {\n> > System.out.println(\"processing selected target: \" +\n> > parsedLine.getOptionValue(OPTION\\_TARGET)); \n> > }\n> It is a bug but it is due to well defined behaviour (so that makes me feel a  \n> little better about myself ![](/jira/images/icons/emoticons/wink.png). To support **special**   \n> (well I call them special anyway) like -Dsystem.property=value we need to be  \n> able to examine the first character of an option. If the first character is  \n> itself defined as an Option then the remainder of the token is used as the  \n> value, e.g. 'D' is the token, it is an option so 'system.property=value' is the  \n> argument value for that option. This is the behaviour that we are seeing for  \n> your example.   \n> 't' is the token, it is an options so 'arget' is the argument value. \n> I suppose a solution to this could be to have a way to specify properties for  \n> parsers. In this case 'posix.special.option == true' for turning   \n> on **special** options. I'll have a look into this and let you know.\n> Just to keep track of this and to get you used to how we operate, can you log a  \n> bug in bugzilla for this.\n> Thanks,  \n> -John K", "test_name": "org.apache.commons.cli.PatternOptionBuilderTest::testSimplePattern", "test_method": "   public void testSimplePattern()\n   {\n       try {\n           Options options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\n           String[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\n      \n           CommandLineParser parser = new PosixParser();\n           CommandLine line = parser.parse(options,args);\n\n           // tests the char methods of CommandLine that delegate to\n           // the String methods\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\n           assertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\n           assertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject(\"b\"));\n           assertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject('b'));\n           assertEquals(\"boolean true flag c\", true, line.hasOption(\"c\"));\n           assertEquals(\"boolean true flag c\", true, line.hasOption('c'));\n           assertEquals(\"boolean false flag d\", false, line.hasOption(\"d\"));\n           assertEquals(\"boolean false flag d\", false, line.hasOption('d'));\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject(\"e\"));\n           assertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject('e'));\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject(\"f\"));\n           assertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f'));\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\n           assertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n'));\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject(\"t\"));\n           assertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject('t'));\n           /// DATES NOT SUPPORTED YET.\n           //      assertEquals(\"number flag t\", new java.util.Date(1023400137276L), line.getOptionObject('z'));\n           //     input is:  \"Thu Jun 06 17:48:57 EDT 2002\"\n       }\n       catch( ParseException exp ) {\n           fail( exp.getMessage() );\n       }\n       catch( java.net.MalformedURLException exp ) {\n           fail( exp.getMessage() );\n       } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: number flag n expected:<4.5> but was:<4.5>\n\torg.apache.commons.cli.PatternOptionBuilderTest.testSimplePattern(PatternOptionBuilderTest.java:70)", "buggy_method": "158 public static Number createNumber(String str)\n159     {\n160         try\n161         {\n162             return NumberUtils.createNumber(str);\n163         }\n164         catch (NumberFormatException nfe)\n165         {\n166             System.err.println(nfe.getMessage());\n167         }\n168 \n169         return null;\n170     }", "bm_classpath": "org.apache.commons.cli.TypeHandler"}, {"bug_name": "Cli_4", "report_text": "> PosixParser interupts \"-target opt\" as \"-t arget opt\"\n> \n> This was posted on the Commons-Developer list and confirmed as a bug.\n> > Is this a bug? Or am I using this incorrectly?  \n> > I have an option with short and long values. Given code that is   \n> > essentially what is below, with a PosixParser I see results as   \n> > follows:  \n> >   \n> > A command line with just \"-t\" prints out the results of the catch   \n> > block  \n> > (OK)  \n> > A command line with just \"-target\" prints out the results of the catch  \n> > block (OK)  \n> > A command line with just \"-t foobar.com\" prints out \"processing selected  \n> > target: foobar.com\" (OK)  \n> > A command line with just \"-target foobar.com\" prints out \"processing  \n> > selected target: arget\" (ERROR?)  \n> >   \n> > ======================================================================  \n> > ==  \n> > =======================  \n> > private static final String OPTION\\_TARGET = \"t\";  \n> > private static final String OPTION\\_TARGET\\_LONG = \"target\";  \n> > // ...  \n> > Option generateTarget = new Option(OPTION\\_TARGET,   \n> > OPTION\\_TARGET\\_LONG,   \n> > true,   \n> > \"Generate files for the specified  \n> > target machine\");  \n> > // ...  \n> > try \n> {\n> > parsedLine = parser.parse(cmdLineOpts, args);\n> > }\n>  catch (ParseException pe) \n> {\n> > System.out.println(\"Invalid command: \" + pe.getMessage() +\n> > \"\\n\");\n> > HelpFormatter hf = new HelpFormatter();\n> > hf.printHelp(USAGE, cmdLineOpts);\n> > System.exit(-1);\n> > }\n> >   \n> > if (parsedLine.hasOption(OPTION\\_TARGET)) \n> {\n> > System.out.println(\"processing selected target: \" +\n> > parsedLine.getOptionValue(OPTION\\_TARGET)); \n> > }\n> It is a bug but it is due to well defined behaviour (so that makes me feel a  \n> little better about myself ![](/jira/images/icons/emoticons/wink.png). To support **special**   \n> (well I call them special anyway) like -Dsystem.property=value we need to be  \n> able to examine the first character of an option. If the first character is  \n> itself defined as an Option then the remainder of the token is used as the  \n> value, e.g. 'D' is the token, it is an option so 'system.property=value' is the  \n> argument value for that option. This is the behaviour that we are seeing for  \n> your example.   \n> 't' is the token, it is an options so 'arget' is the argument value. \n> I suppose a solution to this could be to have a way to specify properties for  \n> parsers. In this case 'posix.special.option == true' for turning   \n> on **special** options. I'll have a look into this and let you know.\n> Just to keep track of this and to get you used to how we operate, can you log a  \n> bug in bugzilla for this.\n> Thanks,  \n> -John K", "test_name": "org.apache.commons.cli.OptionsTest::testMissingOptionsException", "test_method": "    public void testMissingOptionsException() throws ParseException {\n        Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (MissingOptionException e) {\n            assertEquals(\"Missing required options: fx\", e.getMessage());\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[Missing required options: ]fx> but was:<[]fx>\n\torg.apache.commons.cli.OptionsTest.testMissingOptionsException(OptionsTest.java:116)", "buggy_method": "290 private void checkRequiredOptions()\n291         throws MissingOptionException\n292     {\n293         // if there are required options that have not been\n294         // processsed\n295         if (requiredOptions.size() > 0)\n296         {\n297             Iterator iter = requiredOptions.iterator();\n298             StringBuffer buff = new StringBuffer();\n299 \n300 \n301             // loop through the required options\n302             while (iter.hasNext())\n303             {\n304                 buff.append(iter.next());\n305             }\n306 \n307             throw new MissingOptionException(buff.toString());\n308         }\n309     }", "bm_classpath": "org.apache.commons.cli.Parser"}, {"bug_name": "Cli_5", "report_text": "> NullPointerException in Util.stripLeadingHyphens when passed a null argument\n> \n> If you try to do a hasOption(null), you get a NPE:\n> java.lang.NullPointerException  \n>  at org.apache.commons.cli.Util.stripLeadingHyphens(Util.java:39)  \n>  at org.apache.commons.cli.CommandLine.resolveOption(CommandLine.java:166)  \n>  at org.apache.commons.cli.CommandLine.hasOption(CommandLine.java:68)\n> Either hasOption should reject the null argument, or the function should simply return false. I think the latter makes more since, as this is how Java collections generally work.", "test_name": "org.apache.commons.cli.UtilTest::testStripLeadingHyphens", "test_method": "    public void testStripLeadingHyphens() {\n        assertNull(Util.stripLeadingHyphens(null)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.cli.Util.stripLeadingHyphens(Util.java:36)\n\torg.apache.commons.cli.UtilTest.testStripLeadingHyphens(UtilTest.java:28)", "buggy_method": "34 static String stripLeadingHyphens(String str)\n35     {\n36         if (str.startsWith(\"--\"))\n37         {\n38             return str.substring(2, str.length());\n39         }\n40         else if (str.startsWith(\"-\"))\n41         {\n42             return str.substring(1, str.length());\n43         }\n44 \n45         return str;\n46     }", "bm_classpath": "org.apache.commons.cli.Util"}, {"bug_name": "Cli_8", "report_text": "> HelpFormatter wraps incorrectly on every line beyond the first\n> \n> The method findWrapPos(...) in the HelpFormatter is a couple of bugs in the way that it deals with the \"startPos\" variable. This causes it to format every line beyond the first line by \"startPos\" to many characters, beyond the specified width. \n> To see this, create an option with a long description, and then use the help formatter to print it. The first line will be the correct length. The 2nd, 3rd, etc lines will all be too long.\n> I don't have a patch (sorry) - but here is a corrected version of the method.\n> I fixed it in two places - both were using \"width + startPos\" when they should have been using width.\n> ```\n>  protected int findWrapPos(String text, int width, int startPos)\n>     {\n>         int pos = -1;\n>         // the line ends before the max wrap pos or a new line char found\n>         if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n>             || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n>         {\n>             return pos+1;\n>         }\n>         else if ((width) >= text.length())\n>         {\n>             return -1;\n>         }\n>         // look for the last whitespace character before startPos+width\n>         pos = width;\n>         char c;\n>         while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n>                && (c != '\\n') && (c != '\\r'))\n>         {\n>             --pos;\n>         }\n>         // if we found it - just return\n>         if (pos > startPos)\n>         {\n>             return pos;\n>         }\n>         \n>         // must look for the first whitespace chearacter after startPos \n>         // + width\n>         pos = startPos + width;\n>         while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n>                && (c != '\\n') && (c != '\\r'))\n>         {\n>             ++pos;\n>         }\n>         return (pos == text.length())        ? (-1) : pos;\n>     }\n> ```", "test_name": "org.apache.commons.cli.HelpFormatterTest::testPrintWrapped", "test_method": "   public void testPrintWrapped()\n      throws Exception\n   {\n      StringBuffer sb = new StringBuffer();\n      HelpFormatter hf = new HelpFormatter();\n\n      String text = \"This is a test.\";\n      String expected;\n\n      expected = \"This is a\" + hf.getNewLine() + \"test.\";\n      hf.renderWrappedText(sb, 12, 0, text);\n\n      sb.setLength(0);\n      expected = \"This is a\" + hf.getNewLine() + \"    test.\";\n      hf.renderWrappedText(sb, 12, 4, text);\n\n      text = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n          \"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\n\n      sb.setLength(0);\n      expected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" +\n                 hf.getNewLine() +\n                 \"                        form DATE[-DATE] where DATE\" +\n                 hf.getNewLine() +\n                 \"                        has form YYYY[MM[DD]]\";\n      hf.renderWrappedText(sb, 53, 24, text);\n      assertEquals(\"single line padded text 2\", expected, sb.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: single line padded text 2 expected:<...TE[-DATE] where DATE[\n\torg.apache.commons.cli.HelpFormatterTest.testPrintWrapped(HelpFormatterTest.java:96)", "buggy_method": "792 protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n793                                              int nextLineTabStop, String text)\n794     {\n795         int pos = findWrapPos(text, width, 0);\n796 \n797         if (pos == -1)\n798         {\n799             sb.append(rtrim(text));\n800 \n801             return sb;\n802         }\n803         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n804 \n805         // all following lines must be padded with nextLineTabStop space \n806         // characters\n807         final String padding = createPadding(nextLineTabStop);\n808 \n809         while (true)\n810         {\n811             text = padding + text.substring(pos).trim();\n812             pos = findWrapPos(text, width, nextLineTabStop);\n813 \n814             if (pos == -1)\n815             {\n816                 sb.append(text);\n817 \n818                 return sb;\n819             }\n820 \n821             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n822         }\n823     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_9", "report_text": "> MissingOptionException.getMessage() changed from CLI 1.0 > 1.1\n> \n> The MissingOptionException.getMessage() string changed from CLI 1.0 > 1.1. \n> CLI 1.0 was poorly formatted but readable:  \n> Missing required options: -format-source-properties\n> CLI 1.1 is almost unreadable:  \n> Missing required options: formatsourceproperties\n> In CLI 1.0 Options.addOption(Option) prefixed the stored options with a \"-\" and in CLI 1.1 it doesn't.\n> I would suggest changing Parser.checkRequiredOptions() to add the options to the error message with a prefix of \" -\":\n> OLD:   \n>  // loop through the required options  \n>  while (iter.hasNext())\n>  {\n>  buff.append(iter.next());\n>  }\n> NEW:   \n>  // loop through the required options  \n>  while (iter.hasNext())\n>  {\n>  buff.append(\" -\" + iter.next());\n>  }\n> Resulting in:  \n> Missing required options: -format -source -properties", "test_name": "org.apache.commons.cli.OptionsTest::testMissingOptionsException", "test_method": "    public void testMissingOptionsException() throws ParseException {\n        Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n        options.addOption(OptionBuilder.isRequired().create(\"x\"));\n        try {\n            new PosixParser().parse(options, new String[0]);\n            fail(\"Expected MissingOptionException to be thrown\");\n        } catch (MissingOptionException e) {\n            assertEquals(\"Missing required options: f, x\", e.getMessage());\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<... required options: f[, ]x> but was:<... required options: f[]x>\n\torg.apache.commons.cli.OptionsTest.testMissingOptionsException(OptionsTest.java:116)", "buggy_method": "303 protected void checkRequiredOptions()\n304         throws MissingOptionException\n305     {\n306         // if there are required options that have not been\n307         // processsed\n308         if (getRequiredOptions().size() > 0)\n309         {\n310             Iterator iter = getRequiredOptions().iterator();\n311             StringBuffer buff = new StringBuffer(\"Missing required option\");\n312             buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n313             buff.append(\": \");\n314 \n315 \n316             // loop through the required options\n317             while (iter.hasNext())\n318             {\n319                 buff.append(iter.next());\n320             }\n321 \n322             throw new MissingOptionException(buff.toString());\n323         }\n324     }", "bm_classpath": "org.apache.commons.cli.Parser"}, {"bug_name": "Cli_10", "report_text": "> Missing required options not throwing MissingOptionException\n> \n> When an Options object is used to parse a second set of command arguments it won't throw a MissingOptionException.\n> ```\n> import org.apache.commons.cli.CommandLine;\n> import org.apache.commons.cli.GnuParser;\n> import org.apache.commons.cli.OptionBuilder;\n> import org.apache.commons.cli.Options;\n> import org.apache.commons.cli.ParseException;\n> public class Example\n> {\n> \tpublic static void main(String[] args) throws ParseException\n> \t{\n> \t\tbrokenExample();\n> \t\tworkingExample();\n> \t}\n> \t// throws exception as expected\n> \tprivate static void workingExample() throws ParseException\n> \t{\n> \t\tString[] args = {};\n> \t\tOptions opts = new Options();\n> \t\topts.addOption(OptionBuilder.isRequired().create('v'));\n> \t\tGnuParser parser = new GnuParser();\n> \t\tCommandLine secondCL = parser.parse(opts, args);\n> \t\tSystem.out.println(\"Done workingExample\");\n> \t}\n> \t// fails to throw exception on second invocation of parse\n> \tprivate static void brokenExample() throws ParseException\n> \t{\n> \t\tString[] firstArgs = { \"-v\" };\n> \t\tString[] secondArgs = {};\n> \t\tOptions opts = new Options();\n> \t\topts.addOption(OptionBuilder.isRequired().create('v'));\n> \t\tGnuParser parser = new GnuParser();\n> \t\tCommandLine firstCL = parser.parse(opts, firstArgs);\n> \t\tCommandLine secondCL = parser.parse(opts, secondArgs);\n> \t\tSystem.out.println(\"Done brokenExample\");\n> \t}\n> }\n> ```\n> This is a result of the Options object returning the reference to its own list and the parsers modifying that list. The first call is removing the required options as they are found and subsequent calls get back an empty list.", "test_name": "org.apache.commons.cli.ParseRequiredTest::testReuseOptionsTwice", "test_method": "    public void testReuseOptionsTwice() throws Exception\n    {\n        Options opts = new Options();\n\t\topts.addOption(OptionBuilder.isRequired().create('v'));\n\n\t\tGnuParser parser = new GnuParser();\n\n        // first parsing\n        parser.parse(opts, new String[] { \"-v\" });\n\n        try\n        {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(opts, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        }\n        catch (MissingOptionException e)\n        {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: MissingOptionException not thrown\n\torg.apache.commons.cli.ParseRequiredTest.testReuseOptionsTwice(ParseRequiredTest.java:157)", "buggy_method": "44 protected void setOptions(final Options options) {\n45         this.options = options;\n46         this.requiredOptions = options.getRequiredOptions();\n47     }", "bm_classpath": "org.apache.commons.cli.Parser"}, {"bug_name": "Cli_11", "report_text": "> PosixParser interupts \"-target opt\" as \"-t arget opt\"\n> \n> This was posted on the Commons-Developer list and confirmed as a bug.\n> > Is this a bug? Or am I using this incorrectly?  \n> > I have an option with short and long values. Given code that is   \n> > essentially what is below, with a PosixParser I see results as   \n> > follows:  \n> >   \n> > A command line with just \"-t\" prints out the results of the catch   \n> > block  \n> > (OK)  \n> > A command line with just \"-target\" prints out the results of the catch  \n> > block (OK)  \n> > A command line with just \"-t foobar.com\" prints out \"processing selected  \n> > target: foobar.com\" (OK)  \n> > A command line with just \"-target foobar.com\" prints out \"processing  \n> > selected target: arget\" (ERROR?)  \n> >   \n> > ======================================================================  \n> > ==  \n> > =======================  \n> > private static final String OPTION\\_TARGET = \"t\";  \n> > private static final String OPTION\\_TARGET\\_LONG = \"target\";  \n> > // ...  \n> > Option generateTarget = new Option(OPTION\\_TARGET,   \n> > OPTION\\_TARGET\\_LONG,   \n> > true,   \n> > \"Generate files for the specified  \n> > target machine\");  \n> > // ...  \n> > try \n> {\n> > parsedLine = parser.parse(cmdLineOpts, args);\n> > }\n>  catch (ParseException pe) \n> {\n> > System.out.println(\"Invalid command: \" + pe.getMessage() +\n> > \"\\n\");\n> > HelpFormatter hf = new HelpFormatter();\n> > hf.printHelp(USAGE, cmdLineOpts);\n> > System.exit(-1);\n> > }\n> >   \n> > if (parsedLine.hasOption(OPTION\\_TARGET)) \n> {\n> > System.out.println(\"processing selected target: \" +\n> > parsedLine.getOptionValue(OPTION\\_TARGET)); \n> > }\n> It is a bug but it is due to well defined behaviour (so that makes me feel a  \n> little better about myself ![](/jira/images/icons/emoticons/wink.png). To support **special**   \n> (well I call them special anyway) like -Dsystem.property=value we need to be  \n> able to examine the first character of an option. If the first character is  \n> itself defined as an Option then the remainder of the token is used as the  \n> value, e.g. 'D' is the token, it is an option so 'system.property=value' is the  \n> argument value for that option. This is the behaviour that we are seeing for  \n> your example.   \n> 't' is the token, it is an options so 'arget' is the argument value. \n> I suppose a solution to this could be to have a way to specify properties for  \n> parsers. In this case 'posix.special.option == true' for turning   \n> on **special** options. I'll have a look into this and let you know.\n> Just to keep track of this and to get you used to how we operate, can you log a  \n> bug in bugzilla for this.\n> Thanks,  \n> -John K", "test_name": "org.apache.commons.cli.HelpFormatterTest::testPrintOptionWithEmptyArgNameUsage", "test_method": "    public void testPrintOptionWithEmptyArgNameUsage() {\n        Option option = new Option(\"f\", true, null);\n        option.setArgName(\"\");\n        option.setRequired(true);\n\n        Options options = new Options();\n        options.addOption(option);\n\n        StringWriter out = new StringWriter();\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f\" + EOL, out.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<usage: app -f[]\n\torg.apache.commons.cli.HelpFormatterTest.testPrintOptionWithEmptyArgNameUsage(HelpFormatterTest.java:273)", "buggy_method": "613 private static void appendOption(final StringBuffer buff, \n614                                      final Option option, \n615                                      final boolean required)\n616     {\n617         if (!required)\n618         {\n619             buff.append(\"[\");\n620         }\n621 \n622         if (option.getOpt() != null)\n623         {\n624             buff.append(\"-\").append(option.getOpt());\n625         }\n626         else\n627         {\n628             buff.append(\"--\").append(option.getLongOpt());\n629         }\n630 \n631         // if the Option has a value\n632         if (option.hasArg() && (option.getArgName() != null))\n633         {\n634             buff.append(\" <\").append(option.getArgName()).append(\">\");\n635         }\n636 \n637         // if the Option is not a required option\n638         if (!required)\n639         {\n640             buff.append(\"]\");\n641         }\n642     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_12", "report_text": "> PosixParser interupts \"-target opt\" as \"-t arget opt\"\n> \n> This was posted on the Commons-Developer list and confirmed as a bug.\n> > Is this a bug? Or am I using this incorrectly?  \n> > I have an option with short and long values. Given code that is   \n> > essentially what is below, with a PosixParser I see results as   \n> > follows:  \n> >   \n> > A command line with just \"-t\" prints out the results of the catch   \n> > block  \n> > (OK)  \n> > A command line with just \"-target\" prints out the results of the catch  \n> > block (OK)  \n> > A command line with just \"-t foobar.com\" prints out \"processing selected  \n> > target: foobar.com\" (OK)  \n> > A command line with just \"-target foobar.com\" prints out \"processing  \n> > selected target: arget\" (ERROR?)  \n> >   \n> > ======================================================================  \n> > ==  \n> > =======================  \n> > private static final String OPTION\\_TARGET = \"t\";  \n> > private static final String OPTION\\_TARGET\\_LONG = \"target\";  \n> > // ...  \n> > Option generateTarget = new Option(OPTION\\_TARGET,   \n> > OPTION\\_TARGET\\_LONG,   \n> > true,   \n> > \"Generate files for the specified  \n> > target machine\");  \n> > // ...  \n> > try \n> {\n> > parsedLine = parser.parse(cmdLineOpts, args);\n> > }\n>  catch (ParseException pe) \n> {\n> > System.out.println(\"Invalid command: \" + pe.getMessage() +\n> > \"\\n\");\n> > HelpFormatter hf = new HelpFormatter();\n> > hf.printHelp(USAGE, cmdLineOpts);\n> > System.exit(-1);\n> > }\n> >   \n> > if (parsedLine.hasOption(OPTION\\_TARGET)) \n> {\n> > System.out.println(\"processing selected target: \" +\n> > parsedLine.getOptionValue(OPTION\\_TARGET)); \n> > }\n> It is a bug but it is due to well defined behaviour (so that makes me feel a  \n> little better about myself ![](/jira/images/icons/emoticons/wink.png). To support **special**   \n> (well I call them special anyway) like -Dsystem.property=value we need to be  \n> able to examine the first character of an option. If the first character is  \n> itself defined as an Option then the remainder of the token is used as the  \n> value, e.g. 'D' is the token, it is an option so 'system.property=value' is the  \n> argument value for that option. This is the behaviour that we are seeing for  \n> your example.   \n> 't' is the token, it is an options so 'arget' is the argument value. \n> I suppose a solution to this could be to have a way to specify properties for  \n> parsers. In this case 'posix.special.option == true' for turning   \n> on **special** options. I'll have a look into this and let you know.\n> Just to keep track of this and to get you used to how we operate, can you log a  \n> bug in bugzilla for this.\n> Thanks,  \n> -John K", "test_name": "org.apache.commons.cli.GnuParserTest::testShortWithEqual", "test_method": "    public void testShortWithEqual() throws Exception\n    {\n        String[] args = new String[] { \"-f=bar\" };\n\n        Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n\n        Parser parser = new GnuParser();\n        CommandLine cl = parser.parse(options, args);\n\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[]bar> but was:<[=]bar>\n\torg.apache.commons.cli.GnuParserTest.testShortWithEqual(GnuParserTest.java:209)", "buggy_method": "52 protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n53     {\n54         List tokens = new ArrayList();\n55 \n56         boolean eatTheRest = false;\n57 \n58         for (int i = 0; i < arguments.length; i++)\n59         {\n60             String arg = arguments[i];\n61 \n62             if (\"--\".equals(arg))\n63             {\n64                 eatTheRest = true;\n65                 tokens.add(\"--\");\n66             }\n67             else if (\"-\".equals(arg))\n68             {\n69                 tokens.add(\"-\");\n70             }\n71             else if (arg.startsWith(\"-\"))\n72             {\n73                 String opt = Util.stripLeadingHyphens(arg);\n74 \n75                 if (options.hasOption(opt))\n76                 {\n77                     tokens.add(arg);\n78                 }\n79                 else\n80                 {\n81                     if (options.hasOption(arg.substring(0, 2)))\n82                     {\n83                         // the format is --foo=value or -foo=value\n84                         // the format is a special properties option (-Dproperty=value)\n85                         tokens.add(arg.substring(0, 2)); // -D\n86                         tokens.add(arg.substring(2)); // property=value\n87                     }\n88                     else\n89                     {\n90                         eatTheRest = stopAtNonOption;\n91                         tokens.add(arg);\n92                     }\n93                 }\n94             }\n95             else\n96             {\n97                 tokens.add(arg);\n98             }\n99 \n100             if (eatTheRest)\n101             {\n102                 for (i++; i < arguments.length; i++)\n103                 {\n104                     tokens.add(arguments[i]);\n105                 }\n106             }\n107         }\n108 \n109         return (String[]) tokens.toArray(new String[tokens.size()]);\n110     }", "bm_classpath": "org.apache.commons.cli.GnuParser"}, {"bug_name": "Cli_14", "report_text": "> adding a FileValidator results in ClassCastException in parser.parseAndHelp(args)\n> \n> When I add a FileValidator.getExistingFileInstance() to an Argument, I get a ClassCastException when I parse args.\n> Below is a testcase invoke with\n>  java org.apache.commons.cli2.issues.CLI2Sample -classpath commons-cli-2.0-SNAPSHOT.jar --file-name path-to-an-existing-file\n> Run it and you get:\n> Exception in thread \"main\" java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String  \n>  at org.apache.commons.cli2.validation.FileValidator.validate(FileValidator.java:122)  \n>  at org.apache.commons.cli2.option.ArgumentImpl.validate(ArgumentImpl.java:250)  \n>  at org.apache.commons.cli2.option.ParentImpl.validate(ParentImpl.java:123)  \n>  at org.apache.commons.cli2.option.DefaultOption.validate(DefaultOption.java:175)  \n>  at org.apache.commons.cli2.option.GroupImpl.validate(GroupImpl.java:264)  \n>  at org.apache.commons.cli2.commandline.Parser.parse(Parser.java:105)  \n>  at org.apache.commons.cli2.commandline.Parser.parseAndHelp(Parser.java:125)  \n>  at org.apache.commons.cli2.issues.CLI2Sample.main(CLI2Sample.java:38)\n> Comment out the withValidator call and it runs with no exception. \n> I also get a similar ClassCastException if I add a \n>  .withValidator(NumberValidator.getIntegerInstance())\n> to another option/argument.\n> Here is the source\n> package org.apache.commons.cli2.issues;\n> import java.io.File;  \n> import org.apache.commons.cli2.CommandLine;  \n> import org.apache.commons.cli2.Group;  \n> import org.apache.commons.cli2.builder.ArgumentBuilder;  \n> import org.apache.commons.cli2.builder.DefaultOptionBuilder;  \n> import org.apache.commons.cli2.builder.GroupBuilder;  \n> import org.apache.commons.cli2.commandline.Parser;  \n> import org.apache.commons.cli2.option.DefaultOption;  \n> import org.apache.commons.cli2.validation.FileValidator;\n> public class CLI2Sample  \n> {  \n>  public static void main(String[] args)\n>  {\n>  final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n>  final ArgumentBuilder abuilder = new ArgumentBuilder();\n>  final GroupBuilder gbuilder = new GroupBuilder();\n>  DefaultOption fileNameOption = obuilder\n>  .withShortName(\"f\")\n>  .withLongName(\"file-name\")\n>  .withRequired(true)\n>  .withDescription(\"name of an existing file\")\n>  .withArgument(abuilder\n>  .withName(\"file-name\")\n>  .withValidator(FileValidator.getExistingFileInstance())\n>  .create())\n>  .create();\n>  Group options = gbuilder\n>  .withName(\"options\")\n>  .withOption(fileNameOption)\n>  .create();\n>  Parser parser = new Parser();\n>  parser.setHelpTrigger(\"--help\");\n>  parser.setGroup(options);\n>  CommandLine cl = parser.parseAndHelp(args);\n>  }\n> }", "test_name": "org.apache.commons.cli2.bug.BugCLI144Test::testFileValidator", "test_method": "\tpublic void testFileValidator() {\n\t\tfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\n        final ArgumentBuilder abuilder = new ArgumentBuilder();\n        final GroupBuilder gbuilder = new GroupBuilder();\n        DefaultOption fileNameOption = obuilder.withShortName(\"f\")\n                .withLongName(\"file-name\").withRequired(true).withDescription(\n                        \"name of an existing file\").withArgument(\n                        abuilder.withName(\"file-name\").withValidator(\n                                FileValidator.getExistingFileInstance())\n                                .create()).create();\n        Group options = gbuilder.withName(\"options\").withOption(fileNameOption)\n                .create();\n        Parser parser = new Parser();\n        parser.setHelpTrigger(\"--help\");\n        parser.setGroup(options);\n\n        final String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\n        CommandLine cl = parser\n                .parseAndHelp(new String[] { \"--file-name\", fileName }); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: java.io.File cannot be cast to java.lang.String\n\torg.apache.commons.cli2.validation.FileValidator.validate(FileValidator.java:123)\n\torg.apache.commons.cli2.option.ArgumentImpl.validate(ArgumentImpl.java:251)\n\torg.apache.commons.cli2.option.ParentImpl.validate(ParentImpl.java:124)\n\torg.apache.commons.cli2.option.DefaultOption.validate(DefaultOption.java:176)\n\torg.apache.commons.cli2.option.GroupImpl.validate(GroupImpl.java:262)\n\torg.apache.commons.cli2.commandline.Parser.parse(Parser.java:104)\n\torg.apache.commons.cli2.commandline.Parser.parseAndHelp(Parser.java:124)\n\torg.apache.commons.cli2.bug.BugCLI144Test.testFileValidator(BugCLI144Test.java:61)", "buggy_method": "237 public void validate(final WriteableCommandLine commandLine)\n238         throws OptionException {\n239         // number of options found\n240         int present = 0;\n241 \n242         // reference to first unexpected option\n243         Option unexpected = null;\n244 \n245         for (final Iterator i = options.iterator(); i.hasNext();) {\n246             final Option option = (Option) i.next();\n247 \n248             // needs validation?\n249             boolean validate = option.isRequired() || option instanceof Group;\n250             if (validate) {\n251                 option.validate(commandLine);\n252             }\n253 \n254             // if the child option is present then validate it\n255             if (commandLine.hasOption(option)) {\n256                 if (++present > maximum) {\n257                     unexpected = option;\n258 \n259                     break;\n260                 }\n261 \n262                 option.validate(commandLine);\n263             }\n264         }\n265 \n266         // too many options\n267         if (unexpected != null) {\n268             throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n269                                       unexpected.getPreferredName());\n270         }\n271 \n272         // too few option\n273         if (present < minimum) {\n274             throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n275         }\n276 \n277         // validate each anonymous argument\n278         for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n279             final Option option = (Option) i.next();\n280             option.validate(commandLine);\n281         }\n282     }", "bm_classpath": "org.apache.commons.cli2.option.GroupImpl"}, {"bug_name": "Cli_15", "report_text": "> deafult arguments only works if no arguments are submitted\n> \n> When using multple arguments and defaults, the behaviour is counter-intuitive and will only pick up a default if no args are passed in.\n> For instance in the code below I have set up so 0, 1, or 2 args may bve accepted, with defaults 100 and 1000.\n> I expect it to behave as follows.  \n> 1. for 2 args, 1 and 2 the values should be 1 and 2. This works as expected.  \n> 2. for 0 args passed in the values should be 100 and 1000, picking up both of the defaults. This works as expected\n> 3. for 1 arg passed in the values should be 1 and 1000, so the second argument picks up the second default value. The valuse become just 1, which is not as expected..\n> Currently, in the second case will only return 1 and ignore the defaults.\n>  public void testSingleOptionSingleArgument() throws Exception {  \n>  String defaulValue1 = \"100\";  \n>  String defaultValue2 = \"1000\";  \n>  final DefaultOptionBuilder obuilder = new DefaultOptionBuilder();  \n>  final ArgumentBuilder abuilder = new ArgumentBuilder();  \n>  final GroupBuilder gbuilder = new GroupBuilder();\n>  DefaultOption bOption = obuilder.withShortName(\"b\")  \n>  .withLongName(\"b\")  \n>  .withArgument(abuilder.withName(\"b\")  \n>  .withMinimum(0)  \n>  .withMaximum(2)  \n>  .withDefault(defaulValue1)  \n>  .withDefault(defaultValue2)  \n>  .create())  \n>  .create();\n>  Group options = gbuilder  \n>  .withName(\"options\")  \n>  .withOption(bOption)  \n>  .create();\n>  Parser parser = new Parser();  \n>  parser.setHelpTrigger(\"--help\");  \n>  parser.setGroup(options);  \n>  String enteredValue1 = \"1\";  \n>  String[] args = new String[]\n> {\"-b\", enteredValue1}\n> ;  \n>  CommandLine cl = parser.parse(args);  \n>  CommandLine cmd = cl;  \n>  assertNotNull(cmd);  \n>  List b = cmd.getValues(\"-b\");  \n>  assertEquals(\"[\" + enteredValue1 + \"]\", b + \"\");  \n>  }", "test_name": "org.apache.commons.cli2.bug.BugCLI158Test::testSingleOptionSingleArgument", "test_method": "    public void testSingleOptionSingleArgument() throws Exception {\n        Parser parser = createDefaultValueParser(new String[]{\"100\", \"1000\"});\n        String enteredValue1 = \"1\";\n        String[] args = new String[]{\"-b\", enteredValue1};\n        CommandLine cl = parser.parse(args);\n        CommandLine cmd = cl;\n        List b = cmd.getValues(\"-b\");\n        assertEquals(\"[\" + enteredValue1 + \", 1000]\", b + \"\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[1[, 1000]]> but was:<[1[]]>\n\torg.apache.commons.cli2.bug.BugCLI158Test.testSingleOptionSingleArgument(BugCLI158Test.java:70)", "buggy_method": "111 public List getValues(final Option option,\n112                           List defaultValues) {\n113         // initialize the return list\n114         List valueList = (List) values.get(option);\n115 \n116         // grab the correct default values\n117         if ((valueList == null) || valueList.isEmpty()) {\n118             valueList = defaultValues;\n119         }\n120 \n121         // augment the list with the default values\n122         if ((valueList == null) || valueList.isEmpty()) {\n123             valueList = (List) this.defaultValues.get(option);\n124         }\n125                 // if there are more default values as specified, add them to\n126                 // the list.\n127                     // copy the list first\n128         \n129         return valueList == null ? Collections.EMPTY_LIST : valueList;\n130     }", "bm_classpath": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl"}, {"bug_name": "Cli_17", "report_text": "> PosixParser keeps bursting tokens even if a non option character is found\n> \n> PosixParser doesn't stop the bursting process of a token if stopAtNonOption is enabled and a non option character is encountered.\n> For example if the options a and b are defined, with stopAtNonOption=true the following command line:\n> ```\n> -azb\n> ```\n> is turned into:\n> ```\n> -a zb -b\n> ```\n> the right output should be:\n> ```\n> -a zb\n> ```", "test_name": "org.apache.commons.cli.PosixParserTest::testStopBursting", "test_method": "    public void testStopBursting() throws Exception\n    {\n        String[] args = new String[] { \"-azc\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n\n        assertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Confirm  1 extra arg: 2\n\torg.apache.commons.cli.PosixParserTest.testStopBursting(PosixParserTest.java:141)", "buggy_method": "282 protected void burstToken(String token, boolean stopAtNonOption)\n283     {\n284         for (int i = 1; i < token.length(); i++)\n285         {\n286             String ch = String.valueOf(token.charAt(i));\n287 \n288             if (options.hasOption(ch))\n289             {\n290                 tokens.add(\"-\" + ch);\n291                 currentOption = options.getOption(ch);\n292 \n293                 if (currentOption.hasArg() && (token.length() != (i + 1)))\n294                 {\n295                     tokens.add(token.substring(i + 1));\n296 \n297                     break;\n298                 }\n299             }\n300             else if (stopAtNonOption)\n301             {\n302                 process(token.substring(i));\n303             }\n304             else\n305             {\n306                 tokens.add(token);\n307                 break;\n308             }\n309         }\n310     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_18", "report_text": "> PosixParser ignores unrecognized tokens starting with '-'\n> \n> PosixParser doesn't handle properly unrecognized tokens starting with '-' when stopAtNonOption is enabled, the token is simply ignored.\n> For example, if the option 'a' is defined, the following command line:\n> ```\n> -z -a foo\n> ```\n> is interpreted as:\n> ```\n> -a foo\n> ```", "test_name": "org.apache.commons.cli.PosixParserTest::testStop2", "test_method": "    public void testStop2() throws Exception\n    {\n        String[] args = new String[]{\"-z\",\n                                     \"-a\",\n                                     \"-btoast\"};\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Confirm -a is not set\n\torg.apache.commons.cli.PosixParserTest.testStop2(PosixParserTest.java:140)", "buggy_method": "97 protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n98     {\n99         init();\n100         this.options = options;\n101 \n102         // an iterator for the command line tokens\n103         Iterator iter = Arrays.asList(arguments).iterator();\n104 \n105         // process each command line token\n106         while (iter.hasNext())\n107         {\n108             // get the next command line token\n109             String token = (String) iter.next();\n110 \n111             // handle SPECIAL TOKEN\n112             if (token.startsWith(\"--\"))\n113             {\n114                 if (token.indexOf('=') != -1)\n115                 {\n116                     tokens.add(token.substring(0, token.indexOf('=')));\n117                     tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n118                 }\n119                 else\n120                 {\n121                     tokens.add(token);\n122                 }\n123             }\n124 \n125             // single hyphen\n126             else if (\"-\".equals(token))\n127             {\n128                 processSingleHyphen(token);\n129             }\n130             else if (token.startsWith(\"-\"))\n131             {\n132                 if (token.length() == 2)\n133                 {\n134                     processOptionToken(token, stopAtNonOption);\n135                 }\n136                 else if (options.hasOption(token))\n137                 {\n138                     tokens.add(token);\n139                 }\n140                 // requires bursting\n141                 else\n142                 {\n143                     burstToken(token, stopAtNonOption);\n144                 }\n145             }\n146             else if (stopAtNonOption)\n147             {\n148                 process(token);\n149             }\n150             else\n151             {\n152                 tokens.add(token);\n153             }\n154 \n155             gobble(iter);\n156         }\n157 \n158         return (String[]) tokens.toArray(new String[tokens.size()]);\n159     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_19", "report_text": "> PosixParser ignores unrecognized tokens starting with '-'\n> \n> PosixParser doesn't handle properly unrecognized tokens starting with '-' when stopAtNonOption is enabled, the token is simply ignored.\n> For example, if the option 'a' is defined, the following command line:\n> ```\n> -z -a foo\n> ```\n> is interpreted as:\n> ```\n> -a foo\n> ```", "test_name": "org.apache.commons.cli.PosixParserTest::testUnrecognizedOption2", "test_method": "    public void testUnrecognizedOption2() throws Exception\n    {\n        String[] args = new String[] { \"-z\", \"-abtoast\", \"foo\", \"bar\" };\n\n        try\n        {\n            parser.parse(options, args);\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        }\n        catch (UnrecognizedOptionException e)\n        {\n            assertEquals(\"-z\", e.getOption());\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: UnrecognizedOptionException wasn't thrown\n\torg.apache.commons.cli.PosixParserTest.testUnrecognizedOption2(PosixParserTest.java:110)", "buggy_method": "227 private void processOptionToken(String token, boolean stopAtNonOption)\n228     {\n229         if (options.hasOption(token))\n230         {\n231             currentOption = options.getOption(token);\n232             tokens.add(token);\n233         }\n234         else if (stopAtNonOption)\n235         {\n236             eatTheRest = true;\n237             tokens.add(token);\n238         }\n239     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_20", "report_text": "> PosixParser keeps processing tokens after a non unrecognized long option\n> \n> PosixParser keeps processing tokens after a non unrecognized long option when stopAtNonOption is enabled. The tokens after the unrecognized long option are burst, split around '=', etc.. instead of being kept as is.\n> For example, with the options 'a' and 'b' defined, 'b' having an argument, the following command line:\n> ```\n> --zop -abfoo\n> ```\n> is interpreted as:\n> ```\n> --zop -a -b foo\n> ```\n> but the last token should remain unchanged.", "test_name": "org.apache.commons.cli.PosixParserTest::testStop3", "test_method": "    public void testStop3() throws Exception\n    {\n        String[] args = new String[]{\"--zop==1\",\n                                     \"-abtoast\",\n                                     \"--b=bar\"};\n\n        CommandLine cl = parser.parse(options, args, true);\n\n        assertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Confirm  3 extra args: 7\n\torg.apache.commons.cli.PosixParserTest.testStop3(PosixParserTest.java:169)", "buggy_method": "97 protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n98     {\n99         init();\n100         this.options = options;\n101 \n102         // an iterator for the command line tokens\n103         Iterator iter = Arrays.asList(arguments).iterator();\n104 \n105         // process each command line token\n106         while (iter.hasNext())\n107         {\n108             // get the next command line token\n109             String token = (String) iter.next();\n110 \n111             // handle long option --foo or --foo=bar\n112             if (token.startsWith(\"--\"))\n113             {\n114                 if (token.indexOf('=') != -1)\n115                 {\n116                     tokens.add(token.substring(0, token.indexOf('=')));\n117                     tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n118                 }\n119                 else\n120                 {\n121                     tokens.add(token);\n122                 }\n123             }\n124 \n125             // single hyphen\n126             else if (\"-\".equals(token))\n127             {\n128                 tokens.add(token);\n129             }\n130             else if (token.startsWith(\"-\"))\n131             {\n132                 if (token.length() == 2)\n133                 {\n134                     processOptionToken(token, stopAtNonOption);\n135                 }\n136                 else if (options.hasOption(token))\n137                 {\n138                     tokens.add(token);\n139                 }\n140                 // requires bursting\n141                 else\n142                 {\n143                     burstToken(token, stopAtNonOption);\n144                 }\n145             }\n146             else if (stopAtNonOption)\n147             {\n148                 process(token);\n149             }\n150             else\n151             {\n152                 tokens.add(token);\n153             }\n154 \n155             gobble(iter);\n156         }\n157 \n158         return (String[]) tokens.toArray(new String[tokens.size()]);\n159     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_22", "report_text": "> PosixParser interupts \"-target opt\" as \"-t arget opt\"\n> \n> This was posted on the Commons-Developer list and confirmed as a bug.\n> > Is this a bug? Or am I using this incorrectly?  \n> > I have an option with short and long values. Given code that is   \n> > essentially what is below, with a PosixParser I see results as   \n> > follows:  \n> >   \n> > A command line with just \"-t\" prints out the results of the catch   \n> > block  \n> > (OK)  \n> > A command line with just \"-target\" prints out the results of the catch  \n> > block (OK)  \n> > A command line with just \"-t foobar.com\" prints out \"processing selected  \n> > target: foobar.com\" (OK)  \n> > A command line with just \"-target foobar.com\" prints out \"processing  \n> > selected target: arget\" (ERROR?)  \n> >   \n> > ======================================================================  \n> > ==  \n> > =======================  \n> > private static final String OPTION\\_TARGET = \"t\";  \n> > private static final String OPTION\\_TARGET\\_LONG = \"target\";  \n> > // ...  \n> > Option generateTarget = new Option(OPTION\\_TARGET,   \n> > OPTION\\_TARGET\\_LONG,   \n> > true,   \n> > \"Generate files for the specified  \n> > target machine\");  \n> > // ...  \n> > try \n> {\n> > parsedLine = parser.parse(cmdLineOpts, args);\n> > }\n>  catch (ParseException pe) \n> {\n> > System.out.println(\"Invalid command: \" + pe.getMessage() +\n> > \"\\n\");\n> > HelpFormatter hf = new HelpFormatter();\n> > hf.printHelp(USAGE, cmdLineOpts);\n> > System.exit(-1);\n> > }\n> >   \n> > if (parsedLine.hasOption(OPTION\\_TARGET)) \n> {\n> > System.out.println(\"processing selected target: \" +\n> > parsedLine.getOptionValue(OPTION\\_TARGET)); \n> > }\n> It is a bug but it is due to well defined behaviour (so that makes me feel a  \n> little better about myself ![](/jira/images/icons/emoticons/wink.png). To support **special**   \n> (well I call them special anyway) like -Dsystem.property=value we need to be  \n> able to examine the first character of an option. If the first character is  \n> itself defined as an Option then the remainder of the token is used as the  \n> value, e.g. 'D' is the token, it is an option so 'system.property=value' is the  \n> argument value for that option. This is the behaviour that we are seeing for  \n> your example.   \n> 't' is the token, it is an options so 'arget' is the argument value. \n> I suppose a solution to this could be to have a way to specify properties for  \n> parsers. In this case 'posix.special.option == true' for turning   \n> on **special** options. I'll have a look into this and let you know.\n> Just to keep track of this and to get you used to how we operate, can you log a  \n> bug in bugzilla for this.\n> Thanks,  \n> -John K", "test_name": "org.apache.commons.cli.ApplicationTest::testGroovy", "test_method": "    public void testGroovy() throws Exception {\n        Options options = new Options();\n\n        options.addOption(\n            OptionBuilder.withLongOpt(\"define\").\n                withDescription(\"define a system property\").\n                hasArg(true).\n                withArgName(\"name=value\").\n                create('D'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n            .withDescription(\"usage information\")\n            .withLongOpt(\"help\")\n            .create('h'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n            .withDescription(\"debug mode will print out full stack traces\")\n            .withLongOpt(\"debug\")\n            .create('d'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n            .withDescription(\"display the Groovy and JVM versions\")\n            .withLongOpt(\"version\")\n            .create('v'));\n        options.addOption(\n            OptionBuilder.withArgName(\"charset\")\n            .hasArg()\n            .withDescription(\"specify the encoding of the files\")\n            .withLongOpt(\"encoding\")\n            .create('c'));\n        options.addOption(\n            OptionBuilder.withArgName(\"script\")\n            .hasArg()\n            .withDescription(\"specify a command line script\")\n            .create('e'));\n        options.addOption(\n            OptionBuilder.withArgName(\"extension\")\n            .hasOptionalArg()\n            .withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n            .create('i'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n            .withDescription(\"process files line by line using implicit 'line' variable\")\n            .create('n'));\n        options.addOption(\n            OptionBuilder.hasArg(false)\n            .withDescription(\"process files line by line and print result (see also -n)\")\n            .create('p'));\n        options.addOption(\n            OptionBuilder.withArgName(\"port\")\n            .hasOptionalArg()\n            .withDescription(\"listen on a port and process inbound lines\")\n            .create('l'));\n        options.addOption(\n            OptionBuilder.withArgName(\"splitPattern\")\n            .hasOptionalArg()\n            .withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n            .withLongOpt(\"autosplit\")\n            .create('a'));\n\n        Parser parser = new PosixParser();\n        CommandLine line = parser.parse(options, new String[] { \"-e\", \"println 'hello'\" }, true);\n\n        assertEquals(\"println 'hello'\", line.getOptionValue('e')); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[println 'hello']> but was:<[--]>\n\torg.apache.commons.cli.ApplicationTest.testGroovy(ApplicationTest.java:169)", "buggy_method": "94 protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n95     {\n96         init();\n97         this.options = options;\n98 \n99         // an iterator for the command line tokens\n100         Iterator iter = Arrays.asList(arguments).iterator();\n101 \n102         // process each command line token\n103         while (iter.hasNext())\n104         {\n105             // get the next command line token\n106             String token = (String) iter.next();\n107 \n108             // handle long option --foo or --foo=bar\n109             if (token.startsWith(\"--\"))\n110             {\n111                 int pos = token.indexOf('=');\n112                 String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n113 \n114                 if (!options.hasOption(opt))\n115                 {\n116                     processNonOptionToken(token);\n117                 }\n118                 else\n119                 {\n120                     \n121                     tokens.add(opt);\n122                     if (pos != -1)\n123                     {\n124                         tokens.add(token.substring(pos + 1));\n125                     }\n126                 }\n127             }\n128 \n129             // single hyphen\n130             else if (\"-\".equals(token))\n131             {\n132                 tokens.add(token);\n133             }\n134             else if (token.startsWith(\"-\"))\n135             {\n136                 if (token.length() == 2 || options.hasOption(token))\n137                 {\n138                     processOptionToken(token, stopAtNonOption);\n139                 }\n140                 // requires bursting\n141                 else\n142                 {\n143                     burstToken(token, stopAtNonOption);\n144                 }\n145             }\n146             else if (stopAtNonOption)\n147             {\n148                 processNonOptionToken(token);\n149             }\n150             else\n151             {\n152                 tokens.add(token);\n153             }\n154 \n155             gobble(iter);\n156         }\n157 \n158         return (String[]) tokens.toArray(new String[tokens.size()]);\n159     }", "bm_classpath": "org.apache.commons.cli.PosixParser"}, {"bug_name": "Cli_23", "report_text": "> infinite loop in the wrapping code of HelpFormatter\n> \n> If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n> Test case:\n> ```\n> Options options = new Options();\n> options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n> HelpFormatter formatter = new HelpFormatter();\n> formatter.setWidth(20);\n> formatter.printHelp(\"app\", options); // hang & crash\n> ```\n> An helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.", "test_name": "org.apache.commons.cli.bug.BugCLI162Test::testInfiniteLoop", "test_method": "    public void testInfiniteLoop() {\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setWidth(20);\n        formatter.printHelp(\"app\", options); // used to hang & crash // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: Text too long for line - throwing exception to avoid infinite loop [CLI-162]:              looooong description\n\torg.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:836)\n\torg.apache.commons.cli.HelpFormatter.renderOptions(HelpFormatter.java:783)\n\torg.apache.commons.cli.HelpFormatter.printOptions(HelpFormatter.java:662)\n\torg.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:485)\n\torg.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:418)\n\torg.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:334)\n\torg.apache.commons.cli.bug.BugCLI162Test.testInfiniteLoop(BugCLI162Test.java:45)", "buggy_method": "805 protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n806                                              int nextLineTabStop, String text)\n807     {\n808         int pos = findWrapPos(text, width, 0);\n809 \n810         if (pos == -1)\n811         {\n812             sb.append(rtrim(text));\n813 \n814             return sb;\n815         }\n816         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n817 \n818         // all following lines must be padded with nextLineTabStop space \n819         // characters\n820         final String padding = createPadding(nextLineTabStop);\n821 \n822         while (true)\n823         {\n824             int lastPos = pos;\n825             text = padding + text.substring(pos).trim();\n826             pos = findWrapPos(text, width, 0);\n827 \n828             if (pos == -1)\n829             {\n830                 sb.append(text);\n831 \n832                 return sb;\n833             } else\n834             if (pos == lastPos)\n835             {\n836                 throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n837             }\n838 \n839             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n840         }\n841     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_24", "report_text": "> infinite loop in the wrapping code of HelpFormatter\n> \n> If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n> Test case:\n> ```\n> Options options = new Options();\n> options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n> HelpFormatter formatter = new HelpFormatter();\n> formatter.setWidth(20);\n> formatter.printHelp(\"app\", options); // hang & crash\n> ```\n> An helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.", "test_name": "org.apache.commons.cli.bug.BugCLI162Test::testLongLineChunkingIndentIgnored", "test_method": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n        Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n        HelpFormatter formatter = new HelpFormatter();\n        StringWriter sw = new StringWriter();\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: Total width is less than the width of the argument and indent - no room for the description\n\torg.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:825)\n\torg.apache.commons.cli.HelpFormatter.renderOptions(HelpFormatter.java:787)\n\torg.apache.commons.cli.HelpFormatter.printOptions(HelpFormatter.java:666)\n\torg.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:489)\n\torg.apache.commons.cli.HelpFormatter.printHelp(HelpFormatter.java:443)\n\torg.apache.commons.cli.bug.BugCLI162Test.testLongLineChunkingIndentIgnored(BugCLI162Test.java:269)", "buggy_method": "809 protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n810                                              int nextLineTabStop, String text)\n811     {\n812         int pos = findWrapPos(text, width, 0);\n813 \n814         if (pos == -1)\n815         {\n816             sb.append(rtrim(text));\n817 \n818             return sb;\n819         }\n820         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n821 \n822         if (nextLineTabStop >= width)\n823         {\n824             // stops infinite loop happening\n825             throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n826                                             \"- no room for the description\");\n827         }\n828 \n829         // all following lines must be padded with nextLineTabStop space \n830         // characters\n831         final String padding = createPadding(nextLineTabStop);\n832 \n833         while (true)\n834         {\n835             text = padding + text.substring(pos).trim();\n836             pos = findWrapPos(text, width, 0);\n837 \n838             if (pos == -1)\n839             {\n840                 sb.append(text);\n841 \n842                 return sb;\n843             }\n844             \n845             if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n846             {\n847                 pos = width;\n848             }\n849 \n850             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n851         }\n852     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_25", "report_text": "> infinite loop in the wrapping code of HelpFormatter\n> \n> If there is not enough space to display a word on a single line, HelpFormatter goes into a infinite loops until the JVM crashes with an OutOfMemoryError.\n> Test case:\n> ```\n> Options options = new Options();\n> options.addOption(\"h\", \"help\", false, \"This is a looooong description\");\n> HelpFormatter formatter = new HelpFormatter();\n> formatter.setWidth(20);\n> formatter.printHelp(\"app\", options); // hang & crash\n> ```\n> An helpful exception indicating the insufficient width would be more appropriate than an OutOfMemoryError.", "test_name": "org.apache.commons.cli.bug.BugCLI162Test::testLongLineChunkingIndentIgnored", "test_method": "    public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\n        Options options = new Options();\n        options.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\n        HelpFormatter formatter = new HelpFormatter();\n        StringWriter sw = new StringWriter();\n        formatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\n        System.err.println(sw.toString());\n        String expected = \"usage:\\n\" +\n                          \"       org.apache.comm\\n\" +\n                          \"       ons.cli.bug.Bug\\n\" +\n                          \"       CLI162Test\\n\" +\n                          \"Header\\n\" +\n                          \"-x,--extralongarg\\n\" +\n                          \" This description is\\n\" +\n                          \" Long.\\n\" +\n                          \"Footer\\n\";\n        assertEquals( \"Long arguments did not split as expected\", expected, sw.toString() ); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: Long arguments did not split as expected expected:<...\n\torg.apache.commons.cli.bug.BugCLI162Test.testLongLineChunkingIndentIgnored(BugCLI162Test.java:280)", "buggy_method": "809 protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n810                                              int nextLineTabStop, String text)\n811     {\n812         int pos = findWrapPos(text, width, 0);\n813 \n814         if (pos == -1)\n815         {\n816             sb.append(rtrim(text));\n817 \n818             return sb;\n819         }\n820         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n821 \n822         if (nextLineTabStop >= width)\n823         {\n824             // stops infinite loop happening\n825             nextLineTabStop = width - 1;\n826         }\n827 \n828         // all following lines must be padded with nextLineTabStop space \n829         // characters\n830         final String padding = createPadding(nextLineTabStop);\n831 \n832         while (true)\n833         {\n834             text = padding + text.substring(pos).trim();\n835             pos = findWrapPos(text, width, 0);\n836 \n837             if (pos == -1)\n838             {\n839                 sb.append(text);\n840 \n841                 return sb;\n842             }\n843             \n844             if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n845             {\n846                 pos = width;\n847             }\n848 \n849             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n850         }\n851     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_26", "report_text": "> OptionBuilder is not reseted in case of an IAE at create\n> \n> If the call to OptionBuilder.create() fails with an IllegalArgumentException, the OptionBuilder is not resetted and its next usage may contain unwanted settings. Actually this let the [~~CLI-1~~](https://issues.apache.org/jira/browse/CLI-1 \"PosixParser interupts \\\"-target opt\\\" as \\\"-t arget opt\\\"\").2 RCs fail on IBM JDK 6 running on Maven 2.0.10.", "test_name": "org.apache.commons.cli.OptionBuilderTest::testBuilderIsResettedAlways", "test_method": "    public void testBuilderIsResettedAlways() {\n        try\n        {\n            OptionBuilder.withDescription(\"JUnit\").create('\"');\n            fail(\"IllegalArgumentException expected\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n        assertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: we inherited a description\n\torg.apache.commons.cli.OptionBuilderTest.testBuilderIsResettedAlways(OptionBuilderTest.java:164)", "buggy_method": "346 public static Option create(String opt) throws IllegalArgumentException\n347     {\n348             // create the option\n349         Option option = new Option(opt, description);\n350 \n351             // set the option properties\n352             option.setLongOpt(longopt);\n353             option.setRequired(required);\n354             option.setOptionalArg(optionalArg);\n355             option.setArgs(numberOfArgs);\n356             option.setType(type);\n357             option.setValueSeparator(valuesep);\n358             option.setArgName(argName);\n359             // reset the OptionBuilder properties\n360             OptionBuilder.reset();\n361 \n362         // return the Option instance\n363         return option;\n364     }", "bm_classpath": "org.apache.commons.cli.OptionBuilder"}, {"bug_name": "Cli_27", "report_text": "> Unable to select a pure long option in a group\n> \n> OptionGroup doesn't play nice with options with a long name and no short name. If the selected option hasn't a short name, group.setSelected(option) has no effect.", "test_name": "org.apache.commons.cli.BasicParserTest::testOptionGroupLong", "test_method": "public void testOptionGroupLong() throws Exception\n    {\n        OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n        \n        Options options = new Options();\n        options.addOptionGroup(group);\n        \n        CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n        \n        assertTrue(cl.hasOption(\"bar\"));\n        assertEquals(\"selected option\", \"bar\", group.getSelected());\n    }", "error_message": "junit.framework.ComparisonFailure: selected option expected:<bar> but was:<null>\n\torg.apache.commons.cli.ParserTestCase.testOptionGroupLong(ParserTestCase.java:631)", "buggy_method": "86 public void setSelected(Option option) throws AlreadySelectedException\n87     {\n88         if (option == null)\n89         {\n90             // reset the option previously selected\n91             selected = null;\n92             return;\n93         }\n94         \n95         // if no option has already been selected or the \n96         // same option is being reselected then set the\n97         // selected member variable\n98         if (selected == null || selected.equals(option.getOpt()))\n99         {\n100             selected = option.getOpt();\n101         }\n102         else\n103         {\n104             throw new AlreadySelectedException(this, option);\n105         }\n106     }", "bm_classpath": "org.apache.commons.cli.OptionGroup"}, {"bug_name": "Cli_28", "report_text": "> Default options may be partially processed\n> \n> The Properties instance passed to the Parser.parse() method to initialize the default options may be partially processed. This happens when the properties contains an option that doesn't accept arguments and has a default value that isn't evaluated to \"true\". When this case occurs the processing of the properties is stopped and the remaining options are never handled.\n> This is caused by the break statement in Parser.processProperties(Properties), a continue statement should have been used instead.\n> The related test in ValueTest is also wrong, there are two assertions that need to be changed:\n> ```\n> Options opts = new Options();\n> opts.addOption(\"a\", false, \"toggle -a\");\n> opts.addOption(\"c\", \"c\", false, \"toggle -c\");\n> opts.addOption(OptionBuilder.hasOptionalArg().create('e'));\n> properties = new Properties();\n> properties.setProperty( \"a\", \"false\" );\n> properties.setProperty( \"c\", \"no\" );\n> properties.setProperty( \"e\", \"0\" );\n> cmd = parser.parse(opts, null, properties);\n> assertTrue( !cmd.hasOption(\"a\") );\n> assertTrue( !cmd.hasOption(\"c\") );\n> assertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive the value \"0\"\n> ```\n>  and the second one:\n> ```\n> properties = new Properties();\n> properties.setProperty( \"a\", \"just a string\" );\n> properties.setProperty( \"e\", \"\" );\n> cmd = parser.parse(opts, null, properties);\n> assertTrue( !cmd.hasOption(\"a\") );\n> assertTrue( !cmd.hasOption(\"c\") );\n> assertTrue( !cmd.hasOption(\"e\") ); // Wrong, this option accepts an argument and should receive an empty string as value\n> ```", "test_name": "org.apache.commons.cli.ValueTest::testPropertyOptionFlags", "test_method": "    public void testPropertyOptionFlags() throws Exception\n    {\n        Properties properties = new Properties();\n        properties.setProperty( \"a\", \"true\" );\n        properties.setProperty( \"c\", \"yes\" );\n        properties.setProperty( \"e\", \"1\" );\n\n        Parser parser = new PosixParser();\n\n        CommandLine cmd = parser.parse(opts, null, properties);\n\n\n        properties = new Properties();\n        properties.setProperty( \"a\", \"false\" );\n        properties.setProperty( \"c\", \"no\" );\n        properties.setProperty( \"e\", \"0\" );\n\n        cmd = parser.parse(opts, null, properties);\n        assertTrue( cmd.hasOption(\"e\") ); // this option accepts as argument // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.cli.ValueTest.testPropertyOptionFlags(ValueTest.java:215)", "buggy_method": "252 protected void processProperties(Properties properties)\n253     {\n254         if (properties == null)\n255         {\n256             return;\n257         }\n258 \n259         for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n260         {\n261             String option = e.nextElement().toString();\n262 \n263             if (!cmd.hasOption(option))\n264             {\n265                 Option opt = getOptions().getOption(option);\n266 \n267                 // get the value from the properties instance\n268                 String value = properties.getProperty(option);\n269 \n270                 if (opt.hasArg())\n271                 {\n272                     if (opt.getValues() == null || opt.getValues().length == 0)\n273                     {\n274                         try\n275                         {\n276                             opt.addValueForProcessing(value);\n277                         }\n278                         catch (RuntimeException exp)\n279                         {\n280                             // if we cannot add the value don't worry about it\n281                         }\n282                     }\n283                 }\n284                 else if (!(\"yes\".equalsIgnoreCase(value)\n285                         || \"true\".equalsIgnoreCase(value)\n286                         || \"1\".equalsIgnoreCase(value)))\n287                 {\n288                     // if the value is not yes, true or 1 then don't add the\n289                     // option to the CommandLine\n290                     break;\n291                 }\n292 \n293                 cmd.addOption(opt);\n294             }\n295         }\n296     }", "bm_classpath": "org.apache.commons.cli.Parser"}, {"bug_name": "Cli_29", "report_text": "> Commons CLI incorrectly stripping leading and trailing quotes\n> \n> org.apache.commons.cli.Parser.processArgs() calls Util.stripLeadingAndTrailingQuotes() for all argument values. IMHO this is incorrect and totally broken.\n> It is trivial to create a simple test for this. Output:\n>  $ java -cp target/clitest.jar Clitest --balloo \"this is a \\\"test\\\"\"  \n>  Value of argument balloo is 'this is a \"test'.\n> The argument 'balloo' should indeed keep its trailing double quote. It is what the shell gives it, so don't try to do something clever to it.\n> The offending code was committed here:  \n> <http://svn.apache.org/viewvc?view=rev&revision=129874>  \n> and has been there for more than 6 years ![](/jira/images/icons/emoticons/warning.png). Why was this committed in the first place?\n> The fix is trivial, just get rid of Util.stripLeadingAndTrailingQuotes(), and consequently avoid calling it from Parser.processArgs().", "test_name": "org.apache.commons.cli.UtilTest::testStripLeadingAndTrailingQuotes", "test_method": "    public void testStripLeadingAndTrailingQuotes()\n    {\n        assertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<foo \"bar[\"]> but was:<foo \"bar[]>\n\torg.apache.commons.cli.UtilTest.testStripLeadingAndTrailingQuotes(UtilTest.java:38)", "buggy_method": "63 static String stripLeadingAndTrailingQuotes(String str)\n64     {\n65         if (str.startsWith(\"\\\"\"))\n66         {\n67             str = str.substring(1, str.length());\n68         }\n69         int length = str.length();\n70         if (str.endsWith(\"\\\"\"))\n71         {\n72             str = str.substring(0, length - 1);\n73         }\n74         \n75         return str;\n76     }", "bm_classpath": "org.apache.commons.cli.Util"}, {"bug_name": "Cli_30", "report_text": "> The state of the option groups is not updated by the default options\n> \n> The state of the option groups is neither checked nor updated when the default options passed as a Properties instance to the parse method are processed. For example if 'a' and 'b' are two mutually exclusive options, the command line argument could specify 'a' and the default options could contain 'b', the parser will not complain and the resulting CommandLine will contain 'a' and 'b'.", "test_name": "org.apache.commons.cli.BasicParserTest::testPropertyOptionGroup", "test_method": "public void testPropertyOptionGroup() throws Exception\n    {\n        Options opts = new Options();\n        \n        OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        opts.addOptionGroup(group1);\n        \n        OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        opts.addOptionGroup(group2);\n        \n        String[] args = new String[] { \"-a\" };\n        \n        Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n        \n        CommandLine cmd = parse(parser, opts, args, properties);\n        \n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }", "error_message": "org.apache.commons.cli.AlreadySelectedException: The option 'b' was specified but an option from this group has already been selected: 'a'\n\torg.apache.commons.cli.OptionGroup.setSelected(OptionGroup.java:105)\n\torg.apache.commons.cli.Parser.updateRequiredOptions(Parser.java:421)\n\torg.apache.commons.cli.Parser.processProperties(Parser.java:296)\n\torg.apache.commons.cli.Parser.parse(Parser.java:241)\n\torg.apache.commons.cli.Parser.parse(Parser.java:103)\n\torg.apache.commons.cli.ParserTestCase.parse(ParserTestCase.java:875)\n\torg.apache.commons.cli.ParserTestCase.testPropertyOptionGroup(ParserTestCase.java:1037)", "buggy_method": "139 private void handleProperties(Properties properties) throws ParseException\n140     {\n141         if (properties == null)\n142         {\n143             return;\n144         }\n145         \n146         for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n147         {\n148             String option = e.nextElement().toString();\n149             \n150             if (!cmd.hasOption(option))\n151             {\n152                 Option opt = options.getOption(option);\n153             \n154             // if the option is part of a group, check if another option of the group has been selected\n155             \n156                 // get the value from the properties\n157                 String value = properties.getProperty(option);\n158                 \n159                 if (opt.hasArg())\n160                 {\n161                     if (opt.getValues() == null || opt.getValues().length == 0)\n162                     {\n163                         opt.addValueForProcessing(value);\n164                     }\n165                 }\n166                 else if (!(\"yes\".equalsIgnoreCase(value)\n167                         || \"true\".equalsIgnoreCase(value)\n168                         || \"1\".equalsIgnoreCase(value)))\n169                 {\n170                     // if the value is not yes, true or 1 then don't add the option to the CommandLine\n171                     continue;\n172                 }\n173                 \n174                 handleOption(opt);\n175                 currentOption = null;\n176             }\n177         }\n178     }", "bm_classpath": "org.apache.commons.cli.DefaultParser"}, {"bug_name": "Cli_31", "report_text": "> HelpFormatter.setArgName() has no effect\n> \n> The default argument name set on the HelpFormatter has no effect because the Option and the OptionBuilder bring automatically a default value 'arg'.", "test_name": "org.apache.commons.cli.HelpFormatterTest::testDefaultArgName", "test_method": "    public void testDefaultArgName()\n    {\n        Option option = OptionBuilder.hasArg().isRequired().create(\"f\");\n        \n        Options options = new Options();\n        options.addOption(option);\n        \n        StringWriter out = new StringWriter();\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.setArgName(\"argument\");\n        formatter.printUsage(new PrintWriter(out), 80, \"app\", options);\n\n        assertEquals(\"usage: app -f <argument>\" + EOL, out.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<usage: app -f <arg[ument]>\n\torg.apache.commons.cli.HelpFormatterTest.testDefaultArgName(HelpFormatterTest.java:321)", "buggy_method": "636 private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n637     {\n638         if (!required)\n639         {\n640             buff.append(\"[\");\n641         }\n642 \n643         if (option.getOpt() != null)\n644         {\n645             buff.append(\"-\").append(option.getOpt());\n646         }\n647         else\n648         {\n649             buff.append(\"--\").append(option.getLongOpt());\n650         }\n651         \n652         // if the Option has a value and a non blank argname\n653         if (option.hasArg() && option.hasArgName())\n654         {\n655             buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n656             buff.append(\"<\").append(option.getArgName()).append(\">\");\n657         }\n658         \n659         // if the Option is not a required option\n660         if (!required)\n661         {\n662             buff.append(\"]\");\n663         }\n664     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_32", "report_text": "> StringIndexOutOfBoundsException in HelpFormatter.findWrapPos\n> \n> In the last while loop in HelpFormatter.findWrapPos, it can pass text.length() to text.charAt(int), which throws a StringIndexOutOfBoundsException. The first expression in that while loop condition should use a <, not a <=.\n> This is on line 908 in r779646:  \n> <http://svn.apache.org/viewvc/commons/proper/cli/trunk/src/java/org/apache/commons/cli/HelpFormatter.java?revision=779646&view=markup>", "test_name": "org.apache.commons.cli.HelpFormatterTest::testRenderWrappedTextWordCut", "test_method": "    public void testRenderWrappedTextWordCut()\n    {\n        int width = 7;\n        int padding = 0;\n        String text = \"Thisisatest.\";\n        String expected = \"Thisisa\" + EOL + \n                          \"test.\";\n        \n        StringBuffer sb = new StringBuffer();\n        new HelpFormatter().renderWrappedText(sb, width, padding, text); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 12\n\tjava.lang.String.charAt(String.java:658)\n\torg.apache.commons.cli.HelpFormatter.findWrapPos(HelpFormatter.java:938)\n\torg.apache.commons.cli.HelpFormatter.renderWrappedText(HelpFormatter.java:848)\n\torg.apache.commons.cli.HelpFormatterTest.testRenderWrappedTextWordCut(HelpFormatterTest.java:68)", "buggy_method": "902 protected int findWrapPos(String text, int width, int startPos)\n903     {\n904         int pos;\n905         \n906         // the line ends before the max wrap pos or a new line char found\n907         if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n908                 || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n909         {\n910             return pos + 1;\n911         }\n912         else if (startPos + width >= text.length())\n913         {\n914             return -1;\n915         }\n916 \n917 \n918         // look for the last whitespace character before startPos+width\n919         pos = startPos + width;\n920 \n921         char c;\n922 \n923         while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n924                 && (c != '\\n') && (c != '\\r'))\n925         {\n926             --pos;\n927         }\n928 \n929         // if we found it - just return\n930         if (pos > startPos)\n931         {\n932             return pos;\n933         }\n934         \n935         // if we didn't find one, simply chop at startPos+width\n936         pos = startPos + width;\n937         while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n938                && (c != '\\n') && (c != '\\r'))\n939         {\n940             ++pos;\n941         }        \n942         return pos == text.length() ? -1 : pos;\n943     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_33", "report_text": "> HelpFormatter strips leading whitespaces in the footer\n> \n> I discovered a bug in Commons CLI while using it through Groovy's CliBuilder. See the following issue:\n> <http://jira.codehaus.org/browse/GROOVY-4313?page=com.atlassian.jira.plugin.system.issuetabpanels:all-tabpanel>\n> Copied:  \n> The following code:\n> def cli = new CliBuilder(footer: \"line1:\\n line2:\\n\")  \n> cli.usage()\n> Produces the following output:\n> line1  \n> line2\n> Note that there are no whitespaces before \"line2\". Replacing them with \"\\t\" doesn't solve the problem either.", "test_name": "org.apache.commons.cli.HelpFormatterTest::testIndentedHeaderAndFooter", "test_method": "    public void testIndentedHeaderAndFooter()\n    {\n        // related to CLI-207\n        Options options = new Options();\n        HelpFormatter formatter = new HelpFormatter();\n        String header = \"  Header1\\n  Header2\";\n        String footer = \"  Footer1\\n  Footer2\";\n        StringWriter out = new StringWriter();\n        formatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\n\n        assertEquals(\n                \"usage: foobar\" + EOL +\n                \"  Header1\" + EOL +\n                \"  Header2\" + EOL +\n                \"\" + EOL +\n                \"  Footer1\" + EOL +\n                \"  Footer2\" + EOL\n                , out.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...e: foobar\n\torg.apache.commons.cli.HelpFormatterTest.testIndentedHeaderAndFooter(HelpFormatterTest.java:441)", "buggy_method": "726 public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n727     {\n728         StringBuffer sb = new StringBuffer(text.length());\n729 \n730         renderWrappedText(sb, width, nextLineTabStop, text);\n731         pw.println(sb.toString());\n732     }", "bm_classpath": "org.apache.commons.cli.HelpFormatter"}, {"bug_name": "Cli_35", "report_text": "> LongOpt falsely detected as ambiguous\n> \n> Options options = new Options();  \n> options.addOption(Option.builder().longOpt(\"importToOpen\").hasArg().argName(\"FILE\").build());  \n> options.addOption(Option.builder(\"i\").longOpt(\"import\").hasArg().argName(\"FILE\").build());\n> Parsing \"--import=FILE\" is not possible since 1.3 as it throws a AmbiguousOptionException stating that it cannot decide whether import is import or importToOpen. In 1.2 this is not an issue. \n> The root lies in the new DefaultParser which does a startsWith check internally. ", "test_name": "org.apache.commons.cli.bug.BugCLI252Test::testExactOptionNameMatch", "test_method": "    @Test\n    public void testExactOptionNameMatch() throws ParseException {\n        new DefaultParser().parse(getOptions(), new String[]{\"--prefix\"}); // <-- fails here\n    }", "error_message": "org.apache.commons.cli.AmbiguousOptionException: Ambiguous option: '--prefix'  (could be: 'prefix', 'prefixplusplus')\n\torg.apache.commons.cli.DefaultParser.handleLongOptionWithoutEqual(DefaultParser.java:398)\n\torg.apache.commons.cli.DefaultParser.handleLongOption(DefaultParser.java:371)\n\torg.apache.commons.cli.DefaultParser.handleToken(DefaultParser.java:239)\n\torg.apache.commons.cli.DefaultParser.parse(DefaultParser.java:120)\n\torg.apache.commons.cli.DefaultParser.parse(DefaultParser.java:76)\n\torg.apache.commons.cli.DefaultParser.parse(DefaultParser.java:60)\n\torg.apache.commons.cli.bug.BugCLI252Test.testExactOptionNameMatch(BugCLI252Test.java:10)", "buggy_method": "233 public List<String> getMatchingOptions(String opt)\n234     {\n235         opt = Util.stripLeadingHyphens(opt);\n236         \n237         List<String> matchingOpts = new ArrayList<String>();\n238 \n239         // for a perfect match return the single option only\n240 \n241         for (String longOpt : longOpts.keySet())\n242         {\n243             if (longOpt.startsWith(opt))\n244             {\n245                 matchingOpts.add(longOpt);\n246             }\n247         }\n248         \n249         return matchingOpts;\n250     }", "bm_classpath": "org.apache.commons.cli.Options"}, {"bug_name": "Cli_37", "report_text": "> [There is no report available for this bug.]", "test_name": "org.apache.commons.cli.bug.BugCLI265Test::shouldParseShortOptionWithoutValue", "test_method": "    @Test\n    public void shouldParseShortOptionWithoutValue() throws Exception {\n        String[] twoShortOptions = new String[]{\"-t1\", \"-last\"};\n\n        final CommandLine commandLine = parser.parse(options, twoShortOptions);\n\n        assertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Second option has been used as value for first option. Actual: -last\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failEquals(Assert.java:185)\n\torg.junit.Assert.assertNotEquals(Assert.java:161)\n\torg.apache.commons.cli.bug.BugCLI265Test.shouldParseShortOptionWithoutValue(BugCLI265Test.java:52)", "buggy_method": "299 private boolean isShortOption(String token)\n300     {\n301         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n302         return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n303 \n304         // remove leading \"-\" and \"=value\"\n305     }", "bm_classpath": "org.apache.commons.cli.DefaultParser"}, {"bug_name": "Cli_38", "report_text": "> [There is no report available for this bug.]", "test_name": "org.apache.commons.cli.bug.BugCLI265Test::shouldParseConcatenatedShortOptions", "test_method": "    @Test\n    public void shouldParseConcatenatedShortOptions() throws Exception {\n        String[] concatenatedShortOptions = new String[] { \"-t1\", \"-ab\" };\n\n        final CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\n\n        assertNull(commandLine.getOptionValue(\"t1\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected null, but was:<-ab>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotNull(Assert.java:664)\n\torg.junit.Assert.assertNull(Assert.java:646)\n\torg.junit.Assert.assertNull(Assert.java:656)\n\torg.apache.commons.cli.bug.BugCLI265Test.shouldParseConcatenatedShortOptions(BugCLI265Test.java:83)", "buggy_method": "299 private boolean isShortOption(String token)\n300     {\n301         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n302         if (!token.startsWith(\"-\") || token.length() == 1)\n303         {\n304             return false;\n305         }\n306 \n307         // remove leading \"-\" and \"=value\"\n308         int pos = token.indexOf(\"=\");\n309         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n310         return options.hasShortOption(optName);\n311         // check for several concatenated short options\n312     }", "bm_classpath": "org.apache.commons.cli.DefaultParser"}, {"bug_name": "Cli_39", "report_text": "> Option parser type EXISTING_FILE_VALUE not check file existing\n> \n> When the user pass option type FileInputStream.class, I think the expected behavior for the return value is the same type, which the user passed.\n> Options options = new Options();  \n> options.addOption(Option.builder(\"f\").hasArg().type(FileInputStream.class).build());  \n> CommandLine cline = new DefaultParser().parse(options, args);  \n> FileInputStream file = (FileInputStream) cline.getParsedOptionValue(\"f\"); // it returns \"File\" object, without check File exist.\n> I attach a solution for it:  \n> <https://github.com/schaumb/commons-cli/commit/abfcc8211f529ab75f3b3edd4a827e484109eb0b>", "test_name": "org.apache.commons.cli.PatternOptionBuilderTest::testExistingFilePattern", "test_method": "    @Test\n    public void testExistingFilePattern() throws Exception\n    {\n        final Options options = PatternOptionBuilder.parsePattern(\"g<\");\n        final CommandLineParser parser = new PosixParser();\n        final CommandLine line = parser.parse(options, new String[] { \"-g\", \"src/test/resources/existing-readable.file\" });\n\n        final Object parsedReadableFileStream = line.getOptionObject(\"g\");\n\n        assertTrue(\"option g not FileInputStream\", parsedReadableFileStream instanceof FileInputStream); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: option g not FileInputStream\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.cli.PatternOptionBuilderTest.testExistingFilePattern(PatternOptionBuilderTest.java:171)", "buggy_method": "64 public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n65     {\n66         if (PatternOptionBuilder.STRING_VALUE == clazz)\n67         {\n68             return str;\n69         }\n70         else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n71         {\n72             return createObject(str);\n73         }\n74         else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n75         {\n76             return createNumber(str);\n77         }\n78         else if (PatternOptionBuilder.DATE_VALUE == clazz)\n79         {\n80             return createDate(str);\n81         }\n82         else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n83         {\n84             return createClass(str);\n85         }\n86         else if (PatternOptionBuilder.FILE_VALUE == clazz)\n87         {\n88             return createFile(str);\n89         }\n90         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n91         {\n92             return createFile(str);\n93         }\n94         else if (PatternOptionBuilder.FILES_VALUE == clazz)\n95         {\n96             return createFiles(str);\n97         }\n98         else if (PatternOptionBuilder.URL_VALUE == clazz)\n99         {\n100             return createURL(str);\n101         }\n102         else\n103         {\n104             return null;\n105         }\n106     }", "bm_classpath": "org.apache.commons.cli.TypeHandler"}, {"bug_name": "Cli_40", "report_text": "> TypeHandler should throw ParseException for an unsupported class\n> \n> JavaDoc for TypeHandler states that createValue will\n> ```\n> * @throws ParseException if the value creation for the given object type failedtype\n> ```\n> \u00a0However createValue(String str, Class<?> clazz) will return null if the clazz is unknown.", "test_name": "org.apache.commons.cli.TypeHandlerTest::testCreateValueInteger_failure", "test_method": "public void testCreateValueInteger_failure()\n            throws Exception\n    {\n        TypeHandler.createValue(\"just-a-string\", Integer.class);\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.cli.ParseException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "62 @SuppressWarnings(\"unchecked\") // returned value will have type T because it is fixed by clazz\n63     public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n64     {\n65         if (PatternOptionBuilder.STRING_VALUE == clazz)\n66         {\n67             return (T) str;\n68         }\n69         else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n70         {\n71             return (T) createObject(str);\n72         }\n73         else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n74         {\n75             return (T) createNumber(str);\n76         }\n77         else if (PatternOptionBuilder.DATE_VALUE == clazz)\n78         {\n79             return (T) createDate(str);\n80         }\n81         else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n82         {\n83             return (T) createClass(str);\n84         }\n85         else if (PatternOptionBuilder.FILE_VALUE == clazz)\n86         {\n87             return (T) createFile(str);\n88         }\n89         else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n90         {\n91             return (T) openFile(str);\n92         }\n93         else if (PatternOptionBuilder.FILES_VALUE == clazz)\n94         {\n95             return (T) createFiles(str);\n96         }\n97         else if (PatternOptionBuilder.URL_VALUE == clazz)\n98         {\n99             return (T) createURL(str);\n100         }\n101         else\n102         {\n103             return null;\n104         }\n105     }", "bm_classpath": "org.apache.commons.cli.TypeHandler"}, {"bug_name": "Closure_1", "report_text": "> function arguments should not be optimized away\n> \n> Function arguments should not be optimized away, as this comprimizes the function's length property.\r\n> \r\n> **What steps will reproduce the problem?**\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> function foo (bar, baz) {\r\n>  return bar;\r\n> }\r\n> alert (foo.length);\r\n> function foo (bar, baz) {\r\n>  return bar;\r\n> }\r\n> alert (foo.length);\r\n> \r\n> --------------------------------------\r\n> \r\n> What is the expected output?\r\n> \r\n> function foo(a,b){return a}alert(foo.length);\r\n> \r\n> --------------------------------------\r\n> \r\n> What do you see instead?\r\n> \r\n> function foo(a){return a}alert(foo.length);\r\n> \r\n> --------------------------------------\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> I'm using the product from the web page http://closure-compiler.appspot.com/home\r\n> \r\n> I'm using Firefox 3.6.10 on Ubuntu 10.0.4\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> The function's length property is essential to many techniques, such as currying functions.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testSimpleModeLeavesUnusedParams", "test_method": "  public void testSimpleModeLeavesUnusedParams() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    testSame(\"window.f = function(a) {};\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1204)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1175)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:1163)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:1159)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSimpleModeLeavesUnusedParams(CommandLineRunnerTest.java:156)", "buggy_method": "369 private void removeUnreferencedFunctionArgs(Scope fnScope) {\n370     // Notice that removing unreferenced function args breaks\n371     // Function.prototype.length. In advanced mode, we don't really care\n372     // about this: we consider \"length\" the equivalent of reflecting on\n373     // the function's lexical source.\n374     //\n375     // Rather than create a new option for this, we assume that if the user\n376     // is removing globals, then it's OK to remove unused function args.\n377     //\n378     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n379 \n380     Node function = fnScope.getRootNode();\n381 \n382     Preconditions.checkState(function.isFunction());\n383     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n384       // The parameters object literal setters can not be removed.\n385       return;\n386     }\n387 \n388     Node argList = getFunctionArgList(function);\n389     boolean modifyCallers = modifyCallSites\n390         && callSiteOptimizer.canModifyCallers(function);\n391     if (!modifyCallers) {\n392       // Strip unreferenced args off the end of the function declaration.\n393       Node lastArg;\n394       while ((lastArg = argList.getLastChild()) != null) {\n395         Var var = fnScope.getVar(lastArg.getString());\n396         if (!referenced.contains(var)) {\n397           argList.removeChild(lastArg);\n398           compiler.reportCodeChange();\n399         } else {\n400           break;\n401         }\n402       }\n403     } else {\n404       callSiteOptimizer.optimize(fnScope, referenced);\n405     }\n406   }", "bm_classpath": "com.google.javascript.jscomp.RemoveUnusedVars"}, {"bug_name": "Closure_2", "report_text": "> combining @interface and multiple @extends can crash compiler\n> \n> Compile this:\r\n> ---------------------------------\r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @warning\\_level VERBOSE\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> /\\*\\*\r\n>  \\* @interface\r\n>  \\* @extends {unknown\\_1}\r\n>  \\* @extends {unknown\\_2}\r\n>  \\*/\r\n> function Foo() {}\r\n> ---------------------------------\r\n> \r\n> => Get this..\r\n> ---------------------------------------\r\n> 23: java.lang.NullPointerException\r\n>  at com.google.javascript.jscomp.TypeCheck.checkInterfaceConflictProperties(TypeCheck.java:1544)\r\n>  at com.google.javascript.jscomp.TypeCheck.visitFunction(TypeCheck.java:1635)\r\n>  at com.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:761)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:509)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:502)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:502)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:347)\r\n>  at com.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:400)\r\n>  at com.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:371)\r\n>  at com.google.javascript.jscomp.DefaultPassConfig$29$1.process(DefaultPassConfig.java:1209)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:303)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:279)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:191)\r\n>  at com.google.javascript.jscomp.Compiler.check(Compiler.java:814)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:729)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:85)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:637)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:634)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:694)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:634)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:590)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilerInvokerImpl.compile(CompilerInvokerImpl.java:47)\r\n>  at com.google.javascript.jscomp.webservice.backend.ServerController.executeRequest(ServerController.java:177)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.serviceParsedRequest(CompilationRequestHandler.java:180)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.service(CompilationRequestHandler.java:162)\r\n>  at com.google.javascript.jscomp.webservice.frontend.CompilationServlet.doPost(CompilationServlet.java:83)\r\n>  at javax.servlet.http.HttpServlet.service(HttpServlet.java:637)\r\n>  at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)\r\n>  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)\r\n>  at com.google.apphosting.utils.servlet.ParseBlobUploadFilter.doFilter(ParseBlobUploadFilter.java:102)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at com.google.apphosting.runtime.jetty.SaveSessionFilter.doFilter(SaveSessionFilter.java:35)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at com.google.apphosting.utils.servlet.TransactionCleanupFilter.doFilter(TransactionCleanupFilter.java:43)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)\r\n>  at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\r\n>  at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)\r\n>  at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)\r\n>  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)\r\n>  at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.handle(AppVersionHandlerMap.java:266)\r\n>  at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\r\n>  at org.mortbay.jetty.Server.handle(Server.java:326)\r\n>  at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)\r\n>  at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)\r\n>  at com.google.apphosting.runtime.jetty.RpcRequestParser.parseAvailable(RpcRequestParser.java:76)\r\n>  at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)\r\n>  at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:146)\r\n>  at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:447)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:454)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:461)\r\n>  at com.google.tracing.TraceContext.runInContext(TraceContext.java:703)\r\n>  at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:338)\r\n>  at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:330)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:458)\r\n>  at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)\r\n>  at java.lang.Thread.run(Thread.java:679)\r\n> \r\n> Original Post Data: \r\n> output\\_format=json&output\\_info=compiled\\_code&output\\_info=warnings&output\\_info=errors&output\\_info=statistics&compilation\\_level=SIMPLE\\_OPTIMIZATIONS&warning\\_level=VERBOSE&output\\_file\\_name=default.js&js\\_code=%2F\\*\\*%0A\\*%20%40interface%0A\\*%20%40extends%20%7BA%7D%0A\\*%20%40extends%20%7BB%7D%0A\\*%2F%0Afunction%20Foo()%20%7B%7D\r\n> ------------------\r\n> \r\n> \r\n> Seems like a combination of @interface plus more than one @extend and where at least one of the @extend types are unknown causes a crash.\r\n> \r\n> Regards\r\n> / Fredrik Blomqvist", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testBadInterfaceExtendsNonExistentInterfaces", "test_method": "  public void testBadInterfaceExtendsNonExistentInterfaces() throws Exception {\n    String js = \"/** @interface \\n\" +\n        \" * @extends {nonExistent1} \\n\" +\n        \" * @extends {nonExistent2} \\n\" +\n        \" */function A() {}\";\n    String[] expectedWarnings = {\n      \"Bad type annotation. Unknown type nonExistent1\",\n      \"Bad type annotation. Unknown type nonExistent2\"\n    };\n    testTypes(js, expectedWarnings); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.google.javascript.jscomp.TypeCheck.checkInterfaceConflictProperties(TypeCheck.java:1574)\n\tcom.google.javascript.jscomp.TypeCheck.visitFunction(TypeCheck.java:1664)\n\tcom.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:778)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:505)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:498)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:343)\n\tcom.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:404)\n\tcom.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:375)\n\tcom.google.javascript.jscomp.TypeCheck.processForTesting(TypeCheck.java:393)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:11530)\n\tcom.google.javascript.jscomp.TypeCheckTest.testBadInterfaceExtendsNonExistentInterfaces(TypeCheckTest.java:3780)", "buggy_method": "1566 private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n1567       String functionName, HashMap<String, ObjectType> properties,\n1568       HashMap<String, ObjectType> currentProperties,\n1569       ObjectType interfaceType) {\n1570     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n1571     Set<String> currentPropertyNames;\n1572       // This can be the case if interfaceType is proxy to a non-existent\n1573       // object (which is a bad type annotation, but shouldn't crash).\n1574       currentPropertyNames = implicitProto.getOwnPropertyNames();\n1575     for (String name : currentPropertyNames) {\n1576       ObjectType oType = properties.get(name);\n1577       if (oType != null) {\n1578         if (!interfaceType.getPropertyType(name).isEquivalentTo(\n1579             oType.getPropertyType(name))) {\n1580           compiler.report(\n1581               t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n1582                   functionName, name, oType.toString(),\n1583                   interfaceType.toString()));\n1584         }\n1585       }\n1586       currentProperties.put(name, interfaceType);\n1587     }\n1588     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n1589       checkInterfaceConflictProperties(t, n, functionName, properties,\n1590           currentProperties, iType);\n1591     }\n1592   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_3", "report_text": "> optimization fails with variable in catch clause\n> \n> Enter the following in the closure service:\r\n> \r\n> function getStack() {\r\n>  var getErrorObject = function() {\r\n>  try {\r\n>  throw Error(\"\");\r\n>  } catch(err) {\r\n>  return err;\r\n>  }\r\n>  };\r\n>  return getErrorObject().stack;\r\n> }\r\n> window['getStackTrace']=getStack;\r\n> \r\n> Use Optimization = Simple. Note the following result:\r\n> \r\n> function getStack() \r\n> { \r\n>  try \r\n>  { \r\n>  throw Error(\"\"); \r\n>  }\r\n>  catch(a) \r\n>  { \r\n>  } \r\n>  return a.stack \r\n> } \r\n> window.getStackTrace = getStack;\r\n> \r\n> The scope of the variable a is limited to the catch clause, but the compiler references it illegally as the return value of the inlined function.", "test_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testDoNotInlineCatchExpression1a", "test_method": "  public void testDoNotInlineCatchExpression1a() {\n    noInline(\n        \"var a;\\n\" +\n        \"try {\\n\" +\n        \"  throw Error(\\\"\\\");\\n\" +\n        \"}catch(err) {\" +\n        \"   a = err + 1;\\n\" +\n        \"}\\n\" +\n        \"return a.stack\\n\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:905)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:447)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:389)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:571)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:567)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testDoNotInlineCatchExpression1a(FlowSensitiveInlineVariablesTest.java:157)", "buggy_method": "124 @Override\n125   public void enterScope(NodeTraversal t) {\n126 \n127     if (t.inGlobalScope()) {\n128       return; // Don't even brother. All global variables are likely escaped.\n129     }\n130 \n131     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n132         t.getScope().getVarCount()) {\n133       return;\n134     }\n135 \n136     // Compute the forward reaching definition.\n137     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n138     // Process the body of the function.\n139     Preconditions.checkState(t.getScopeRoot().isFunction());\n140     cfa.process(null, t.getScopeRoot().getLastChild());\n141     cfg = cfa.getCfg();\n142     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n143     reachingDef.analyze();\n144     candidates = Lists.newLinkedList();\n145 \n146     // Using the forward reaching definition search to find all the inline\n147     // candidates\n148     new NodeTraversal(compiler, new GatherCandiates()).traverse(\n149         t.getScopeRoot().getLastChild());\n150 \n151     // Compute the backward reaching use. The CFG can be reused.\n152     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n153     reachingUses.analyze();\n154     for (Candidate c : candidates) {\n155       if (c.canInline()) {\n156         c.inlineVariable();\n157 \n158         // If definition c has dependencies, then inlining it may have\n159         // introduced new dependencies for our other inlining candidates.\n160         //\n161         // MustBeReachingVariableDef uses this dependency graph in its\n162         // analysis, so some of these candidates may no longer be valid.\n163         // We keep track of when the variable dependency graph changed\n164         // so that we can back off appropriately.\n165         if (!c.defMetadata.depends.isEmpty()) {\n166           inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n167         }\n168       }\n169     }\n170   }", "bm_classpath": "com.google.javascript.jscomp.FlowSensitiveInlineVariables"}, {"bug_name": "Closure_4", "report_text": "> Converting from an interface type to a constructor which @implements itself causes stack overflow.\n> \n> // Options: --externs externs/es3.js --property\\_renaming OFF --variable\\_renaming OFF --jscomp\\_warning=checkTypes --js=t.js\r\n> \r\n> \r\n> // File: t.js\r\n> /\\*\\*\r\n>  \\* @interface\r\n>  \\*/\r\n> var OtherType = function() {}\r\n> \r\n> /\\*\\*\r\n>  \\* @implements {MyType}\r\n>  \\* @constructor\r\n>  \\*/\r\n> var MyType = function() {}\r\n> \r\n> /\\*\\*\r\n>  \\* @type {MyType}\r\n>  \\*/\r\n> var x = /\\*\\* @type {!OtherType} \\*/ (new Object());\r\n> \r\n> Get Infinite recursion in:\r\n> \r\n> PrototypeObjectType.isSubtype @ 350\r\n> \r\n> Options:\r\n> \r\n> - prevent cycles in the inheritance/implements graph\r\n> - detect cycles after they are created and exit compilation before any subsequent passes run\r\n> - detect and remove cycles after they are created but before any subsequent passes run\r\n> - make every subsequent pass robust against cycles in that graph", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testImplementsExtendsLoop", "test_method": "  public void testImplementsExtendsLoop() throws Exception {\n    testClosureTypesMultipleWarnings(\n        suppressMissingProperty(\"foo\") +\n            \"/** @constructor \\n * @implements {F} */var G = function() {};\" +\n            \"/** @constructor \\n * @extends {G} */var F = function() {};\" +\n        \"alert((new F).foo);\",\n        Lists.newArrayList(\n            \"Parse error. Cycle detected in inheritance chain of type F\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE. can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE. can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2>\n\tcom.google.javascript.jscomp.TypeCheckTest.testClosureTypesMultipleWarnings(TypeCheckTest.java:11383)\n\tcom.google.javascript.jscomp.TypeCheckTest.testImplementsExtendsLoop(TypeCheckTest.java:9232)", "buggy_method": "183 @Override\n184   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n185     // TODO(user): Investigate whether it is really necessary to keep two\n186     // different mechanisms for resolving named types, and if so, which order\n187     // makes more sense. Now, resolution via registry is first in order to\n188     // avoid triggering the warnings built into the resolution via properties.\n189     boolean resolved = resolveViaRegistry(t, enclosing);\n190     if (detectImplicitPrototypeCycle()) {\n191       handleTypeCycle(t);\n192     }\n193 \n194     if (resolved) {\n195       super.resolveInternal(t, enclosing);\n196       finishPropertyContinuations();\n197       return registry.isLastGeneration() ?\n198           getReferencedType() : this;\n199     }\n200 \n201     resolveViaProperties(t, enclosing);\n202     if (detectImplicitPrototypeCycle()) {\n203       handleTypeCycle(t);\n204     }\n205 \n206     super.resolveInternal(t, enclosing);\n207     if (isResolved()) {\n208       finishPropertyContinuations();\n209     }\n210     return registry.isLastGeneration() ?\n211         getReferencedType() : this;\n212   }", "bm_classpath": "com.google.javascript.rhino.jstype.NamedType"}, {"bug_name": "Closure_5", "report_text": "> Compiler ignores 'delete' statements, can break functionality.\n> \n> When the compiler rewrites internally-referenced object variables to non-object variables, as in the example below, it ignores 'delete' statements. These delete statements work as expected with the objects originally written, but don't function the same when the variables are no longer object properties. See:\r\n> \r\n> (function(arg) {\r\n>  var foo = {};\r\n> \r\n>  foo.bar = arg;\r\n> \r\n>  console.log(foo.bar);\r\n> \r\n>  delete foo.bar;\r\n> \r\n>  console.log(foo.bar);\r\n> })();\r\n> \r\n> Compiles to (simple setting):\r\n> (function(a){console.log(a);delete a;console.log(a)})();\r\n> \r\n> Perhaps the compiler needs to look for these delete statements and change them to setting the rewritten variable to undefined instead.", "test_name": "com.google.javascript.jscomp.InlineObjectLiteralsTest::testNoInlineDeletedProperties", "test_method": "  public void testNoInlineDeletedProperties() {\n    testSameLocal(\n        \"var foo = {bar:1};\" +\n        \"delete foo.bar;\" +\n        \"return foo.bar;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:903)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.InlineObjectLiteralsTest.testLocal(InlineObjectLiteralsTest.java:362)\n\tcom.google.javascript.jscomp.InlineObjectLiteralsTest.testSameLocal(InlineObjectLiteralsTest.java:367)\n\tcom.google.javascript.jscomp.InlineObjectLiteralsTest.testNoInlineDeletedProperties(InlineObjectLiteralsTest.java:352)", "buggy_method": "155 private boolean isInlinableObject(List<Reference> refs) {\n156       boolean ret = false;\n157       Set<String> validProperties = Sets.newHashSet();\n158       for (Reference ref : refs) {\n159         Node name = ref.getNode();\n160         Node parent = ref.getParent();\n161         Node gramps = ref.getGrandparent();\n162 \n163         // Ignore most indirect references, like x.y (but not x.y(),\n164         // since the function referenced by y might reference 'this').\n165         //\n166         if (parent.isGetProp()) {\n167           Preconditions.checkState(parent.getFirstChild() == name);\n168           // A call target may be using the object as a 'this' value.\n169           if (gramps.isCall()\n170               && gramps.getFirstChild() == parent) {\n171             return false;\n172           }\n173 \n174           // Deleting a property has different semantics from deleting\n175           // a variable, so deleted properties should not be inlined.\n176 \n177           // NOTE(nicksantos): This pass's object-splitting algorithm has\n178           // a blind spot. It assumes that if a property isn't defined on an\n179           // object, then the value is undefined. This is not true, because\n180           // Object.prototype can have arbitrary properties on it.\n181           //\n182           // We short-circuit this problem by bailing out if we see a reference\n183           // to a property that isn't defined on the object literal. This\n184           // isn't a perfect algorithm, but it should catch most cases.\n185           String propName = parent.getLastChild().getString();\n186           if (!validProperties.contains(propName)) {\n187             if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n188               validProperties.add(propName);\n189             } else {\n190               return false;\n191             }\n192           }\n193           continue;\n194         }\n195 \n196         // Only rewrite VAR declarations or simple assignment statements\n197         if (!isVarOrAssignExprLhs(name)) {\n198            return false;\n199         }\n200 \n201         Node val = ref.getAssignedValue();\n202         if (val == null) {\n203           // A var with no assignment.\n204           continue;\n205         }\n206 \n207         // We're looking for object literal assignments only.\n208         if (!val.isObjectLit()) {\n209           return false;\n210         }\n211 \n212         // Make sure that the value is not self-referential. IOW,\n213         // disallow things like x = {b: x.a}.\n214         //\n215         // TODO: Only exclude unorderable self-referential\n216         // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n217         // but x = {a: 1, b: x.a} is.\n218         //\n219         // Also, ES5 getters/setters aren't handled by this pass.\n220         for (Node child = val.getFirstChild(); child != null;\n221              child = child.getNext()) {\n222           if (child.isGetterDef() ||\n223               child.isSetterDef()) {\n224             // ES5 get/set not supported.\n225             return false;\n226           }\n227 \n228           validProperties.add(child.getString());\n229 \n230           Node childVal = child.getFirstChild();\n231           // Check if childVal is the parent of any of the passed in\n232           // references, as that is how self-referential assignments\n233           // will happen.\n234           for (Reference t : refs) {\n235             Node refNode = t.getParent();\n236             while (!NodeUtil.isStatementBlock(refNode)) {\n237               if (refNode == childVal) {\n238                 // There's a self-referential assignment\n239                 return false;\n240               }\n241               refNode = refNode.getParent();\n242             }\n243           }\n244         }\n245 \n246 \n247         // We have found an acceptable object literal assignment. As\n248         // long as there are no other assignments that mess things up,\n249         // we can inline.\n250         ret = true;\n251       }\n252       return ret;\n253     }", "bm_classpath": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior"}, {"bug_name": "Closure_6", "report_text": "> better 'this' type checking\n> \n> /\\*\\* @constructor \\*/\r\n> function F() {}\r\n> F.prototype.bar = function() { this.baz(); };\r\n> F.prototype.baz = function() { };\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> function G() {}\r\n> G.prototype.bar = F.prototype.bar;\r\n> \r\n> We should notice that \"F.prototype.bar\" and \"G.prototype.bar\" have different \"this\" types, and emit a warning.", "test_name": "com.google.javascript.jscomp.LooseTypeCheckTest::testTypeRedefinition", "test_method": "  public void testTypeRedefinition() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"a={};/**@enum {string}*/ a.A = {ZOR:'b'};\"\n        + \"/** @constructor */ a.A = function() {}\",\n        Lists.newArrayList(\n            \"variable a.A redefined with type function (new:a.A): undefined, \" +\n            \"original definition at [testcode]:1 with type enum{a.A}\",\n            \"assignment to property A of a\\n\" +\n            \"found   : function (new:a.A): undefined\\n\" +\n            \"required: enum{a.A}\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2> but was:<1>\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testClosureTypesMultipleWarnings(LooseTypeCheckTest.java:6939)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypeRedefinition(LooseTypeCheckTest.java:2121)", "buggy_method": "362 boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n363       JSType leftType, Node owner, String propName) {\n364     // The NoType check is a hack to make typedefs work OK.\n365     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n366       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n367         registerMismatch(rightType, leftType, null);\n368       } else {\n369       // Do not type-check interface methods, because we expect that\n370       // they will have dummy implementations that do not match the type\n371       // annotations.\n372       JSType ownerType = getJSType(owner);\n373       if (ownerType.isFunctionPrototypeType()) {\n374         FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n375         if (ownerFn.isInterface() &&\n376             rightType.isFunctionType() && leftType.isFunctionType()) {\n377           return true;\n378         }\n379       }\n380 \n381       mismatch(t, n,\n382           \"assignment to property \" + propName + \" of \" +\n383           getReadableJSTypeName(owner, true),\n384           rightType, leftType);\n385       }\n386       return false;\n387     }\n388     return true;\n389   }", "bm_classpath": "com.google.javascript.jscomp.TypeValidator"}, {"bug_name": "Closure_7", "report_text": "> Bad type inference with goog.isFunction and friends\n> \n> experimental/johnlenz/typeerror/test.js:16: WARNING - Property length\r\n> never defined on Number\r\n>  var i = object.length;\r\n> \r\n> \r\n> This is the reduced test case:\r\n> \r\n> /\\*\\*\r\n>  \\* @param {\\*} object Any object.\r\n>  \\* @return {boolean}\r\n>  \\*/\r\n> test.isMatched = function(object) {\r\n>  if (goog.isDef(object)) {\r\n>  if (goog.isFunction(object)) {\r\n>  // return object();\r\n>  } else if (goog.isBoolean(object)) {\r\n>  // return object;\r\n>  } else if (goog.isString(object)) {\r\n>  // return test.isDef(object);\r\n>  } else if (goog.isArray(object)) {\r\n>  var i = object.length;\r\n>  }\r\n>  }\r\n>  return false;\r\n> };", "test_name": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsFunction2", "test_method": "  public void testGoogIsFunction2() throws Exception {\n    testClosureFunction(\"goog.isFunction\",\n        OBJECT_NUMBER_STRING_BOOLEAN,\n        U2U_CONSTRUCTOR_TYPE,\n        OBJECT_NUMBER_STRING_BOOLEAN); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: (Object|boolean|number|string)\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:106)\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:96)\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testClosureFunction(ClosureReverseAbstractInterpreterTest.java:187)\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testGoogIsFunction2(ClosureReverseAbstractInterpreterTest.java:121)", "buggy_method": "609 @Override\n610     public JSType caseObjectType(ObjectType type) {\n611       if (value.equals(\"function\")) {\n612         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n613         return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n614           // Objects are restricted to \"Function\", subtypes are left\n615           // Only filter out subtypes of \"function\"\n616       }\n617       return matchesExpectation(\"object\") ? type : null;\n618     }", "bm_classpath": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter$RestrictByOneTypeOfResultVisitor"}, {"bug_name": "Closure_8", "report_text": "> Obfuscated code triggers TypeError in Firefox\n> \n> The Closure Compiler is a great tool, but I'm having problems with it. It often produces code that triggers TypeError in Firefox, even though original code does not. Here is why. The original code may look as follows:\r\n> \r\n> function(argument){\r\n> ...//use argument\r\n> var variable = ...;\r\n> ...//argument not used anymore\r\n> }\r\n> \r\n> But often Closure Compiler will translate it to:\r\n> function(a){\r\n> ...\r\n> var a = ...;\r\n> ...\r\n> }\r\n> \r\n> This is not wrong JS, since argument is no longer used, Closure Compiler tries to reuse the name 'a' for something else.\r\n> \r\n> This triggers the following in Firefox 13-15:\r\n> TypeError: variable a re-declares argument\r\n> \r\n> Still, the resulting code is correct and runs, but it's very annoying debugging it when I'm getting all the time a lot of TypeErrors in the console.\r\n> \r\n> Also, our customers have noticed these TypeErrors when testing the product and it undermines our code reliability.\r\n> \r\n> Could you please rename variables in such a way as to avoid these TypeErrors (not to rename vars in a way that will coincide with function argument names)?\r\n> \r\n> **What steps will reproduce the problem?**\n> This happens reproducibly on our real-life JS input, which I cannot submit for various reasons. If my problem description is not clear enough, please make a comment and I will try to construct some artificial example that also triggers the TypeError.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> The expected output is obfuscated code with variables renamed to unique names, in order not to trigger TypeError in Firefox. Instead I see variables renamed to the same name, which runs OK, but Firefox complains with TypeError.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 20120917 (revision 2180)\r\n> Built on: 2012/09/17 14:33\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.CollapseVariableDeclarationsTest::testIssue820", "test_method": "  public void testIssue820() throws Exception {\n    // Don't redeclare function parameters, this is incompatible with\n    // strict mode.\n    testSame(\"function f(a){ var b=1; a=2; var c; }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:560)\n\tcom.google.javascript.jscomp.CollapseVariableDeclarationsTest.testIssue820(CollapseVariableDeclarationsTest.java:48)", "buggy_method": "190 private boolean canBeRedeclared(Node n, Scope s) {\n191       if (!NodeUtil.isExprAssign(n)) {\n192         return false;\n193       }\n194       Node assign = n.getFirstChild();\n195       Node lhs = assign.getFirstChild();\n196 \n197       if (!lhs.isName()) {\n198         return false;\n199       }\n200 \n201       Var var = s.getVar(lhs.getString());\n202       return var != null\n203           && var.getScope() == s\n204           && !blacklistedVars.contains(var);\n205     }", "bm_classpath": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses"}, {"bug_name": "Closure_9", "report_text": "> Compiler fails to find amd module in a subdirectory\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Create 1st AMD module in lib/Foo.js\r\n> 2. Create 2nd AMD module in Bar.js depending on lib/Foo.js\r\n> 3. Try to compile both files with Bar.js as main module\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> java -jar compiler.jar --transform\\_amd\\_modules --process\\_common\\_js\\_modules --common\\_js\r\n> \\_entry\\_module=Bar.js --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --js\\_output\\_file=out.js --js=Bar.js --js=lib/Foo.js\r\n> ERROR - required entry point \"module$lib$Foo\" never provided\r\n> \r\n> 1 error(s), 0 warning(s)\r\n> make: \\*\\*\\* [out.js] Error 1\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Latest version from trunk including fix for issue #804\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Find minimal not-working example attached with Makefile. The same setup has been working prior to fix for #804 (although with backslashes). This feature does not seem to have enough unit test coverage.", "test_name": "com.google.javascript.jscomp.ProcessCommonJSModulesTest::testGuessModuleName", "test_method": "  public void testGuessModuleName() {\n    ProcessCommonJSModules pass = new ProcessCommonJSModules(null, \"foo\");\n    assertEquals(\"module$baz\",\n        pass.guessCJSModuleName(\"foo\\\\baz.js\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<module$[]baz> but was:<module$[foo\\]baz>\n\tcom.google.javascript.jscomp.ProcessCommonJSModulesTest.testGuessModuleName(ProcessCommonJSModulesTest.java:132)", "buggy_method": "116 private String normalizeSourceName(String filename) {\n117     // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n118     // wrestle it back.\n119 \n120     if (filename.indexOf(filenamePrefix) == 0) {\n121       filename = filename.substring(filenamePrefix.length());\n122     }\n123 \n124     return filename;\n125   }", "bm_classpath": "com.google.javascript.jscomp.ProcessCommonJSModules"}, {"bug_name": "Closure_10", "report_text": "> Wrong code generated if mixing types in ternary operator\n> \n> **What steps will reproduce the problem?**\n> 1. Use Google Closure Compiler to compile this code:\r\n> \r\n>  var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;\r\n> \r\n> You can either simple or advanced. It doesn't matter\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> I'm seeing this as a result:\r\n>  var a = (0.5 < Math.random() ? 1 : 2) + 7;\r\n> \r\n> This is obviously wrong as the '1' string literal got converted to a number, and 3+4 got combined into 7 while that's not ok as '1' + 3 + 4 = '134', not '17'.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> **Please provide any additional information below.**\n> \r\n> Seems like this issue happens only when you are mixing types together. If both 1 and 2 are string literals or if they are both numbers it won't happen. I was also a little surprised to see this happening in simple mode as it actually breaks the behavior.", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIssue821", "test_method": "  public void testIssue821() {\n    foldSame(\"var a =(Math.random()>0.5? '1' : 2 ) + 3 + 4;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:560)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.foldSame(PeepholeFoldConstantsTest.java:67)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testIssue821(PeepholeFoldConstantsTest.java:581)", "buggy_method": "1415 static boolean mayBeString(Node n, boolean recurse) {\n1416     if (recurse) {\n1417       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n1418     } else {\n1419       return mayBeStringHelper(n);\n1420     }\n1421   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_11", "report_text": "> Record type invalid property not reported on function with @this annotation\n> \n> Code:\r\n> \r\n> var makeClass = function(protoMethods) {\r\n>  var clazz = function() {\r\n>  this.initialize.apply(this, arguments);\r\n>  }\r\n>  for (var i in protoMethods) {\r\n>  clazz.prototype[i] = protoMethods[i];\r\n>  }\r\n> \r\n>  return clazz;\r\n> }\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @param {{name: string, height: number}} options\r\n>  \\*/\r\n> var Person = function(options){};\r\n> Person = makeClass(/\\*\\* @lends Person.prototype \\*/ {\r\n>  /\\*\\*\r\n>  \\* @this {Person}\r\n>  \\* @param {{name: string, height: number}} options\r\n>  \\*/\r\n>  initialize: function(options) {\r\n>  /\\*\\* @type {string} \\*/ this.name\\_ = options.thisPropDoesNotExist;\r\n>  },\r\n> \r\n>  /\\*\\*\r\n>  \\* @param {string} message\r\n>  \\* @this {Person}\r\n>  \\*/\r\n>  say: function(message) {\r\n>  window.console.log(this.name\\_ + ' says: ' + message);\r\n>  }\r\n> });\r\n> \r\n> \r\n> var joe = new Person({name: 'joe', height: 300});\r\n> joe.say('hi');\r\n> \r\n> \r\n> compiled with:\r\n> java -jar build/compiler.jar --formatting=PRETTY\\_PRINT --jscomp\\_error=checkTypes --jscomp\\_error=externsValidation --compilation\\_level=SIMPLE\\_OPTIMIZATIONS repro.js\r\n> \r\n> \r\n> I would expect an error on this line:\r\n>  /\\*\\* @type {string} \\*/ this.name\\_ = options.thisPropDoesNotExist;\r\n> \r\n> which works in other contexts.\r\n> \r\n> Thanks!", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testGetprop4", "test_method": "  public void testGetprop4() throws Exception {\n    testTypes(\"var x = null; x.prop = 3;\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10495)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10475)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10413)\n\tcom.google.javascript.jscomp.TypeCheckTest.testGetprop4(TypeCheckTest.java:3927)", "buggy_method": "1303 private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n1304     // obj.prop or obj.method()\n1305     // Lots of types can appear on the left, a call to a void function can\n1306     // never be on the left. getPropertyType will decide what is acceptable\n1307     // and what isn't.\n1308     Node property = n.getLastChild();\n1309     Node objNode = n.getFirstChild();\n1310     JSType childType = getJSType(objNode);\n1311 \n1312     if (childType.isDict()) {\n1313       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n1314     } else if (n.getJSType() != null && parent.isAssign()) {\n1315       return;\n1316     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n1317         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n1318       checkPropertyAccess(childType, property.getString(), t, n);\n1319     }\n1320     ensureTyped(t, n);\n1321   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_12", "report_text": "> Try/catch blocks incorporate code not inside original blocks\n> \n> **What steps will reproduce the problem?**\n> \r\n> Starting with this code:\r\n> \r\n> -----\r\n> function a() {\r\n>  var x = '1';\r\n>  try {\r\n>  x += somefunction();\r\n>  } catch(e) {\r\n>  }\r\n>  x += \"2\";\r\n>  try {\r\n>  x += somefunction();\r\n>  } catch(e) {\r\n>  }\r\n>  document.write(x);\r\n> }\r\n> \r\n> a();\r\n> a();\r\n> -----\r\n> \r\n> It gets compiled to:\r\n> \r\n> -----\r\n> function b() {\r\n>  var a;\r\n>  try {\r\n>  a = \"1\" + somefunction()\r\n>  }catch(c) {\r\n>  }\r\n>  try {\r\n>  a = a + \"2\" + somefunction()\r\n>  }catch(d) {\r\n>  }\r\n>  document.write(a)\r\n> }\r\n> b();\r\n> b();\r\n> -----\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> The problem is that it's including the constant \"1\" and \"2\" inside the try block when the shouldn't be. When executed uncompiled, the script prints \"1212\". When compiled, the script prints \"undefinedundefined\".\r\n> \r\n> This behavior doesn't happen if the entire function gets inlined, or if the code between the two try blocks is sufficiently complex.\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 20120430 (revision 1918)\r\n> Built on: 2012/04/30 18:02\r\n> java version \"1.6.0\\_33\"\r\n> Java(TM) SE Runtime Environment (build 1.6.0\\_33-b03-424-11M3720)\r\n> Java HotSpot(TM) 64-Bit Server VM (build 20.8-b03-424, mixed mode)", "test_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testIssue794b", "test_method": "  public void testIssue794b() {\n    noInline(\n        \"var x = 1; \" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"x = x + 1;\" +\n        \"try { x = x + someFunction(); } catch (e) {}\" +\n        \"return x;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:409)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:387)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:526)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:522)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testIssue794b(FlowSensitiveInlineVariablesTest.java:513)", "buggy_method": "159 private boolean hasExceptionHandler(Node cfgNode) {\n160     return false;\n161   }", "bm_classpath": "com.google.javascript.jscomp.MaybeReachingVariableUse"}, {"bug_name": "Closure_13", "report_text": "> true/false are not always replaced for !0/!1\n> \n> **What steps will reproduce the problem?**\n> \r\n> function some\\_function() {\r\n>  var fn1;\r\n>  var fn2;\r\n> \r\n>  if (any\\_expression) {\r\n>  fn2 = external\\_ref;\r\n>  fn1 = function (content) {\r\n>  return fn2();\r\n>  }\r\n>  }\r\n> \r\n>  return {\r\n>  method1: function () {\r\n>  if (fn1) fn1();\r\n>  return true;\r\n>  },\r\n>  method2: function () {\r\n>  return false;\r\n>  }\r\n>  }\r\n> }\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> We expect that true/false will be replaced for !0/!1, but it doesn't happend.\r\n> \r\n> function some\\_function() {\r\n>  var a, b;\r\n>  any\\_expression && (b = external\\_ref, a = function () {\r\n>  return b()\r\n>  });\r\n>  return {\r\n>  method1: function () {\r\n>  a && a();\r\n>  return true\r\n>  },\r\n>  method2: function () {\r\n>  return false\r\n>  }\r\n>  }\r\n> };\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> This is output for latest official build.\r\n> I also got the same output for 20120430, 20120305. But 20111117 is OK.\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Here is just one of example. I found too many non-replaced true/false in compiler output. Replacement non-replaced true/false to !1/!0 in conpiler output saves 1-2 kb for 850 kb js file.", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIssue787", "test_method": "  public void testIssue787() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var fn1;\\n\" +\n        \"  var fn2;\\n\" +\n        \"\\n\" +\n        \"  if (any_expression) {\\n\" +\n        \"    fn2 = external_ref;\\n\" +\n        \"    fn1 = function (content) {\\n\" +\n        \"      return fn2();\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return {\\n\" +\n        \"    method1: function () {\\n\" +\n        \"      if (fn1) fn1();\\n\" +\n        \"      return true;\\n\" +\n        \"    },\\n\" +\n        \"    method2: function () {\\n\" +\n        \"      return false;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"}\";\n\n    String result = \"\" +\n        \"function some_function() {\\n\" +\n        \"  var a, b;\\n\" +\n        \"  any_expression && (b = external_ref, a = function() {\\n\" +\n        \"    return b()\\n\" +\n        \"  });\\n\" +\n        \"  return{method1:function() {\\n\" +\n        \"    a && a();\\n\" +\n        \"    return !0\\n\" +\n        \"  }, method2:function() {\\n\" +\n        \"    return !1\\n\" +\n        \"  }}\\n\" +\n        \"}\\n\" +\n        \"\";\n\n    test(options, code, result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:94)\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:76)\n\tcom.google.javascript.jscomp.IntegrationTest.testIssue787(IntegrationTest.java:2262)", "buggy_method": "113 private void traverse(Node node) {\n114     // The goal here is to avoid retraversing\n115     // the entire AST to catch newly created opportunities.\n116     // So we track whether a \"unit of code\" has changed,\n117     // and revisit immediately.\n118     if (!shouldVisit(node)) {\n119       return;\n120     }\n121 \n122     int visits = 0;\n123     do {\n124       Node c = node.getFirstChild();\n125       while(c != null) {\n126         traverse(c);\n127         Node next = c.getNext();\n128         c = next;\n129       }\n130 \n131       visit(node);\n132       visits++;\n133 \n134       Preconditions.checkState(visits < 10000, \"too many interations\");\n135     } while (shouldRetraverse(node));\n136 \n137     exitNode(node);\n138   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeOptimizationsPass"}, {"bug_name": "Closure_14", "report_text": "> bogus 'missing return' warning\n> \n> The following sample code compiles with \"Missing return statement. Function expected to return boolean.\" warning:\r\n> \r\n> /\\*\\*\r\n>  \\* @return {boolean}\r\n>  \\*/\r\n> function fb(a)\r\n> {\r\n>  try\r\n>  {\r\n>  alert(a); // Some method, which can throw\r\n>  if (a > 0)\r\n>  return false;\r\n>  }\r\n>  finally\r\n>  {\r\n>  a = 5;\r\n>  }\r\n>  \r\n>  return true;\r\n> }", "test_name": "com.google.javascript.jscomp.CheckMissingReturnTest::testIssue779", "test_method": "  public void testIssue779() {\n    testNotMissing(\n        \"var a = f(); try { alert(); if (a > 0) return 1; }\" +\n        \"finally { a = 5; } return 2;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_MISSING_RETURN_STATEMENT. Missing return statement. Function expected to return number. at testcode line 1 : 24 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:816)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:560)\n\tcom.google.javascript.jscomp.CheckMissingReturnTest.testNotMissing(CheckMissingReturnTest.java:210)\n\tcom.google.javascript.jscomp.CheckMissingReturnTest.testNotMissing(CheckMissingReturnTest.java:215)\n\tcom.google.javascript.jscomp.CheckMissingReturnTest.testIssue779(CheckMissingReturnTest.java:195)", "buggy_method": "692 private static Node computeFollowNode(\n693       Node fromNode, Node node, ControlFlowAnalysis cfa) {\n694     /*\n695      * This is the case where:\n696      *\n697      * 1. Parent is null implies that we are transferring control to the end of\n698      * the script.\n699      *\n700      * 2. Parent is a function implies that we are transferring control back to\n701      * the caller of the function.\n702      *\n703      * 3. If the node is a return statement, we should also transfer control\n704      * back to the caller of the function.\n705      *\n706      * 4. If the node is root then we have reached the end of what we have been\n707      * asked to traverse.\n708      *\n709      * In all cases we should transfer control to a \"symbolic return\" node.\n710      * This will make life easier for DFAs.\n711      */\n712     Node parent = node.getParent();\n713     if (parent == null || parent.isFunction() ||\n714         (cfa != null && node == cfa.root)) {\n715       return null;\n716     }\n717 \n718     // If we are just before a IF/WHILE/DO/FOR:\n719     switch (parent.getType()) {\n720       // The follow() of any of the path from IF would be what follows IF.\n721       case Token.IF:\n722         return computeFollowNode(fromNode, parent, cfa);\n723       case Token.CASE:\n724       case Token.DEFAULT_CASE:\n725         // After the body of a CASE, the control goes to the body of the next\n726         // case, without having to go to the case condition.\n727         if (parent.getNext() != null) {\n728           if (parent.getNext().isCase()) {\n729             return parent.getNext().getFirstChild().getNext();\n730           } else if (parent.getNext().isDefaultCase()) {\n731             return parent.getNext().getFirstChild();\n732           } else {\n733             Preconditions.checkState(false, \"Not reachable\");\n734           }\n735         } else {\n736           return computeFollowNode(fromNode, parent, cfa);\n737         }\n738         break;\n739       case Token.FOR:\n740         if (NodeUtil.isForIn(parent)) {\n741           return parent;\n742         } else {\n743           return parent.getFirstChild().getNext().getNext();\n744         }\n745       case Token.WHILE:\n746       case Token.DO:\n747         return parent;\n748       case Token.TRY:\n749         // If we are coming out of the TRY block...\n750         if (parent.getFirstChild() == node) {\n751           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n752             return computeFallThrough(parent.getLastChild());\n753           } else { // and have no FINALLY.\n754             return computeFollowNode(fromNode, parent, cfa);\n755           }\n756         // CATCH block.\n757         } else if (NodeUtil.getCatchBlock(parent) == node){\n758           if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n759             return computeFallThrough(node.getNext());\n760           } else {\n761             return computeFollowNode(fromNode, parent, cfa);\n762           }\n763         // If we are coming out of the FINALLY block...\n764         } else if (parent.getLastChild() == node){\n765           if (cfa != null) {\n766             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n767               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n768             }\n769           }\n770           return computeFollowNode(fromNode, parent, cfa);\n771         }\n772     }\n773 \n774     // Now that we are done with the special cases follow should be its\n775     // immediate sibling, unless its sibling is a function\n776     Node nextSibling = node.getNext();\n777 \n778     // Skip function declarations because control doesn't get pass into it.\n779     while (nextSibling != null && nextSibling.isFunction()) {\n780       nextSibling = nextSibling.getNext();\n781     }\n782 \n783     if (nextSibling != null) {\n784       return computeFallThrough(nextSibling);\n785     } else {\n786       // If there are no more siblings, control is transferred up the AST.\n787       return computeFollowNode(fromNode, parent, cfa);\n788     }\n789   }", "bm_classpath": "com.google.javascript.jscomp.ControlFlowAnalysis"}, {"bug_name": "Closure_15", "report_text": "> Switched order of \"delete key\" and \"key in\" statements changes semantic\n> \n> // Input:\r\n> \r\n> var customData = { key: 'value' };\r\n> \r\n> function testRemoveKey( key ) {\r\n>  var dataSlot = customData,\r\n>  retval = dataSlot && dataSlot[ key ],\r\n>  hadKey = dataSlot && ( key in dataSlot );\r\n> \r\n>  if ( dataSlot )\r\n>  delete dataSlot[ key ];\r\n> \r\n>  return hadKey ? retval : null;\r\n> };\r\n> \r\n> console.log( testRemoveKey( 'key' ) ); // 'value'\r\n> console.log( 'key' in customData ); // false\r\n> \r\n> \r\n> // Compiled version:\r\n> \r\n> var customData={key:\"value\"};function testRemoveKey(b){var a=customData,c=a&&a[b];a&&delete a[b];return a&&b in a?c:null}console.log(testRemoveKey(\"key\"));console.log(\"key\"in customData);\r\n> \r\n> // null\r\n> // false\r\n> \r\n> \r\n> \"b in a\" is executed after \"delete a[b]\" what obviously doesn't make sense in this case.\r\n> \r\n> \r\n> Reproducible on: http://closure-compiler.appspot.com/home and in \"Version: 20120430 (revision 1918) Built on: 2012/04/30 18:02\"", "test_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testSimpleForIn", "test_method": "  public void testSimpleForIn() {\n    inline(\"var a,b,x = a in b; x\",\n           \"var a,b,x; a in b\");\n    noInline(\"var a, b; var x = a in b; print(1); x\");\n    noInline(\"var a,b,x = a in b; delete a[b]; x\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:409)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:387)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:457)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:453)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testSimpleForIn(FlowSensitiveInlineVariablesTest.java:68)", "buggy_method": "83 @Override\n84       public boolean apply(Node n) {\n85         // When the node is null it means, we reached the implicit return\n86         // where the function returns (possibly without an return statement)\n87         if (n == null) {\n88           return false;\n89         }\n90 \n91         // TODO(user): We only care about calls to functions that\n92         // passes one of the dependent variable to a non-side-effect free\n93         // function.\n94         if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n95           return true;\n96         }\n97 \n98         if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n99           return true;\n100         }\n101 \n102 \n103         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n104           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n105             return true;\n106           }\n107         }\n108         return false;\n109       }", "bm_classpath": "com.google.javascript.jscomp.FlowSensitiveInlineVariables$1"}, {"bug_name": "Closure_16", "report_text": "> JSCompiler does not recursively resolve typedefs\n> \n> goog.provide('a.b.c');\r\n> \r\n> goog.scope(function() {\r\n> var b = a.b;\r\n> var c = b.c;\r\n> \r\n> /\\*\\* @typedef {string} \\*/\r\n> c.MyType;\r\n> \r\n> /\\*\\* @param {c.MyType} x The variable. \\*/\r\n> c.myFunc = function(x) {};\r\n> \r\n> });\r\n> \r\n> results in a compiler error.\r\n> \r\n> given that JSCompiler \\*does\\* recursively resolve other names, this appears to be a bug rather than an intended limitation.", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIssue772", "test_method": "  public void testIssue772() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.closurePass = true;\n    options.checkTypes = true;\n    test(\n        options,\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"goog.scope(function() {\" +\n        \"  var b = a.b;\" +\n        \"  var c = b.c;\" +\n        \"  /** @typedef {string} */\" +\n        \"  c.MyType;\" +\n        \"  /** @param {c.MyType} x The variable. */\" +\n        \"  c.myFunc = function(x) {};\" +\n        \"});\",\n        \"/** @const */ var a = {};\" +\n        \"/** @const */ a.b = {};\" +\n        \"/** @const */ a.b.c = {};\" +\n        \"a.b.c.MyType;\" +\n        \"a.b.c.myFunc = function(x) {};\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected no warnings or errors\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:86)\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:76)\n\tcom.google.javascript.jscomp.IntegrationTest.testIssue772(IntegrationTest.java:1868)", "buggy_method": "457 private void fixTypeNode(Node typeNode) {\n458       if (typeNode.isString()) {\n459         String name = typeNode.getString();\n460         int endIndex = name.indexOf('.');\n461         if (endIndex == -1) {\n462           endIndex = name.length();\n463         }\n464         String baseName = name.substring(0, endIndex);\n465         Var aliasVar = aliases.get(baseName);\n466         if (aliasVar != null) {\n467           Node aliasedNode = aliasVar.getInitialValue();\n468           aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n469         }\n470       }\n471 \n472       for (Node child = typeNode.getFirstChild(); child != null;\n473            child = child.getNext()) {\n474         fixTypeNode(child);\n475       }\n476     }", "bm_classpath": "com.google.javascript.jscomp.ScopedAliases$Traversal"}, {"bug_name": "Closure_17", "report_text": "> @const dumps type cast information\n> \n> The following code compiles fine:\r\n> \r\n> /\\*\\*\r\n> \\* Class defining an interface with two numbers.\r\n> \\* @interface\r\n> \\*/\r\n> function TwoNumbers() {}\r\n> \r\n> /\\*\\* @type number \\*/\r\n> TwoNumbers.prototype.first;\r\n> \r\n> /\\*\\* @type number \\*/\r\n> TwoNumbers.prototype.second;\r\n> \r\n> var SOME\\_DEFAULT =\r\n>  /\\*\\* @type {TwoNumbers} \\*/ ({first: 1, second: 2});\r\n> \r\n> /\\*\\*\r\n>  \\* Class with a two number member.\r\n>  \\* @constructor\r\n>  \\*/\r\n> function HasTwoNumbers() {\r\n>  /\\*\\* @type {TwoNumbers} \\*/\r\n>  this.twoNumbers = this.getTwoNumbers();\r\n> }\r\n> \r\n> /\\*\\*\r\n>  \\* Get the default two numbers.\r\n>  \\* @return {TwoNumbers}\r\n>  \\*/\r\n> HasTwoNumbers.prototype.getTwoNumbers = function() {\r\n>  return SOME\\_DEFAULT;\r\n> };\r\n> \r\n> Now realizing that SOME\\_DEFAULTS is actually a preset constant which should not change I would like to say for that line (just adding an @const)\r\n> \r\n> /\\*\\* @const \\*/ var SOME\\_DEFAULT =\r\n>  /\\*\\* @type {TwoNumbers} \\*/ ({first: 1, second: 2});\r\n> \r\n> However that starts throwing warnings as adding the @const makes the compiler dump the type. (Does the value get inlined without the typecast?)\r\n> \r\n> Expected:\r\n> Compiles fine.\r\n> \r\n> Error can be reproduced on:\r\n> http://closure-compiler.appspot.com/home\r\n> copy-past the attached file in there, it throws a warning and does not compile.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue688", "test_method": "  public void testIssue688() throws Exception {\n    testTypes(\n        \"/** @const */ var SOME_DEFAULT =\\n\" +\n        \"    /** @type {TwoNumbers} */ ({first: 1, second: 2});\\n\" +\n        \"/**\\n\" +\n        \"* Class defining an interface with two numbers.\\n\" +\n        \"* @interface\\n\" +\n        \"*/\\n\" +\n        \"function TwoNumbers() {}\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.first;\\n\" +\n        \"/** @type number */\\n\" +\n        \"TwoNumbers.prototype.second;\\n\" +\n        \"/** @return {number} */ function f() { return SOME_DEFAULT; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : (TwoNumbers|null)\\n\" +\n        \"required: number\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<in[consistent return type\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10224)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10203)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10141)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue688(TypeCheckTest.java:5906)", "buggy_method": "1267 private JSType getDeclaredType(String sourceName, JSDocInfo info,\n1268         Node lValue, @Nullable Node rValue) {\n1269       if (info != null && info.hasType()) {\n1270         return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n1271       } else if (rValue != null && rValue.isFunction() &&\n1272           shouldUseFunctionLiteralType(\n1273               JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n1274         return rValue.getJSType();\n1275       } else if (info != null) {\n1276         if (info.hasEnumParameterType()) {\n1277           if (rValue != null && rValue.isObjectLit()) {\n1278             return rValue.getJSType();\n1279           } else {\n1280             return createEnumTypeFromNodes(\n1281                 rValue, lValue.getQualifiedName(), info, lValue);\n1282           }\n1283         } else if (info.isConstructor() || info.isInterface()) {\n1284           return createFunctionTypeFromNodes(\n1285               rValue, lValue.getQualifiedName(), info, lValue);\n1286         } else {\n1287           // Check if this is constant, and if it has a known type.\n1288           if (info.isConstant()) {\n1289             JSType knownType = null;\n1290             if (rValue != null) {\n1291               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n1292                 // If rValue has a type-cast, we use the type in the type-cast.\n1293                 // If rValue's type was already computed during scope creation,\n1294                 // then we can safely use that.\n1295                 return rValue.getJSType();\n1296               } else if (rValue.isOr()) {\n1297                 // Check for a very specific JS idiom:\n1298                 // var x = x || TYPE;\n1299                 // This is used by Closure's base namespace for esoteric\n1300                 // reasons.\n1301                 Node firstClause = rValue.getFirstChild();\n1302                 Node secondClause = firstClause.getNext();\n1303                 boolean namesMatch = firstClause.isName()\n1304                     && lValue.isName()\n1305                     && firstClause.getString().equals(lValue.getString());\n1306                 if (namesMatch && secondClause.getJSType() != null\n1307                     && !secondClause.getJSType().isUnknownType()) {\n1308                   return secondClause.getJSType();\n1309                 }\n1310               }\n1311             }\n1312           }\n1313         }\n1314       }\n1315 \n1316       return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n1317     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_18", "report_text": "> Dependency sorting with closurePass set to false no longer works.\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Instantiate new instance of Compiler\r\n> \r\n> 2. Set closurePass to false to prevent goog.require/goog.provide removal.\r\n> compilerOptions.setClosurePass(false);\r\n> \r\n> 3. Turn dependency sorting on.\r\n> DependencyOptions dependencyOptions = new DependencyOptions();\r\n> dependencyOptions.setDependencySorting(true);\r\n> \r\n> 4. Compile js code\r\n> \r\n> \r\n> What is the expected output? \r\n> Dependent files should be sorted and concatenated in their dependent order.\r\n> \r\n> What do you see instead?\r\n> Dependent files are not sorted.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> > r1824\r\n> mac OS 10.7\r\n> \r\n> \r\n> **Please provide any additional information below.**\n> This worked in the r1810 release. However, it looks like this was changed in r1824. The compiler now expects closurePass to be true for dependency sorting to work.\r\n> http://code.google.com/p/closure-compiler/source/detail?path=/trunk/src/com/google/javascript/jscomp/Compiler.java&r=1824\r\n> \r\n> What we are looking for is a way to sort dependencies and concatenate all files in their dependent order without removing the goog.require/goog.provide js calls. Turning closurePass to true causes the goog calls to be replaced. We use this methodology in local development to test our JS code.\r\n> \r\n> Thanks!", "test_name": "com.google.javascript.jscomp.IntegrationTest::testDependencySorting", "test_method": "  public void testDependencySorting() throws Exception {\n    CompilerOptions options = createCompilerOptions();\n    options.setDependencyOptions(\n        new DependencyOptions()\n        .setDependencySorting(true));\n    test(\n        options,\n        new String[] {\n          \"goog.require('x');\",\n          \"goog.provide('x');\",\n        },\n        new String[] {\n          \"goog.provide('x');\",\n          \"goog.require('x');\",\n\n          // For complicated reasons involving modules,\n          // the compiler creates a synthetic source file.\n          \"\",\n        }); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:94)\n\tcom.google.javascript.jscomp.IntegrationTest.testDependencySorting(IntegrationTest.java:2107)", "buggy_method": "1240 Node parseInputs() {\n1241     boolean devMode = options.devMode != DevMode.OFF;\n1242 \n1243     // If old roots exist (we are parsing a second time), detach each of the\n1244     // individual file parse trees.\n1245     if (externsRoot != null) {\n1246       externsRoot.detachChildren();\n1247     }\n1248     if (jsRoot != null) {\n1249       jsRoot.detachChildren();\n1250     }\n1251 \n1252     // Parse main JS sources.\n1253     jsRoot = IR.block();\n1254     jsRoot.setIsSyntheticBlock(true);\n1255 \n1256     externsRoot = IR.block();\n1257     externsRoot.setIsSyntheticBlock(true);\n1258 \n1259     externAndJsRoot = IR.block(externsRoot, jsRoot);\n1260     externAndJsRoot.setIsSyntheticBlock(true);\n1261 \n1262     if (options.tracer.isOn()) {\n1263       tracker = new PerformanceTracker(jsRoot, options.tracer);\n1264       addChangeHandler(tracker.getCodeChangeHandler());\n1265     }\n1266 \n1267     Tracer tracer = newTracer(\"parseInputs\");\n1268 \n1269     try {\n1270       // Parse externs sources.\n1271       for (CompilerInput input : externs) {\n1272         Node n = input.getAstRoot(this);\n1273         if (hasErrors()) {\n1274           return null;\n1275         }\n1276         externsRoot.addChildToBack(n);\n1277       }\n1278 \n1279       // Modules inferred in ProcessCommonJS pass.\n1280       if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n1281         processAMDAndCommonJSModules();\n1282       }\n1283 \n1284       hoistExterns(externsRoot);\n1285 \n1286       // Check if the sources need to be re-ordered.\n1287       boolean staleInputs = false;\n1288       if (options.dependencyOptions.needsManagement() && options.closurePass) {\n1289         for (CompilerInput input : inputs) {\n1290           // Forward-declare all the provided types, so that they\n1291           // are not flagged even if they are dropped from the process.\n1292           for (String provide : input.getProvides()) {\n1293             getTypeRegistry().forwardDeclareType(provide);\n1294           }\n1295         }\n1296 \n1297         try {\n1298           inputs =\n1299               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n1300               .manageDependencies(options.dependencyOptions, inputs);\n1301           staleInputs = true;\n1302         } catch (CircularDependencyException e) {\n1303           report(JSError.make(\n1304               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n1305 \n1306           // If in IDE mode, we ignore the error and keep going.\n1307           if (hasErrors()) {\n1308             return null;\n1309           }\n1310         } catch (MissingProvideException e) {\n1311           report(JSError.make(\n1312               MISSING_ENTRY_ERROR, e.getMessage()));\n1313 \n1314           // If in IDE mode, we ignore the error and keep going.\n1315           if (hasErrors()) {\n1316             return null;\n1317           }\n1318         }\n1319       }\n1320 \n1321       hoistNoCompileFiles();\n1322 \n1323       if (staleInputs) {\n1324         repartitionInputs();\n1325       }\n1326 \n1327       // Build the AST.\n1328       for (CompilerInput input : inputs) {\n1329         Node n = input.getAstRoot(this);\n1330         if (n == null) {\n1331           continue;\n1332         }\n1333 \n1334         if (devMode) {\n1335           runSanityCheck();\n1336           if (hasErrors()) {\n1337             return null;\n1338           }\n1339         }\n1340 \n1341         if (options.sourceMapOutputPath != null ||\n1342             options.nameReferenceReportPath != null) {\n1343 \n1344           // Annotate the nodes in the tree with information from the\n1345           // input file. This information is used to construct the SourceMap.\n1346           SourceInformationAnnotator sia =\n1347               new SourceInformationAnnotator(\n1348                   input.getName(), options.devMode != DevMode.OFF);\n1349           NodeTraversal.traverse(this, n, sia);\n1350         }\n1351 \n1352         jsRoot.addChildToBack(n);\n1353       }\n1354 \n1355       if (hasErrors()) {\n1356         return null;\n1357       }\n1358       return externAndJsRoot;\n1359     } finally {\n1360       stopTracer(tracer, \"parseInputs\");\n1361     }\n1362   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_19", "report_text": "> Type refining of 'this' raises IllegalArgumentException\n> \n> **What steps will reproduce the problem?**\n> 1. goog.isFunction(this) or goog.isObject(this) or goog.isNull(this) etc.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expected: normal compilation, checking the type of this\r\n> Actual output:\r\n> \r\n> 23: java.lang.IllegalArgumentException: Node cannot be refined. \r\n> THIS 1 [source\\_file: Input\\_0] : global this\r\n> \r\n>  at com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.declareNameInScope(ChainableReverseAbstractInterpreter.java:172)\r\n>  at com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.restrictParameter(ClosureReverseAbstractInterpreter.java:240)\r\n>  at com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.getPreciserScopeKnowingConditionOutcome(ClosureReverseAbstractInterpreter.java:221)\r\n>  at com.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:239)\r\n>  at com.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:59)\r\n>  at com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DataFlowAnalysis.java:448)\r\n>  at com.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:213)\r\n>  at com.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:181)\r\n>  at com.google.javascript.jscomp.TypeInferencePass.inferTypes(TypeInferencePass.java:90)\r\n>  at com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.enterScope(TypeInferencePass.java:106)\r\n>  at com.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:581)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:345)\r\n>  at com.google.javascript.jscomp.TypeInferencePass.inferTypes(TypeInferencePass.java:81)\r\n>  at com.google.javascript.jscomp.TypeInferencePass.process(TypeInferencePass.java:74)\r\n>  at com.google.javascript.jscomp.DefaultPassConfig$24$1.process(DefaultPassConfig.java:1119)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:296)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:273)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:187)\r\n>  at com.google.javascript.jscomp.Compiler.check(Compiler.java:768)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:683)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:79)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:586)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:583)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:628)\r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:651)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:601)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:583)\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Any version (local and http://closure-compiler.appspot.com/).\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> A workaround is to assign 'this' to a variable. \"var a=this;goog.isNull(a)\" works.", "test_name": "com.google.javascript.jscomp.TypeInferenceTest::testNoThisInference", "test_method": "  public void testNoThisInference() {\n    JSType thisType = createNullableType(OBJECT_TYPE);\n    assumingThisType(thisType);\n    inFunction(\"var out = 3; if (goog.isNull(this)) out = this;\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Node cannot be refined.\n\tcom.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter.declareNameInScope(ChainableReverseAbstractInterpreter.java:175)\n\tcom.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.restrictParameter(ClosureReverseAbstractInterpreter.java:239)\n\tcom.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter.getPreciserScopeKnowingConditionOutcome(ClosureReverseAbstractInterpreter.java:220)\n\tcom.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:235)\n\tcom.google.javascript.jscomp.TypeInference.branchedFlowThrough(TypeInference.java:64)\n\tcom.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DataFlowAnalysis.java:447)\n\tcom.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:212)\n\tcom.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:180)\n\tcom.google.javascript.jscomp.TypeInferenceTest.inFunction(TypeInferenceTest.java:126)\n\tcom.google.javascript.jscomp.TypeInferenceTest.testNoThisInference(TypeInferenceTest.java:1003)", "buggy_method": "157 protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n158     switch (node.getType()) {\n159       case Token.NAME:\n160         scope.inferSlotType(node.getString(), type);\n161         break;\n162 \n163       case Token.GETPROP:\n164         String qualifiedName = node.getQualifiedName();\n165         Preconditions.checkNotNull(qualifiedName);\n166 \n167         JSType origType = node.getJSType();\n168         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n169         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n170         break;\n171 \n172         // \"this\" references aren't currently modeled in the CFG.\n173 \n174       default:\n175         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n176             node.toStringTree());\n177     }\n178   }", "bm_classpath": "com.google.javascript.jscomp.type.ChainableReverseAbstractInterpreter"}, {"bug_name": "Closure_20", "report_text": "> String conversion optimization is incorrect\n> \n> **What steps will reproduce the problem?**\n> \r\n> var f = {\r\n>  valueOf: function() { return undefined; }\r\n> }\r\n> String(f)\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expected output: \"[object Object]\"\r\n> Actual output: \"undefined\"\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> All versions (http://closure-compiler.appspot.com/ as well).\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> The compiler optimizes String(x) calls by replacing them with x + ''. This is correct in most cases, but incorrect in corner cases like the one mentioned above.", "test_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testSimpleFunctionCall", "test_method": "  public void testSimpleFunctionCall() {\n    test(\"var a = String(23)\", \"var a = '' + 23\");\n    test(\"var a = String('hello')\", \"var a = '' + 'hello'\");\n    testSame(\"var a = String('hello', bar());\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:560)\n\tcom.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest.testSimpleFunctionCall(PeepholeSubstituteAlternateSyntaxTest.java:1031)", "buggy_method": "208 private Node tryFoldSimpleFunctionCall(Node n) {\n209     Preconditions.checkState(n.isCall());\n210     Node callTarget = n.getFirstChild();\n211     if (callTarget != null && callTarget.isName() &&\n212           callTarget.getString().equals(\"String\")) {\n213       // Fold String(a) to '' + (a) on immutable literals,\n214       // which allows further optimizations\n215       //\n216       // We can't do this in the general case, because String(a) has\n217       // slightly different semantics than '' + (a). See\n218       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n219       Node value = callTarget.getNext();\n220       if (value != null) {\n221         Node addition = IR.add(\n222             IR.string(\"\").srcref(callTarget),\n223             value.detachFromParent());\n224         n.getParent().replaceChild(n, addition);\n225         reportCodeChange();\n226         return addition;\n227       }\n228     }\n229     return n;\n230   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"}, {"bug_name": "Closure_21", "report_text": "> Classify non-rightmost expressions as problematic\n> \n> **Purpose of code changes:**\n> When it comes to an expression involving the comma operator, only the\r\n> first element of such a sequence is checked for being free of side\r\n> effects. If the element is free of side effects, it is classified as\r\n> problematic and a warning is issued.\r\n> \r\n> As other non-rightmost elements are not checked for being free of side\r\n> effects and therefore cannot be classified as problematic, this leads\r\n> to unexpected behavior:\r\n> \r\n> 1. foo((1, 2, 42)) is transformed into foo((1, 3)) and a warning is\r\n> issued only with regard to the first element.\r\n> 2. foo((bar(), 2, 42)) is transformed into foo((bar(), 3)) and no\r\n> warning is issued.\r\n> 3. foo(((1, 2, 3), (4, 5, 42))) is transformed into foo((1, 4, 42)) and\r\n> warnings are issued with regard to the first elements of inner\r\n> sequences only.", "test_name": "com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode", "test_method": "  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one warning, repeated 1 time(s). expected:<1> but was:<0>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:841)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.test(CheckSideEffectsTest.java:39)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.testUselessCode(CheckSideEffectsTest.java:71)", "buggy_method": "83 @Override\n84   public void visit(NodeTraversal t, Node n, Node parent) {\n85     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n86     // I've been unable to think of any cases where this indicates a bug,\n87     // and apparently some people like keeping these semicolons around,\n88     // so we'll allow it.\n89     if (n.isEmpty() ||\n90         n.isComma()) {\n91       return;\n92     }\n93 \n94     if (parent == null) {\n95       return;\n96     }\n97 \n98     // Do not try to remove a block or an expr result. We already handle\n99     // these cases when we visit the child, and the peephole passes will\n100     // fix up the tree in more clever ways when these are removed.\n101     if (n.isExprResult()) {\n102       return;\n103     }\n104 \n105     // This no-op statement was there so that JSDoc information could\n106     // be attached to the name. This check should not complain about it.\n107     if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n108       return;\n109     }\n110 \n111     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n112     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n113     if (parent.getType() == Token.COMMA) {\n114       if (isResultUsed) {\n115         return;\n116       }\n117       if (n == parent.getLastChild()) {\n118         for (Node an : parent.getAncestors()) {\n119           int ancestorType = an.getType();\n120           if (ancestorType == Token.COMMA) continue;\n121           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n122           else break;\n123         }\n124       }\n125     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n126       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n127         return;\n128       }\n129     }\n130     if (\n131         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n132       String msg = \"This code lacks side-effects. Is there a bug?\";\n133       if (n.isString()) {\n134         msg = \"Is there a missing '+' on the previous line?\";\n135       } else if (isSimpleOp) {\n136         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n137             \"' operator is not being used.\";\n138       }\n139 \n140       t.getCompiler().report(\n141           t.makeError(n, level, USELESS_CODE_ERROR, msg));\n142       // TODO(johnlenz): determine if it is necessary to\n143       // try to protect side-effect free statements as well.\n144       if (!NodeUtil.isStatement(n)) {\n145         problemNodes.add(n);\n146       }\n147     }\n148   }", "bm_classpath": "com.google.javascript.jscomp.CheckSideEffects"}, {"bug_name": "Closure_22", "report_text": "> Classify non-rightmost expressions as problematic\n> \n> **Purpose of code changes:**\n> When it comes to an expression involving the comma operator, only the\r\n> first element of such a sequence is checked for being free of side\r\n> effects. If the element is free of side effects, it is classified as\r\n> problematic and a warning is issued.\r\n> \r\n> As other non-rightmost elements are not checked for being free of side\r\n> effects and therefore cannot be classified as problematic, this leads\r\n> to unexpected behavior:\r\n> \r\n> 1. foo((1, 2, 42)) is transformed into foo((1, 3)) and a warning is\r\n> issued only with regard to the first element.\r\n> 2. foo((bar(), 2, 42)) is transformed into foo((bar(), 3)) and no\r\n> warning is issued.\r\n> 3. foo(((1, 2, 3), (4, 5, 42))) is transformed into foo((1, 4, 42)) and\r\n> warnings are issued with regard to the first elements of inner\r\n> sequences only.", "test_name": "com.google.javascript.jscomp.CheckSideEffectsTest::testUselessCode", "test_method": "  public void testUselessCode() {\n    test(\"function f(x) { if(x) return; }\", ok);\n    test(\"function f(x) { if(x); }\", \"function f(x) { if(x); }\", e);\n\n    test(\"if(x) x = y;\", ok);\n    test(\"if(x) x == bar();\", \"if(x) JSCOMPILER_PRESERVE(x == bar());\", e);\n\n    test(\"x = 3;\", ok);\n    test(\"x == 3;\", \"JSCOMPILER_PRESERVE(x == 3);\", e);\n\n    test(\"var x = 'test'\", ok);\n    test(\"var x = 'test'\\n'str'\",\n         \"var x = 'test'\\nJSCOMPILER_PRESERVE('str')\", e);\n\n    test(\"\", ok);\n    test(\"foo();;;;bar();;;;\", ok);\n\n    test(\"var a, b; a = 5, b = 6\", ok);\n    test(\"var a, b; a = 5, b == 6\",\n         \"var a, b; a = 5, JSCOMPILER_PRESERVE(b == 6)\", e);\n    test(\"var a, b; a = (5, 6)\",\n         \"var a, b; a = (JSCOMPILER_PRESERVE(5), 6)\", e);\n    test(\"var a, b; a = (bar(), 6, 7)\",\n         \"var a, b; a = (bar(), JSCOMPILER_PRESERVE(6), 7)\", e); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one warning, repeated 1 time(s). expected:<1> but was:<0>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:841)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.test(CheckSideEffectsTest.java:39)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.testUselessCode(CheckSideEffectsTest.java:71)", "buggy_method": "83 @Override\n84   public void visit(NodeTraversal t, Node n, Node parent) {\n85     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n86     // I've been unable to think of any cases where this indicates a bug,\n87     // and apparently some people like keeping these semicolons around,\n88     // so we'll allow it.\n89     if (n.isEmpty() ||\n90         n.isComma()) {\n91       return;\n92     }\n93 \n94     if (parent == null) {\n95       return;\n96     }\n97 \n98     // Do not try to remove a block or an expr result. We already handle\n99     // these cases when we visit the child, and the peephole passes will\n100     // fix up the tree in more clever ways when these are removed.\n101     if (parent.getType() == Token.COMMA) {\n102       Node gramps = parent.getParent();\n103       if (gramps.isCall() && parent == gramps.getFirstChild()) {\n104         if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n105       return;\n106         }\n107     }\n108 \n109     // This no-op statement was there so that JSDoc information could\n110     // be attached to the name. This check should not complain about it.\n111       if (n == parent.getLastChild()) {\n112         for (Node an : parent.getAncestors()) {\n113           int ancestorType = an.getType();\n114           if (ancestorType == Token.COMMA)\n115             continue;\n116           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n117             return;\n118           else\n119             break;\n120         }\n121       }\n122     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n123       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n124            n == parent.getFirstChild().getNext().getNext())) {\n125       } else {\n126       return;\n127       }\n128     }\n129 \n130     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n131     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n132     if (!isResultUsed &&\n133         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n134       if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n135         return;\n136       } else if (n.isExprResult()) {\n137         return;\n138       }\n139       String msg = \"This code lacks side-effects. Is there a bug?\";\n140       if (n.isString()) {\n141         msg = \"Is there a missing '+' on the previous line?\";\n142       } else if (isSimpleOp) {\n143         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n144             \"' operator is not being used.\";\n145       }\n146 \n147       t.getCompiler().report(\n148           t.makeError(n, level, USELESS_CODE_ERROR, msg));\n149       // TODO(johnlenz): determine if it is necessary to\n150       // try to protect side-effect free statements as well.\n151       if (!NodeUtil.isStatement(n)) {\n152         problemNodes.add(n);\n153       }\n154     }\n155   }", "bm_classpath": "com.google.javascript.jscomp.CheckSideEffects"}, {"bug_name": "Closure_23", "report_text": "> tryFoldArrayAccess does not check for side effects\n> \n> **What steps will reproduce the problem?**\n> 1. Compile the following program with simple or advanced optimization:\r\n> console.log([console.log('hello, '), 'world!'][1]);\r\n> \r\n> **What is the expected output? What do you see instead?**\n> The expected output would preserve side effects. It would not transform the program at all or transform it into:\r\n> \r\n> console.log((console.log(\"hello\"), \"world!\"));\r\n> \r\n> Instead, the program is transformed into:\r\n> \r\n> console.log(\"world!\");\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Revision 2022. Ubuntu 12.04.\r\n> \r\n> **Please provide any additional information below.**\n> tryFoldArrayAccess in com.google.javascript.jscomp.PeepholeFoldConstants should check whether every array element that is not going to be preserved has no side effects.", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldGetElem", "test_method": "  public void testFoldGetElem() {\n    fold(\"x = [,10][0]\", \"x = void 0\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR. Array index out of bounds: NUMBER 0.0 1 [source_file: testcode] at testcode line 1 : 10 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:816)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.fold(PeepholeFoldConstantsTest.java:71)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testFoldGetElem(PeepholeFoldConstantsTest.java:765)", "buggy_method": "1422 private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n1423     Node parent = n.getParent();\n1424     // If GETPROP/GETELEM is used as assignment target the array literal is\n1425     // acting as a temporary we can't fold it here:\n1426     //    \"[][0] += 1\"\n1427     if (isAssignmentTarget(n)) {\n1428       return n;\n1429     }\n1430 \n1431     if (!right.isNumber()) {\n1432       // Sometimes people like to use complex expressions to index into\n1433       // arrays, or strings to index into array methods.\n1434       return n;\n1435     }\n1436 \n1437     double index = right.getDouble();\n1438     int intIndex = (int) index;\n1439     if (intIndex != index) {\n1440       error(INVALID_GETELEM_INDEX_ERROR, right);\n1441       return n;\n1442     }\n1443 \n1444     if (intIndex < 0) {\n1445       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n1446       return n;\n1447     }\n1448 \n1449     Node current = left.getFirstChild();\n1450     Node elem = null;\n1451     for (int i = 0; current != null && i < intIndex; i++) {\n1452         elem = current;\n1453 \n1454       current = current.getNext();\n1455     }\n1456 \n1457     if (elem == null) {\n1458       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n1459       return n;\n1460     }\n1461 \n1462     if (elem.isEmpty()) {\n1463       elem = NodeUtil.newUndefinedNode(elem);\n1464     } else {\n1465       left.removeChild(elem);\n1466     }\n1467 \n1468     // Replace the entire GETELEM with the value\n1469     n.getParent().replaceChild(n, elem);\n1470     reportCodeChange();\n1471     return elem;\n1472   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_24", "report_text": "> goog.scope doesn't properly check declared functions\n> \n> The following code is a compiler error:\r\n> \r\n> goog.scope(function() {\r\n>  var x = function(){};\r\n> });\r\n> \r\n> but the following code is not:\r\n> \r\n> goog.scope(function() {\r\n>  function x() {}\r\n> });\r\n> \r\n> Both code snippets should be a compiler error, because they prevent the goog.scope from being unboxed.", "test_name": "com.google.javascript.jscomp.ScopedAliasesTest::testNonAliasLocal", "test_method": "  public void testNonAliasLocal() {\n    testScopedFailure(\"var x = 10\", ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom + 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog['dom']\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"var x = goog.dom, y = 10\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL);\n    testScopedFailure(\"function f() {}\",\n        ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:932)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testScopedFailure(ScopedAliasesTest.java:359)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testNonAliasLocal(ScopedAliasesTest.java:413)", "buggy_method": "272 private void findAliases(NodeTraversal t) {\n273       Scope scope = t.getScope();\n274       for (Var v : scope.getVarIterable()) {\n275         Node n = v.getNode();\n276         int type = n.getType();\n277         Node parent = n.getParent();\n278         if (parent.isVar()) {\n279           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n280           String name = n.getString();\n281           Var aliasVar = scope.getVar(name);\n282           aliases.put(name, aliasVar);\n283 \n284           String qualifiedName =\n285               aliasVar.getInitialValue().getQualifiedName();\n286           transformation.addAlias(name, qualifiedName);\n287           // Bleeding functions already get a BAD_PARAMETERS error, so just\n288           // do nothing.\n289           // Parameters of the scope function also get a BAD_PARAMETERS\n290           // error.\n291         } else {\n292           // TODO(robbyw): Support using locals for private variables.\n293           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n294         }\n295         }\n296       }\n297     }", "bm_classpath": "com.google.javascript.jscomp.ScopedAliases$Traversal"}, {"bug_name": "Closure_25", "report_text": "> anonymous object type inference behavior is different when calling constructors\n> \n> The following compiles fine with:\r\n> java -jar build/compiler.jar --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --jscomp\\_error=accessControls --jscomp\\_error=checkTypes --jscomp\\_error=checkVars --js ~/Desktop/reverse.js\r\n> \r\n> reverse.js:\r\n> /\\*\\*\r\n>  \\* @param {{prop1: string, prop2: (number|undefined)}} parry\r\n>  \\*/\r\n> function callz(parry) {\r\n>  if (parry.prop2 && parry.prop2 < 5) alert('alright!');\r\n>  alert(parry.prop1);\r\n> }\r\n> \r\n> callz({prop1: 'hi'});\r\n> \r\n> \r\n> \r\n> However, the following does not:\r\n> /\\*\\*\r\n>  \\* @param {{prop1: string, prop2: (number|undefined)}} parry\r\n>  \\* @constructor\r\n>  \\*/\r\n> function callz(parry) {\r\n>  if (parry.prop2 && parry.prop2 < 5) alert('alright!');\r\n>  alert(parry.prop1);\r\n> }\r\n> \r\n> new callz({prop1: 'hi'});\r\n> \r\n> \r\n> /Users/dolapo/Desktop/reverse.js:10: ERROR - actual parameter 1 of callz does not match formal parameter\r\n> found : {prop1: string}\r\n> required: {prop1: string, prop2: (number|undefined)}\r\n> new callz({prop1: 'hi'});\r\n> \r\n> \r\n> \r\n> Thanks!", "test_name": "com.google.javascript.jscomp.TypeInferenceTest::testBackwardsInferenceNew", "test_method": "  public void testBackwardsInferenceNew() {\n    inFunction(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @param {{foo: (number|undefined)}} x\\n\" +\n        \" */\" +\n        \"function F(x) {}\" +\n        \"var y = {};\" +\n        \"new F(y);\");\n\n    assertEquals(\"{foo: (number|undefined)}\", getType(\"y\").toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{[foo: (number|undefined)]}> but was:<{[]}>\n\tcom.google.javascript.jscomp.TypeInferenceTest.testBackwardsInferenceNew(TypeInferenceTest.java:890)", "buggy_method": "1035 private FlowScope traverseNew(Node n, FlowScope scope) {\n1036 \n1037     Node constructor = n.getFirstChild();\n1038     scope = traverse(constructor, scope);\n1039     JSType constructorType = constructor.getJSType();\n1040     JSType type = null;\n1041     if (constructorType != null) {\n1042       constructorType = constructorType.restrictByNotNullOrUndefined();\n1043       if (constructorType.isUnknownType()) {\n1044         type = getNativeType(UNKNOWN_TYPE);\n1045       } else {\n1046         FunctionType ct = constructorType.toMaybeFunctionType();\n1047         if (ct == null && constructorType instanceof FunctionType) {\n1048           // If constructorType is a NoObjectType, then toMaybeFunctionType will\n1049           // return null. But NoObjectType implements the FunctionType\n1050           // interface, precisely because it can validly construct objects.\n1051           ct = (FunctionType) constructorType;\n1052         }\n1053         if (ct != null && ct.isConstructor()) {\n1054           type = ct.getInstanceType();\n1055         }\n1056       }\n1057     }\n1058     n.setJSType(type);\n1059     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n1060       scope = traverse(arg, scope);\n1061     }\n1062     return scope;\n1063   }", "bm_classpath": "com.google.javascript.jscomp.TypeInference"}, {"bug_name": "Closure_26", "report_text": "> ProcessCommonJSModules module$exports failures when checkTypes enabled\n> \n> If you define a module (echo.js) as:\r\n> define(function() { return {\r\n>  echo: function(val) {\r\n>  window.console.log(val);\r\n>  }\r\n> }});\r\n> \r\n> and an entry point\\* that does not define any new modules as:\r\n> var echo = require('echo');\r\n> echo.echo('hello world');\r\n> \r\n> and compile with:\r\n> java -jar build/compiler.jar --formatting=PRETTY\\_PRINT --jscomp\\_error=checkTypes --compilation\\_level=SIMPLE\\_OPTIMIZATIONS --transform\\_amd\\_modules --process\\_common\\_js\\_modules --js=echo.js --js=echo-main.js --common\\_js\\_entry\\_module=echo-main.js\r\n> \r\n> You get the error:\r\n> echo-main.js:1: ERROR - Property module$exports never defined on module$echo\\_main\r\n> \r\n> which is probably happening because of ProcessCommonJSModules#emitOptionalModuleExportsOverride is testing a property that doesn't exist. I can try to cook up a patch but it would probably fall back to using goog.isDef and there's probably a cleaner way :)\r\n> \r\n> \r\n> \r\n> \r\n> \\*p.s what is the intended definition of entry points that do not define new modules. the following leaves a call to a require function:\r\n> require(['echo'], function(echo) {\r\n>  echo.echo('hello world');\r\n> });", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testTransformAMDAndProcessCJS", "test_method": "  public void testTransformAMDAndProcessCJS() {\n    args.add(\"--transform_amd_modules\");\n    args.add(\"--process_common_js_modules\");\n    args.add(\"--common_js_entry_module=foo/bar\");\n    setFilename(0, \"foo/bar.js\");\n    test(\"define({foo: 1})\",\n        \"var module$foo$bar={}, module$foo$bar={foo:1};\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1109)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1080)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1072)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testTransformAMDAndProcessCJS(CommandLineRunnerTest.java:1057)", "buggy_method": "205 private void emitOptionalModuleExportsOverride(Node script,\n206         String moduleName) {\n207 \n208       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n209           IR.string(\"module$exports\"));\n210       script.addChildToBack(IR.ifNode(\n211           moduleExportsProp,\n212           IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n213               moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n214           script));\n215     }", "bm_classpath": "com.google.javascript.jscomp.ProcessCommonJSModules$ProcessCommonJsModulesCallback"}, {"bug_name": "Closure_27", "report_text": "> Error trying to build try-catch block (AST)\n> \n> 1. EXAMPLE\r\n> \r\n> Node nodeTry = IR.block(\r\n>  IR.var(\r\n>  IR.name(\"testing\"), \r\n>  IR.number(11)\r\n>  )\r\n> );\r\n> Node nodeCatch = IR.catchNode(\r\n>  IR.name(\"blabla\"),\r\n>  IR.block(\r\n>  IR.var(\r\n>  IR.name(\"testing\"),\r\n>  IR.number(22)\r\n>  )\r\n>  )\r\n> );\r\n> IR.tryCatch(nodeTry, nodeCatch);\r\n> \r\n> \r\n> 2. THROWS ERROR\r\n> \r\n> Exception in thread \"main\" java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(FUNCTION tt): input.js:2:4\r\n>  function tt() {\r\n>  Parent(BLOCK): input.js:1:4\r\n> try {\r\n> \r\n> \r\n> 3. SOLUTION\r\n> \r\n> IR.block is verifing the catch node is a statement which it isnt.", "test_name": "com.google.javascript.rhino.IRTest::testIssue727_1", "test_method": "  public void testIssue727_1() {\n    testIR(\n        IR.tryFinally(\n            IR.block(),\n            IR.block()),\n        \"TRY\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\" +\n        \"    BLOCK\\n\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException\n\tcom.google.common.base.Preconditions.checkState(Preconditions.java:129)\n\tcom.google.javascript.rhino.IR.tryFinally(IR.java:224)\n\tcom.google.javascript.rhino.IRTest.testIssue727_1(IRTest.java:48)", "buggy_method": "223 public static Node tryFinally(Node tryBody, Node finallyBody) {\n224     Preconditions.checkState(tryBody.isLabelName());\n225     Preconditions.checkState(finallyBody.isLabelName());\n226     Node catchBody = block().copyInformationFrom(tryBody);\n227     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n228   }", "bm_classpath": "com.google.javascript.rhino.IR"}, {"bug_name": "Closure_29", "report_text": "> closure compiler screws up a perfectly valid isFunction() implementation\n> \n> hi, this function does not get compiled correctly via google closure compiler\r\n> \r\n>  isFunction = function(functionToCheck) {\r\n>  var getType;\r\n>  getType = {}; //just an object\r\n>  return functionToCheck && getType.toString.apply(functionToCheck) === '[object Function]';\r\n>  };\r\n> \r\n> gets compiled into \r\n> \r\n> isFunction = function(a) {\r\n>  return a && \"[object Function]\" === (void 0).apply(a)\r\n> };\r\n> \r\n> to make it work, we have to use an array instead of an object (even though we just want to call the object toString method)\r\n> \r\n>  isFunction = function(functionToCheck) {\r\n>  var getType;\r\n>  getType = []; //not it's an array \r\n>  return functionToCheck && getType.toString.apply(functionToCheck) === '[object Function]';\r\n>  };\r\n> \r\n> gets compiled into\r\n> \r\n> isFunction = function(a) {\r\n>  var b;\r\n>  b = [];\r\n>  return a && \"[object Function]\" === b.toString.apply(a)\r\n> };\r\n> \r\n> and it does what it should do. \r\n> \r\n> i wasted an hour to find that bug. bugs me. great tool otherwise.", "test_name": "com.google.javascript.jscomp.InlineObjectLiteralsTest::testObject10", "test_method": "  public void testObject10() {\n    testLocal(\"var x; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b);\",\n         \"var JSCompiler_object_inline_a_0;\" +\n         \"var JSCompiler_object_inline_b_1;\" +\n         \"var b = f();\" +\n         \"JSCompiler_object_inline_a_0=a,JSCompiler_object_inline_b_1=b,true;\" +\n         \"if(JSCompiler_object_inline_a_0) g(JSCompiler_object_inline_b_1)\");\n    testLocal(\"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\",\n         \"var x = {}; var b = f(); x = {a:a, b:b}; if(x.a) g(x.b) + x.c\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:892)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:371)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:340)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:328)\n\tcom.google.javascript.jscomp.InlineObjectLiteralsTest.testLocal(InlineObjectLiteralsTest.java:355)\n\tcom.google.javascript.jscomp.InlineObjectLiteralsTest.testObject10(InlineObjectLiteralsTest.java:174)", "buggy_method": "155 private boolean isInlinableObject(List<Reference> refs) {\n156       boolean ret = false;\n157       for (Reference ref : refs) {\n158         Node name = ref.getNode();\n159         Node parent = ref.getParent();\n160         Node gramps = ref.getGrandparent();\n161 \n162         // Ignore indirect references, like x.y (except x.y(), since\n163         // the function referenced by y might reference 'this').\n164         //\n165         if (parent.isGetProp()) {\n166           Preconditions.checkState(parent.getFirstChild() == name);\n167           // A call target maybe using the object as a 'this' value.\n168           if (gramps.isCall()\n169               && gramps.getFirstChild() == parent) {\n170             return false;\n171           }\n172 \n173           // NOTE(nicksantos): This pass's object-splitting algorithm has\n174           // a blind spot. It assumes that if a property isn't defined on an\n175           // object, then the value is undefined. This is not true, because\n176           // Object.prototype can have arbitrary properties on it.\n177           //\n178           // We short-circuit this problem by bailing out if we see a reference\n179           // to a property that isn't defined on the object literal. This\n180           // isn't a perfect algorithm, but it should catch most cases.\n181           continue;\n182         }\n183 \n184         // Only rewrite VAR declarations or simple assignment statements\n185         if (!isVarOrAssignExprLhs(name)) {\n186            return false;\n187         }\n188 \n189         Node val = ref.getAssignedValue();\n190         if (val == null) {\n191           // A var with no assignment.\n192           continue;\n193         }\n194 \n195         // We're looking for object literal assignments only.\n196         if (!val.isObjectLit()) {\n197           return false;\n198         }\n199 \n200         // Make sure that the value is not self-refential. IOW,\n201         // disallow things like x = {b: x.a}.\n202         //\n203         // TODO: Only exclude unorderable self-referential\n204         // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n205         // but x = {a: 1, b: x.a} is.\n206         //\n207         // Also, ES5 getters/setters aren't handled by this pass.\n208         for (Node child = val.getFirstChild(); child != null;\n209              child = child.getNext()) {\n210           if (child.isGetterDef() ||\n211               child.isSetterDef()) {\n212             // ES5 get/set not supported.\n213             return false;\n214           }\n215 \n216 \n217           Node childVal = child.getFirstChild();\n218           // Check if childVal is the parent of any of the passed in\n219           // references, as that is how self-referential assignments\n220           // will happen.\n221           for (Reference t : refs) {\n222             Node refNode = t.getParent();\n223             while (!NodeUtil.isStatementBlock(refNode)) {\n224               if (refNode == childVal) {\n225                 // There's a self-referential assignment\n226                 return false;\n227               }\n228               refNode = refNode.getParent();\n229             }\n230           }\n231         }\n232 \n233 \n234         // We have found an acceptable object literal assignment. As\n235         // long as there are no other assignments that mess things up,\n236         // we can inline.\n237         ret = true;\n238       }\n239       return ret;\n240     }", "bm_classpath": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior"}, {"bug_name": "Closure_30", "report_text": "> Combining temporary strings are over-optimized in advanced build\n> \n> **What steps will reproduce the problem?**\n> 1. This bug only manifests itself in large code bases. How large, and what the specifics are, I haven't yet worked out, since the output differs. But the principle code is:\r\n> \r\n> sgxColorRGBA.prototype.asHex = function() {\r\n>  var hexString = \"\";\r\n>  \r\n>  str = (sgxFloor(this.r\\*255)).toString(16);\r\n>  if (str.length < 2) { str = \"0\"+str; }\r\n>  hexString += str;\r\n> \r\n>  str = (sgxFloor(this.g\\*255)).toString(16);\r\n>  if (str.length < 2) { str = \"0\"+str; }\r\n>  hexString += str;\r\n> \r\n>  str = (sgxFloor(this.b\\*255)).toString(16);\r\n>  if (str.length < 2) { str = \"0\"+str; }\r\n>  hexString += str;\r\n> \r\n>  str = (sgxFloor(this.a\\*255)).toString(16);\r\n>  if (str.length < 2) { str = \"0\"+str; }\r\n>  hexString += str;\r\n> \r\n>  return hexString;\r\n> }\r\n> \r\n> Note that 'str' is not declared as var.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I see this:\r\n> sgxColorRGBA.prototype.pb = function() {\r\n>  str = A(255 \\* this.A).toString(16);\r\n>  2 > str.length && (str = \"0\" + str);\r\n>  str = A(255 \\* this.w).toString(16);\r\n>  2 > str.length && (str = \"0\" + str);\r\n>  str = A(255 \\* this.s).toString(16);\r\n>  2 > str.length && (str = \"0\" + str);\r\n>  str = A(255 \\* this.r).toString(16);\r\n>  2 > str.length && (str = \"0\" + str);\r\n>  return\"\" + str + str + str + str\r\n> };\r\n> \r\n> Obviously, repeatedly adding 'str' is broken in the final line, compared to the original. So whatever is aggregating the result is seeing a temporary 'str' reference and combining it, I guess. If 'str' is declared as var, the problem goes away.\r\n> \r\n> I'd expect a warning, at least.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Live at http://closure-compiler.appspot.com\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> As a stand-alone method, both 'var str' and 'str' works. It's only when the project hits a certain (undetermined) size that it fails.", "test_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testInlineAcrossSideEffect1", "test_method": "  public void testInlineAcrossSideEffect1() {\n    // This can't be inlined because print() has side-effects and might change\n    // the definition of noSFX.\n    //\n    // noSFX must be both const and pure in order to inline it.\n    noInline(\"var y; var x = noSFX(y); print(x)\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:873)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:434)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:398)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:376)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:443)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:439)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testInlineAcrossSideEffect1(FlowSensitiveInlineVariablesTest.java:329)", "buggy_method": "155 @Override\n156   public void process(Node externs, Node root) {\n157     (new NodeTraversal(compiler, this)).traverse(root);\n158   }", "bm_classpath": "com.google.javascript.jscomp.FlowSensitiveInlineVariables"}, {"bug_name": "Closure_31", "report_text": "> Add support for --manage_closure_dependencies and --only_closure_dependencies with compilation level WHITESPACE_ONLY\n> \n> The compiler options --manage\\_closure\\_dependencies and --only\\_closure\\_dependencies are currently ignored with compilation level WHITESPACE\\_ONLY. It would be helpful for testing, if dependency management were supported for WHITESPACE\\_ONLY in addition to SIMPLE\\_OPTIMIZATIONS and ADVANCED\\_OPTIMIZATIONS. For example, both Closure Builder and plovr automatically manage dependencies for all compilation levels.\r\n> \r\n> The proposed change (see attached diff) does not automatically manage dependencies, but it enables dependency management if either --manage\\_closure\\_dependencies or --only\\_closure\\_dependencies is specified, or if at least one --closure\\_entry\\_point is specified.\r\n> \r\n> The attached diff passed the JUnit tests: ant test", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testDependencySortingWhitespaceMode", "test_method": "  public void testDependencySortingWhitespaceMode() {\n    args.add(\"--manage_closure_dependencies\");\n    args.add(\"--compilation_level=WHITESPACE_ONLY\");\n    test(new String[] {\n          \"goog.require('beer');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.provide('hops');\",\n         },\n         new String[] {\n          \"goog.provide('hops');\",\n          \"goog.provide('beer');\\ngoog.require('hops');\",\n          \"goog.require('beer');\"\n         }); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1034)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1005)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testDependencySortingWhitespaceMode(CommandLineRunnerTest.java:627)", "buggy_method": "1236 Node parseInputs() {\n1237     boolean devMode = options.devMode != DevMode.OFF;\n1238 \n1239     // If old roots exist (we are parsing a second time), detach each of the\n1240     // individual file parse trees.\n1241     if (externsRoot != null) {\n1242       externsRoot.detachChildren();\n1243     }\n1244     if (jsRoot != null) {\n1245       jsRoot.detachChildren();\n1246     }\n1247 \n1248     // Parse main js sources.\n1249     jsRoot = IR.block();\n1250     jsRoot.setIsSyntheticBlock(true);\n1251 \n1252     externsRoot = IR.block();\n1253     externsRoot.setIsSyntheticBlock(true);\n1254 \n1255     externAndJsRoot = IR.block(externsRoot, jsRoot);\n1256     externAndJsRoot.setIsSyntheticBlock(true);\n1257 \n1258     if (options.tracer.isOn()) {\n1259       tracker = new PerformanceTracker(jsRoot, options.tracer);\n1260       addChangeHandler(tracker.getCodeChangeHandler());\n1261     }\n1262 \n1263     Tracer tracer = newTracer(\"parseInputs\");\n1264 \n1265     try {\n1266       // Parse externs sources.\n1267       for (CompilerInput input : externs) {\n1268         Node n = input.getAstRoot(this);\n1269         if (hasErrors()) {\n1270           return null;\n1271         }\n1272         externsRoot.addChildToBack(n);\n1273       }\n1274 \n1275       // Modules inferred in ProcessCommonJS pass.\n1276       if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n1277         processAMDAndCommonJSModules();\n1278       }\n1279 \n1280       // Check if inputs need to be rebuilt from modules.\n1281       boolean staleInputs = false;\n1282 \n1283       // Check if the sources need to be re-ordered.\n1284       if (options.dependencyOptions.needsManagement() &&\n1285           !options.skipAllPasses &&\n1286           options.closurePass) {\n1287         for (CompilerInput input : inputs) {\n1288           // Forward-declare all the provided types, so that they\n1289           // are not flagged even if they are dropped from the process.\n1290           for (String provide : input.getProvides()) {\n1291             getTypeRegistry().forwardDeclareType(provide);\n1292           }\n1293         }\n1294 \n1295         try {\n1296           inputs =\n1297               (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n1298               .manageDependencies(options.dependencyOptions, inputs);\n1299           staleInputs = true;\n1300         } catch (CircularDependencyException e) {\n1301           report(JSError.make(\n1302               JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n1303 \n1304           // If in IDE mode, we ignore the error and keep going.\n1305           if (hasErrors()) {\n1306             return null;\n1307           }\n1308         } catch (MissingProvideException e) {\n1309           report(JSError.make(\n1310               MISSING_ENTRY_ERROR, e.getMessage()));\n1311 \n1312           // If in IDE mode, we ignore the error and keep going.\n1313           if (hasErrors()) {\n1314             return null;\n1315           }\n1316         }\n1317       }\n1318 \n1319       for (CompilerInput input : inputs) {\n1320         Node n = input.getAstRoot(this);\n1321 \n1322         // Inputs can have a null AST during initial parse.\n1323         if (n == null) {\n1324           continue;\n1325         }\n1326 \n1327         if (n.getJSDocInfo() != null) {\n1328           JSDocInfo info = n.getJSDocInfo();\n1329           if (info.isExterns()) {\n1330             // If the input file is explicitly marked as an externs file, then\n1331             // assume the programmer made a mistake and throw it into\n1332             // the externs pile anyways.\n1333             externsRoot.addChildToBack(n);\n1334             input.setIsExtern(true);\n1335 \n1336             input.getModule().remove(input);\n1337 \n1338             externs.add(input);\n1339             staleInputs = true;\n1340           } else if (info.isNoCompile()) {\n1341             input.getModule().remove(input);\n1342             staleInputs = true;\n1343           }\n1344         }\n1345       }\n1346 \n1347       if (staleInputs) {\n1348         fillEmptyModules(modules);\n1349         rebuildInputsFromModules();\n1350       }\n1351 \n1352       // Build the AST.\n1353       for (CompilerInput input : inputs) {\n1354         Node n = input.getAstRoot(this);\n1355         if (n == null) {\n1356           continue;\n1357         }\n1358 \n1359         if (devMode) {\n1360           runSanityCheck();\n1361           if (hasErrors()) {\n1362             return null;\n1363           }\n1364         }\n1365 \n1366         if (options.sourceMapOutputPath != null ||\n1367             options.nameReferenceReportPath != null) {\n1368 \n1369           // Annotate the nodes in the tree with information from the\n1370           // input file. This information is used to construct the SourceMap.\n1371           SourceInformationAnnotator sia =\n1372               new SourceInformationAnnotator(\n1373                   input.getName(), options.devMode != DevMode.OFF);\n1374           NodeTraversal.traverse(this, n, sia);\n1375         }\n1376 \n1377         jsRoot.addChildToBack(n);\n1378       }\n1379 \n1380       if (hasErrors()) {\n1381         return null;\n1382       }\n1383       return externAndJsRoot;\n1384     } finally {\n1385       stopTracer(tracer, \"parseInputs\");\n1386     }\n1387   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_32", "report_text": "> Preserve doesn't preserve whitespace at start of line\n> \n> **What steps will reproduce the problem?**\n> \r\n> Code such as:\r\n> /\\*\\*\r\n>  \\* @preserve\r\n> \r\n> This\r\n>  was\r\n>  ASCII\r\n>  Art\r\n> \r\n> \\*/\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> The words line up on the left:\r\n> /\\*\r\n> This\r\n> was\r\n> ASCII\r\n> Art\r\n> \\*/\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Live web verison.\r\n> \r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIssue701", "test_method": "  public void testIssue701() {\n    // Check ASCII art in license comments.\n    String ascii = \"/**\\n\" +\n        \" * @preserve\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\";\n    String result = \"/*\\n\\n\" +\n        \"   This\\n\" +\n        \"     is\\n\" +\n        \"       ASCII    ART\\n\" +\n        \"*/\\n\";\n    testSame(createCompilerOptions(), ascii);\n    assertEquals(result, lastCompiler.toSource()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:</*\n\tcom.google.javascript.jscomp.IntegrationTest.testIssue701(IntegrationTest.java:1674)", "buggy_method": "1328 @SuppressWarnings(\"fallthrough\")\n1329   private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n1330                                                       WhitespaceOption option) {\n1331 \n1332     if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n1333         token == JsDocToken.EOF) {\n1334       return new ExtractionInfo(\"\", token);\n1335     }\n1336 \n1337     stream.update();\n1338     int startLineno = stream.getLineno();\n1339     int startCharno = stream.getCharno() + 1;\n1340 \n1341     // Read the content from the first line.\n1342     String line = stream.getRemainingJSDocLine();\n1343     if (option != WhitespaceOption.PRESERVE) {\n1344       line = line.trim();\n1345     }\n1346 \n1347     StringBuilder builder = new StringBuilder();\n1348     builder.append(line);\n1349 \n1350     state = State.SEARCHING_ANNOTATION;\n1351     token = next();\n1352 \n1353     boolean ignoreStar = false;\n1354 \n1355     // Track the start of the line to count whitespace that\n1356     // the tokenizer skipped. Because this case is rare, it's easier\n1357     // to do this here than in the tokenizer.\n1358 \n1359     do {\n1360       switch (token) {\n1361         case STAR:\n1362           if (ignoreStar) {\n1363             // Mark the position after the star as the new start of the line.\n1364           } else {\n1365             // The star is part of the comment.\n1366             if (builder.length() > 0) {\n1367               builder.append(' ');\n1368             }\n1369 \n1370             builder.append('*');\n1371           }\n1372 \n1373           token = next();\n1374           continue;\n1375 \n1376         case EOL:\n1377           if (option != WhitespaceOption.SINGLE_LINE) {\n1378             builder.append(\"\\n\");\n1379           }\n1380 \n1381           ignoreStar = true;\n1382           token = next();\n1383           continue;\n1384 \n1385         default:\n1386           ignoreStar = false;\n1387           state = State.SEARCHING_ANNOTATION;\n1388 \n1389               // All tokens must be separated by a space.\n1390 \n1391           if (token == JsDocToken.EOC ||\n1392               token == JsDocToken.EOF ||\n1393               // When we're capturing a license block, annotations\n1394               // in the block are ok.\n1395               (token == JsDocToken.ANNOTATION &&\n1396                option != WhitespaceOption.PRESERVE)) {\n1397             String multilineText = builder.toString();\n1398 \n1399             if (option != WhitespaceOption.PRESERVE) {\n1400               multilineText = multilineText.trim();\n1401             }\n1402 \n1403             int endLineno = stream.getLineno();\n1404             int endCharno = stream.getCharno();\n1405 \n1406             if (multilineText.length() > 0) {\n1407               jsdocBuilder.markText(multilineText, startLineno, startCharno,\n1408                   endLineno, endCharno);\n1409             }\n1410 \n1411             return new ExtractionInfo(multilineText, token);\n1412           }\n1413 \n1414           if (builder.length() > 0) {\n1415             builder.append(' ');\n1416           }\n1417           builder.append(toString(token));\n1418 \n1419           line = stream.getRemainingJSDocLine();\n1420 \n1421           if (option != WhitespaceOption.PRESERVE) {\n1422             line = trimEnd(line);\n1423           }\n1424 \n1425           builder.append(line);\n1426           token = next();\n1427       }\n1428     } while (true);\n1429   }", "bm_classpath": "com.google.javascript.jscomp.parsing.JsDocInfoParser"}, {"bug_name": "Closure_33", "report_text": "> weird object literal invalid property error on unrelated object prototype\n> \n> Apologies in advance for the convoluted repro case and the vague summary.\r\n> \r\n> Compile the following code (attached as repro.js) with:\r\n> java -jar build/compiler.jar --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --jscomp\\_error=accessControls --jscomp\\_error=checkTypes --jscomp\\_error=checkVars --js repro.js \\*\r\n> \r\n> /\\*\\*\r\n>  \\* @param {{text: string}} opt\\_data\r\n>  \\* @return {string}\r\n>  \\*/\r\n> function temp1(opt\\_data) {\r\n>  return opt\\_data.text;\r\n> }\r\n> \r\n> /\\*\\*\r\n>  \\* @param {{activity: (boolean|number|string|null|Object)}} opt\\_data\r\n>  \\* @return {string}\r\n>  \\*/\r\n> function temp2(opt\\_data) {\r\n>  /\\*\\* @notypecheck \\*/\r\n>  function \\_\\_inner() {\r\n>  return temp1(opt\\_data.activity);\r\n>  }\r\n>  return \\_\\_inner();\r\n> }\r\n> \r\n> /\\*\\*\r\n>  \\* @param {{n: number, text: string, b: boolean}} opt\\_data\r\n>  \\* @return {string}\r\n>  \\*/\r\n> function temp3(opt\\_data) {\r\n>  return 'n: ' + opt\\_data.n + ', t: ' + opt\\_data.text + '.';\r\n> }\r\n> \r\n> function callee() {\r\n>  var output = temp3({\r\n>  n: 0,\r\n>  text: 'a string',\r\n>  b: true\r\n>  })\r\n>  alert(output);\r\n> }\r\n> \r\n> callee();\r\n> \r\n> \r\n> yields:\r\n> repro.js:30: ERROR - actual parameter 1 of temp3 does not match formal parameter\r\n> found : {b: boolean, n: number, text: (string|undefined)}\r\n> required: {b: boolean, n: number, text: string}\r\n>  var output = temp3({\r\n> \r\n> It seems like temp3 is actually being called with the right type {b: boolean, n: number, text: string} though it seems to think that text is a (string|undefined)\r\n> This seems to happen because of the seemingly unrelated code in functions temp1 and temp2. If I change the name of the text property (as in repro3.js) it works.\r\n> Additionally, if I fix the type of the activity property in the record type of temp2 it works (as in repro2.js)\r\n> \r\n> This comes up in our codebase in some situations where we don't have type info for all the objects being passed into a function. It's always a tricky one to find because it reports an error at a location that looks correct.\r\n> \r\n> \r\n> \\* it also fails with SIMPLE\\_OPTIMIZATIONS", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue700", "test_method": "  public void testIssue700() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @param {{text: string}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp1(opt_data) {\\n\" +\n        \"  return opt_data.text;\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{activity: (boolean|number|string|null|Object)}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp2(opt_data) {\\n\" +\n        \"  /** @notypecheck */\\n\" +\n        \"  function __inner() {\\n\" +\n        \"    return temp1(opt_data.activity);\\n\" +\n        \"  }\\n\" +\n        \"  return __inner();\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @param {{n: number, text: string, b: boolean}} opt_data\\n\" +\n        \" * @return {string}\\n\" +\n        \" */\\n\" +\n        \"function temp3(opt_data) {\\n\" +\n        \"  return 'n: ' + opt_data.n + ', t: ' + opt_data.text + '.';\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"function callee() {\\n\" +\n        \"  var output = temp3({\\n\" +\n        \"    n: 0,\\n\" +\n        \"    text: 'a string',\\n\" +\n        \"    b: true\\n\" +\n        \"  })\\n\" +\n        \"  alert(output);\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"callee();\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9908)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9882)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9820)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9816)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue700(TypeCheckTest.java:5777)", "buggy_method": "554 @Override\n555   public void matchConstraint(ObjectType constraintObj) {\n556     // We only want to match contraints on anonymous types.\n557 \n558     // Handle the case where the constraint object is a record type.\n559     //\n560     // param constraintObj {{prop: (number|undefined)}}\n561     // function f(constraintObj) {}\n562     // f({});\n563     //\n564     // We want to modify the object literal to match the constraint, by\n565     // taking any each property on the record and trying to match\n566     // properties on this object.\n567     if (constraintObj.isRecordType()) {\n568       for (String prop : constraintObj.getOwnPropertyNames()) {\n569         JSType propType = constraintObj.getPropertyType(prop);\n570         if (!isPropertyTypeDeclared(prop)) {\n571           JSType typeToInfer = propType;\n572           if (!hasProperty(prop)) {\n573             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n574                 .getLeastSupertype(propType);\n575           }\n576           defineInferredProperty(prop, typeToInfer, null);\n577         }\n578       }\n579     }\n580   }", "bm_classpath": "com.google.javascript.rhino.jstype.PrototypeObjectType"}, {"bug_name": "Closure_34", "report_text": "> StackOverflowError exception when running closure compiler (javascript attached)\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. I'm trying to run: java -jar compiler.jar --js AdMedia.eam.js --js\\_output\\_file AdMedia.eam.min.js\r\n> 2. AdMedia.eam.js is attached.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> I get the following exception:\r\n> java.lang.RuntimeException: java.lang.RuntimeException: java.lang.StackOverflowError\r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:643)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:588)\r\n>  at com.google.javascript.jscomp.Compiler.toSource(Compiler.java:1492)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.processResults(AbstractCommandLineRunner.java:788)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:726)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:334)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:871)\r\n> Caused by: java.lang.RuntimeException: java.lang.StackOverflowError\r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:643)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:588)\r\n>  at com.google.javascript.jscomp.Compiler.toSource(Compiler.java:1608)\r\n>  at com.google.javascript.jscomp.Compiler$5.call(Compiler.java:1503)\r\n>  at com.google.javascript.jscomp.Compiler$5.call(Compiler.java:1492)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:615)\r\n>  at java.lang.Thread.run(Unknown Source)\r\n> Caused by: java.lang.StackOverflowError\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:91)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n>  at com.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:103)\r\n>  at com.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:881)\r\n> .\r\n> .\r\n> .\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Closure:\r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 20120305 (revision 1810)\r\n> Built on: 2012/03/05 20:55\r\n> \r\n> Java:\r\n> java version \"1.6.0\\_31\"\r\n> Java(TM) SE Runtime Environment (build 1.6.0\\_31-b05)\r\n> Java HotSpot(TM) Client VM (build 20.6-b01, mixed mode, sharing)\r\n> \r\n> Windows 7 (64-bit)\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Works fine on the following Java version:\r\n> java version \"1.7.0\"\r\n> Java(TM) SE Runtime Environment (build 1.7.0-b147)\r\n> Java HotSpot(TM) 64-Bit Server VM (build 21.0-b17, mixed mode)", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testManyAdds", "test_method": "public void testManyAdds() {\n    int numAdds = 10000;\n    List<String> numbers = Lists.newArrayList(\"0\", \"1\");\n    Node current = new Node(Token.ADD, Node.newNumber(0), Node.newNumber(1));\n    for (int i = 2; i < numAdds; i++) {\n      current = new Node(Token.ADD, current);\n\n      // 1000 is printed as 1E3, and screws up our test.\n      int num = i % 1000;\n      numbers.add(String.valueOf(num));\n      current.addChildToBack(Node.newNumber(num));\n    }\n\n    String expected = Joiner.on(\"+\").join(numbers);\n    String actual = printNode(current).replace(\"\\n\", \"\");\n    assertEquals(expected, actual);\n  }", "error_message": "java.lang.StackOverflowError\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:102)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)\n\tcom.google.javascript.jscomp.CodeGenerator.add(CodeGenerator.java:122)\n\tcom.google.javascript.jscomp.CodeGenerator.addExpr(CodeGenerator.java:891)", "buggy_method": "85 void add(Node n, Context context) {\n86     if (!cc.continueProcessing()) {\n87       return;\n88     }\n89 \n90     int type = n.getType();\n91     String opstr = NodeUtil.opToStr(type);\n92     int childCount = n.getChildCount();\n93     Node first = n.getFirstChild();\n94     Node last = n.getLastChild();\n95 \n96     // Handle all binary operators\n97     if (opstr != null && first != last) {\n98       Preconditions.checkState(\n99           childCount == 2,\n100           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n101           opstr, childCount);\n102       int p = NodeUtil.precedence(type);\n103 \n104       // For right-hand-side of operations, only pass context if it's\n105       // the IN_FOR_INIT_CLAUSE one.\n106       Context rhsContext = getContextForNoInOperator(context);\n107 \n108       // Handle associativity.\n109       // e.g. if the parse tree is a * (b * c),\n110       // we can simply generate a * b * c.\n111       if (last.getType() == type &&\n112           NodeUtil.isAssociative(type)) {\n113         addExpr(first, p, context);\n114         cc.addOp(opstr, true);\n115         addExpr(last, p, rhsContext);\n116       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n117         // Assignments are the only right-associative binary operators\n118         addExpr(first, p, context);\n119         cc.addOp(opstr, true);\n120         addExpr(last, p, rhsContext);\n121       } else {\n122         addExpr(first, p, context);\n123         cc.addOp(opstr, true);\n124         addExpr(last, p + 1, rhsContext);\n125       }\n126       return;\n127     }\n128 \n129     cc.startSourceMapping(n);\n130 \n131     switch (type) {\n132       case Token.TRY: {\n133         Preconditions.checkState(first.getNext().isBlock() &&\n134                 !first.getNext().hasMoreThanOneChild());\n135         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n136 \n137         add(\"try\");\n138         add(first, Context.PRESERVE_BLOCK);\n139 \n140         // second child contains the catch block, or nothing if there\n141         // isn't a catch block\n142         Node catchblock = first.getNext().getFirstChild();\n143         if (catchblock != null) {\n144           add(catchblock);\n145         }\n146 \n147         if (childCount == 3) {\n148           add(\"finally\");\n149           add(last, Context.PRESERVE_BLOCK);\n150         }\n151         break;\n152       }\n153 \n154       case Token.CATCH:\n155         Preconditions.checkState(childCount == 2);\n156         add(\"catch(\");\n157         add(first);\n158         add(\")\");\n159         add(last, Context.PRESERVE_BLOCK);\n160         break;\n161 \n162       case Token.THROW:\n163         Preconditions.checkState(childCount == 1);\n164         add(\"throw\");\n165         add(first);\n166 \n167         // Must have a ';' after a throw statement, otherwise safari can't\n168         // parse this.\n169         cc.endStatement(true);\n170         break;\n171 \n172       case Token.RETURN:\n173         add(\"return\");\n174         if (childCount == 1) {\n175           add(first);\n176         } else {\n177           Preconditions.checkState(childCount == 0);\n178         }\n179         cc.endStatement();\n180         break;\n181 \n182       case Token.VAR:\n183         if (first != null) {\n184           add(\"var \");\n185           addList(first, false, getContextForNoInOperator(context));\n186         }\n187         break;\n188 \n189       case Token.LABEL_NAME:\n190         Preconditions.checkState(!n.getString().isEmpty());\n191         addIdentifier(n.getString());\n192         break;\n193 \n194       case Token.NAME:\n195         if (first == null || first.isEmpty()) {\n196           addIdentifier(n.getString());\n197         } else {\n198           Preconditions.checkState(childCount == 1);\n199           addIdentifier(n.getString());\n200           cc.addOp(\"=\", true);\n201           if (first.isComma()) {\n202             addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n203           } else {\n204             // Add expression, consider nearby code at lowest level of\n205             // precedence.\n206             addExpr(first, 0, getContextForNoInOperator(context));\n207           }\n208         }\n209         break;\n210 \n211       case Token.ARRAYLIT:\n212         add(\"[\");\n213         addArrayList(first);\n214         add(\"]\");\n215         break;\n216 \n217       case Token.PARAM_LIST:\n218         add(\"(\");\n219         addList(first);\n220         add(\")\");\n221         break;\n222 \n223       case Token.COMMA:\n224         Preconditions.checkState(childCount == 2);\n225         unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n226         break;\n227 \n228       case Token.NUMBER:\n229         Preconditions.checkState(childCount == 0);\n230         cc.addNumber(n.getDouble());\n231         break;\n232 \n233       case Token.TYPEOF:\n234       case Token.VOID:\n235       case Token.NOT:\n236       case Token.BITNOT:\n237       case Token.POS: {\n238         // All of these unary operators are right-associative\n239         Preconditions.checkState(childCount == 1);\n240         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n241         addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n242         break;\n243       }\n244 \n245       case Token.NEG: {\n246         Preconditions.checkState(childCount == 1);\n247 \n248         // It's important to our sanity checker that the code\n249         // we print produces the same AST as the code we parse back.\n250         // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n251         if (n.getFirstChild().isNumber()) {\n252           cc.addNumber(-n.getFirstChild().getDouble());\n253         } else {\n254           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n255           addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n256         }\n257 \n258         break;\n259       }\n260 \n261       case Token.HOOK: {\n262         Preconditions.checkState(childCount == 3);\n263         int p = NodeUtil.precedence(type);\n264         addExpr(first, p + 1, context);\n265         cc.addOp(\"?\", true);\n266         addExpr(first.getNext(), 1, Context.OTHER);\n267         cc.addOp(\":\", true);\n268         addExpr(last, 1, Context.OTHER);\n269         break;\n270       }\n271 \n272       case Token.REGEXP:\n273         if (!first.isString() ||\n274             !last.isString()) {\n275           throw new Error(\"Expected children to be strings\");\n276         }\n277 \n278         String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n279 \n280         // I only use one .add because whitespace matters\n281         if (childCount == 2) {\n282           add(regexp + last.getString());\n283         } else {\n284           Preconditions.checkState(childCount == 1);\n285           add(regexp);\n286         }\n287         break;\n288 \n289       case Token.FUNCTION:\n290         if (n.getClass() != Node.class) {\n291           throw new Error(\"Unexpected Node subclass.\");\n292         }\n293         Preconditions.checkState(childCount == 3);\n294         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n295         if (funcNeedsParens) {\n296           add(\"(\");\n297         }\n298 \n299         add(\"function\");\n300         add(first);\n301 \n302         add(first.getNext());\n303         add(last, Context.PRESERVE_BLOCK);\n304         cc.endFunction(context == Context.STATEMENT);\n305 \n306         if (funcNeedsParens) {\n307           add(\")\");\n308         }\n309         break;\n310 \n311       case Token.GETTER_DEF:\n312       case Token.SETTER_DEF:\n313         Preconditions.checkState(n.getParent().isObjectLit());\n314         Preconditions.checkState(childCount == 1);\n315         Preconditions.checkState(first.isFunction());\n316 \n317         // Get methods are unnamed\n318         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n319         if (type == Token.GETTER_DEF) {\n320           // Get methods have no parameters.\n321           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n322           add(\"get \");\n323         } else {\n324           // Set methods have one parameter.\n325           Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n326           add(\"set \");\n327         }\n328 \n329         // The name is on the GET or SET node.\n330         String name = n.getString();\n331         Node fn = first;\n332         Node parameters = fn.getChildAtIndex(1);\n333         Node body = fn.getLastChild();\n334 \n335         // Add the property name.\n336         if (!n.isQuotedString() &&\n337             TokenStream.isJSIdentifier(name) &&\n338             // do not encode literally any non-literal characters that were\n339             // unicode escaped.\n340             NodeUtil.isLatin(name)) {\n341           add(name);\n342         } else {\n343           // Determine if the string is a simple number.\n344           double d = getSimpleNumber(name);\n345           if (!Double.isNaN(d)) {\n346             cc.addNumber(d);\n347           } else {\n348             addJsString(n);\n349           }\n350         }\n351 \n352         add(parameters);\n353         add(body, Context.PRESERVE_BLOCK);\n354         break;\n355 \n356       case Token.SCRIPT:\n357       case Token.BLOCK: {\n358         if (n.getClass() != Node.class) {\n359           throw new Error(\"Unexpected Node subclass.\");\n360         }\n361         boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n362         if (preserveBlock) {\n363           cc.beginBlock();\n364         }\n365 \n366         boolean preferLineBreaks =\n367             type == Token.SCRIPT ||\n368             (type == Token.BLOCK &&\n369                 !preserveBlock &&\n370                 n.getParent() != null &&\n371                 n.getParent().isScript());\n372         for (Node c = first; c != null; c = c.getNext()) {\n373           add(c, Context.STATEMENT);\n374 \n375           // VAR doesn't include ';' since it gets used in expressions\n376           if (c.isVar()) {\n377             cc.endStatement();\n378           }\n379 \n380           if (c.isFunction()) {\n381             cc.maybeLineBreak();\n382           }\n383 \n384           // Prefer to break lines in between top-level statements\n385           // because top level statements are more homogeneous.\n386           if (preferLineBreaks) {\n387             cc.notePreferredLineBreak();\n388           }\n389         }\n390         if (preserveBlock) {\n391           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n392         }\n393         break;\n394       }\n395 \n396       case Token.FOR:\n397         if (childCount == 4) {\n398           add(\"for(\");\n399           if (first.isVar()) {\n400             add(first, Context.IN_FOR_INIT_CLAUSE);\n401           } else {\n402             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n403           }\n404           add(\";\");\n405           add(first.getNext());\n406           add(\";\");\n407           add(first.getNext().getNext());\n408           add(\")\");\n409           addNonEmptyStatement(\n410               last, getContextForNonEmptyExpression(context), false);\n411         } else {\n412           Preconditions.checkState(childCount == 3);\n413           add(\"for(\");\n414           add(first);\n415           add(\"in\");\n416           add(first.getNext());\n417           add(\")\");\n418           addNonEmptyStatement(\n419               last, getContextForNonEmptyExpression(context), false);\n420         }\n421         break;\n422 \n423       case Token.DO:\n424         Preconditions.checkState(childCount == 2);\n425         add(\"do\");\n426         addNonEmptyStatement(first, Context.OTHER, false);\n427         add(\"while(\");\n428         add(last);\n429         add(\")\");\n430         cc.endStatement();\n431         break;\n432 \n433       case Token.WHILE:\n434         Preconditions.checkState(childCount == 2);\n435         add(\"while(\");\n436         add(first);\n437         add(\")\");\n438         addNonEmptyStatement(\n439             last, getContextForNonEmptyExpression(context), false);\n440         break;\n441 \n442       case Token.EMPTY:\n443         Preconditions.checkState(childCount == 0);\n444         break;\n445 \n446       case Token.GETPROP: {\n447         Preconditions.checkState(\n448             childCount == 2,\n449             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n450         Preconditions.checkState(\n451             last.isString(),\n452             \"Bad GETPROP: RHS should be STRING\");\n453         boolean needsParens = (first.isNumber());\n454         if (needsParens) {\n455           add(\"(\");\n456         }\n457         addExpr(first, NodeUtil.precedence(type), context);\n458         if (needsParens) {\n459           add(\")\");\n460         }\n461         add(\".\");\n462         addIdentifier(last.getString());\n463         break;\n464       }\n465 \n466       case Token.GETELEM:\n467         Preconditions.checkState(\n468             childCount == 2,\n469             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n470         addExpr(first, NodeUtil.precedence(type), context);\n471         add(\"[\");\n472         add(first.getNext());\n473         add(\"]\");\n474         break;\n475 \n476       case Token.WITH:\n477         Preconditions.checkState(childCount == 2);\n478         add(\"with(\");\n479         add(first);\n480         add(\")\");\n481         addNonEmptyStatement(\n482             last, getContextForNonEmptyExpression(context), false);\n483         break;\n484 \n485       case Token.INC:\n486       case Token.DEC: {\n487         Preconditions.checkState(childCount == 1);\n488         String o = type == Token.INC ? \"++\" : \"--\";\n489         int postProp = n.getIntProp(Node.INCRDECR_PROP);\n490         // A non-zero post-prop value indicates a post inc/dec, default of zero\n491         // is a pre-inc/dec.\n492         if (postProp != 0) {\n493           addExpr(first, NodeUtil.precedence(type), context);\n494           cc.addOp(o, false);\n495         } else {\n496           cc.addOp(o, false);\n497           add(first);\n498         }\n499         break;\n500       }\n501 \n502       case Token.CALL:\n503         // We have two special cases here:\n504         // 1) If the left hand side of the call is a direct reference to eval,\n505         // then it must have a DIRECT_EVAL annotation. If it does not, then\n506         // that means it was originally an indirect call to eval, and that\n507         // indirectness must be preserved.\n508         // 2) If the left hand side of the call is a property reference,\n509         // then the call must not a FREE_CALL annotation. If it does, then\n510         // that means it was originally an call without an explicit this and\n511         // that must be preserved.\n512         if (isIndirectEval(first)\n513             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n514           add(\"(0,\");\n515           addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n516           add(\")\");\n517         } else {\n518           addExpr(first, NodeUtil.precedence(type), context);\n519         }\n520         add(\"(\");\n521         addList(first.getNext());\n522         add(\")\");\n523         break;\n524 \n525       case Token.IF:\n526         boolean hasElse = childCount == 3;\n527         boolean ambiguousElseClause =\n528             context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n529         if (ambiguousElseClause) {\n530           cc.beginBlock();\n531         }\n532 \n533         add(\"if(\");\n534         add(first);\n535         add(\")\");\n536 \n537         if (hasElse) {\n538           addNonEmptyStatement(\n539               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n540           add(\"else\");\n541           addNonEmptyStatement(\n542               last, getContextForNonEmptyExpression(context), false);\n543         } else {\n544           addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n545           Preconditions.checkState(childCount == 2);\n546         }\n547 \n548         if (ambiguousElseClause) {\n549           cc.endBlock();\n550         }\n551         break;\n552 \n553       case Token.NULL:\n554         Preconditions.checkState(childCount == 0);\n555         add(\"null\");\n556         break;\n557 \n558       case Token.THIS:\n559         Preconditions.checkState(childCount == 0);\n560         add(\"this\");\n561         break;\n562 \n563       case Token.FALSE:\n564         Preconditions.checkState(childCount == 0);\n565         add(\"false\");\n566         break;\n567 \n568       case Token.TRUE:\n569         Preconditions.checkState(childCount == 0);\n570         add(\"true\");\n571         break;\n572 \n573       case Token.CONTINUE:\n574         Preconditions.checkState(childCount <= 1);\n575         add(\"continue\");\n576         if (childCount == 1) {\n577           if (!first.isLabelName()) {\n578             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n579           }\n580           add(\" \");\n581           add(first);\n582         }\n583         cc.endStatement();\n584         break;\n585 \n586       case Token.DEBUGGER:\n587         Preconditions.checkState(childCount == 0);\n588         add(\"debugger\");\n589         cc.endStatement();\n590         break;\n591 \n592       case Token.BREAK:\n593         Preconditions.checkState(childCount <= 1);\n594         add(\"break\");\n595         if (childCount == 1) {\n596           if (!first.isLabelName()) {\n597             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n598           }\n599           add(\" \");\n600           add(first);\n601         }\n602         cc.endStatement();\n603         break;\n604 \n605       case Token.EXPR_RESULT:\n606         Preconditions.checkState(childCount == 1);\n607         add(first, Context.START_OF_EXPR);\n608         cc.endStatement();\n609         break;\n610 \n611       case Token.NEW:\n612         add(\"new \");\n613         int precedence = NodeUtil.precedence(type);\n614 \n615         // If the first child contains a CALL, then claim higher precedence\n616         // to force parentheses. Otherwise, when parsed, NEW will bind to the\n617         // first viable parentheses (don't traverse into functions).\n618         if (NodeUtil.containsType(\n619             first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n620           precedence = NodeUtil.precedence(first.getType()) + 1;\n621         }\n622         addExpr(first, precedence, Context.OTHER);\n623 \n624         // '()' is optional when no arguments are present\n625         Node next = first.getNext();\n626         if (next != null) {\n627           add(\"(\");\n628           addList(next);\n629           add(\")\");\n630         }\n631         break;\n632 \n633       case Token.STRING:\n634         if (childCount !=\n635             ((n.getParent() != null &&\n636               n.getParent().isObjectLit()) ? 1 : 0)) {\n637           throw new IllegalStateException(\n638               \"Unexpected String children: \" + n.getParent().toStringTree());\n639         }\n640         addJsString(n);\n641         break;\n642 \n643       case Token.DELPROP:\n644         Preconditions.checkState(childCount == 1);\n645         add(\"delete \");\n646         add(first);\n647         break;\n648 \n649       case Token.OBJECTLIT: {\n650         boolean needsParens = (context == Context.START_OF_EXPR);\n651         if (needsParens) {\n652           add(\"(\");\n653         }\n654         add(\"{\");\n655         for (Node c = first; c != null; c = c.getNext()) {\n656           if (c != first) {\n657             cc.listSeparator();\n658           }\n659 \n660           if (c.isGetterDef() || c.isSetterDef()) {\n661             add(c);\n662           } else {\n663             Preconditions.checkState(c.isString());\n664             String key = c.getString();\n665             // Object literal property names don't have to be quoted if they\n666             // are not JavaScript keywords\n667             if (!c.isQuotedString() &&\n668                 !TokenStream.isKeyword(key) &&\n669                 TokenStream.isJSIdentifier(key) &&\n670                 // do not encode literally any non-literal characters that\n671                 // were unicode escaped.\n672                 NodeUtil.isLatin(key)) {\n673               add(key);\n674             } else {\n675               // Determine if the string is a simple number.\n676               double d = getSimpleNumber(key);\n677               if (!Double.isNaN(d)) {\n678                 cc.addNumber(d);\n679               } else {\n680                 addExpr(c, 1, Context.OTHER);\n681               }\n682             }\n683             add(\":\");\n684             addExpr(c.getFirstChild(), 1, Context.OTHER);\n685           }\n686         }\n687         add(\"}\");\n688         if (needsParens) {\n689           add(\")\");\n690         }\n691         break;\n692       }\n693 \n694       case Token.SWITCH:\n695         add(\"switch(\");\n696         add(first);\n697         add(\")\");\n698         cc.beginBlock();\n699         addAllSiblings(first.getNext());\n700         cc.endBlock(context == Context.STATEMENT);\n701         break;\n702 \n703       case Token.CASE:\n704         Preconditions.checkState(childCount == 2);\n705         add(\"case \");\n706         add(first);\n707         addCaseBody(last);\n708         break;\n709 \n710       case Token.DEFAULT_CASE:\n711         Preconditions.checkState(childCount == 1);\n712         add(\"default\");\n713         addCaseBody(first);\n714         break;\n715 \n716       case Token.LABEL:\n717         Preconditions.checkState(childCount == 2);\n718         if (!first.isLabelName()) {\n719           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n720         }\n721         add(first);\n722         add(\":\");\n723         addNonEmptyStatement(\n724             last, getContextForNonEmptyExpression(context), true);\n725         break;\n726 \n727       default:\n728         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n729     }\n730 \n731     cc.endSourceMapping(n);\n732   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_35", "report_text": "> assignment to object in conditional causes type error on function w/ record type return type\n> \n> slightly dodgy code :)\r\n> \r\n> /\\*\\* @returns {{prop1: (Object|undefined), prop2: (string|undefined), prop3: (string|undefined)}} \\*/\r\n> function func(a, b) {\r\n>  var results;\r\n>  if (a) {\r\n>  results = {};\r\n>  results.prop1 = {a: 3};\r\n>  }\r\n>  if (b) {\r\n>  results = results || {};\r\n>  results.prop2 = 'prop2';\r\n>  } else {\r\n>  results = results || {};\r\n>  results.prop3 = 'prop3';\r\n>  }\r\n>  return results;\r\n> }\r\n> results in this error:\r\n> \r\n> \r\n> JSC\\_TYPE\\_MISMATCH: inconsistent return type\r\n> found : ({prop1: {a: number}}|{})\r\n> required: {prop1: (Object|null|undefined), prop2: (string|undefined), prop3: (string|undefined)} at line 18 character 7\r\n> return results;\r\n> \r\n> \r\n> \r\n> defining results on the first line on the function causes it the world.\r\n> the still dodgy, but slightly less so, use of this is if the function return type were that record type|undefined and not all branches were guaranteed to be executed.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue669", "test_method": "  public void testIssue669() throws Exception {\n    testTypes(\n        \"/** @return {{prop1: (Object|undefined)}} */\" +\n         \"function f(a) {\" +\n         \"  var results;\" +\n         \"  if (a) {\" +\n         \"    results = {};\" +\n         \"    results.prop1 = {a: 3};\" +\n         \"  } else {\" +\n         \"    results = {prop2: 3};\" +\n         \"  }\" +\n         \"  return results;\" +\n         \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9694)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9668)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9606)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9602)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue669(TypeCheckTest.java:5621)", "buggy_method": "1113 private void inferPropertyTypesToMatchConstraint(\n1114       JSType type, JSType constraint) {\n1115     if (type == null || constraint == null) {\n1116       return;\n1117     }\n1118 \n1119     ObjectType constraintObj =\n1120         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n1121     if (constraintObj != null && constraintObj.isRecordType()) {\n1122       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n1123       if (objType != null) {\n1124         for (String prop : constraintObj.getOwnPropertyNames()) {\n1125           JSType propType = constraintObj.getPropertyType(prop);\n1126           if (!objType.isPropertyTypeDeclared(prop)) {\n1127             JSType typeToInfer = propType;\n1128             if (!objType.hasProperty(prop)) {\n1129               typeToInfer =\n1130                   getNativeType(VOID_TYPE).getLeastSupertype(propType);\n1131             }\n1132             objType.defineInferredProperty(prop, typeToInfer, null);\n1133           }\n1134         }\n1135       }\n1136     }\n1137   }", "bm_classpath": "com.google.javascript.jscomp.TypeInference"}, {"bug_name": "Closure_36", "report_text": "> goog.addSingletonGetter prevents unused class removal\n> \n> **What steps will reproduce the problem?**\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // @use\\_closure\\_library true\r\n> // @formatting pretty\\_print,print\\_input\\_delimiter\r\n> // @warning\\_level VERBOSE\r\n> // @debug true\r\n> // ==/ClosureCompiler==\r\n> \r\n> goog.provide('foo');\r\n> \r\n> var foo = function() { this.values = []; };\r\n> goog.addSingletonGetter(foo);\r\n> \r\n> foo.prototype.add = function(value) {this.values.push(value)};\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expect: The code is completely removed.\r\n> \r\n> Instead:\r\n> \r\n> (function($ctor$$) {\r\n>  $ctor$$.$getInstance$ = function $$ctor$$$$getInstance$$() {\r\n>  return $ctor$$.$instance\\_$ || ($ctor$$.$instance\\_$ = new $ctor$$)\r\n>  }\r\n> })(function() {\r\n> });\r\n> \r\n> \r\n> What version of the product are you using? On what operating system?\r\n> \r\n> http://closure-compiler.appspot.com on Feb 28, 2012\r\n> \r\n> Please provide any additional information below.", "test_name": "com.google.javascript.jscomp.IntegrationTest::testSingletonGetter1", "test_method": "  public void testSingletonGetter1() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel.ADVANCED_OPTIMIZATIONS\n        .setOptionsForCompilationLevel(options);\n    options.setCodingConvention(new ClosureCodingConvention());\n    test(options,\n        \"/** @const */\\n\" +\n        \"var goog = goog || {};\\n\" +\n        \"goog.addSingletonGetter = function(ctor) {\\n\" +\n        \"  ctor.getInstance = function() {\\n\" +\n        \"    return ctor.instance_ || (ctor.instance_ = new ctor());\\n\" +\n        \"  };\\n\" +\n        \"};\" +\n        \"function Foo() {}\\n\" +\n        \"goog.addSingletonGetter(Foo);\" +\n        \"Foo.prototype.bar = 1;\" +\n        \"function Bar() {}\\n\" +\n        \"goog.addSingletonGetter(Bar);\" +\n        \"Bar.prototype.bar = 1;\",\n        \"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2006)\n\tcom.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:1988)\n\tcom.google.javascript.jscomp.IntegrationTest.testSingletonGetter1(IntegrationTest.java:1942)", "buggy_method": "519 private boolean canInline(\n520         Reference declaration,\n521         Reference initialization,\n522         Reference reference) {\n523       if (!isValidDeclaration(declaration)\n524           || !isValidInitialization(initialization)\n525           || !isValidReference(reference)) {\n526         return false;\n527       }\n528 \n529       // If the value is read more than once, skip it.\n530       // VAR declarations and EXPR_RESULT don't need the value, but other\n531       // ASSIGN expressions parents do.\n532       if (declaration != initialization &&\n533           !initialization.getGrandparent().isExprResult()) {\n534         return false;\n535       }\n536 \n537       // Be very conservative and do no cross control structures or\n538       // scope boundaries\n539       if (declaration.getBasicBlock() != initialization.getBasicBlock()\n540           || declaration.getBasicBlock() != reference.getBasicBlock()) {\n541         return false;\n542       }\n543 \n544       // Do not inline into a call node. This would change\n545       // the context in which it was being called. For example,\n546       //   var a = b.c;\n547       //   a();\n548       // should not be inlined, because it calls a in the context of b\n549       // rather than the context of the window.\n550       //   var a = b.c;\n551       //   f(a)\n552       // is ok.\n553       Node value = initialization.getAssignedValue();\n554       Preconditions.checkState(value != null);\n555       if (value.isGetProp()\n556           && reference.getParent().isCall()\n557           && reference.getParent().getFirstChild() == reference.getNode()) {\n558         return false;\n559       }\n560 \n561       if (value.isFunction()) {\n562         Node callNode = reference.getParent();\n563         if (reference.getParent().isCall()) {\n564           CodingConvention convention = compiler.getCodingConvention();\n565           // Bug 2388531: Don't inline subclass definitions into class defining\n566           // calls as this confused class removing logic.\n567           SubclassRelationship relationship =\n568               convention.getClassesDefinedByCall(callNode);\n569           if (relationship != null) {\n570             return false;\n571           }\n572 \n573           // issue 668: Don't inline singleton getter methods\n574           // calls as this confused class removing logic.\n575         }\n576       }\n577 \n578       return canMoveAggressively(value) ||\n579           canMoveModerately(initialization, reference);\n580     }", "bm_classpath": "com.google.javascript.jscomp.InlineVariables$InliningBehavior"}, {"bug_name": "Closure_37", "report_text": "> incomplete function definition crashes the compiler when ideMode is enabled\n> \n> The code:\r\n> \r\n> f f f ;\r\n> function t\r\n> \r\n> The cause:\r\n> \r\n> Rhino is creating an incomplete FUNCTION node. We could fix this in Rhino or the IRFactory. If it is invalid in Rhino we should fix it there, I'm not sure how to determine this so maybe we should fix it in the IRFactory and be done with it.\r\n> \r\n> The stack trace:\r\n> \r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> at com.google.common.base.Preconditions.checkState(Preconditions.java:135)\r\n> at com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:544)\r\n> at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:493)\r\n> at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:501)\r\n> at com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:281)\r\n> at com.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:459)\r\n> at com.google.javascript.jscomp.PrepareAst.process(PrepareAst.java:70)\r\n> at com.google.javascript.jscomp.Compiler.prepareAst(Compiler.java:1836)\r\n> at com.google.javascript.jscomp.JsAst.parse(JsAst.java:100)\r\n> at com.google.javascript.jscomp.JsAst.getAstRoot(JsAst.java:53)\r\n> at com.google.javascript.jscomp.CompilerInput.getAstRoot(CompilerInput.java:120)\r\n> at com.google.javascript.jscomp.Compiler.parseInputs(Compiler.java:1303)\r\n> at com.google.javascript.jscomp.Compiler.parse(Compiler.java:697)", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIncompleteFunction", "test_method": "  public void testIncompleteFunction() {\n    CompilerOptions options = createCompilerOptions();\n    options.ideMode = true;\n    DiagnosticType[] warnings = new DiagnosticType[]{\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR,\n        RhinoErrorReporter.PARSE_ERROR};\n    test(options,\n        new String[] { \"var foo = {bar: function(e) }\" },\n        new String[] { \"var foo = {bar: function(e){}};\" },\n        warnings\n    ); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n\tcom.google.javascript.jscomp.Compiler.runCallable(Compiler.java:642)\n\tcom.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:587)\n\tcom.google.javascript.jscomp.Compiler.compile(Compiler.java:569)\n\tcom.google.javascript.jscomp.Compiler.compileModules(Compiler.java:560)\n\tcom.google.javascript.jscomp.Compiler.compile(Compiler.java:542)\n\tcom.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2080)\n\tcom.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:2041)\n\tcom.google.javascript.jscomp.IntegrationTest.testIncompleteFunction(IntegrationTest.java:1945)", "buggy_method": "510 private void traverseFunction(Node n, Node parent) {\n511     Preconditions.checkState(n.getChildCount() == 3);\n512     Preconditions.checkState(n.isFunction());\n513 \n514     final Node fnName = n.getFirstChild();\n515 \n516     boolean isFunctionExpression = (parent != null)\n517         && NodeUtil.isFunctionExpression(n);\n518 \n519     if (!isFunctionExpression) {\n520       // Functions declarations are in the scope containing the declaration.\n521       traverseBranch(fnName, n);\n522     }\n523 \n524     curNode = n;\n525     pushScope(n);\n526 \n527     if (isFunctionExpression) {\n528       // Function expression names are only accessible within the function\n529       // scope.\n530       traverseBranch(fnName, n);\n531     }\n532 \n533     final Node args = fnName.getNext();\n534     final Node body = args.getNext();\n535 \n536     // Args\n537     traverseBranch(args, n);\n538 \n539     // Body\n540     Preconditions.checkState(body.getNext() == null &&\n541             body.isBlock());\n542     traverseBranch(body, n);\n543 \n544     popScope();\n545   }", "bm_classpath": "com.google.javascript.jscomp.NodeTraversal"}, {"bug_name": "Closure_38", "report_text": "> Identifier minus a negative number needs a space between the \"-\"s\n> \n> **What steps will reproduce the problem?**\n> 1. Compile the attached file with java -jar build/compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --js bulletfail.js --js\\_output\\_file cc.js\r\n> 2. Try to run the file in a JS engine, for example node cc.js\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> The file does not parse properly, because it contains\r\n> \r\n>  g--0.0\r\n> \r\n> This is subtraction of a negative number, but it looks like JS engines interpret it as decrementing g, and then fail to parse the 0.0. (g- -0.0, with a space, would parse ok.)\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Trunk closure compiler on Ubuntu\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testMinusNegativeZero", "test_method": "  public void testMinusNegativeZero() {\n    // Negative zero is weird, because we have to be able to distinguish\n    // it from positive zero (there are some subtle differences in behavior).\n    assertPrint(\"x- -0\", \"x- -0.0\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<x-[ ]-0.0> but was:<x-[]-0.0>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:401)\n\tcom.google.javascript.jscomp.CodePrinterTest.testMinusNegativeZero(CodePrinterTest.java:1374)", "buggy_method": "240 void addNumber(double x) {\n241     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n242     // x--4 (which is a syntax error).\n243     char prev = getLastChar();\n244     boolean negativeZero = isNegativeZero(x);\n245     if (x < 0 && prev == '-') {\n246       add(\" \");\n247     }\n248 \n249     if ((long) x == x && !negativeZero) {\n250       long value = (long) x;\n251       long mantissa = value;\n252       int exp = 0;\n253       if (Math.abs(x) >= 100) {\n254         while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n255           mantissa /= 10;\n256           exp++;\n257         }\n258       }\n259       if (exp > 2) {\n260         add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n261       } else {\n262         add(Long.toString(value));\n263       }\n264     } else {\n265       add(String.valueOf(x));\n266     }\n267   }", "bm_classpath": "com.google.javascript.jscomp.CodeConsumer"}, {"bug_name": "Closure_39", "report_text": "> externExport with @typedef can generate invalid externs\n> \n> **What steps will reproduce the problem?**\n> 1. Create a file that has a @typedef and code referencing the type def above and below the typedef declaration.\r\n> 2. Run the closure compiler and grab the externExport string stored on the last result for review.\r\n> 3. I have attached both source and output files displaying the issue.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> The code above the @typedef references the aliased name of the @typedef as expected however the code below the @typedef tries embedding the body of the @typedef and ends up truncating it if the length is too long with a \"...\". This throws bad type errors when compiling against this extern. What is odd is this only seems to be the case when the parameter with the type is optional. When neither are optional it embeds the types, which is not a big deal, except when types are long; they get truncated and throw errors.\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> plovr built from revision 3103:d6db24beeb7f\r\n> Revision numbers for embedded Closure Tools:\r\n> Closure Library: 1374\r\n> Closure Compiler: 1559\r\n> Closure Templates: 23\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.rhino.jstype.RecordTypeTest::testRecursiveRecord", "test_method": "  public void testRecursiveRecord() {\n    ProxyObjectType loop = new ProxyObjectType(registry, NUMBER_TYPE);\n    JSType record = new RecordTypeBuilder(registry)\n        .addProperty(\"loop\", loop, null)\n        .addProperty(\"number\", NUMBER_TYPE, null)\n        .addProperty(\"string\", STRING_TYPE, null)\n        .build();\n\n    loop.setReferencedType(record);\n    assertEquals(\"{loop: ?, number: number, string: string}\",\n        record.toAnnotationString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{loop: [?], number: number, st...> but was:<{loop: [{...}], number: number, st...>\n\tcom.google.javascript.rhino.jstype.RecordTypeTest.testRecursiveRecord(RecordTypeTest.java:59)", "buggy_method": "352 @Override\n353   String toStringHelper(boolean forAnnotations) {\n354     if (hasReferenceName()) {\n355       return getReferenceName();\n356     } else if (prettyPrint) {\n357       // Don't pretty print recursively.\n358       prettyPrint = false;\n359 \n360       // Use a tree set so that the properties are sorted.\n361       Set<String> propertyNames = Sets.newTreeSet();\n362       for (ObjectType current = this;\n363            current != null && !current.isNativeObjectType() &&\n364                propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n365            current = current.getImplicitPrototype()) {\n366         propertyNames.addAll(current.getOwnPropertyNames());\n367       }\n368 \n369       StringBuilder sb = new StringBuilder();\n370       sb.append(\"{\");\n371 \n372       int i = 0;\n373       for (String property : propertyNames) {\n374         if (i > 0) {\n375           sb.append(\", \");\n376         }\n377 \n378         sb.append(property);\n379         sb.append(\": \");\n380         sb.append(getPropertyType(property).toString());\n381 \n382         ++i;\n383         if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n384           sb.append(\", ...\");\n385           break;\n386         }\n387       }\n388 \n389       sb.append(\"}\");\n390 \n391       prettyPrint = true;\n392       return sb.toString();\n393     } else {\n394       return \"{...}\";\n395     }\n396   }", "bm_classpath": "com.google.javascript.rhino.jstype.PrototypeObjectType"}, {"bug_name": "Closure_40", "report_text": "> smartNameRemoval causing compiler crash\n> \n> **What steps will reproduce the problem?**\n> Compiler the following code in advanced mode:\r\n> \r\n> {{{\r\n> var goog = {};\r\n> goog.inherits = function(x, y) {};\r\n> var ns = {};\r\n> /\\*\\* @constructor \\*/ ns.PageSelectionModel = function(){};\r\n> \r\n> /\\*\\* @constructor \\*/ \r\n> ns.PageSelectionModel.FooEvent = function() {};\r\n> /\\*\\* @constructor \\*/ \r\n> ns.PageSelectionModel.SelectEvent = function() {};\r\n> goog.inherits(ns.PageSelectionModel.ChangeEvent, ns.PageSelectionModel.FooEvent);\r\n> }}}\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> The compiler will crash. The last var check throws an illegal state exception because it knows something is wrong.\r\n> \r\n> The crash is caused by smartNameRemoval. It has special logic for counting references in class-defining function calls (like goog.inherits), and it isn't properly creating a reference to PageSelectionModel.", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIssue284", "test_method": "  public void testIssue284() {\n    CompilerOptions options = createCompilerOptions();\n    options.smartNameRemoval = true;\n    test(options,\n        \"var goog = {};\" +\n        \"goog.inherits = function(x, y) {};\" +\n        \"var ns = {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.FooEvent = function() {};\" +\n        \"/** @constructor */\" +\n        \"ns.PageSelectionModel.SelectEvent = function() {};\" +\n        \"goog.inherits(ns.PageSelectionModel.ChangeEvent,\" +\n        \"    ns.PageSelectionModel.FooEvent);\",\n        \"\"); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n\tcom.google.javascript.jscomp.Compiler.runCallable(Compiler.java:639)\n\tcom.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:584)\n\tcom.google.javascript.jscomp.Compiler.compile(Compiler.java:566)\n\tcom.google.javascript.jscomp.Compiler.compileModules(Compiler.java:557)\n\tcom.google.javascript.jscomp.Compiler.compile(Compiler.java:539)\n\tcom.google.javascript.jscomp.IntegrationTest.compile(IntegrationTest.java:2046)\n\tcom.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:1960)\n\tcom.google.javascript.jscomp.IntegrationTest.test(IntegrationTest.java:1951)\n\tcom.google.javascript.jscomp.IntegrationTest.testIssue284(IntegrationTest.java:1769)", "buggy_method": "595 @Override\n596     public void visit(NodeTraversal t, Node n, Node parent) {\n597 \n598       // Record global variable and function declarations\n599       if (t.inGlobalScope()) {\n600         if (NodeUtil.isVarDeclaration(n)) {\n601           NameInformation ns = createNameInformation(t, n, parent);\n602           Preconditions.checkNotNull(ns);\n603           recordSet(ns.name, n);\n604         } else if (NodeUtil.isFunctionDeclaration(n)) {\n605           Node nameNode = n.getFirstChild();\n606           NameInformation ns = createNameInformation(t, nameNode, n);\n607           if (ns != null) {\n608             JsName nameInfo = getName(nameNode.getString(), true);\n609             recordSet(nameInfo.name, nameNode);\n610           }\n611         } else if (NodeUtil.isObjectLitKey(n, parent)) {\n612           NameInformation ns = createNameInformation(t, n, parent);\n613           if (ns != null) {\n614             recordSet(ns.name, n);\n615           }\n616         }\n617       }\n618 \n619       // Record assignments and call sites\n620       if (n.isAssign()) {\n621         Node nameNode = n.getFirstChild();\n622 \n623         NameInformation ns = createNameInformation(t, nameNode, n);\n624         if (ns != null) {\n625           if (ns.isPrototype) {\n626             recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n627           } else {\n628             recordSet(ns.name, nameNode);\n629           }\n630         }\n631       } else if (n.isCall()) {\n632         Node nameNode = n.getFirstChild();\n633         NameInformation ns = createNameInformation(t, nameNode, n);\n634         if (ns != null && ns.onlyAffectsClassDef) {\n635           JsName name = getName(ns.name, false);\n636           if (name != null) {\n637           refNodes.add(new ClassDefiningFunctionNode(\n638               name, n, parent, parent.getParent()));\n639           }\n640         }\n641       }\n642     }", "bm_classpath": "com.google.javascript.jscomp.NameAnalyzer$FindDeclarationsAndSetters"}, {"bug_name": "Closure_41", "report_text": "> In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures.\n> \n> In ADVANCED mode, Compiler fails to warn about overridden methods with different signatures. The following code only warns in the one instance noted in the comment, whereas I would expect it to complain about the declarations of both Bar.prototype.add and Bar.prototype.sub, as they claim @inheritDoc, but have seemingly different signatures from that of their superclass methods.\r\n> \r\n> It would be helpful to have such a warning so that when you change the signature of a superclass method, you can run the Compiler to trigger warnings and find all of the other signatures that you need to update.\r\n> \r\n> Run the following:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // @use\\_closure\\_library true\r\n> // ==/ClosureCompiler==\r\n> \r\n> goog.provide('Foo');\r\n> goog.provide('Bar');\r\n> \r\n> \r\n> /\\*\\* @constructor \\*/\r\n> Foo = function() {};\r\n> \r\n> \r\n> /\\*\\*\r\n>  \\* @param {number} a\r\n>  \\* @param {number} b\r\n>  \\* @return {number}\r\n>  \\*/\r\n> Foo.prototype.add = function(a, b) {\r\n>  return a + b;\r\n> };\r\n> \r\n> \r\n> /\\*\\*\r\n>  \\* @param {number} a\r\n>  \\* @param {number} b\r\n>  \\* @return {number}\r\n>  \\*/\r\n> Foo.prototype.sub = goog.abstractMethod;\r\n> \r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @extends {Foo}\r\n>  \\*/\r\n> Bar = function() {\r\n>  goog.base(this);\r\n> };\r\n> goog.inherits(Bar, Foo);\r\n> \r\n> \r\n> /\\*\\* @inheritDoc \\*/\r\n> Bar.prototype.add = function(one) {\r\n>  return one;\r\n> };\r\n> \r\n> \r\n> /\\*\\* @inheritDoc \\*/\r\n> Bar.prototype.sub = function(one) {\r\n>  return one;\r\n> };\r\n> \r\n> \r\n> var foo = /\\*\\* @type {Foo} \\*/ (new Bar());\r\n> alert(foo.add(3, 4));\r\n> \r\n> var bar = new Bar();\r\n> // THIS PRODUCES JSC\\_WRONG\\_ARGUMENT\\_COUNT\r\n> alert(bar.add(3, 4));", "test_name": "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference6", "test_method": "  public void testMethodInference6() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @param {number} x */ F.prototype.foo = function(x) { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function() { };\" +\n        \"(new G()).foo(1);\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7035)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7009)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6953)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6949)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testMethodInference6(LooseTypeCheckTest.java:1772)", "buggy_method": "242 FunctionTypeBuilder inferFromOverriddenFunction(\n243       @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n244     if (oldType == null) {\n245       return this;\n246     }\n247 \n248     returnType = oldType.getReturnType();\n249     returnTypeInferred = oldType.isReturnTypeInferred();\n250     if (paramsParent == null) {\n251       // Not a function literal.\n252       parametersNode = oldType.getParametersNode();\n253       if (parametersNode == null) {\n254         parametersNode = new FunctionParamBuilder(typeRegistry).build();\n255       }\n256     } else {\n257       // We're overriding with a function literal. Apply type information\n258       // to each parameter of the literal.\n259       FunctionParamBuilder paramBuilder =\n260           new FunctionParamBuilder(typeRegistry);\n261       Iterator<Node> oldParams = oldType.getParameters().iterator();\n262       boolean warnedAboutArgList = false;\n263       boolean oldParamsListHitOptArgs = false;\n264       for (Node currentParam = paramsParent.getFirstChild();\n265            currentParam != null; currentParam = currentParam.getNext()) {\n266         if (oldParams.hasNext()) {\n267           Node oldParam = oldParams.next();\n268           Node newParam = paramBuilder.newParameterFromNode(oldParam);\n269 \n270           oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n271               oldParam.isVarArgs() ||\n272               oldParam.isOptionalArg();\n273 \n274           // The subclass method might write its var_args as individual\n275           // arguments.\n276           if (currentParam.getNext() != null && newParam.isVarArgs()) {\n277             newParam.setVarArgs(false);\n278             newParam.setOptionalArg(true);\n279           }\n280         } else {\n281           warnedAboutArgList |= addParameter(\n282               paramBuilder,\n283               typeRegistry.getNativeType(UNKNOWN_TYPE),\n284               warnedAboutArgList,\n285               codingConvention.isOptionalParameter(currentParam) ||\n286                   oldParamsListHitOptArgs,\n287               codingConvention.isVarArgsParameter(currentParam));\n288         }\n289       }\n290 \n291       // Clone any remaining params that aren't in the function literal.\n292 \n293       parametersNode = paramBuilder.build();\n294     }\n295     return this;\n296   }", "bm_classpath": "com.google.javascript.jscomp.FunctionTypeBuilder"}, {"bug_name": "Closure_42", "report_text": "> Simple \"Whitespace only\" compression removing \"each\" keyword from \"for each (var x in arr)\" loop\n> \n> **What steps will reproduce the problem?**\n> See below code snippet before after compression\r\n> \r\n> ---Before---\r\n> contactcenter.screenpop.updatePopStatus = function(stamp, status) {\r\n> for each ( var curTiming in this.timeLog.timings ) {\r\n> if ( curTiming.callId == stamp ) {\r\n> curTiming.flag = status;\r\n> break;\r\n> }\r\n> }\r\n> };\r\n> ---After---\r\n> contactcenter.screenpop.updatePopStatus=function(stamp,status){for(var curTiming in this.timeLog.timings)if(curTiming.callId==stamp){curTiming.flag=status;break}};\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> ---each keyword should be preserved\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> **Please provide any additional information below.**\n> for each (\\*\\* in \\*\\*) ---> returns object value\r\n> for (\\*\\* in \\*\\*) --> returns index", "test_name": "com.google.javascript.jscomp.parsing.ParserTest::testForEach", "test_method": "  public void testForEach() {\n    parseError(\n        \"function f(stamp, status) {\\n\" +\n        \"  for each ( var curTiming in this.timeLog.timings ) {\\n\" +\n        \"    if ( curTiming.callId == stamp ) {\\n\" +\n        \"      curTiming.flag = status;\\n\" +\n        \"      break;\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\",\n        \"unsupported language extension: for each\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.parsing.ParserTest.parseError(ParserTest.java:991)\n\tcom.google.javascript.jscomp.parsing.ParserTest.testForEach(ParserTest.java:962)", "buggy_method": "566 @Override\n567     Node processForInLoop(ForInLoop loopNode) {\n568 \n569         // Return the bare minimum to put the AST in a valid state.\n570       return newNode(\n571           Token.FOR,\n572           transform(loopNode.getIterator()),\n573           transform(loopNode.getIteratedObject()),\n574           transformBlock(loopNode.getBody()));\n575     }", "bm_classpath": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher"}, {"bug_name": "Closure_43", "report_text": "> @lends does not work unless class is defined beforehand\n> \n> **What steps will reproduce the problem?**\n> With advanced optimizations enabled as well as type checking (--jscomp\\_error=checkTypes), try to use @lends in the same way it's used on the jsdoc page at http://code.google.com/p/jsdoc-toolkit/wiki/TagLends - using either a utility method called \"makeClass\" or another method of class constructing such as John Resig's method at http://ejohn.org/blog/simple-javascript-inheritance/\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Expected output is to have code compiled but instead I get a compile error such as:\r\n> \r\n> ERROR - Variable Person.prototype not declared before @lends annotation.\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Latest svn build, OS X.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testLends10", "test_method": "  public void testLends10() throws Exception {\n    testTypes(\n        \"function defineClass(x) { return function() {}; } \" +\n        \"/** @constructor */\" +\n        \"var Foo = defineClass(\" +\n        \"    /** @lends {Foo.prototype} */ ({/** @type {number} */ bar: 1}));\" +\n        \"/** @return {string} */ function f() { return (new Foo()).bar; }\",\n        \"inconsistent return type\\n\" +\n        \"found   : number\\n\" +\n        \"required: string\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[inconsistent return type\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9511)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9490)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9428)\n\tcom.google.javascript.jscomp.TypeCheckTest.testLends10(TypeCheckTest.java:8781)", "buggy_method": "497 @Override\n498     public void visit(NodeTraversal t, Node n, Node parent) {\n499       inputId = t.getInputId();\n500       attachLiteralTypes(t, n);\n501 \n502       switch (n.getType()) {\n503         case Token.CALL:\n504           checkForClassDefiningCalls(t, n, parent);\n505           checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n506           break;\n507 \n508         case Token.FUNCTION:\n509           if (t.getInput() == null || !t.getInput().isExtern()) {\n510             nonExternFunctions.add(n);\n511           }\n512 \n513           // Hoisted functions are handled during pre-traversal.\n514           if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n515             defineFunctionLiteral(n, parent);\n516           }\n517           break;\n518 \n519         case Token.ASSIGN:\n520           // Handle initialization of properties.\n521           Node firstChild = n.getFirstChild();\n522           if (firstChild.isGetProp() &&\n523               firstChild.isQualifiedName()) {\n524             maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n525                 firstChild, n, firstChild.getNext());\n526           }\n527           break;\n528 \n529         case Token.CATCH:\n530           defineCatch(n, parent);\n531           break;\n532 \n533         case Token.VAR:\n534           defineVar(n, parent);\n535           break;\n536 \n537         case Token.GETPROP:\n538           // Handle stubbed properties.\n539           if (parent.isExprResult() &&\n540               n.isQualifiedName()) {\n541             maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n542           }\n543           break;\n544       }\n545 \n546       // Analyze any @lends object literals in this statement.\n547     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_44", "report_text": "> alert(/ / / / /)\n> \n> alert(/ / / / /);\r\n> output: alert(/ /// /);\r\n> should be: alert(/ // / /);", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testIssue620", "test_method": "  public void testIssue620() {\n    assertPrint(\"alert(/ / / / /);\", \"alert(/ // / /)\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<alert(/ //[ ]/ /)> but was:<alert(/ //[]/ /)>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:389)\n\tcom.google.javascript.jscomp.CodePrinterTest.testIssue620(CodePrinterTest.java:1283)", "buggy_method": "181 void add(String newcode) {\n182     maybeEndStatement();\n183 \n184     if (newcode.length() == 0) {\n185       return;\n186     }\n187 \n188     char c = newcode.charAt(0);\n189     if ((isWordChar(c) || c == '\\\\') &&\n190         isWordChar(getLastChar())) {\n191       // need space to separate. This is not pretty printing.\n192       // For example: \"return foo;\"\n193       append(\" \");\n194       // Do not allow a forward slash to appear after a DIV.\n195       // For example,\n196       // REGEXP DIV REGEXP\n197       // is valid and should print like\n198       // / // / /\n199     }\n200 \n201     append(newcode);\n202   }", "bm_classpath": "com.google.javascript.jscomp.CodeConsumer"}, {"bug_name": "Closure_45", "report_text": "> Assignment removed when used as an expression result to Array.push\n> \n> **What steps will reproduce the problem?**\n> 1. Open online closure-compiler\r\n> 2. Input code:\r\n>  function f() {\r\n>  var a = [], b;\r\n>  a.push(b = []);\r\n>  b[0] = 1;\r\n>  return a;\r\n>  }\r\n> 3. Press [Compile]\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Except OK.\r\n> Output: function f(){var a=[];a.push([]);return a}; //wrong\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Current online version.", "test_name": "com.google.javascript.jscomp.RemoveUnusedVarsTest::testIssue618_1", "test_method": "  public void testIssue618_1() {\n    this.removeGlobal = false;\n    testSame(\n        \"function f() {\\n\" +\n        \"  var a = [], b;\\n\" +\n        \"  a.push(b = []);\\n\" +\n        \"  b[0] = 1;\\n\" +\n        \"  return a;\\n\" +\n        \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:866)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:427)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:352)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:321)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:309)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:541)\n\tcom.google.javascript.jscomp.RemoveUnusedVarsTest.testIssue618_1(RemoveUnusedVarsTest.java:741)", "buggy_method": "704 private void interpretAssigns() {\n705     boolean changes = false;\n706     do {\n707       changes = false;\n708 \n709       // We can't use traditional iterators and iterables for this list,\n710       // because our lazily-evaluated continuations will modify it while\n711       // we traverse it.\n712       for (int current = 0; current < maybeUnreferenced.size(); current++) {\n713         Var var = maybeUnreferenced.get(current);\n714         if (referenced.contains(var)) {\n715           maybeUnreferenced.remove(current);\n716           current--;\n717         } else {\n718           boolean assignedToUnknownValue = false;\n719           boolean hasPropertyAssign = false;\n720 \n721           if (var.getParentNode().isVar() &&\n722               !NodeUtil.isForIn(var.getParentNode().getParent())) {\n723             Node value = var.getInitialValue();\n724             assignedToUnknownValue = value != null &&\n725                 !NodeUtil.isLiteralValue(value, true);\n726           } else {\n727             // This was initialized to a function arg or a catch param\n728             // or a for...in variable.\n729             assignedToUnknownValue = true;\n730           }\n731 \n732           for (Assign assign : assignsByVar.get(var)) {\n733             if (assign.isPropertyAssign) {\n734               hasPropertyAssign = true;\n735             } else if (!NodeUtil.isLiteralValue(\n736                 assign.assignNode.getLastChild(), true)) {\n737               assignedToUnknownValue = true;\n738             }\n739           }\n740 \n741           if (assignedToUnknownValue && hasPropertyAssign) {\n742             changes = markReferencedVar(var) || changes;\n743             maybeUnreferenced.remove(current);\n744             current--;\n745           }\n746         }\n747       }\n748     } while (changes);\n749   }", "bm_classpath": "com.google.javascript.jscomp.RemoveUnusedVars"}, {"bug_name": "Closure_46", "report_text": "> ClassCastException during TypeCheck pass\n> \n> **What steps will reproduce the problem?**\n> 1. Compile code that has a ProxyObjectType that references a RecordType. For example, we have a NamedType in a typedef that references a RecordType.\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Patch attached. Is this the correct fix?", "test_name": "com.google.javascript.rhino.jstype.JSTypeTest::testRecordTypeLeastSuperType2", "test_method": "  public void testRecordTypeLeastSuperType2() {\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    builder.addProperty(\"e\", NUMBER_TYPE, null);\n    builder.addProperty(\"b\", STRING_TYPE, null);\n    builder.addProperty(\"c\", STRING_TYPE, null);\n    JSType otherRecordType = builder.build();\n\n    assertTypeEquals(\n        registry.createUnionType(recordType, otherRecordType),\n        recordType.getLeastSupertype(otherRecordType)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: ({a: number, b: string}|{b: string, c: string, e: number})\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:99)\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:95)\n\tcom.google.javascript.rhino.testing.BaseJSTypeTestCase.assertTypeEquals(BaseJSTypeTestCase.java:573)\n\tcom.google.javascript.rhino.jstype.JSTypeTest.testRecordTypeLeastSuperType2(JSTypeTest.java:2721)", "buggy_method": "140 @Override\n141   public JSType getLeastSupertype(JSType that) {\n142     if (!that.isRecordType()) {\n143       return super.getLeastSupertype(that);\n144     }\n145     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n146     for (String property : properties.keySet()) {\n147       if (that.toMaybeRecordType().hasProperty(property) &&\n148           that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n149               getPropertyType(property))) {\n150         builder.addProperty(property, getPropertyType(property),\n151             getPropertyNode(property));\n152       }\n153     }\n154     return builder.build();\n155   }", "bm_classpath": "com.google.javascript.rhino.jstype.RecordType"}, {"bug_name": "Closure_47", "report_text": "> Original source line numbers are one-based in source maps.\n> \n> Generated source line/column numbers and original column numbers are zero-based. Original source line numbers should be zero based as well.", "test_name": "com.google.debugging.sourcemap.SourceMapGeneratorV3Test::testParseSourceMetaMap", "test_method": "  public void testParseSourceMetaMap() throws Exception {\n    final String INPUT1 = \"file1\";\n    final String INPUT2 = \"file2\";\n    LinkedHashMap<String, String> inputs = Maps.newLinkedHashMap();\n    inputs.put(INPUT1, \"var __FOO__ = 1;\");\n    inputs.put(INPUT2, \"var __BAR__ = 2;\");\n    RunResult result1 = compile(inputs.get(INPUT1), INPUT1);\n    RunResult result2 = compile(inputs.get(INPUT2), INPUT2);\n\n    final String MAP1 = \"map1\";\n    final String MAP2 = \"map2\";\n    final LinkedHashMap<String, String> maps = Maps.newLinkedHashMap();\n    maps.put(MAP1, result1.sourceMapFileContent);\n    maps.put(MAP2, result2.sourceMapFileContent);\n\n    List<SourceMapSection> sections = Lists.newArrayList();\n\n    StringBuilder output = new StringBuilder();\n    FilePosition offset = appendAndCount(output, result1.generatedSource);\n    sections.add(SourceMapSection.forURL(MAP1, 0, 0));\n    output.append(result2.generatedSource);\n    sections.add(\n        SourceMapSection.forURL(MAP2, offset.getLine(), offset.getColumn()));\n\n    SourceMapGeneratorV3 generator = new SourceMapGeneratorV3();\n    StringBuilder mapContents = new StringBuilder();\n    generator.appendIndexMapTo(mapContents, \"out.js\", sections);\n\n    check(inputs, output.toString(), mapContents.toString(),\n      new SourceMapSupplier() {\n        @Override\n        public String getSourceMap(String url){\n          return maps.get(url);\n      }}); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<5> but was:<4>\n\tcom.google.debugging.sourcemap.SourceMapTestCase.check(SourceMapTestCase.java:252)\n\tcom.google.debugging.sourcemap.SourceMapGeneratorV3Test.testParseSourceMetaMap(SourceMapGeneratorV3Test.java:450)", "buggy_method": "482 private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n483     if (entry.getSourceFileId() == UNMAPPED) {\n484       return null;\n485     } else {\n486       // Adjust the line/column here to be start at 1.\n487       Builder x = OriginalMapping.newBuilder()\n488         .setOriginalFile(sources[entry.getSourceFileId()])\n489         .setLineNumber(entry.getSourceLine())\n490         .setColumnPosition(entry.getSourceColumn());\n491       if (entry.getNameId() != UNMAPPED) {\n492         x.setIdentifier(names[entry.getNameId()]);\n493       }\n494       return x.build();\n495     }\n496   }", "bm_classpath": "com.google.debugging.sourcemap.SourceMapConsumerV3"}, {"bug_name": "Closure_48", "report_text": "> Type checking error when replacing a function with a stub after calling.\n> \n> Given the following Javascript:\r\n> \r\n>  /\\*\\* @constructor \\*/\r\n>  var myclass = function() {\r\n>  }\r\n>  \r\n>  /\\*\\* @param {boolean} success \\*/\r\n>  myclass.prototype.fn = function(success) { }\r\n>  \r\n>  myclass.prototype.test = function() {\r\n>  this.fn();\r\n>  this.fn = function() { };\r\n>  }\r\n> \r\n> I would expect an error at both lines of test(). Instead, the second line causes the error in the first not to be reported.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue586", "test_method": "  public void testIssue586() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var MyClass = function() {};\" +\n        \"/** @param {boolean} success */\" +\n        \"MyClass.prototype.fn = function(success) {};\" +\n        \"MyClass.prototype.test = function() {\" +\n        \"  this.fn();\" +\n        \"  this.fn = function() {};\" +\n        \"};\",\n        \"Function MyClass.prototype.fn: called with 0 argument(s). \" +\n        \"Function requires at least 1 argument(s) \" +\n        \"and no more than 1 argument(s).\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9391)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9371)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9309)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue586(TypeCheckTest.java:5443)", "buggy_method": "1416 void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n1417         Node n, Node parent, Node rhsValue) {\n1418       Node ownerNode = n.getFirstChild();\n1419       String ownerName = ownerNode.getQualifiedName();\n1420       String qName = n.getQualifiedName();\n1421       String propName = n.getLastChild().getString();\n1422       Preconditions.checkArgument(qName != null && ownerName != null);\n1423 \n1424       // Precedence of type information on GETPROPs:\n1425       // 1) @type annnotation / @enum annotation\n1426       // 2) ASSIGN to FUNCTION literal\n1427       // 3) @param/@return annotation (with no function literal)\n1428       // 4) ASSIGN to something marked @const\n1429       // 5) ASSIGN to anything else\n1430       //\n1431       // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n1432       // the function has jsdoc or has not been declared before.\n1433       //\n1434       // FUNCTION literals are special because TypedScopeCreator is very smart\n1435       // about getting as much type information as possible for them.\n1436 \n1437       // Determining type for #1 + #2 + #3 + #4\n1438       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n1439       if (valueType == null && rhsValue != null) {\n1440         // Determining type for #5\n1441         valueType = rhsValue.getJSType();\n1442       }\n1443       // Function prototypes are special.\n1444       // It's a common JS idiom to do:\n1445       // F.prototype = { ... };\n1446       // So if F does not have an explicitly declared super type,\n1447       // allow F.prototype to be redefined arbitrarily.\n1448       if (\"prototype\".equals(propName)) {\n1449         Var qVar = scope.getVar(qName);\n1450         if (qVar != null) {\n1451           // If the programmer has declared that F inherits from Super,\n1452           // and they assign F.prototype to an object literal,\n1453           // then they are responsible for making sure that the object literal's\n1454           // implicit prototype is set up appropriately. We just obey\n1455           // the @extends tag.\n1456           ObjectType qVarType = ObjectType.cast(qVar.getType());\n1457           if (qVarType != null &&\n1458               rhsValue != null &&\n1459               rhsValue.isObjectLit()) {\n1460             typeRegistry.resetImplicitPrototype(\n1461                 rhsValue.getJSType(), qVarType.getImplicitPrototype());\n1462           } else if (!qVar.isTypeInferred()) {\n1463             // If the programmer has declared that F inherits from Super,\n1464             // and they assign F.prototype to some arbitrary expression,\n1465             // there's not much we can do. We just ignore the expression,\n1466             // and hope they've annotated their code in a way to tell us\n1467             // what props are going to be on that prototype.\n1468             return;\n1469           }\n1470           if (qVar.getScope() == scope) {\n1471             scope.undeclare(qVar);\n1472           }\n1473         }\n1474       }\n1475 \n1476       if (valueType == null) {\n1477         if (parent.isExprResult()) {\n1478           stubDeclarations.add(new StubDeclaration(\n1479               n,\n1480               t.getInput() != null && t.getInput().isExtern(),\n1481               ownerName));\n1482         }\n1483 \n1484         return;\n1485       }\n1486 \n1487       // NOTE(nicksantos): Determining whether a property is declared or not\n1488       // is really really obnoxious.\n1489       //\n1490       // The problem is that there are two (equally valid) coding styles:\n1491       //\n1492       // (function() {\n1493       //   /* The authoritative definition of goog.bar. */\n1494       //   goog.bar = function() {};\n1495       // })();\n1496       //\n1497       // function f() {\n1498       //   goog.bar();\n1499       //   /* Reset goog.bar to a no-op. */\n1500       //   goog.bar = function() {};\n1501       // }\n1502       //\n1503       // In a dynamic language with first-class functions, it's very difficult\n1504       // to know which one the user intended without looking at lots of\n1505       // contextual information (the second example demonstrates a small case\n1506       // of this, but there are some really pathological cases as well).\n1507       //\n1508       // The current algorithm checks if either the declaration has\n1509       // jsdoc type information, or @const with a known type,\n1510       // or a function literal with a name we haven't seen before.\n1511       boolean inferred = true;\n1512       if (info != null) {\n1513         // Determining declaration for #1 + #3 + #4\n1514         inferred = !(info.hasType()\n1515             || info.hasEnumParameterType()\n1516             || (info.isConstant() && valueType != null\n1517                 && !valueType.isUnknownType())\n1518             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n1519       }\n1520 \n1521       if (inferred) {\n1522         // Determining declaration for #2\n1523         inferred = !(rhsValue != null &&\n1524             rhsValue.isFunction() &&\n1525             (info != null || !scope.isDeclared(qName, false)));\n1526       }\n1527 \n1528       if (!inferred) {\n1529         ObjectType ownerType = getObjectSlot(ownerName);\n1530         if (ownerType != null) {\n1531           // Only declare this as an official property if it has not been\n1532           // declared yet.\n1533           boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n1534           if ((!ownerType.hasOwnProperty(propName) ||\n1535                ownerType.isPropertyTypeInferred(propName)) &&\n1536               ((isExtern && !ownerType.isNativeObjectType()) ||\n1537                !ownerType.isInstanceType())) {\n1538             // If the property is undeclared or inferred, declare it now.\n1539             ownerType.defineDeclaredProperty(propName, valueType, n);\n1540           }\n1541         }\n1542 \n1543         // If the property is already declared, the error will be\n1544         // caught when we try to declare it in the current scope.\n1545         defineSlot(n, parent, valueType, inferred);\n1546       } else if (rhsValue != null && rhsValue.isTrue()) {\n1547         // We declare these for delegate proxy method properties.\n1548         FunctionType ownerType =\n1549             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n1550         if (ownerType != null) {\n1551           JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n1552           String delegateName = codingConvention.getDelegateSuperclassName();\n1553           JSType delegateType = delegateName == null ?\n1554               null : typeRegistry.getType(delegateName);\n1555           if (delegateType != null &&\n1556               ownerTypeOfThis.isSubtype(delegateType)) {\n1557             defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n1558           }\n1559         }\n1560       }\n1561     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_49", "report_text": "> Incorrect output if a function is assigned to a variable, and the function contains a variable with the same name\n> \n> **What steps will reproduce the problem?**\n> \r\n>  1. Enter the following into the online compiler\r\n> \r\n>  var foo = function bar(){\r\n>  var bar;\r\n>  alert(bar)\r\n>  };\r\n> \r\n>  2. Compile using simple optimization\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n>  I'd expect to see\r\n> \r\n>  var foo = function() {\r\n>  alert(void 0)\r\n>  };\r\n> \r\n>  Instead I see\r\n> \r\n>  var foo = function bar() {\r\n>  alert(bar)\r\n>  };\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n>  Using http://closure-compiler.appspot.com/home\r\n> \r\n> **Please provide any additional information below.**\n> \r\n>  The compiled output is correct if you remove the \"var foo =\" part, or if you rename the function from \"bar\" to something else.", "test_name": "com.google.javascript.jscomp.FunctionInjectorTest::testInline19b", "test_method": "  public void testInline19b() {\n    helperInlineReferenceToFunction(\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() { foo(x,y); }\",\n        \"var x = 1; var y = 2;\" +\n        \"function foo(a,b){y = a; x = b;}; \" +\n        \"function bar() {\" +\n           \"{var b$$inline_1=y;\" +\n            \"y = x;\" +\n            \"x = b$$inline_1;}\" +\n        \"}\",\n        \"foo\", INLINE_BLOCK); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.FunctionInjectorTest$2.call(FunctionInjectorTest.java:1479)\n\tcom.google.javascript.jscomp.FunctionInjectorTest$TestCallback.visit(FunctionInjectorTest.java:1524)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:498)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:536)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:483)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:277)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:455)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperInlineReferenceToFunction(FunctionInjectorTest.java:1488)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperInlineReferenceToFunction(FunctionInjectorTest.java:1393)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.testInline19b(FunctionInjectorTest.java:945)", "buggy_method": "75 @Override\n76   public void enterScope(NodeTraversal t) {\n77     Node declarationRoot = t.getScopeRoot();\n78     Renamer renamer;\n79     if (nameStack.isEmpty()) {\n80       // If the contextual renamer is being used the starting context can not\n81       // be a function.\n82       Preconditions.checkState(\n83           declarationRoot.getType() != Token.FUNCTION ||\n84           !(rootRenamer instanceof ContextualRenamer));\n85       Preconditions.checkState(t.inGlobalScope());\n86       renamer = rootRenamer;\n87     } else {\n88       renamer = nameStack.peek().forChildScope();\n89     }\n90 \n91     if (declarationRoot.getType() == Token.FUNCTION) {\n92       for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n93         String name = c.getString();\n94         renamer.addDeclaredName(name);\n95       }\n96       Node functionBody = declarationRoot.getLastChild();\n97       findDeclaredNames(functionBody, null, renamer);\n98     }  else \n99     if (declarationRoot.getType() != Token.FUNCTION) {\n100       // Add the block declarations\n101       findDeclaredNames(declarationRoot, null, renamer);\n102     }\n103     nameStack.push(renamer);\n104   }", "bm_classpath": "com.google.javascript.jscomp.MakeDeclaredNamesUnique"}, {"bug_name": "Closure_50", "report_text": "> Optimisation: convert array.join(\",\") to array.join()\n> \n> **What steps will reproduce the problem?**\n> \r\n> Compile this code:\r\n> \r\n> var variable = confirm(\"value from user\");\r\n> var array = [ \"constant\", variable ];\r\n> alert( array.join(\",\") );\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> $ java -jar /usr/local/slando/lib/Google/compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --js foo.js\r\n> var a=[\"constant\",confirm(\"value from user\")];alert(a.join(\",\"));\r\n> \r\n> We could save three bytes here by producing:\r\n> \r\n> var a=[\"constant\",confirm(\"value from user\")];alert(a.join());\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> $ java -jar /usr/local/slando/lib/Google/compiler.jar --version\r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 1180\r\n> Built on: 2011/06/15 21:40\r\n> \r\n> Running on Linux 2.6.18\r\n> \r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Here's a common pattern this would be useful in:\r\n> \r\n> var my\\_jquery\\_selectors = [];\r\n> // ... append to my\\_jquery\\_selectors from various parts of the codebase ...\r\n> $(my\\_jquery\\_selectors.join(\",\")).html(\"the code is more readable with the comma left in place\");", "test_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethodsTest::testStringJoinAdd", "test_method": "  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\",\n        \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join()\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:862)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.PeepholeReplaceKnownMethodsTest.fold(PeepholeReplaceKnownMethodsTest.java:280)\n\tcom.google.javascript.jscomp.PeepholeReplaceKnownMethodsTest.testStringJoinAdd(PeepholeReplaceKnownMethodsTest.java:87)", "buggy_method": "367 private Node tryFoldArrayJoin(Node n) {\n368     Node callTarget = n.getFirstChild();\n369 \n370     if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n371       return n;\n372     }\n373 \n374     Node right = callTarget.getNext();\n375     if (right != null) {\n376       if (!NodeUtil.isImmutableValue(right)) {\n377         return n;\n378       }\n379     }\n380 \n381     Node arrayNode = callTarget.getFirstChild();\n382     Node functionName = arrayNode.getNext();\n383 \n384     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n385         !functionName.getString().equals(\"join\")) {\n386       return n;\n387     }\n388 \n389       // \",\" is the default, it doesn't need to be explicit\n390 \n391     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n392     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n393     StringBuilder sb = null;\n394     int foldedSize = 0;\n395     Node prev = null;\n396     Node elem = arrayNode.getFirstChild();\n397     // Merges adjacent String nodes.\n398     while (elem != null) {\n399       if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n400         if (sb == null) {\n401           sb = new StringBuilder();\n402         } else {\n403           sb.append(joinString);\n404         }\n405         sb.append(NodeUtil.getArrayElementStringValue(elem));\n406       } else {\n407         if (sb != null) {\n408           Preconditions.checkNotNull(prev);\n409           // + 2 for the quotes.\n410           foldedSize += sb.length() + 2;\n411           arrayFoldedChildren.add(\n412               Node.newString(sb.toString()).copyInformationFrom(prev));\n413           sb = null;\n414         }\n415         foldedSize += InlineCostEstimator.getCost(elem);\n416         arrayFoldedChildren.add(elem);\n417       }\n418       prev = elem;\n419       elem = elem.getNext();\n420     }\n421 \n422     if (sb != null) {\n423       Preconditions.checkNotNull(prev);\n424       // + 2 for the quotes.\n425       foldedSize += sb.length() + 2;\n426       arrayFoldedChildren.add(\n427           Node.newString(sb.toString()).copyInformationFrom(prev));\n428     }\n429     // one for each comma.\n430     foldedSize += arrayFoldedChildren.size() - 1;\n431 \n432     int originalSize = InlineCostEstimator.getCost(n);\n433     switch (arrayFoldedChildren.size()) {\n434       case 0:\n435         Node emptyStringNode = Node.newString(\"\");\n436         n.getParent().replaceChild(n, emptyStringNode);\n437         reportCodeChange();\n438         return emptyStringNode;\n439       case 1:\n440         Node foldedStringNode = arrayFoldedChildren.remove(0);\n441         if (foldedSize > originalSize) {\n442           return n;\n443         }\n444         arrayNode.detachChildren();\n445         if (foldedStringNode.getType() != Token.STRING) {\n446           // If the Node is not a string literal, ensure that\n447           // it is coerced to a string.\n448           Node replacement = new Node(Token.ADD,\n449               Node.newString(\"\").copyInformationFrom(n),\n450               foldedStringNode);\n451           foldedStringNode = replacement;\n452         }\n453         n.getParent().replaceChild(n, foldedStringNode);\n454         reportCodeChange();\n455         return foldedStringNode;\n456       default:\n457         // No folding could actually be performed.\n458         if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n459           return n;\n460         }\n461         int kJoinOverhead = \"[].join()\".length();\n462         foldedSize += kJoinOverhead;\n463         foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n464         if (foldedSize > originalSize) {\n465           return n;\n466         }\n467         arrayNode.detachChildren();\n468         for (Node node : arrayFoldedChildren) {\n469           arrayNode.addChildToBack(node);\n470         }\n471         reportCodeChange();\n472         break;\n473     }\n474 \n475     return n;\n476   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods"}, {"bug_name": "Closure_51", "report_text": "> -0.0 becomes 0 even in whitespace mode\n> \n> Affects dart: http://code.google.com/p/dart/issues/detail?id=146", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testIssue582", "test_method": "  public void testIssue582() {\n    assertPrint(\"var x = -0.0;\", \"var x=-0.0\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x=[-0.]0> but was:<var x=[]0>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:389)\n\tcom.google.javascript.jscomp.CodePrinterTest.testIssue582(CodePrinterTest.java:1273)", "buggy_method": "233 void addNumber(double x) {\n234     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n235     // x--4 (which is a syntax error).\n236     char prev = getLastChar();\n237     if (x < 0 && prev == '-') {\n238       add(\" \");\n239     }\n240 \n241     if ((long) x == x) {\n242       long value = (long) x;\n243       long mantissa = value;\n244       int exp = 0;\n245       if (Math.abs(x) >= 100) {\n246         while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n247           mantissa /= 10;\n248           exp++;\n249         }\n250       }\n251       if (exp > 2) {\n252         add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n253       } else {\n254         add(Long.toString(value));\n255       }\n256     } else {\n257       add(String.valueOf(x));\n258     }\n259   }", "bm_classpath": "com.google.javascript.jscomp.CodeConsumer"}, {"bug_name": "Closure_52", "report_text": "> Converts string properties into numbers in literal object definitions\n> \n> **What steps will reproduce the problem?**\n> 1. Minimize the following script:\r\n> \r\n> var lit = {\"0102\":\"Zero One Zero Two\"};\r\n> alert(lit[\"0102\"]);\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expected:\r\n> var lit={\"0102\":\"Zero One Zero Two\"};alert(lit[\"0102\"]);\r\n> \r\n> Actual:\r\n> var lit={102:\"Zero One Zero Two\"};alert(lit[\"0102\"]);\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> r1459\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testNumericKeys", "test_method": "  public void testNumericKeys() {\n    assertPrint(\"var x = {'010': 1};\", \"var x={\\\"010\\\":1}\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x={[\"010\"]:1}> but was:<var x={[10]:1}>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:389)\n\tcom.google.javascript.jscomp.CodePrinterTest.testNumericKeys(CodePrinterTest.java:1259)", "buggy_method": "737 static boolean isSimpleNumber(String s) {\n738     int len = s.length();\n739     for (int index = 0; index < len; index++) {\n740       char c = s.charAt(index);\n741       if (c < '0' || c > '9') {\n742         return false;\n743       }\n744     }\n745     return len > 0;\n746   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_53", "report_text": "> compiler-20110811 crashes with index(1) must be less than size(1)\n> \n> **What steps will reproduce the problem?**\n> Run compiler on https://raw.github.com/scottschiller/SoundManager2/master/script/soundmanager2-nodebug.js\r\n> \r\n> You can copy this into the Appspot closure compiler to see the error:\r\n> // ==ClosureCompiler==\r\n> // @output\\_file\\_name default.js\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @code\\_url https://raw.github.com/scottschiller/SoundManager2/master/script/soundmanager2-nodebug.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> I've attached a dump of the error from appspot.\r\n> \r\n> (This is the popular SoundManager library for HTML5 audio)\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Got crash...\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Latest (compiler-20110811). We were previously using the June build, and had no problems\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.InlineObjectLiteralsTest::testBug545", "test_method": "  public void testBug545() {\n    testLocal(\"var a = {}\", \"\");\n    testLocal(\"var a; a = {}\", \"true\"); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n\tcom.google.common.base.Preconditions.checkElementIndex(Preconditions.java:301)\n\tcom.google.common.base.Preconditions.checkElementIndex(Preconditions.java:280)\n\tcom.google.common.collect.Lists$ReverseList.reverseIndex(Lists.java:743)\n\tcom.google.common.collect.Lists$ReverseList.get(Lists.java:774)\n\tcom.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior.replaceAssignmentExpression(InlineObjectLiterals.java:349)\n\tcom.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior.splitObject(InlineObjectLiterals.java:412)\n\tcom.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior.afterExitScope(InlineObjectLiterals.java:103)\n\tcom.google.javascript.jscomp.ReferenceCollectingCallback.exitScope(ReferenceCollectingCallback.java:187)\n\tcom.google.javascript.jscomp.NodeTraversal.popScope(NodeTraversal.java:560)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:520)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:465)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:473)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:473)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:286)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:446)\n\tcom.google.javascript.jscomp.ReferenceCollectingCallback.process(ReferenceCollectingCallback.java:110)\n\tcom.google.javascript.jscomp.InlineObjectLiterals.process(InlineObjectLiterals.java:66)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:765)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)", "buggy_method": "303 private void replaceAssignmentExpression(Var v, Reference ref,\n304                                              Map<String, String> varmap) {\n305       // Compute all of the assignments necessary\n306       List<Node> nodes = Lists.newArrayList();\n307       Node val = ref.getAssignedValue();\n308       blacklistVarReferencesInTree(val, v.scope);\n309       Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n310       Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n311       for (Node key = val.getFirstChild(); key != null;\n312            key = key.getNext()) {\n313         String var = key.getString();\n314         Node value = key.removeFirstChild();\n315         // TODO(user): Copy type information.\n316         nodes.add(\n317           new Node(Token.ASSIGN,\n318                    Node.newString(Token.NAME, varmap.get(var)), value));\n319         all.remove(var);\n320       }\n321 \n322       // TODO(user): Better source information.\n323       for (String var : all) {\n324         nodes.add(\n325           new Node(Token.ASSIGN,\n326                    Node.newString(Token.NAME, varmap.get(var)),\n327                    NodeUtil.newUndefinedNode(null)));\n328       }\n329 \n330       Node replacement;\n331         // All assignments evaluate to true, so make sure that the\n332         // expr statement evaluates to true in case it matters.\n333         nodes.add(new Node(Token.TRUE));\n334 \n335         // Join these using COMMA.  A COMMA node must have 2 children, so we\n336         // create a tree. In the tree the first child be the COMMA to match\n337         // the parser, otherwise tree equality tests fail.\n338         nodes = Lists.reverse(nodes);\n339         replacement = new Node(Token.COMMA);\n340         Node cur = replacement;\n341         int i;\n342         for (i = 0; i < nodes.size() - 2; i++) {\n343           cur.addChildToFront(nodes.get(i));\n344           Node t = new Node(Token.COMMA);\n345           cur.addChildToFront(t);\n346           cur = t;\n347         }\n348         cur.addChildToFront(nodes.get(i));\n349         cur.addChildToFront(nodes.get(i + 1));\n350 \n351       Node replace = ref.getParent();\n352       replacement.copyInformationFromForTree(replace);\n353 \n354       if (replace.getType() == Token.VAR) {\n355         replace.getParent().replaceChild(\n356             replace, NodeUtil.newExpr(replacement));\n357       } else {\n358         replace.getParent().replaceChild(replace, replacement);\n359       }\n360     }", "bm_classpath": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior"}, {"bug_name": "Closure_54", "report_text": "> Prototype methods can't be used from the constructor in case prototype is explicitly defined.\n> \n> Consider the following source code:\r\n> http://trac.webkit.org/browser/trunk/Source/WebCore/inspector/front-end/DOMAgent.js\r\n> \r\n> When I mark WebInspector.DOMAgent as a @constructor, I get the following warning.\r\n> \r\n> Source/WebCore/inspector/front-end/DOMAgent.js:48: WARNING - Property \\_setAttributesPayload never defined on WebInspector.DOMNode\r\n>  this.\\_setAttributesPayload(payload.attributes);\r\n> \r\n> It sounds like the problem is in the way we define prototypes in line 83-ish. That's the way WebKit style tells us to do.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue537a", "test_method": "  public void testIssue537a() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"Foo.prototype = {method: function() {}};\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" * @extends {Foo}\\n\" +\n        \" */\\n\" +\n        \"function Bar() {\" +\n        \"  Foo.call(this);\" +\n        \"  if (this.baz()) this.method(1);\" +\n        \"}\" +\n        \"Bar.prototype = {\" +\n        \"  baz: function() {\" +\n        \"    return true;\" +\n        \"  }\" +\n        \"};\" +\n        \"Bar.prototype.__proto__ = Foo.prototype;\",\n        \"Function Foo.prototype.method: called with 1 argument(s). \" +\n        \"Function requires at least 0 argument(s) \" +\n        \"and no more than 0 argument(s).\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[Function Foo.prototype.method: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).]> but was:<[Property baz never defined on Bar]>\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9230)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9209)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9150)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue537a(TypeCheckTest.java:5264)", "buggy_method": "1373 void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n1374         Node n, Node parent, Node rhsValue) {\n1375       Node ownerNode = n.getFirstChild();\n1376       String ownerName = ownerNode.getQualifiedName();\n1377       String qName = n.getQualifiedName();\n1378       String propName = n.getLastChild().getString();\n1379       Preconditions.checkArgument(qName != null && ownerName != null);\n1380 \n1381       // Precedence of type information on GETPROPs:\n1382       // 1) @type annnotation / @enum annotation\n1383       // 2) ASSIGN to FUNCTION literal\n1384       // 3) @param/@return annotation (with no function literal)\n1385       // 4) ASSIGN to something marked @const\n1386       // 5) ASSIGN to anything else\n1387       //\n1388       // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n1389       // the function has jsdoc or has not been declared before.\n1390       //\n1391       // FUNCTION literals are special because TypedScopeCreator is very smart\n1392       // about getting as much type information as possible for them.\n1393 \n1394       // Determining type for #1 + #2 + #3 + #4\n1395       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n1396       if (valueType == null && rhsValue != null) {\n1397         // Determining type for #5\n1398         valueType = rhsValue.getJSType();\n1399       }\n1400       // Function prototypes are special.\n1401       // It's a common JS idiom to do:\n1402       // F.prototype = { ... };\n1403       // So if F does not have an explicitly declared super type,\n1404       // allow F.prototype to be redefined arbitrarily.\n1405       if (\"prototype\".equals(propName)) {\n1406         Var qVar = scope.getVar(qName);\n1407         if (qVar != null) {\n1408           // If the programmer has declared that F inherits from Super,\n1409           // and they assign F.prototype to an object literal,\n1410           // then they are responsible for making sure that the object literal's\n1411           // implicit prototype is set up appropriately. We just obey\n1412           // the @extends tag.\n1413           if (!qVar.isTypeInferred()) {\n1414             // If the programmer has declared that F inherits from Super,\n1415             // and they assign F.prototype to some arbitrary expression,\n1416             // there's not much we can do. We just ignore the expression,\n1417             // and hope they've annotated their code in a way to tell us\n1418             // what props are going to be on that prototype.\n1419             return;\n1420           }\n1421           if (qVar.getScope() == scope) {\n1422             scope.undeclare(qVar);\n1423           }\n1424         }\n1425       }\n1426 \n1427       if (valueType == null) {\n1428         if (parent.getType() == Token.EXPR_RESULT) {\n1429           stubDeclarations.add(new StubDeclaration(\n1430               n,\n1431               t.getInput() != null && t.getInput().isExtern(),\n1432               ownerName));\n1433         }\n1434 \n1435         return;\n1436       }\n1437 \n1438       boolean inferred = true;\n1439       if (info != null) {\n1440         // Determining declaration for #1 + #3 + #4\n1441         inferred = !(info.hasType()\n1442             || info.hasEnumParameterType()\n1443             || (info.isConstant() && valueType != null\n1444                 && !valueType.isUnknownType())\n1445             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n1446       }\n1447 \n1448       if (inferred) {\n1449         // Determining declaration for #2\n1450         inferred = !(rhsValue != null &&\n1451             rhsValue.getType() == Token.FUNCTION &&\n1452             (info != null || !scope.isDeclared(qName, false)));\n1453       }\n1454 \n1455       if (!inferred) {\n1456         ObjectType ownerType = getObjectSlot(ownerName);\n1457         if (ownerType != null) {\n1458           // Only declare this as an official property if it has not been\n1459           // declared yet.\n1460           boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n1461           if ((!ownerType.hasOwnProperty(propName) ||\n1462                ownerType.isPropertyTypeInferred(propName)) &&\n1463               ((isExtern && !ownerType.isNativeObjectType()) ||\n1464                !ownerType.isInstanceType())) {\n1465             // If the property is undeclared or inferred, declare it now.\n1466             ownerType.defineDeclaredProperty(propName, valueType, n);\n1467           }\n1468         }\n1469 \n1470         // If the property is already declared, the error will be\n1471         // caught when we try to declare it in the current scope.\n1472         defineSlot(n, parent, valueType, inferred);\n1473       } else if (rhsValue != null &&\n1474           rhsValue.getType() == Token.TRUE) {\n1475         // We declare these for delegate proxy method properties.\n1476         FunctionType ownerType =\n1477             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n1478         if (ownerType != null) {\n1479           JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n1480           String delegateName = codingConvention.getDelegateSuperclassName();\n1481           JSType delegateType = delegateName == null ?\n1482               null : typeRegistry.getType(delegateName);\n1483           if (delegateType != null &&\n1484               ownerTypeOfThis.isSubtype(delegateType)) {\n1485             defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n1486           }\n1487         }\n1488       }\n1489     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_55", "report_text": "> Exception when emitting code containing getters\n> \n> Consider the following source code: http://trac.webkit.org/browser/trunk/Source/WebCore/inspector/front-end/Settings.js#L123\r\n> \r\n> Following exception fires unless I remove the \"get name()\" getter from the code.\r\n> \r\n> java.lang.RuntimeException: java.lang.IllegalStateException: Expected function but was call Reference node CALL 128 [free\\_call: 1] [source\\_file: Settings.js]\r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:629)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:574)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:556)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:515)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:662)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:295)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:758)\r\n> Caused by: java.lang.IllegalStateException: Expected function but was call Reference node CALL 128 [free\\_call: 1] [source\\_file: Settings.js]\r\n>  at com.google.javascript.jscomp.AstValidator$1.handleViolation(AstValidator.java:51)\r\n>  at com.google.javascript.jscomp.AstValidator.violation(AstValidator.java:763)\r\n>  at com.google.javascript.jscomp.AstValidator.validateNodeType(AstValidator.java:768)\r\n>  at com.google.javascript.jscomp.AstValidator.validateFunctionExpression(AstValidator.java:359)\r\n>  at com.google.javascript.jscomp.AstValidator.validateObjectLitGetKey(AstValidator.java:696)\r\n>  at com.google.javascript.jscomp.AstValidator.validateObjectLitKey(AstValidator.java:677)\r\n>  at com.google.javascript.jscomp.AstValidator.validateObjectLit(AstValidator.java:670)\r\n>  at com.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:252)\r\n>  at com.google.javascript.jscomp.AstValidator.validateAssignmentExpression(AstValidator.java:603)\r\n>  at com.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:219)\r\n>  at com.google.javascript.jscomp.AstValidator.validateExprStmt(AstValidator.java:476)\r\n>  at com.google.javascript.jscomp.AstValidator.validateStatement(AstValidator.java:126)\r\n>  at com.google.javascript.jscomp.AstValidator.validateScript(AstValidator.java:89)\r\n>  at com.google.javascript.jscomp.AstValidator.validateCodeRoot(AstValidator.java:79)\r\n>  at com.google.javascript.jscomp.AstValidator.process(AstValidator.java:63)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:273)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:250)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:168)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1634)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:664)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:70)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:559)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Compiler.java:556)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Compiler.java:601)\r\n>  at java.lang.Thread.run(Thread.java:680)", "test_name": "com.google.javascript.jscomp.FunctionRewriterTest::testIssue538", "test_method": "  public void testIssue538() {\n    checkCompilesToSame(      \"/** @constructor */\\n\" +\n        \"WebInspector.Setting = function() {}\\n\" +\n        \"WebInspector.Setting.prototype = {\\n\" +\n        \"    get name0(){return this._name;},\\n\" +\n        \"    get name1(){return this._name;},\\n\" +\n        \"    get name2(){return this._name;},\\n\" +\n        \"    get name3(){return this._name;},\\n\" +\n        \"    get name4(){return this._name;},\\n\" +\n        \"    get name5(){return this._name;},\\n\" +\n        \"    get name6(){return this._name;},\\n\" +\n        \"    get name7(){return this._name;},\\n\" +\n        \"    get name8(){return this._name;},\\n\" +\n        \"    get name9(){return this._name;},\\n\" +\n        \"}\", 1); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: Expected function but was call Reference node CALL 4 [free_call: 1] [source_file: testcode]\n\tcom.google.javascript.jscomp.AstValidator$1.handleViolation(AstValidator.java:51)\n\tcom.google.javascript.jscomp.AstValidator.violation(AstValidator.java:763)\n\tcom.google.javascript.jscomp.AstValidator.validateNodeType(AstValidator.java:768)\n\tcom.google.javascript.jscomp.AstValidator.validateFunctionExpression(AstValidator.java:359)\n\tcom.google.javascript.jscomp.AstValidator.validateObjectLitGetKey(AstValidator.java:696)\n\tcom.google.javascript.jscomp.AstValidator.validateObjectLitKey(AstValidator.java:677)\n\tcom.google.javascript.jscomp.AstValidator.validateObjectLit(AstValidator.java:670)\n\tcom.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:252)\n\tcom.google.javascript.jscomp.AstValidator.validateAssignmentExpression(AstValidator.java:603)\n\tcom.google.javascript.jscomp.AstValidator.validateExpression(AstValidator.java:219)\n\tcom.google.javascript.jscomp.AstValidator.validateExprStmt(AstValidator.java:476)\n\tcom.google.javascript.jscomp.AstValidator.validateStatement(AstValidator.java:126)\n\tcom.google.javascript.jscomp.AstValidator.validateScript(AstValidator.java:89)\n\tcom.google.javascript.jscomp.AstValidator.validateCodeRoot(AstValidator.java:79)\n\tcom.google.javascript.jscomp.AstValidator.validateRoot(AstValidator.java:72)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:767)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)", "buggy_method": "116 private static boolean isReduceableFunctionExpression(Node n) {\n117     return NodeUtil.isFunctionExpression(n);\n118   }", "bm_classpath": "com.google.javascript.jscomp.FunctionRewriter"}, {"bug_name": "Closure_56", "report_text": "> Last warning or error in output is truncated\n> \n> The last error or warning statement written to the output appears to be getting truncated. It's causing a problem for my error / warning parser.\r\n> \r\n> To reproduce, create a file called test.js and add the following content to it:\r\n> \r\n> ---------------\r\n> alert(foo);\r\n> alert(bar);\r\n> ---------------\r\n> \r\n> When compiled, the output looks like this:\r\n> \r\n> ---------------\r\n> >java -jar compiler.jar --warning\\_level VERBOSE --js test.js\r\n> test.js:1: ERROR - variable foo is undefined\r\n> alert(foo);\r\n>  ^\r\n> \r\n> test.js:2: ERROR - variable bar is undefined\r\n> \r\n> 2 error(s), 0 warning(s)\r\n> ---------------\r\n> \r\n> If you look at the last error includes neither the line the error occurred on nor the column-indicating caret. This happens with warnings as well.\r\n> \r\n> Tested against r1257 committed 2011-07-11 11:11:32 -0700.", "test_name": "com.google.javascript.jscomp.JSCompilerSourceExcerptProviderTest::testExceptNoNewLine", "test_method": "  public void testExceptNoNewLine() throws Exception {\n    assertEquals(\"foo2:third line\", provider.getSourceLine(\"foo2\", 3)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<foo2:third line> but was:<null>\n\tcom.google.javascript.jscomp.JSCompilerSourceExcerptProviderTest.testExceptNoNewLine(JSCompilerSourceExcerptProviderTest.java:67)", "buggy_method": "205 public String getLine(int lineNumber) {\n206     String js = \"\";\n207     try {\n208       // NOTE(nicksantos): Right now, this is optimized for few warnings.\n209       // This is probably the right trade-off, but will be slow if there\n210       // are lots of warnings in one file.\n211       js = getCode();\n212     } catch (IOException e) {\n213       return null;\n214     }\n215 \n216     int pos = 0;\n217     int startLine = 1;\n218 \n219     // If we've saved a previous offset and it's for a line less than the\n220     // one we're searching for, then start at that point.\n221     if (lineNumber >= lastLine) {\n222       pos = lastOffset;\n223       startLine = lastLine;\n224     }\n225 \n226     for (int n = startLine; n < lineNumber; n++) {\n227       int nextpos = js.indexOf('\\n', pos);\n228       if (nextpos == -1) {\n229         return null;\n230       }\n231       pos = nextpos + 1;\n232     }\n233 \n234     // Remember this offset for the next search we do.\n235     lastOffset = pos;\n236     lastLine = lineNumber;\n237 \n238     if (js.indexOf('\\n', pos) == -1) {\n239       // If next new line cannot be found, there are two cases\n240       // 1. pos already reaches the end of file, then null should be returned\n241       // 2. otherwise, return the contents between pos and the end of file.\n242         return null;\n243     } else {\n244       return js.substring(pos, js.indexOf('\\n', pos));\n245     }\n246   }", "bm_classpath": "com.google.javascript.jscomp.SourceFile"}, {"bug_name": "Closure_57", "report_text": "> compiler crashes when  goog.provide used with non string\n> \n> **What steps will reproduce the problem?**\n> 1. insert goog.provide(some.function);\r\n> 2. compile.\r\n> **3.**\n> **What is the expected output? What do you see instead?**\n> \r\n> This should give an error diagnostic. What it gives is:\r\n> \r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please email js-compiler@google.com with this stack trace.\r\n> GETPROP 17 [originalname: Spike] [source\\_file: file.js] is not a string node\r\n>  Node(CALL): file.js:17:12\r\n> goog.provide(mine.Spike);\r\n> ...\r\n> [stack traces...]\r\n> \r\n> I think this is the current build as of the day of this report.", "test_name": "com.google.javascript.jscomp.ClosureCodingConventionTest::testRequire", "test_method": "  public void testRequire() {\n    assertNotRequire(\"goog.require(foo)\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: <null> but was: foo\n\tcom.google.javascript.jscomp.ClosureCodingConventionTest.assertNotRequire(ClosureCodingConventionTest.java:218)\n\tcom.google.javascript.jscomp.ClosureCodingConventionTest.testRequire(ClosureCodingConventionTest.java:196)", "buggy_method": "188 private static String extractClassNameIfGoog(Node node, Node parent,\n189       String functionName){\n190     String className = null;\n191     if (NodeUtil.isExprCall(parent)) {\n192       Node callee = node.getFirstChild();\n193       if (callee != null && callee.getType() == Token.GETPROP) {\n194         String qualifiedName = callee.getQualifiedName();\n195         if (functionName.equals(qualifiedName)) {\n196           Node target = callee.getNext();\n197           if (target != null) {\n198             className = target.getString();\n199           }\n200         }\n201       }\n202     }\n203     return className;\n204   }", "bm_classpath": "com.google.javascript.jscomp.ClosureCodingConvention"}, {"bug_name": "Closure_58", "report_text": "> Online CC bug: report java error.\n> \n> **What steps will reproduce the problem?**\n> 1. open http://closure-compiler.appspot.com/\r\n> 2. input js code:\r\n>  function keys(obj) {\r\n>  var a = [], i = 0;\r\n>  for (a[i++] in obj)\r\n>  ;\r\n>  return a;\r\n>  }\r\n> 3. press [compile] button.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Except OK. See java error.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Online CC version.", "test_name": "com.google.javascript.jscomp.LiveVariableAnalysisTest::testExpressionInForIn", "test_method": "  public void testExpressionInForIn() {\n    assertLiveBeforeX(\"var a = [0]; X:for (a[1] in foo) { }\", \"a\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException\n\tcom.google.common.base.Preconditions.checkState(Preconditions.java:129)\n\tcom.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal(LiveVariablesAnalysis.java:266)\n\tcom.google.javascript.jscomp.LiveVariablesAnalysis.computeGenKill(LiveVariablesAnalysis.java:206)\n\tcom.google.javascript.jscomp.LiveVariablesAnalysis.flowThrough(LiveVariablesAnalysis.java:159)\n\tcom.google.javascript.jscomp.LiveVariablesAnalysis.flowThrough(LiveVariablesAnalysis.java:47)\n\tcom.google.javascript.jscomp.DataFlowAnalysis.flow(DataFlowAnalysis.java:275)\n\tcom.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:212)\n\tcom.google.javascript.jscomp.DataFlowAnalysis.analyze(DataFlowAnalysis.java:180)\n\tcom.google.javascript.jscomp.LiveVariableAnalysisTest.computeLiveness(LiveVariableAnalysisTest.java:366)\n\tcom.google.javascript.jscomp.LiveVariableAnalysisTest.getFlowStateAtX(LiveVariableAnalysisTest.java:312)\n\tcom.google.javascript.jscomp.LiveVariableAnalysisTest.assertLiveBeforeX(LiveVariableAnalysisTest.java:279)\n\tcom.google.javascript.jscomp.LiveVariableAnalysisTest.testExpressionInForIn(LiveVariableAnalysisTest.java:210)", "buggy_method": "178 private void computeGenKill(Node n, BitSet gen, BitSet kill,\n179       boolean conditional) {\n180 \n181     switch (n.getType()) {\n182       case Token.SCRIPT:\n183       case Token.BLOCK:\n184       case Token.FUNCTION:\n185         return;\n186 \n187       case Token.WHILE:\n188       case Token.DO:\n189       case Token.IF:\n190         computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n191             conditional);\n192         return;\n193 \n194       case Token.FOR:\n195         if (!NodeUtil.isForIn(n)) {\n196           computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n197               conditional);\n198         } else {\n199           // for(x in y) {...}\n200           Node lhs = n.getFirstChild();\n201           Node rhs = lhs.getNext();\n202           if (NodeUtil.isVar(lhs)) {\n203             // for(var x in y) {...}\n204             lhs = lhs.getLastChild();\n205           }\n206             addToSetIfLocal(lhs, kill);\n207             addToSetIfLocal(lhs, gen);\n208           computeGenKill(rhs, gen, kill, conditional);\n209         }\n210         return;\n211 \n212       case Token.VAR:\n213         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n214           if (c.hasChildren()) {\n215             computeGenKill(c.getFirstChild(), gen, kill, conditional);\n216             if (!conditional) {\n217               addToSetIfLocal(c, kill);\n218             }\n219           }\n220         }\n221         return;\n222 \n223       case Token.AND:\n224       case Token.OR:\n225         computeGenKill(n.getFirstChild(), gen, kill, conditional);\n226         // May short circuit.\n227         computeGenKill(n.getLastChild(), gen, kill, true);\n228         return;\n229 \n230       case Token.HOOK:\n231         computeGenKill(n.getFirstChild(), gen, kill, conditional);\n232         // Assume both sides are conditional.\n233         computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n234         computeGenKill(n.getLastChild(), gen, kill, true);\n235         return;\n236 \n237       case Token.NAME:\n238         if (isArgumentsName(n)) {\n239           markAllParametersEscaped();\n240         } else {\n241           addToSetIfLocal(n, gen);\n242         }\n243         return;\n244 \n245       default:\n246         if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n247           Node lhs = n.getFirstChild();\n248           if (!conditional) {\n249             addToSetIfLocal(lhs, kill);\n250           }\n251           if (!NodeUtil.isAssign(n)) {\n252             // assignments such as a += 1 reads a.\n253             addToSetIfLocal(lhs, gen);\n254           }\n255           computeGenKill(lhs.getNext(), gen, kill, conditional);\n256         } else {\n257           for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n258             computeGenKill(c, gen, kill, conditional);\n259           }\n260         }\n261         return;\n262     }\n263   }", "bm_classpath": "com.google.javascript.jscomp.LiveVariablesAnalysis"}, {"bug_name": "Closure_59", "report_text": "> Cannot exclude globalThis checks through command line\n> \n> **What steps will reproduce the problem?**\n> 1. Run command line utility\r\n> 2. Supply flags --warning\\_level VERBOSE --jscomp\\_off globalThis --jscomp\\_off nonStandardJsDocs\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I expect that globalThis and nonStandardJsDocs warnings will be ignored. Only nonStandardJsDocs warnings are ignored.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Version 1180\r\n> Sun OS 5.10\r\n> \r\n> **Please provide any additional information below.**\n> --jscomp\\_error also doesn't work with globalThis (works with nonStandardJSDocs).", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testCheckGlobalThisOff", "test_method": "  public void testCheckGlobalThisOff() {\n    args.add(\"--warning_level=VERBOSE\");\n    args.add(\"--jscomp_off=globalThis\");\n    testSame(\"function f() { this.a = 3; }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected no warnings or errors\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:861)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:847)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:835)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:831)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testCheckGlobalThisOff(CommandLineRunnerTest.java:160)", "buggy_method": "226 public void initOptions(CompilerOptions options) {\n227     this.options = options;\n228     if (errorManager == null) {\n229       if (outStream == null) {\n230         setErrorManager(\n231             new LoggerErrorManager(createMessageFormatter(), logger));\n232       } else {\n233         PrintStreamErrorManager printer =\n234             new PrintStreamErrorManager(createMessageFormatter(), outStream);\n235         printer.setSummaryDetailLevel(options.summaryDetailLevel);\n236         setErrorManager(printer);\n237       }\n238     }\n239 \n240     // DiagnosticGroups override the plain checkTypes option.\n241     if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n242       options.checkTypes = true;\n243     } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n244       options.checkTypes = false;\n245     } else if (!options.checkTypes) {\n246       // If DiagnosticGroups did not override the plain checkTypes\n247       // option, and checkTypes is enabled, then turn off the\n248       // parser type warnings.\n249       options.setWarningLevel(\n250           DiagnosticGroup.forType(\n251               RhinoErrorReporter.TYPE_PARSE_ERROR),\n252           CheckLevel.OFF);\n253     }\n254 \n255     if (options.checkGlobalThisLevel.isOn()) {\n256       options.setWarningLevel(\n257           DiagnosticGroups.GLOBAL_THIS,\n258           options.checkGlobalThisLevel);\n259     }\n260 \n261     if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n262       options.setWarningLevel(\n263           DiagnosticGroups.ES5_STRICT,\n264           CheckLevel.ERROR);\n265     }\n266 \n267     // Initialize the warnings guard.\n268     List<WarningsGuard> guards = Lists.newArrayList();\n269     guards.add(\n270         new SuppressDocWarningsGuard(\n271             getDiagnosticGroups().getRegisteredGroups()));\n272     guards.add(options.getWarningsGuard());\n273 \n274     ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n275 \n276     // All passes must run the variable check. This synthesizes\n277     // variables later so that the compiler doesn't crash. It also\n278     // checks the externs file for validity. If you don't want to warn\n279     // about missing variable declarations, we shut that specific\n280     // error off.\n281     if (!options.checkSymbols &&\n282         !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n283       composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n284           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n285     }\n286 \n287     this.warningsGuard = composedGuards;\n288   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_60", "report_text": "> void function () {}(); wrongly identified as having no side effects\n> \n> This code results in the execution of the function and should not be identified as having no side effects.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testIssue504", "test_method": "  public void testIssue504() {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"void function() { alert('hi'); }();\",\n         \"alert('hi');\", CheckSideEffects.USELESS_CODE_ERROR); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:861)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:875)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testIssue504(CommandLineRunnerTest.java:365)", "buggy_method": "74 static TernaryValue getImpureBooleanValue(Node n) {\n75     switch (n.getType()) {\n76       case Token.ASSIGN:\n77       case Token.COMMA:\n78         // For ASSIGN and COMMA the value is the value of the RHS.\n79         return getImpureBooleanValue(n.getLastChild());\n80       case Token.NOT:\n81         TernaryValue value = getImpureBooleanValue(n.getLastChild());\n82         return value.not();\n83       case Token.AND: {\n84         TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n85         TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n86         return lhs.and(rhs);\n87       }\n88       case Token.OR:  {\n89         TernaryValue lhs = getImpureBooleanValue(n.getFirstChild());\n90         TernaryValue rhs = getImpureBooleanValue(n.getLastChild());\n91         return lhs.or(rhs);\n92       }\n93       case Token.HOOK:  {\n94         TernaryValue trueValue = getImpureBooleanValue(\n95             n.getFirstChild().getNext());\n96         TernaryValue falseValue = getImpureBooleanValue(n.getLastChild());\n97         if (trueValue.equals(falseValue)) {\n98           return trueValue;\n99         } else {\n100           return TernaryValue.UNKNOWN;\n101         }\n102       }\n103       case Token.ARRAYLIT:\n104       case Token.OBJECTLIT:\n105         // ignoring side-effects\n106         return TernaryValue.TRUE;\n107 \n108 \n109       default:\n110         return getPureBooleanValue(n);\n111     }\n112   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_61", "report_text": "> Closure removes needed code.\n> \n> **What steps will reproduce the problem?**\n> 1. Try the following code, in Simple mode\r\n> Math.blah = function(test) { test.a = 5; };\r\n> var test = new Object();\r\n> Math.blah(test); \r\n> 2. The output is\r\n> Math.blah=function(a){a.a=5};var test={};\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> Note that Math.blah(test) was removed. It should not be. It issues a warning: JSC\\_USELESS\\_CODE: Suspicious code. This code lacks side-effects. Is there a bug? at line 4 character 9\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Tested on Google hosted Closure service.\r\n> \r\n> **Please provide any additional information below.**\n> Closure seems to be protective about Math in particular, and doesn't like people messing around with her? So, when I try the following code:-\r\n> var n = {};\r\n> n.blah = function(test) { test.a = 5; };\r\n> var test = new Object();\r\n> n.blah(test);\r\n> \r\n> It works. When I replace n by Math, then again, Closure kicks out blah. I need that poor fellow. Please talk some sense into it.", "test_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest::testCall1", "test_method": "  public void testCall1() {\n    test(\"Math.sin(0);\", \"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:862)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.PeepholeRemoveDeadCodeTest.testCall1(PeepholeRemoveDeadCodeTest.java:544)", "buggy_method": "926 static boolean functionCallHasSideEffects(\n927       Node callNode, @Nullable AbstractCompiler compiler) {\n928     if (callNode.getType() != Token.CALL) {\n929       throw new IllegalStateException(\n930           \"Expected CALL node, got \" + Token.name(callNode.getType()));\n931     }\n932 \n933     if (callNode.isNoSideEffectsCall()) {\n934       return false;\n935     }\n936 \n937     Node nameNode = callNode.getFirstChild();\n938 \n939     // Built-in functions with no side effects.\n940     if (nameNode.getType() == Token.NAME) {\n941       String name = nameNode.getString();\n942       if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n943         return false;\n944       }\n945     } else if (nameNode.getType() == Token.GETPROP) {\n946       if (callNode.hasOneChild()\n947           && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n948                 nameNode.getLastChild().getString())) {\n949         return false;\n950       }\n951 \n952       if (callNode.isOnlyModifiesThisCall()\n953           && evaluatesToLocalValue(nameNode.getFirstChild())) {\n954         return false;\n955       }\n956 \n957       // Functions in the \"Math\" namespace have no side effects.\n958 \n959       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n960         if (nameNode.getFirstChild().getType() == Token.REGEXP\n961             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n962           return false;\n963         } else if (nameNode.getFirstChild().getType() == Token.STRING\n964             && STRING_REGEXP_METHODS.contains(\n965                 nameNode.getLastChild().getString())) {\n966           Node param = nameNode.getNext();\n967           if (param != null &&\n968               (param.getType() == Token.STRING\n969                   || param.getType() == Token.REGEXP))\n970           return false;\n971         }\n972       }\n973     }\n974 \n975     return true;\n976   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_62", "report_text": "> Column-indicating caret is sometimes not in error output\n> \n> For some reason, the caret doesn't always show up in the output when there are errors.\r\n> \r\n> When test.js looks like this:\r\n> \r\n> \r\n> >alert(1;\r\n> \r\n> \r\n> , the output is this:\r\n> \r\n> \r\n> >java -jar compiler.jar --js test.js\r\n> test.js:1: ERROR - Parse error. missing ) after argument list\r\n> \r\n> 1 error(s), 0 warning(s)\r\n> \r\n> \r\n> However, when test.js looks like this (notice the line break after the semicolon):\r\n> \r\n> \r\n> >alert(1;\r\n> >\r\n> \r\n> \r\n> , the output is this:\r\n> \r\n> \r\n> >java -jar compiler.jar --js test.js\r\n> test.js:1: ERROR - Parse error. missing ) after argument list\r\n> alert(1;\r\n>  ^\r\n> \r\n> 1 error(s), 0 warning(s)\r\n> \r\n> \r\n> That's the simplest reproduction of the problem that I could come up with, but I just encountered the problem in a file with ~100 LOC in it. This is the first time I believe I've run into the problem, but when it happens, my error parser fails and it becomes a pain to track down the raw output to find the actual problem.\r\n> \r\n> Tested against r1171, committed 6/10 08:06. The problem is present going back to at least r1000, so this isn't a new issue.", "test_name": "com.google.javascript.jscomp.LightweightMessageFormatterTest::testFormatErrorSpaceEndOfLine1", "test_method": "  public void testFormatErrorSpaceEndOfLine1() throws Exception {\n    JSError error = JSError.make(\"javascript/complex.js\",\n        1, 10, FOO_TYPE);\n    LightweightMessageFormatter formatter = formatter(\"assert (1;\");\n    assertEquals(\"javascript/complex.js:1: ERROR - error description here\\n\" +\n        \"assert (1;\\n\" +\n        \"          ^\\n\", formatter.formatError(error)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...ion here\n\tcom.google.javascript.jscomp.LightweightMessageFormatterTest.testFormatErrorSpaceEndOfLine1(LightweightMessageFormatterTest.java:91)", "buggy_method": "66 private String format(JSError error, boolean warning) {\n67     // extract source excerpt\n68     SourceExcerptProvider source = getSource();\n69     String sourceExcerpt = source == null ? null :\n70         excerpt.get(\n71             source, error.sourceName, error.lineNumber, excerptFormatter);\n72 \n73     // formatting the message\n74     StringBuilder b = new StringBuilder();\n75     if (error.sourceName != null) {\n76       b.append(error.sourceName);\n77       if (error.lineNumber > 0) {\n78         b.append(':');\n79         b.append(error.lineNumber);\n80       }\n81       b.append(\": \");\n82     }\n83 \n84     b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n85     b.append(\" - \");\n86 \n87     b.append(error.description);\n88     b.append('\\n');\n89     if (sourceExcerpt != null) {\n90       b.append(sourceExcerpt);\n91       b.append('\\n');\n92       int charno = error.getCharno();\n93 \n94       // padding equal to the excerpt and arrow at the end\n95       // charno == sourceExpert.length() means something is missing\n96       // at the end of the line\n97       if (excerpt.equals(LINE)\n98           && 0 <= charno && charno < sourceExcerpt.length()) {\n99         for (int i = 0; i < charno; i++) {\n100           char c = sourceExcerpt.charAt(i);\n101           if (Character.isWhitespace(c)) {\n102             b.append(c);\n103           } else {\n104             b.append(' ');\n105           }\n106         }\n107         b.append(\"^\\n\");\n108       }\n109     }\n110     return b.toString();\n111   }", "bm_classpath": "com.google.javascript.jscomp.LightweightMessageFormatter"}, {"bug_name": "Closure_64", "report_text": "> --language_in=ECMASCRIPT5_STRICT results in 1 'use strict' per input file\n> \n> **What steps will reproduce the problem?**\n> 1. Create a JS file called \"get\\_num.js\" with the contents \"var getNum = function() { return 5; };\"\r\n> 2. Create a JS file called \"alert.js\" with the contents \"alert(getNum());\"\r\n> 3. Compile the two files with the following command:\r\n> \r\n> java -jar compiler.jar --language\\_in=ECMASCRIPT5\\_STRICT --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --warning\\_level=VERBOSE --js get\\_num.js --js alert.js\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> I would expect the output to be:\r\n> \r\n> 'use strict';alert(5);\r\n> \r\n> or, if the compiler wants to be really clever, just \"alert(5)\" since this is already ES5 Strict compliant.\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Head on Mac OS X\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> https://groups.google.com/forum/#!topic/closure-compiler-discuss/TOLXpePju5Q", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testES5StrictUseStrictMultipleInputs", "test_method": "  public void testES5StrictUseStrictMultipleInputs() {\n    args.add(\"--language_in=ECMASCRIPT5_STRICT\");\n    Compiler compiler = compile(new String[] {\"var x = f.function\",\n        \"var y = f.function\", \"var z = f.function\"});\n    String outputSource = compiler.toSource();\n    assertEquals(outputSource.substring(13).indexOf(\"'use strict'\"), -1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<17> but was:<-1>\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testES5StrictUseStrictMultipleInputs(CommandLineRunnerTest.java:803)", "buggy_method": "1458 @Override\n1459   String toSource(Node n) {\n1460     initCompilerOptionsIfTesting();\n1461     return toSource(n, null);\n1462   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_65", "report_text": "> String escaping mishandles null byte\n> \n> **What steps will reproduce the problem?**\n> 1. Run:\r\n> var x = \"\\u00003\"; if (x.length < 2) { alert(\"fail\"); } else { alert(\"win\"); }\r\n> 2. Compile and run\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \"win\" is expected. \"fail\" is observed\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> r1167 on OS x 10.6\r\n> \r\n> **Please provide any additional information below.**\n> The problem is here: http://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/javascript/jscomp/CodeGenerator.java#1015\r\n> \r\n> Here's a patch that fixes it:\r\n> $ svn diff\r\n> Index: src/com/google/javascript/jscomp/CodeGenerator.java\r\n> ===================================================================\r\n> --- src/com/google/javascript/jscomp/CodeGenerator.java (revision 1167)\r\n> +++ src/com/google/javascript/jscomp/CodeGenerator.java (working copy)\r\n> @@ -1012,7 +1012,7 @@\r\n>  for (int i = 0; i < s.length(); i++) {\r\n>  char c = s.charAt(i);\r\n>  switch (c) {\r\n> - case '\\0': sb.append(\"\\\\0\"); break;\r\n> + case '\\0': sb.append(\"\\\\000\"); break;\r\n>  case '\\n': sb.append(\"\\\\n\"); break;\r\n>  case '\\r': sb.append(\"\\\\r\"); break;\r\n>  case '\\t': sb.append(\"\\\\t\"); break;\r\n> \r\n> You could also lookahead and output \"\\\\000\" only if the following char is 0-7 (octal valid) and otherwise output \"\\\\0\". Is 2 bytes worth the complexity?", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testZero", "test_method": "  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\000\\\"\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x=\"\\0[00]\"> but was:<var x=\"\\0[]\">\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:387)\n\tcom.google.javascript.jscomp.CodePrinterTest.testZero(CodePrinterTest.java:1231)", "buggy_method": "1005 static String strEscape(String s, char quote,\n1006                           String doublequoteEscape,\n1007                           String singlequoteEscape,\n1008                           String backslashEscape,\n1009                           CharsetEncoder outputCharsetEncoder) {\n1010     StringBuilder sb = new StringBuilder(s.length() + 2);\n1011     sb.append(quote);\n1012     for (int i = 0; i < s.length(); i++) {\n1013       char c = s.charAt(i);\n1014       switch (c) {\n1015         case '\\0': sb.append(\"\\\\0\"); break;\n1016         case '\\n': sb.append(\"\\\\n\"); break;\n1017         case '\\r': sb.append(\"\\\\r\"); break;\n1018         case '\\t': sb.append(\"\\\\t\"); break;\n1019         case '\\\\': sb.append(backslashEscape); break;\n1020         case '\\\"': sb.append(doublequoteEscape); break;\n1021         case '\\'': sb.append(singlequoteEscape); break;\n1022         case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n1023           if (i >= 2 &&\n1024               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n1025                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n1026             sb.append(\"\\\\>\");\n1027           } else {\n1028             sb.append(c);\n1029           }\n1030           break;\n1031         case '<':\n1032           // Break </script into <\\/script\n1033           final String END_SCRIPT = \"/script\";\n1034 \n1035           // Break <!-- into <\\!--\n1036           final String START_COMMENT = \"!--\";\n1037 \n1038           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n1039                               END_SCRIPT.length())) {\n1040             sb.append(\"<\\\\\");\n1041           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n1042                                      START_COMMENT.length())) {\n1043             sb.append(\"<\\\\\");\n1044           } else {\n1045             sb.append(c);\n1046           }\n1047           break;\n1048         default:\n1049           // If we're given an outputCharsetEncoder, then check if the\n1050           //  character can be represented in this character set.\n1051           if (outputCharsetEncoder != null) {\n1052             if (outputCharsetEncoder.canEncode(c)) {\n1053               sb.append(c);\n1054             } else {\n1055               // Unicode-escape the character.\n1056               appendHexJavaScriptRepresentation(sb, c);\n1057             }\n1058           } else {\n1059             // No charsetEncoder provided - pass straight latin characters\n1060             // through, and escape the rest.  Doing the explicit character\n1061             // check is measurably faster than using the CharsetEncoder.\n1062             if (c > 0x1f && c < 0x7f) {\n1063               sb.append(c);\n1064             } else {\n1065               // Other characters can be misinterpreted by some js parsers,\n1066               // or perhaps mangled by proxies along the way,\n1067               // so we play it safe and unicode escape them.\n1068               appendHexJavaScriptRepresentation(sb, c);\n1069             }\n1070           }\n1071       }\n1072     }\n1073     sb.append(quote);\n1074     return sb.toString();\n1075   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_66", "report_text": "> @enum does not type correctly\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. create an enum with any syntax\r\n> my example:\r\n> /\\*\\* \r\n> @type {Object}\r\n> \\*/\r\n> var NS = {};\r\n> \r\n> /\\*\\*\r\n> @enum {number}\r\n> \\*/\r\n> NS.keys = { \r\n>  a: 1, \r\n>  b: 2, \r\n>  c: 3\r\n> };\r\n> \r\n> /\\*\\*\r\n> @enum\r\n> \\*/\r\n> window['gKEYS'] = NS.keys;\r\n> \r\n> \r\n> 2. complie with --compilation\\_level ADVANCED\\_OPTIMIZATIONS --summary\\_detail\\_level 3 --warning\\_level VERBOSE\r\n> \r\n> 3. look at the % typed\r\n> \r\n> **What is the expected output? What do you see instead?**\n> it shouldn't count the enum as un-typed; it does...\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Version: 1043\r\n> Built on: 2011/05/02 19:47\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> i also tried to tersely coerce the type, eg:\r\n> /\\*\\* @type {number} \\*/ a: (/\\*\\* @type {number} \\*/(1)),\r\n> \r\n> which has no effect.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testGetTypedPercent5", "test_method": "  public void testGetTypedPercent5() throws Exception {\n    String js = \"/** @enum {number} */ keys = {A: 1,B: 2,C: 3};\";\n    assertEquals(100.0, getTypedPercent(js), 0.1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<100.0> but was:<62.5>\n\tcom.google.javascript.jscomp.TypeCheckTest.testGetTypedPercent5(TypeCheckTest.java:7784)", "buggy_method": "461 public void visit(NodeTraversal t, Node n, Node parent) {\n462     JSType childType;\n463     JSType leftType, rightType;\n464     Node left, right;\n465     // To be explicitly set to false if the node is not typeable.\n466     boolean typeable = true;\n467 \n468     switch (n.getType()) {\n469       case Token.NAME:\n470         typeable = visitName(t, n, parent);\n471         break;\n472 \n473       case Token.LP:\n474         // If this is under a FUNCTION node, it is a parameter list and can be\n475         // ignored here.\n476         if (parent.getType() != Token.FUNCTION) {\n477           ensureTyped(t, n, getJSType(n.getFirstChild()));\n478         } else {\n479           typeable = false;\n480         }\n481         break;\n482 \n483       case Token.COMMA:\n484         ensureTyped(t, n, getJSType(n.getLastChild()));\n485         break;\n486 \n487       case Token.TRUE:\n488       case Token.FALSE:\n489         ensureTyped(t, n, BOOLEAN_TYPE);\n490         break;\n491 \n492       case Token.THIS:\n493         ensureTyped(t, n, t.getScope().getTypeOfThis());\n494         break;\n495 \n496       case Token.REF_SPECIAL:\n497         ensureTyped(t, n);\n498         break;\n499 \n500       case Token.GET_REF:\n501         ensureTyped(t, n, getJSType(n.getFirstChild()));\n502         break;\n503 \n504       case Token.NULL:\n505         ensureTyped(t, n, NULL_TYPE);\n506         break;\n507 \n508       case Token.NUMBER:\n509         ensureTyped(t, n, NUMBER_TYPE);\n510         break;\n511 \n512       case Token.STRING:\n513         // Object literal keys are handled with OBJECTLIT\n514         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n515           ensureTyped(t, n, STRING_TYPE);\n516           // Object literal keys are not typeable\n517         }\n518         break;\n519 \n520       case Token.GET:\n521       case Token.SET:\n522         // Object literal keys are handled with OBJECTLIT\n523         break;\n524 \n525       case Token.ARRAYLIT:\n526         ensureTyped(t, n, ARRAY_TYPE);\n527         break;\n528 \n529       case Token.REGEXP:\n530         ensureTyped(t, n, REGEXP_TYPE);\n531         break;\n532 \n533       case Token.GETPROP:\n534         visitGetProp(t, n, parent);\n535         typeable = !(parent.getType() == Token.ASSIGN &&\n536                      parent.getFirstChild() == n);\n537         break;\n538 \n539       case Token.GETELEM:\n540         visitGetElem(t, n);\n541         // The type of GETELEM is always unknown, so no point counting that.\n542         // If that unknown leaks elsewhere (say by an assignment to another\n543         // variable), then it will be counted.\n544         typeable = false;\n545         break;\n546 \n547       case Token.VAR:\n548         visitVar(t, n);\n549         typeable = false;\n550         break;\n551 \n552       case Token.NEW:\n553         visitNew(t, n);\n554         typeable = true;\n555         break;\n556 \n557       case Token.CALL:\n558         visitCall(t, n);\n559         typeable = !NodeUtil.isExpressionNode(parent);\n560         break;\n561 \n562       case Token.RETURN:\n563         visitReturn(t, n);\n564         typeable = false;\n565         break;\n566 \n567       case Token.DEC:\n568       case Token.INC:\n569         left = n.getFirstChild();\n570         validator.expectNumber(\n571             t, left, getJSType(left), \"increment/decrement\");\n572         ensureTyped(t, n, NUMBER_TYPE);\n573         break;\n574 \n575       case Token.NOT:\n576         ensureTyped(t, n, BOOLEAN_TYPE);\n577         break;\n578 \n579       case Token.VOID:\n580         ensureTyped(t, n, VOID_TYPE);\n581         break;\n582 \n583       case Token.TYPEOF:\n584         ensureTyped(t, n, STRING_TYPE);\n585         break;\n586 \n587       case Token.BITNOT:\n588         childType = getJSType(n.getFirstChild());\n589         if (!childType.matchesInt32Context()) {\n590           report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n591               childType.toString());\n592         }\n593         ensureTyped(t, n, NUMBER_TYPE);\n594         break;\n595 \n596       case Token.POS:\n597       case Token.NEG:\n598         left = n.getFirstChild();\n599         validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n600         ensureTyped(t, n, NUMBER_TYPE);\n601         break;\n602 \n603       case Token.EQ:\n604       case Token.NE: {\n605         leftType = getJSType(n.getFirstChild());\n606         rightType = getJSType(n.getLastChild());\n607 \n608         JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n609         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n610         TernaryValue result =\n611             leftTypeRestricted.testForEquality(rightTypeRestricted);\n612         if (result != TernaryValue.UNKNOWN) {\n613           if (n.getType() == Token.NE) {\n614             result = result.not();\n615           }\n616           report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n617               rightType.toString(), result.toString());\n618         }\n619         ensureTyped(t, n, BOOLEAN_TYPE);\n620         break;\n621       }\n622 \n623       case Token.SHEQ:\n624       case Token.SHNE: {\n625         leftType = getJSType(n.getFirstChild());\n626         rightType = getJSType(n.getLastChild());\n627 \n628         JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n629         JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n630         if (!leftTypeRestricted.canTestForShallowEqualityWith(\n631                 rightTypeRestricted)) {\n632           report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n633               rightType.toString());\n634         }\n635         ensureTyped(t, n, BOOLEAN_TYPE);\n636         break;\n637       }\n638 \n639       case Token.LT:\n640       case Token.LE:\n641       case Token.GT:\n642       case Token.GE:\n643         leftType = getJSType(n.getFirstChild());\n644         rightType = getJSType(n.getLastChild());\n645         if (rightType.isNumber()) {\n646           validator.expectNumber(\n647               t, n, leftType, \"left side of numeric comparison\");\n648         } else if (leftType.isNumber()) {\n649           validator.expectNumber(\n650               t, n, rightType, \"right side of numeric comparison\");\n651         } else if (leftType.matchesNumberContext() &&\n652                    rightType.matchesNumberContext()) {\n653           // OK.\n654         } else {\n655           // Whether the comparison is numeric will be determined at runtime\n656           // each time the expression is evaluated. Regardless, both operands\n657           // should match a string context.\n658           String message = \"left side of comparison\";\n659           validator.expectString(t, n, leftType, message);\n660           validator.expectNotNullOrUndefined(\n661               t, n, leftType, message, getNativeType(STRING_TYPE));\n662           message = \"right side of comparison\";\n663           validator.expectString(t, n, rightType, message);\n664           validator.expectNotNullOrUndefined(\n665               t, n, rightType, message, getNativeType(STRING_TYPE));\n666         }\n667         ensureTyped(t, n, BOOLEAN_TYPE);\n668         break;\n669 \n670       case Token.IN:\n671         left = n.getFirstChild();\n672         right = n.getLastChild();\n673         leftType = getJSType(left);\n674         rightType = getJSType(right);\n675         validator.expectObject(t, n, rightType, \"'in' requires an object\");\n676         validator.expectString(t, left, leftType, \"left side of 'in'\");\n677         ensureTyped(t, n, BOOLEAN_TYPE);\n678         break;\n679 \n680       case Token.INSTANCEOF:\n681         left = n.getFirstChild();\n682         right = n.getLastChild();\n683         leftType = getJSType(left);\n684         rightType = getJSType(right).restrictByNotNullOrUndefined();\n685 \n686         validator.expectAnyObject(\n687             t, left, leftType, \"deterministic instanceof yields false\");\n688         validator.expectActualObject(\n689             t, right, rightType, \"instanceof requires an object\");\n690         ensureTyped(t, n, BOOLEAN_TYPE);\n691         break;\n692 \n693       case Token.ASSIGN:\n694         visitAssign(t, n);\n695         typeable = false;\n696         break;\n697 \n698       case Token.ASSIGN_LSH:\n699       case Token.ASSIGN_RSH:\n700       case Token.ASSIGN_URSH:\n701       case Token.ASSIGN_DIV:\n702       case Token.ASSIGN_MOD:\n703       case Token.ASSIGN_BITOR:\n704       case Token.ASSIGN_BITXOR:\n705       case Token.ASSIGN_BITAND:\n706       case Token.ASSIGN_SUB:\n707       case Token.ASSIGN_ADD:\n708       case Token.ASSIGN_MUL:\n709       case Token.LSH:\n710       case Token.RSH:\n711       case Token.URSH:\n712       case Token.DIV:\n713       case Token.MOD:\n714       case Token.BITOR:\n715       case Token.BITXOR:\n716       case Token.BITAND:\n717       case Token.SUB:\n718       case Token.ADD:\n719       case Token.MUL:\n720         visitBinaryOperator(n.getType(), t, n);\n721         break;\n722 \n723       case Token.DELPROP:\n724         if (!isReference(n.getFirstChild())) {\n725           report(t, n, BAD_DELETE);\n726         }\n727         ensureTyped(t, n, BOOLEAN_TYPE);\n728         break;\n729 \n730       case Token.CASE:\n731         JSType switchType = getJSType(parent.getFirstChild());\n732         JSType caseType = getJSType(n.getFirstChild());\n733         validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n734         typeable = false;\n735         break;\n736 \n737       case Token.WITH: {\n738         Node child = n.getFirstChild();\n739         childType = getJSType(child);\n740         validator.expectObject(\n741             t, child, childType, \"with requires an object\");\n742         typeable = false;\n743         break;\n744       }\n745 \n746       case Token.FUNCTION:\n747         visitFunction(t, n);\n748         break;\n749 \n750       // These nodes have no interesting type behavior.\n751       case Token.LABEL:\n752       case Token.LABEL_NAME:\n753       case Token.SWITCH:\n754       case Token.BREAK:\n755       case Token.CATCH:\n756       case Token.TRY:\n757       case Token.SCRIPT:\n758       case Token.EXPR_RESULT:\n759       case Token.BLOCK:\n760       case Token.EMPTY:\n761       case Token.DEFAULT:\n762       case Token.CONTINUE:\n763       case Token.DEBUGGER:\n764       case Token.THROW:\n765         typeable = false;\n766         break;\n767 \n768       // These nodes require data flow analysis.\n769       case Token.DO:\n770       case Token.FOR:\n771       case Token.IF:\n772       case Token.WHILE:\n773         typeable = false;\n774         break;\n775 \n776       // These nodes are typed during the type inference.\n777       case Token.AND:\n778       case Token.HOOK:\n779       case Token.OBJECTLIT:\n780       case Token.OR:\n781         if (n.getJSType() != null) { // If we didn't run type inference.\n782           ensureTyped(t, n);\n783         } else {\n784           // If this is an enum, then give that type to the objectlit as well.\n785           if ((n.getType() == Token.OBJECTLIT)\n786               && (parent.getJSType() instanceof EnumType)) {\n787             ensureTyped(t, n, parent.getJSType());\n788           } else {\n789             ensureTyped(t, n);\n790           }\n791         }\n792         if (n.getType() == Token.OBJECTLIT) {\n793           for (Node key : n.children()) {\n794             visitObjLitKey(t, key, n);\n795           }\n796         }\n797         break;\n798 \n799       default:\n800         report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n801         ensureTyped(t, n);\n802         break;\n803     }\n804 \n805     // Don't count externs since the user's code may not even use that part.\n806     typeable = typeable && !inExterns;\n807 \n808     if (typeable) {\n809       doPercentTypedAccounting(t, n);\n810     }\n811 \n812     checkNoTypeCheckSection(n, false);\n813   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_67", "report_text": "> Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function\n> \n> If we provide the below code to advanced:\r\n> \r\n> \r\n> function A() {\r\n> this.\\_x = 1;\r\n> }\r\n> \r\n> A.prototype['func1'] = // done to save public reference to func1\r\n> A.prototype.func1 = function() {\r\n>  this.\\_x = 2;\r\n>  this.func2();\r\n> }\r\n> \r\n> A.prototype.func2 = function() {\r\n>  this.\\_x = 3;\r\n>  this.func3();\r\n> }\r\n> \r\n> window['A'] = A;\r\n> \r\n> \r\n> We get the output:\r\n> \r\n> \r\n> function a() {\r\n>  this.a = 1\r\n> }\r\n> a.prototype.func1 = a.prototype.b = function() {\r\n>  this.a = 2;\r\n>  this.c() // Problem!\r\n> };\r\n> window.A = a;\r\n> \r\n> \r\n> So the compiler emits no errors, and renames 'func2' to 'c' but ends up throwing away the definition of that function!\r\n> \r\n> The problem arises when I use:\r\n> \r\n> A.prototype['func1'] = // done to save public reference to func1\r\n> A.prototype.func1 = function() {\r\n> ...\r\n> }\r\n> \r\n> The ['func1'] line is apparently enough to save the reference correctly, but also has the side effect of causing the function innards to do the wrong thing.\r\n> \r\n> I can of course instead write it as:\r\n> \r\n> A.prototype['func1'] = A.prototype.func1;\r\n> A.prototype.func1 = function() {\r\n>  this.\\_x = 2;\r\n>  this.func2();\r\n> }\r\n> \r\n> In which case Advanced will compile correctly and the results will also be valid.\r\n> \r\n> function a() {\r\n>  this.a = 1\r\n> }\r\n> a.prototype.func1 = a.prototype.b;\r\n> a.prototype.b = function() {\r\n>  this.a = 2;\r\n>  this.a = 3 // func2, correctly minified\r\n> };\r\n> window.A = a;\r\n> \r\n> \r\n> For now I can just use the expected way of declaring that func1 export, but since the compiler returns with no errors or warnings and creates a function with no definition, it seems worth reporting.", "test_name": "com.google.javascript.jscomp.RemoveUnusedPrototypePropertiesTest::testAliasing7", "test_method": "  public void testAliasing7() {\n    // An exported alias must preserved any referenced values in the\n    // referenced function.\n    testSame(\"function e(){}\" +\n           \"e.prototype['alias1'] = e.prototype.method1 = \" +\n               \"function(){this.method2()};\" +\n           \"e.prototype.method2 = function(){};\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:862)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:537)\n\tcom.google.javascript.jscomp.RemoveUnusedPrototypePropertiesTest.testAliasing7(RemoveUnusedPrototypePropertiesTest.java:189)", "buggy_method": "314 private boolean isPrototypePropertyAssign(Node assign) {\n315       Node n = assign.getFirstChild();\n316       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n317           && n.getType() == Token.GETPROP\n318           ) {\n319         // We want to exclude the assignment itself from the usage list\n320         boolean isChainedProperty =\n321             n.getFirstChild().getType() == Token.GETPROP;\n322 \n323         if (isChainedProperty) {\n324           Node child = n.getFirstChild().getFirstChild().getNext();\n325 \n326           if (child.getType() == Token.STRING &&\n327               child.getString().equals(\"prototype\")) {\n328             return true;\n329           }\n330         }\n331       }\n332 \n333       return false;\n334     }", "bm_classpath": "com.google.javascript.jscomp.AnalyzePrototypeProperties$ProcessProperties"}, {"bug_name": "Closure_68", "report_text": "> Cryptic error message on invalid \"@type function\" annotation\n> \n> **What steps will reproduce the problem?**\n> 1. test.js:\r\n> \r\n>  /\\*\\*\r\n>  \\* @type function\r\n>  \\*/\r\n>  var callback;\r\n> \r\n> 2. java -jar compiler.jar --js test.js \r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Warning reported is:\r\n> \r\n> test.js:3: WARNING - Parse error. Unexpected end of file\r\n>  \\*/\r\n>  ^\r\n> \r\n> Expected to see the actual warning (e.g., \"expected '('\", for the \\*previous\\* line)\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> compiler-20110502\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Simply adding \"()\" to it (\"@type function()\") removes the warning, but it would be much more effective if it could communicate that properly.", "test_name": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testIssue477", "test_method": "  public void testIssue477() throws Exception {\n    parse(\"@type function */\",\n        \"Bad type annotation. missing opening (\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: extra warning: Unexpected end of file\n\tcom.google.javascript.jscomp.testing.TestErrorReporter.warning(TestErrorReporter.java:62)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser.addParserWarning(JsDocInfoParser.java:65)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:887)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2690)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2672)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2667)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.testIssue477(JsDocInfoParserTest.java:509)", "buggy_method": "169 boolean parse() {\n170     int lineno;\n171     int charno;\n172 \n173     // JSTypes are represented as Rhino AST nodes, and then resolved later.\n174     JSTypeExpression type;\n175 \n176     state = State.SEARCHING_ANNOTATION;\n177     skipEOLs();\n178 \n179     JsDocToken token = next();\n180 \n181     List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n182 \n183     // Always record that we have a comment.\n184     if (jsdocBuilder.shouldParseDocumentation()) {\n185       ExtractionInfo blockInfo = extractBlockComment(token);\n186       token = blockInfo.token;\n187       if (!blockInfo.string.isEmpty()) {\n188         jsdocBuilder.recordBlockDescription(blockInfo.string);\n189       }\n190     } else {\n191       if (token != JsDocToken.ANNOTATION &&\n192           token != JsDocToken.EOC) {\n193         // Mark that there was a description, but don't bother marking\n194         // what it was.\n195         jsdocBuilder.recordBlockDescription(\"\");\n196       }\n197     }\n198 \n199     // Parse the actual JsDoc.\n200     retry: for (;;) {\n201       switch (token) {\n202         case ANNOTATION:\n203           if (state == State.SEARCHING_ANNOTATION) {\n204             state = State.SEARCHING_NEWLINE;\n205             lineno = stream.getLineno();\n206             charno = stream.getCharno();\n207 \n208             String annotationName = stream.getString();\n209             Annotation annotation = annotationNames.get(annotationName);\n210             if (annotation == null) {\n211               parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n212                   stream.getLineno(), stream.getCharno());\n213             } else {\n214               // Mark the beginning of the annotation.\n215               jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n216 \n217               switch (annotation) {\n218                 case AUTHOR:\n219                   if (jsdocBuilder.shouldParseDocumentation()) {\n220                     ExtractionInfo authorInfo = extractSingleLineBlock();\n221                     String author = authorInfo.string;\n222 \n223                     if (author.length() == 0) {\n224                       parser.addParserWarning(\"msg.jsdoc.authormissing\",\n225                           stream.getLineno(), stream.getCharno());\n226                     } else {\n227                       jsdocBuilder.addAuthor(author);\n228                     }\n229                     token = authorInfo.token;\n230                   } else {\n231                     token = eatTokensUntilEOL(token);\n232                   }\n233                   continue retry;\n234 \n235                 case CONSTANT:\n236                   if (!jsdocBuilder.recordConstancy()) {\n237                     parser.addParserWarning(\"msg.jsdoc.const\",\n238                         stream.getLineno(), stream.getCharno());\n239                   }\n240                   token = eatTokensUntilEOL();\n241                   continue retry;\n242 \n243                 case CONSTRUCTOR:\n244                   if (!jsdocBuilder.recordConstructor()) {\n245                     if (jsdocBuilder.isInterfaceRecorded()) {\n246                       parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n247                           stream.getLineno(), stream.getCharno());\n248                     } else {\n249                       parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n250                           stream.getLineno(), stream.getCharno());\n251                     }\n252                   }\n253                   token = eatTokensUntilEOL();\n254                   continue retry;\n255 \n256                 case DEPRECATED:\n257                   if (!jsdocBuilder.recordDeprecated()) {\n258                     parser.addParserWarning(\"msg.jsdoc.deprecated\",\n259                         stream.getLineno(), stream.getCharno());\n260                   }\n261 \n262                   // Find the reason/description, if any.\n263                   ExtractionInfo reasonInfo =\n264                       extractMultilineTextualBlock(token);\n265 \n266                   String reason = reasonInfo.string;\n267 \n268                   if (reason.length() > 0) {\n269                     jsdocBuilder.recordDeprecationReason(reason);\n270                   }\n271 \n272                   token = reasonInfo.token;\n273                   continue retry;\n274 \n275                 case INTERFACE:\n276                   if (!jsdocBuilder.recordInterface()) {\n277                     if (jsdocBuilder.isConstructorRecorded()) {\n278                       parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n279                           stream.getLineno(), stream.getCharno());\n280                     } else {\n281                       parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n282                           stream.getLineno(), stream.getCharno());\n283                     }\n284                   }\n285                   token = eatTokensUntilEOL();\n286                   continue retry;\n287 \n288                 case DESC:\n289                   if (jsdocBuilder.isDescriptionRecorded()) {\n290                     parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n291                         stream.getLineno(), stream.getCharno());\n292                     token = eatTokensUntilEOL();\n293                     continue retry;\n294                   } else {\n295                     ExtractionInfo descriptionInfo =\n296                         extractMultilineTextualBlock(token);\n297 \n298                     String description = descriptionInfo.string;\n299 \n300                     jsdocBuilder.recordDescription(description);\n301                     token = descriptionInfo.token;\n302                     continue retry;\n303                   }\n304 \n305                 case FILE_OVERVIEW:\n306                   String fileOverview = \"\";\n307                   if (jsdocBuilder.shouldParseDocumentation()) {\n308                     ExtractionInfo fileOverviewInfo =\n309                         extractMultilineTextualBlock(token,\n310                             WhitespaceOption.TRIM);\n311 \n312                     fileOverview = fileOverviewInfo.string;\n313 \n314                     token = fileOverviewInfo.token;\n315                   } else {\n316                     token = eatTokensUntilEOL(token);\n317                   }\n318 \n319                   if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n320                       fileOverviewJSDocInfo != null) {\n321                     parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n322                         stream.getLineno(), stream.getCharno());\n323                   }\n324                   continue retry;\n325 \n326                 case LICENSE:\n327                 case PRESERVE:\n328                   ExtractionInfo preserveInfo =\n329                       extractMultilineTextualBlock(token,\n330                                                    WhitespaceOption.PRESERVE);\n331 \n332                   String preserve = preserveInfo.string;\n333 \n334                   if (preserve.length() > 0) {\n335                     if (fileLevelJsDocBuilder != null) {\n336                       fileLevelJsDocBuilder.append(preserve);\n337                     }\n338                   }\n339 \n340                   token = preserveInfo.token;\n341                   continue retry;\n342 \n343                 case ENUM:\n344                   token = next();\n345                   lineno = stream.getLineno();\n346                   charno = stream.getCharno();\n347 \n348                   type = null;\n349                   if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n350                     type = createJSTypeExpression(\n351                         parseAndRecordTypeNode(token));\n352                   }\n353 \n354                   if (type == null) {\n355                     type = createJSTypeExpression(newStringNode(\"number\"));\n356                   }\n357                   if (!jsdocBuilder.recordEnumParameterType(type)) {\n358                     parser.addTypeWarning(\n359                         \"msg.jsdoc.incompat.type\", lineno, charno);\n360                   }\n361                   token = eatTokensUntilEOL(token);\n362                   continue retry;\n363 \n364                 case EXPORT:\n365                   if (!jsdocBuilder.recordExport()) {\n366                     parser.addParserWarning(\"msg.jsdoc.export\",\n367                         stream.getLineno(), stream.getCharno());\n368                   }\n369                   token = eatTokensUntilEOL();\n370                   continue retry;\n371 \n372                 case EXTERNS:\n373                   if (!jsdocBuilder.recordExterns()) {\n374                     parser.addParserWarning(\"msg.jsdoc.externs\",\n375                         stream.getLineno(), stream.getCharno());\n376                   }\n377                   token = eatTokensUntilEOL();\n378                   continue retry;\n379 \n380                 case JAVA_DISPATCH:\n381                   if (!jsdocBuilder.recordJavaDispatch()) {\n382                     parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n383                         stream.getLineno(), stream.getCharno());\n384                   }\n385                   token = eatTokensUntilEOL();\n386                   continue retry;\n387 \n388                 case EXTENDS:\n389                 case IMPLEMENTS:\n390                   skipEOLs();\n391                   token = next();\n392                   lineno = stream.getLineno();\n393                   charno = stream.getCharno();\n394                   boolean matchingRc = false;\n395 \n396                   if (token == JsDocToken.LC) {\n397                     token = next();\n398                     matchingRc = true;\n399                   }\n400 \n401                   if (token == JsDocToken.STRING) {\n402                     Node typeNode = parseAndRecordTypeNameNode(\n403                         token, lineno, charno, matchingRc);\n404 \n405                     lineno = stream.getLineno();\n406                     charno = stream.getCharno();\n407 \n408                     typeNode = wrapNode(Token.BANG, typeNode);\n409                     if (typeNode != null && !matchingRc) {\n410                       typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n411                     }\n412                     type = createJSTypeExpression(typeNode);\n413 \n414                     if (annotation == Annotation.EXTENDS) {\n415                       // record the extended type, check later\n416                       extendedTypes.add(new ExtendedTypeInfo(\n417                           type, stream.getLineno(), stream.getCharno()));\n418                     } else {\n419                       Preconditions.checkState(\n420                           annotation == Annotation.IMPLEMENTS);\n421                       if (!jsdocBuilder.recordImplementedInterface(type)) {\n422                         parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n423                             lineno, charno);\n424                       }\n425                     }\n426                     token = next();\n427                     if (matchingRc) {\n428                       if (token != JsDocToken.RC) {\n429                         parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n430                             stream.getLineno(), stream.getCharno());\n431                       }\n432                     } else if (token != JsDocToken.EOL &&\n433                         token != JsDocToken.EOF && token != JsDocToken.EOC) {\n434                       parser.addTypeWarning(\"msg.end.annotation.expected\",\n435                           stream.getLineno(), stream.getCharno());\n436                     }\n437                   } else {\n438                     parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n439                   }\n440                   token = eatTokensUntilEOL(token);\n441                   continue retry;\n442 \n443                 case HIDDEN:\n444                   if (!jsdocBuilder.recordHiddenness()) {\n445                     parser.addParserWarning(\"msg.jsdoc.hidden\",\n446                         stream.getLineno(), stream.getCharno());\n447                   }\n448                   token = eatTokensUntilEOL();\n449                   continue retry;\n450 \n451                 case LENDS:\n452                   skipEOLs();\n453 \n454                   matchingRc = false;\n455                   if (match(JsDocToken.LC)) {\n456                     token = next();\n457                     matchingRc = true;\n458                   }\n459 \n460                   if (match(JsDocToken.STRING)) {\n461                     token = next();\n462                     if (!jsdocBuilder.recordLends(stream.getString())) {\n463                       parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n464                           stream.getLineno(), stream.getCharno());\n465                     }\n466                   } else {\n467                     parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n468                         stream.getLineno(), stream.getCharno());\n469                   }\n470 \n471                   if (matchingRc && !match(JsDocToken.RC)) {\n472                     parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n473                         stream.getLineno(), stream.getCharno());\n474                   }\n475                   token = eatTokensUntilEOL();\n476                   continue retry;\n477 \n478                 case MEANING:\n479                   ExtractionInfo meaningInfo =\n480                       extractMultilineTextualBlock(token);\n481                   String meaning = meaningInfo.string;\n482                   token = meaningInfo.token;\n483                   if (!jsdocBuilder.recordMeaning(meaning)) {\n484                     parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n485                         stream.getLineno(), stream.getCharno());\n486                   }\n487                   continue retry;\n488 \n489                 case NO_ALIAS:\n490                   if (!jsdocBuilder.recordNoAlias()) {\n491                     parser.addParserWarning(\"msg.jsdoc.noalias\",\n492                         stream.getLineno(), stream.getCharno());\n493                   }\n494                   token = eatTokensUntilEOL();\n495                   continue retry;\n496 \n497                 case NO_COMPILE:\n498                   if (!jsdocBuilder.recordNoCompile()) {\n499                     parser.addParserWarning(\"msg.jsdoc.nocompile\",\n500                         stream.getLineno(), stream.getCharno());\n501                   }\n502                   token = eatTokensUntilEOL();\n503                   continue retry;\n504 \n505                 case NO_TYPE_CHECK:\n506                   if (!jsdocBuilder.recordNoTypeCheck()) {\n507                     parser.addParserWarning(\"msg.jsdoc.nocheck\",\n508                         stream.getLineno(), stream.getCharno());\n509                   }\n510                   token = eatTokensUntilEOL();\n511                   continue retry;\n512 \n513                 case NOT_IMPLEMENTED:\n514                   token = eatTokensUntilEOL();\n515                   continue retry;\n516 \n517                 case INHERIT_DOC:\n518                 case OVERRIDE:\n519                   if (!jsdocBuilder.recordOverride()) {\n520                     parser.addTypeWarning(\"msg.jsdoc.override\",\n521                         stream.getLineno(), stream.getCharno());\n522                   }\n523                   token = eatTokensUntilEOL();\n524                   continue retry;\n525 \n526                 case THROWS:\n527                   skipEOLs();\n528                   token = next();\n529                   lineno = stream.getLineno();\n530                   charno = stream.getCharno();\n531                   type = null;\n532 \n533                   if (token == JsDocToken.LC) {\n534                     type = createJSTypeExpression(\n535                         parseAndRecordTypeNode(token));\n536 \n537                     if (type == null) {\n538                       // parsing error reported during recursive descent\n539                       // recovering parsing\n540                       token = eatTokensUntilEOL();\n541                       continue retry;\n542                     }\n543                   }\n544 \n545                   // *Update* the token to that after the type annotation.\n546                   token = current();\n547 \n548                   // Save the throw type.\n549                   jsdocBuilder.recordThrowType(type);\n550 \n551                   // Find the throw's description (if applicable).\n552                   if (jsdocBuilder.shouldParseDocumentation()) {\n553                     ExtractionInfo descriptionInfo =\n554                         extractMultilineTextualBlock(token);\n555 \n556                     String description = descriptionInfo.string;\n557 \n558                     if (description.length() > 0) {\n559                       jsdocBuilder.recordThrowDescription(type, description);\n560                     }\n561 \n562                     token = descriptionInfo.token;\n563                   } else {\n564                     token = eatTokensUntilEOL(token);\n565                   }\n566                   continue retry;\n567 \n568                 case PARAM:\n569                   skipEOLs();\n570                   token = next();\n571                   lineno = stream.getLineno();\n572                   charno = stream.getCharno();\n573                   type = null;\n574 \n575                   if (token == JsDocToken.LC) {\n576                     type = createJSTypeExpression(\n577                         parseAndRecordParamTypeNode(token));\n578 \n579                     if (type == null) {\n580                       // parsing error reported during recursive descent\n581                       // recovering parsing\n582                       token = eatTokensUntilEOL();\n583                       continue retry;\n584                     }\n585                     skipEOLs();\n586                     token = next();\n587                     lineno = stream.getLineno();\n588                     charno = stream.getCharno();\n589                   }\n590 \n591                   String name = null;\n592                   boolean isBracketedParam = JsDocToken.LB == token;\n593                   if (isBracketedParam) {\n594                     token = next();\n595                   }\n596 \n597                   if (JsDocToken.STRING != token) {\n598                     parser.addTypeWarning(\"msg.missing.variable.name\",\n599                         lineno, charno);\n600                   } else {\n601                     name = stream.getString();\n602 \n603                     if (isBracketedParam) {\n604                       token = next();\n605 \n606                       // Throw out JsDocToolkit's \"default\" parameter\n607                       // annotation.  It makes no sense under our type\n608                       // system.\n609                       if (JsDocToken.EQUALS == token) {\n610                         token = next();\n611                         if (JsDocToken.STRING == token) {\n612                           token = next();\n613                         }\n614                       }\n615 \n616                       if (JsDocToken.RB != token) {\n617                         reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n618                       } else if (type != null) {\n619                         // Make the type expression optional, if it isn't\n620                         // already.\n621                         type = JSTypeExpression.makeOptionalArg(type);\n622                       }\n623                     }\n624 \n625                     // If the param name has a DOT in it, just throw it out\n626                     // quietly. We do not handle the JsDocToolkit method\n627                     // for handling properties of params.\n628                     if (name.indexOf('.') > -1) {\n629                       name = null;\n630                     } else if (!jsdocBuilder.recordParameter(name, type)) {\n631                       if (jsdocBuilder.hasParameter(name)) {\n632                         parser.addTypeWarning(\"msg.dup.variable.name\", name,\n633                             lineno, charno);\n634                       } else {\n635                         parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n636                             lineno, charno);\n637                       }\n638                     }\n639                   }\n640 \n641                   if (name == null) {\n642                     token = eatTokensUntilEOL(token);\n643                     continue retry;\n644                   }\n645 \n646                   jsdocBuilder.markName(name, lineno, charno);\n647 \n648                   // Find the parameter's description (if applicable).\n649                   if (jsdocBuilder.shouldParseDocumentation()) {\n650                     ExtractionInfo paramDescriptionInfo =\n651                         extractMultilineTextualBlock(token);\n652 \n653                     String paramDescription = paramDescriptionInfo.string;\n654 \n655                     if (paramDescription.length() > 0) {\n656                       jsdocBuilder.recordParameterDescription(name,\n657                           paramDescription);\n658                     }\n659 \n660                     token = paramDescriptionInfo.token;\n661                   } else {\n662                     token = eatTokensUntilEOL(token);\n663                   }\n664                   continue retry;\n665 \n666                 case PRESERVE_TRY:\n667                   if (!jsdocBuilder.recordPreserveTry()) {\n668                     parser.addParserWarning(\"msg.jsdoc.preservertry\",\n669                         stream.getLineno(), stream.getCharno());\n670                   }\n671                   token = eatTokensUntilEOL();\n672                   continue retry;\n673 \n674                 case PRIVATE:\n675                   if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n676                     parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n677                         stream.getLineno(), stream.getCharno());\n678                   }\n679                   token = eatTokensUntilEOL();\n680                   continue retry;\n681 \n682                 case PROTECTED:\n683                   if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n684                     parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n685                         stream.getLineno(), stream.getCharno());\n686                   }\n687                   token = eatTokensUntilEOL();\n688                   continue retry;\n689 \n690                 case PUBLIC:\n691                   if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n692                     parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n693                         stream.getLineno(), stream.getCharno());\n694                   }\n695                   token = eatTokensUntilEOL();\n696                   continue retry;\n697 \n698                 case NO_SHADOW:\n699                   if (!jsdocBuilder.recordNoShadow()) {\n700                     parser.addParserWarning(\"msg.jsdoc.noshadow\",\n701                         stream.getLineno(), stream.getCharno());\n702                   }\n703                   token = eatTokensUntilEOL();\n704                   continue retry;\n705 \n706                 case NO_SIDE_EFFECTS:\n707                   if (!jsdocBuilder.recordNoSideEffects()) {\n708                     parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n709                         stream.getLineno(), stream.getCharno());\n710                   }\n711                   token = eatTokensUntilEOL();\n712                   continue retry;\n713 \n714                 case MODIFIES:\n715                   token = parseModifiesTag(next());\n716                   continue retry;\n717 \n718                 case IMPLICIT_CAST:\n719                   if (!jsdocBuilder.recordImplicitCast()) {\n720                     parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n721                         stream.getLineno(), stream.getCharno());\n722                   }\n723                   token = eatTokensUntilEOL();\n724                   continue retry;\n725 \n726                 case SEE:\n727                   if (jsdocBuilder.shouldParseDocumentation()) {\n728                     ExtractionInfo referenceInfo = extractSingleLineBlock();\n729                     String reference = referenceInfo.string;\n730 \n731                     if (reference.length() == 0) {\n732                       parser.addParserWarning(\"msg.jsdoc.seemissing\",\n733                           stream.getLineno(), stream.getCharno());\n734                     } else {\n735                       jsdocBuilder.addReference(reference);\n736                     }\n737 \n738                     token = referenceInfo.token;\n739                   } else {\n740                     token = eatTokensUntilEOL(token);\n741                   }\n742                   continue retry;\n743 \n744                 case SUPPRESS:\n745                   token = parseSuppressTag(next());\n746                   continue retry;\n747 \n748                 case TEMPLATE:\n749                   ExtractionInfo templateInfo = extractSingleLineBlock();\n750                   String templateTypeName = templateInfo.string;\n751 \n752                   if (templateTypeName.length() == 0) {\n753                     parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n754                           stream.getLineno(), stream.getCharno());\n755                   } else if (!jsdocBuilder.recordTemplateTypeName(\n756                       templateTypeName)) {\n757                     parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n758                         stream.getLineno(), stream.getCharno());\n759                   }\n760 \n761                   token = templateInfo.token;\n762                   continue retry;\n763 \n764                 case VERSION:\n765                   ExtractionInfo versionInfo = extractSingleLineBlock();\n766                   String version = versionInfo.string;\n767 \n768                   if (version.length() == 0) {\n769                     parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n770                           stream.getLineno(), stream.getCharno());\n771                   } else {\n772                     if (!jsdocBuilder.recordVersion(version)) {\n773                        parser.addParserWarning(\"msg.jsdoc.extraversion\",\n774                           stream.getLineno(), stream.getCharno());\n775                     }\n776                   }\n777 \n778                   token = versionInfo.token;\n779                   continue retry;\n780 \n781                 case DEFINE:\n782                 case RETURN:\n783                 case THIS:\n784                 case TYPE:\n785                 case TYPEDEF:\n786                   lineno = stream.getLineno();\n787                   charno = stream.getCharno();\n788 \n789                   Node typeNode = null;\n790                   if (!lookAheadForTypeAnnotation() &&\n791                       annotation == Annotation.RETURN) {\n792                     // If RETURN doesn't have a type annotation, record\n793                     // it as the unknown type.\n794                     typeNode = newNode(Token.QMARK);\n795                   } else {\n796                     skipEOLs();\n797                     token = next();\n798                     typeNode = parseAndRecordTypeNode(token, lineno, charno);\n799                   }\n800 \n801                   if (annotation == Annotation.THIS) {\n802                     typeNode = wrapNode(Token.BANG, typeNode);\n803                     if (typeNode != null && token != JsDocToken.LC) {\n804                       typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n805                     }\n806                   }\n807                   type = createJSTypeExpression(typeNode);\n808 \n809                   if (type == null) {\n810                     // error reported during recursive descent\n811                     // recovering parsing\n812                   } else {\n813                     switch (annotation) {\n814                       case DEFINE:\n815                         if (!jsdocBuilder.recordDefineType(type)) {\n816                           parser.addParserWarning(\"msg.jsdoc.define\",\n817                               lineno, charno);\n818                         }\n819                         break;\n820 \n821                       case RETURN:\n822                         if (!jsdocBuilder.recordReturnType(type)) {\n823                           parser.addTypeWarning(\n824                               \"msg.jsdoc.incompat.type\", lineno, charno);\n825                           break;\n826                         }\n827 \n828                         // Find the return's description (if applicable).\n829                         if (jsdocBuilder.shouldParseDocumentation()) {\n830                           ExtractionInfo returnDescriptionInfo =\n831                               extractMultilineTextualBlock(token);\n832 \n833                           String returnDescription =\n834                               returnDescriptionInfo.string;\n835 \n836                           if (returnDescription.length() > 0) {\n837                             jsdocBuilder.recordReturnDescription(\n838                                 returnDescription);\n839                           }\n840 \n841                           token = returnDescriptionInfo.token;\n842                         } else {\n843                           token = eatTokensUntilEOL(token);\n844                         }\n845                         continue retry;\n846 \n847                       case THIS:\n848                         if (!jsdocBuilder.recordThisType(type)) {\n849                           parser.addTypeWarning(\n850                               \"msg.jsdoc.incompat.type\", lineno, charno);\n851                         }\n852                         break;\n853 \n854                       case TYPE:\n855                         if (!jsdocBuilder.recordType(type)) {\n856                           parser.addTypeWarning(\n857                               \"msg.jsdoc.incompat.type\", lineno, charno);\n858                         }\n859                         break;\n860 \n861                       case TYPEDEF:\n862                         if (!jsdocBuilder.recordTypedef(type)) {\n863                           parser.addTypeWarning(\n864                               \"msg.jsdoc.incompat.type\", lineno, charno);\n865                         }\n866                         break;\n867                     }\n868 \n869                   token = eatTokensUntilEOL();\n870                   }\n871                   continue retry;\n872               }\n873             }\n874           }\n875           break;\n876 \n877         case EOC:\n878           if (hasParsedFileOverviewDocInfo()) {\n879             fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n880           }\n881           checkExtendedTypes(extendedTypes);\n882           return true;\n883 \n884         case EOF:\n885           // discard any accumulated information\n886           jsdocBuilder.build(null);\n887           parser.addParserWarning(\"msg.unexpected.eof\",\n888               stream.getLineno(), stream.getCharno());\n889           checkExtendedTypes(extendedTypes);\n890           return false;\n891 \n892         case EOL:\n893           if (state == State.SEARCHING_NEWLINE) {\n894             state = State.SEARCHING_ANNOTATION;\n895           }\n896           token = next();\n897           continue retry;\n898 \n899         default:\n900           if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n901             token = next();\n902             continue retry;\n903           } else {\n904             state = State.SEARCHING_NEWLINE;\n905             token = eatTokensUntilEOL();\n906             continue retry;\n907           }\n908       }\n909 \n910       // next token\n911       token = next();\n912     }\n913   }", "bm_classpath": "com.google.javascript.jscomp.parsing.JsDocInfoParser"}, {"bug_name": "Closure_69", "report_text": "> Compiler should warn/error when instance methods are operated on\n> \n> **What steps will reproduce the problem?**\n> 1. Compile and run the following code:\r\n>  goog.require('goog.graphics.Path');\r\n>  function demo() {\r\n>  var path = new goog.graphics.Path();\r\n>  var points = [[1,1], [2,2]];\r\n>  for (var i = 0; i < points.length; i++) {\r\n>  (i == 0 ? path.moveTo : path.lineTo)(points[i][0], points[i][1]);\r\n>  }\r\n>  }\r\n>  goog.exportSymbol('demo', demo);\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I expect it to either work or produce a warning. In this case, the latter since there's an error in the javascript - when calling path.moveTo(x, y), \"this\" is set correctly to the path element in the moveTo function. But when the function is operated on, as in (i == 0 ? path.moveTo : path.lineTo)(x, y), it's no longer an instance method invocation, so \"this\" reverts to the window object. In this case, an error results because moveTo references a field in Path that is now \"undefined\". Better would be to issue a warning/error that an instance method is being converted to a normal function (perhaps only if it references this).\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Unknown (it's built into my build tools) - I presume this issue is present in all builds. Running on ubuntu.\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testThisTypeOfFunction2", "test_method": "  public void testThisTypeOfFunction2() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"/** @type {function(this:F)} */ function f() {}\" +\n        \"f();\",\n        \"\\\"function (this:F): ?\\\" must be called with a \\\"this\\\" type\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8977)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8957)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8898)\n\tcom.google.javascript.jscomp.TypeCheckTest.testThisTypeOfFunction2(TypeCheckTest.java:4553)", "buggy_method": "1544 private void visitCall(NodeTraversal t, Node n) {\n1545     Node child = n.getFirstChild();\n1546     JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n1547 \n1548     if (!childType.canBeCalled()) {\n1549       report(t, n, NOT_CALLABLE, childType.toString());\n1550       ensureTyped(t, n);\n1551       return;\n1552     }\n1553 \n1554     // A couple of types can be called as if they were functions.\n1555     // If it is a function type, then validate parameters.\n1556     if (childType instanceof FunctionType) {\n1557       FunctionType functionType = (FunctionType) childType;\n1558 \n1559       boolean isExtern = false;\n1560       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n1561       if(functionJSDocInfo != null) {\n1562         String sourceName = functionJSDocInfo.getSourceName();\n1563         CompilerInput functionSource = compiler.getInput(sourceName);\n1564         isExtern = functionSource.isExtern();\n1565       }\n1566 \n1567       // Non-native constructors should not be called directly\n1568       // unless they specify a return type and are defined\n1569       // in an extern.\n1570       if (functionType.isConstructor() &&\n1571           !functionType.isNativeObjectType() &&\n1572           (functionType.getReturnType().isUnknownType() ||\n1573            functionType.getReturnType().isVoidType() ||\n1574            !isExtern)) {\n1575         report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n1576       }\n1577 \n1578       // Functions with explcit 'this' types must be called in a GETPROP\n1579       // or GETELEM.\n1580 \n1581       visitParameterList(t, n, functionType);\n1582       ensureTyped(t, n, functionType.getReturnType());\n1583     } else {\n1584       ensureTyped(t, n);\n1585     }\n1586 \n1587     // TODO: Add something to check for calls of RegExp objects, which is not\n1588     // supported by IE.  Either say something about the return type or warn\n1589     // about the non-portability of the call or both.\n1590   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_70", "report_text": "> unexpected typed coverage of less than 100%\n> \n> **What steps will reproduce the problem?**\n> 1. Create JavaScript file:\r\n> /\\*global window\\*/\r\n> /\\*jslint sub: true\\*/\r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @param {!Element} element\r\n>  \\*/\r\n> function Example(element) {\r\n>  /\\*\\*\r\n>  \\* @param {!string} ns\r\n>  \\* @param {!string} name\r\n>  \\* @return {undefined}\r\n>  \\*/\r\n>  this.appendElement = function appendElement(ns, name) {\r\n>  var e = element.ownerDocument.createElementNS(ns, name);\r\n>  element.appendChild(e);\r\n>  };\r\n> }\r\n> window[\"Example\"] = Example;\r\n> 2. compile it:\r\n> java -jar compiler.jar --jscomp\\_error checkTypes --summary\\_detail\\_level 3 --js v.js --js\\_output\\_file compiled.js\r\n> 3. observe the outcome:\r\n> 0 error(s), 0 warning(s), 73.7% typed\r\n> \r\n> **What is the expected output? What do you see instead?**\n> This was expected:\r\n> 0 error(s), 0 warning(s), 100% typed\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Closure Compiler Version: 964, Built on: 2011/04/05 14:31 on GNU/Linux.\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.LooseTypeCheckTest::testDuplicateLocalVarDecl", "test_method": "  public void testDuplicateLocalVarDecl() throws Exception {\n    testClosureTypesMultipleWarnings(\n        \"/** @param {number} x */\\n\" +\n        \"function f(x) { /** @type {string} */ var x = ''; }\",\n        Lists.newArrayList(\n            \"variable x redefined with type string, original definition\" +\n            \" at  [testcode] :2 with type number\",\n            \"initializing variable\\n\" +\n            \"found   : string\\n\" +\n            \"required: number\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2> but was:<1>\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testClosureTypesMultipleWarnings(LooseTypeCheckTest.java:7054)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testDuplicateLocalVarDecl(LooseTypeCheckTest.java:1970)", "buggy_method": "1734 private void declareArguments(Node functionNode) {\n1735       Node astParameters = functionNode.getFirstChild().getNext();\n1736       Node body = astParameters.getNext();\n1737       FunctionType functionType = (FunctionType) functionNode.getJSType();\n1738       if (functionType != null) {\n1739         Node jsDocParameters = functionType.getParametersNode();\n1740         if (jsDocParameters != null) {\n1741           Node jsDocParameter = jsDocParameters.getFirstChild();\n1742           for (Node astParameter : astParameters.children()) {\n1743             if (jsDocParameter != null) {\n1744               defineSlot(astParameter, functionNode,\n1745                   jsDocParameter.getJSType(), true);\n1746               jsDocParameter = jsDocParameter.getNext();\n1747             } else {\n1748               defineSlot(astParameter, functionNode, null, true);\n1749             }\n1750           }\n1751         }\n1752       }\n1753     } // end declareArguments", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder"}, {"bug_name": "Closure_71", "report_text": "> no warnings when @private prop is redeclared on subclass\n> \n> **What steps will reproduce the problem?**\n> /\\*\\* @constructor \\*/ function Foo() { /\\*\\* @private \\*/ this.x\\_ = 3; }\r\n> \r\n> then, in a separate file:\r\n> /\\*\\* @constructor \r\n>  \\* @extends {Foo} \\*/ function SubFoo() { /\\*\\* @private \\*/ this.x\\_ = 3; }\r\n> \r\n> then, compile with --jscomp\\_error=visibility\r\n> \r\n> Expected: You should get an error.\r\n> Actual: No error.\r\n> \r\n> You get an error as appropriate if the second @private annotation is removed.", "test_name": "com.google.javascript.jscomp.CheckAccessControlsTest::testNoPrivateAccessForProperties6", "test_method": "  public void testNoPrivateAccessForProperties6() {\n    // Overriding a private property with a non-private property\n    // in a different file causes problems.\n    test(new String[] {\n      \"/** @constructor */ function Foo() {} \" +\n      \"/** @private */ Foo.prototype.bar_ = function() {};\",\n      \"/** @constructor \\n * @extends {Foo} */ \" +\n      \"function SubFoo() {};\" +\n      \"SubFoo.prototype.bar_ = function() {};\"\n    }, null, BAD_PRIVATE_PROPERTY_ACCESS); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Overriding private property of Foo.prototype.\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:904)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:486)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:460)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CheckAccessControlsTest.testNoPrivateAccessForProperties6(CheckAccessControlsTest.java:402)", "buggy_method": "407 private void checkPropertyVisibility(NodeTraversal t,\n408       Node getprop, Node parent) {\n409     ObjectType objectType =\n410         ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n411     String propertyName = getprop.getLastChild().getString();\n412 \n413     if (objectType != null) {\n414       // Is this a normal property access, or are we trying to override\n415       // an existing property?\n416       boolean isOverride = t.inGlobalScope() &&\n417           parent.getType() == Token.ASSIGN &&\n418           parent.getFirstChild() == getprop;\n419 \n420       // Find the lowest property defined on a class with visibility\n421       // information.\n422       if (isOverride) {\n423         objectType = objectType.getImplicitPrototype();\n424       }\n425       JSDocInfo docInfo = null;\n426       for (; objectType != null;\n427            objectType = objectType.getImplicitPrototype()) {\n428         docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n429         if (docInfo != null &&\n430             docInfo.getVisibility() != Visibility.INHERITED) {\n431           break;\n432         }\n433       }\n434 \n435       if (objectType == null) {\n436         // We couldn't find a visibility modifier; assume it's public.\n437         return;\n438       }\n439 \n440       boolean sameInput =\n441           t.getInput().getName().equals(docInfo.getSourceName());\n442       Visibility visibility = docInfo.getVisibility();\n443       JSType ownerType = normalizeClassType(objectType);\n444       if (isOverride) {\n445         // Check an ASSIGN statement that's trying to override a property\n446         // on a superclass.\n447         JSDocInfo overridingInfo = parent.getJSDocInfo();\n448         Visibility overridingVisibility = overridingInfo == null ?\n449             Visibility.INHERITED : overridingInfo.getVisibility();\n450 \n451         // Check that (a) the property *can* be overridden, and\n452         // (b) that the visibility of the override is the same as the\n453         // visibility of the original property.\n454         if (visibility == Visibility.PRIVATE && !sameInput) {\n455           compiler.report(\n456               t.makeError(getprop, PRIVATE_OVERRIDE,\n457                   objectType.toString()));\n458         } else if (overridingVisibility != Visibility.INHERITED &&\n459             overridingVisibility != visibility) {\n460           compiler.report(\n461               t.makeError(getprop, VISIBILITY_MISMATCH,\n462                   visibility.name(), objectType.toString(),\n463                   overridingVisibility.name()));\n464         }\n465       } else {\n466         if (sameInput) {\n467           // private access is always allowed in the same file.\n468           return;\n469         } else if (visibility == Visibility.PRIVATE &&\n470             (currentClass == null || ownerType.differsFrom(currentClass))) {\n471           if (docInfo.isConstructor() &&\n472               isValidPrivateConstructorAccess(parent)) {\n473             return;\n474           }\n475 \n476           // private access is not allowed outside the file from a different\n477           // enclosing class.\n478           compiler.report(\n479               t.makeError(getprop,\n480                   BAD_PRIVATE_PROPERTY_ACCESS,\n481                   propertyName,\n482                   validator.getReadableJSTypeName(\n483                       getprop.getFirstChild(), true)));\n484         } else if (visibility == Visibility.PROTECTED) {\n485           // There are 3 types of legal accesses of a protected property:\n486           // 1) Accesses in the same file\n487           // 2) Overriding the property in a subclass\n488           // 3) Accessing the property from inside a subclass\n489           // The first two have already been checked for.\n490           if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n491             compiler.report(\n492                 t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n493                     propertyName,\n494                     validator.getReadableJSTypeName(\n495                         getprop.getFirstChild(), true)));\n496           }\n497         }\n498       }\n499     }\n500   }", "bm_classpath": "com.google.javascript.jscomp.CheckAccessControls"}, {"bug_name": "Closure_72", "report_text": "> Internal Compiler Error on Bullet\n> \n> **What steps will reproduce the problem?**\n> 1. The attachment is the Bullet physics library, compiled from C++ to JS using Emscripten.\r\n> 2. I tried to compile it using the Closure Compiler, latest downloadable version (Apr 5 2011), with\r\n> \r\n> java -jar apr5compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --variable\\_map\\_output\\_file js.vars --js bullet\\_1\\_1\\_q1.js --js\\_output\\_file bullet\\_1\\_1\\_q1.cc.js\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> I would expect it to compile successfully. Instead it halts (after a few hours) with\r\n> \r\n> \r\n> ==================\r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(LABEL): bullet\\_1\\_1\\_q1.js:60150:8\r\n>  $for\\_body$5: while(1) { \r\n>  Parent(BLOCK): bullet\\_1\\_1\\_q1.js:60043:26\r\n>  if (\\_\\_label\\_\\_ == 0) {\r\n> \r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(LABEL): bullet\\_1\\_1\\_q1.js:60150:8\r\n>  $for\\_body$5: while(1) { \r\n>  Parent(BLOCK): bullet\\_1\\_1\\_q1.js:60043:26\r\n>  if (\\_\\_label\\_\\_ == 0) {\r\n> \r\n>  at com.google.common.base.Preconditions.checkState(Preconditions.java:129)\r\n>  at com.google.javascript.jscomp.RenameLabels$ProcessLabels.shouldTraverse(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseFunction(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)\r\n>  at com.google.javascript.jscomp.RenameLabels.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)\r\n>  at java.lang.Thread.run(Thread.java:662)\r\n> Caused by: java.lang.IllegalStateException\r\n>  ... 40 more\r\n> ==================\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> The Closure Compiler download from Apr 5 2011, on Ubuntu 10.04 32 bit.", "test_name": "com.google.javascript.jscomp.InlineFunctionsTest::testInlineFunctions31", "test_method": "  public void testInlineFunctions31() {\n    // Don't introduce a duplicate label in the same scope\n    test(\"function foo(){ lab:{4;} }\" +\n        \"lab:{foo();}\",\n        \"lab:{{JSCompiler_inline_label_0:{4}}}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:862)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.InlineFunctionsTest.testInlineFunctions31(InlineFunctionsTest.java:388)", "buggy_method": "142 private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n143     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n144     // Make variable names unique to this instance.\n145     NodeTraversal.traverse(\n146         compiler, fnNode, new MakeDeclaredNamesUnique(\n147             new InlineRenamer(\n148                 idSupplier,\n149                 \"inline_\",\n150                 isCallInLoop)));\n151     // Make label names unique to this instance.\n152   }", "bm_classpath": "com.google.javascript.jscomp.FunctionToBlockMutator"}, {"bug_name": "Closure_73", "report_text": "> Codepoint U+007f appears raw in output\n> \n> **What steps will reproduce the problem?**\n> 1. Open http://closure-compiler.appspot.com/home in your browser\r\n> 2. Enter the source code: alert('\\x7f')\r\n> 3. Hit the \"Compile\" button.\r\n> \r\n> What is the expected output?\r\n> alert(\"\\x7f\")\r\n> \r\n> What do you see instead?\r\n> alert(\"\u007f\");\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> The version live on 11 April 2011.\r\n> \r\n> **Please provide any additional information below.**\n> Codepoint U+007f is a delete control character and is the only non-printable ASCII codepoint that is not <= U+0020. http://www.fileformat.info/info/unicode/char/7f/index.htm\r\n> \r\n> It should probably not appear raw in emitted source code because, it can confuse encoders.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testUnicode", "test_method": "  public void testUnicode() {\n    assertPrint(\"var x ='\\\\x7f';\", \"var x=\\\"\\\\u007f\\\"\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x=\"[\\u007f]\"> but was:<var x=\"[\u007f]\">\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:387)\n\tcom.google.javascript.jscomp.CodePrinterTest.testUnicode(CodePrinterTest.java:1215)", "buggy_method": "988 static String strEscape(String s, char quote,\n989                           String doublequoteEscape,\n990                           String singlequoteEscape,\n991                           String backslashEscape,\n992                           CharsetEncoder outputCharsetEncoder) {\n993     StringBuilder sb = new StringBuilder(s.length() + 2);\n994     sb.append(quote);\n995     for (int i = 0; i < s.length(); i++) {\n996       char c = s.charAt(i);\n997       switch (c) {\n998         case '\\0': sb.append(\"\\\\0\"); break;\n999         case '\\n': sb.append(\"\\\\n\"); break;\n1000         case '\\r': sb.append(\"\\\\r\"); break;\n1001         case '\\t': sb.append(\"\\\\t\"); break;\n1002         case '\\\\': sb.append(backslashEscape); break;\n1003         case '\\\"': sb.append(doublequoteEscape); break;\n1004         case '\\'': sb.append(singlequoteEscape); break;\n1005         case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n1006           if (i >= 2 &&\n1007               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n1008                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n1009             sb.append(\"\\\\>\");\n1010           } else {\n1011             sb.append(c);\n1012           }\n1013           break;\n1014         case '<':\n1015           // Break </script into <\\/script\n1016           final String END_SCRIPT = \"/script\";\n1017 \n1018           // Break <!-- into <\\!--\n1019           final String START_COMMENT = \"!--\";\n1020 \n1021           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n1022                               END_SCRIPT.length())) {\n1023             sb.append(\"<\\\\\");\n1024           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n1025                                      START_COMMENT.length())) {\n1026             sb.append(\"<\\\\\");\n1027           } else {\n1028             sb.append(c);\n1029           }\n1030           break;\n1031         default:\n1032           // If we're given an outputCharsetEncoder, then check if the\n1033           //  character can be represented in this character set.\n1034           if (outputCharsetEncoder != null) {\n1035             if (outputCharsetEncoder.canEncode(c)) {\n1036               sb.append(c);\n1037             } else {\n1038               // Unicode-escape the character.\n1039               appendHexJavaScriptRepresentation(sb, c);\n1040             }\n1041           } else {\n1042             // No charsetEncoder provided - pass straight latin characters\n1043             // through, and escape the rest.  Doing the explicit character\n1044             // check is measurably faster than using the CharsetEncoder.\n1045             if (c > 0x1f && c <= 0x7f) {\n1046               sb.append(c);\n1047             } else {\n1048               // Other characters can be misinterpreted by some js parsers,\n1049               // or perhaps mangled by proxies along the way,\n1050               // so we play it safe and unicode escape them.\n1051               appendHexJavaScriptRepresentation(sb, c);\n1052             }\n1053           }\n1054       }\n1055     }\n1056     sb.append(quote);\n1057     return sb.toString();\n1058   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_74", "report_text": "> Obvious optimizations don't works in \"inline if\"\n> \n> Try it (advanced mode):\r\n>  alert(true == null ? a() : b());\r\n> \r\n> EVER true != null, in this case, EVER will trigger b(), but we get:\r\n>  alert(!0 == null ? a() : b());\r\n> \r\n> Same for:\r\n>  alert(true == false ? a() : b());\r\n> \r\n> Real life use:\r\n>  function sum(a, b){\r\n>  return (a == true ? 2 : a) + b;\r\n>  }\r\n>  alert(sum(true, 1));\r\n> \r\n> Results in:\r\n>  alert((!0 == !0 ? 2 : 1) + 1);\r\n> \r\n> But correct is:\r\n>  alert(3);", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldComparison3", "test_method": "  public void testFoldComparison3() {\n    fold(\"x = !1 == !0\", \"x = false\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:844)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:411)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:336)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:293)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.fold(PeepholeFoldConstantsTest.java:69)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testFoldComparison3(PeepholeFoldConstantsTest.java:700)", "buggy_method": "887 @SuppressWarnings(\"fallthrough\")\n888   private Node tryFoldComparison(Node n, Node left, Node right) {\n889     if (!NodeUtil.isLiteralValue(left, false) ||\n890         !NodeUtil.isLiteralValue(right, false)) {\n891       // We only handle non-literal operands for LT and GT.\n892       if (n.getType() != Token.GT && n.getType() != Token.LT) {\n893         return n;\n894       }\n895     }\n896 \n897     int op = n.getType();\n898     boolean result;\n899 \n900     // TODO(johnlenz): Use the JSType to compare nodes of different types.\n901 \n902     boolean rightLiteral = NodeUtil.isLiteralValue(right, false);\n903     boolean undefinedRight = ((Token.NAME == right.getType()\n904           && right.getString().equals(\"undefined\"))\n905           || (Token.VOID == right.getType()\n906               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n907     int lhType = left.getType();\n908     int rhType = right.getType();\n909     switch (lhType) {\n910       case Token.VOID:\n911         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n912           return n;\n913         } else if (!rightLiteral) {\n914           return n;\n915         } else {\n916           result = compareToUndefined(right, op);\n917         }\n918         break;\n919 \n920       case Token.NULL:\n921       case Token.TRUE:\n922       case Token.FALSE:\n923         if (undefinedRight) {\n924           result = compareToUndefined(left, op);\n925           break;\n926         }\n927         if (rhType != Token.TRUE &&\n928             rhType != Token.FALSE &&\n929             rhType != Token.NULL) {\n930           return n;\n931         }\n932         switch (op) {\n933           case Token.SHEQ:\n934           case Token.EQ:\n935             result = lhType == rhType;\n936             break;\n937 \n938           case Token.SHNE:\n939           case Token.NE:\n940             result = lhType != rhType;\n941             break;\n942 \n943           case Token.GE:\n944           case Token.LE:\n945           case Token.GT:\n946           case Token.LT:\n947             Boolean compareResult = compareAsNumbers(op, left, right);\n948             if (compareResult != null) {\n949               result = compareResult;\n950             } else {\n951               return n;\n952             }\n953             break;\n954 \n955           default:\n956             return n;  // we only handle == and != here\n957         }\n958         break;\n959 \n960       case Token.THIS:\n961         if (right.getType() != Token.THIS) {\n962           return n;\n963         }\n964         switch (op) {\n965           case Token.SHEQ:\n966           case Token.EQ:\n967             result = true;\n968             break;\n969 \n970           case Token.SHNE:\n971           case Token.NE:\n972             result = false;\n973             break;\n974 \n975           // We can only handle == and != here.\n976           // GT, LT, GE, LE depend on the type of \"this\" and how it will\n977           // be converted to number.  The results are different depending on\n978           // whether it is a string, NaN or other number value.\n979           default:\n980             return n;\n981         }\n982         break;\n983 \n984       case Token.STRING:\n985         if (undefinedRight) {\n986           result = compareToUndefined(left, op);\n987           break;\n988         }\n989         if (Token.STRING != right.getType()) {\n990           return n;  // Only eval if they are the same type\n991         }\n992         switch (op) {\n993           case Token.SHEQ:\n994           case Token.EQ:\n995             result = left.getString().equals(right.getString());\n996             break;\n997 \n998           case Token.SHNE:\n999           case Token.NE:\n1000             result = !left.getString().equals(right.getString());\n1001             break;\n1002 \n1003           default:\n1004             return n;  // we only handle == and != here\n1005         }\n1006         break;\n1007 \n1008       case Token.NUMBER:\n1009         if (undefinedRight) {\n1010           result = compareToUndefined(left, op);\n1011           break;\n1012         }\n1013         if (Token.NUMBER != right.getType()) {\n1014           return n;  // Only eval if they are the same type\n1015         }\n1016         Boolean compareResult = compareAsNumbers(op, left, right);\n1017         if (compareResult != null) {\n1018           result = compareResult;\n1019         } else {\n1020           return null;\n1021         }\n1022         break;\n1023 \n1024       case Token.NAME:\n1025         if (undefinedRight) {\n1026           result = compareToUndefined(left, op);\n1027           break;\n1028         }\n1029 \n1030         if (rightLiteral) {\n1031           boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n1032           if (undefinedLeft) {\n1033             result = compareToUndefined(right, op);\n1034             break;\n1035           }\n1036         }\n1037 \n1038         if (Token.NAME != right.getType()) {\n1039           return n;  // Only eval if they are the same type\n1040         }\n1041         String ln = left.getString();\n1042         String rn = right.getString();\n1043         if (!ln.equals(rn)) {\n1044           return n;  // Not the same value name.\n1045         }\n1046 \n1047         switch (op) {\n1048           // If we knew the named value wouldn't be NaN, it would be nice\n1049           // to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n1050           case Token.LT:\n1051           case Token.GT:\n1052             result = false;\n1053             break;\n1054           default:\n1055             return n;  // don't handle that op\n1056         }\n1057         break;\n1058 \n1059       default:\n1060         // assert, this should cover all consts\n1061         return n;\n1062     }\n1063 \n1064     Node newNode = new Node(result ? Token.TRUE : Token.FALSE);\n1065     n.getParent().replaceChild(n, newNode);\n1066     reportCodeChange();\n1067 \n1068     return newNode;\n1069   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_75", "report_text": "> closure compiled swfobject error\n> \n> swfobject.js code\r\n> \r\n> function urlEncodeIfNecessary(s) {\r\n>  var regex = /[\\\\\\\"<>\\.;]/;\r\n>  var hasBadChars = regex.exec(s) != null;\r\n>  return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;\r\n> }\r\n> \r\n> closure compiled:\r\n> \r\n> function Z(a){return/[\\\"<>.;]/.exec(a)!=\r\n> null&&typeof encodeURIComponent!=j?encodeURIComponent(a):a}\r\n> \r\n> but it's error.and minify erray:\r\n> Fatal error: Uncaught exception 'JSMin\\_UnterminatedStringException' with message 'Unterminated String: '\"<>.;]/.exec(a)!=''\r\n> \r\n> return/[\\\"<>.;]/ to return /[\\\"<>.;]/ that's OK\r\n> \r\n> \r\n> ie = !+\"\\v1\", closure compiled to ie=!1, my god!!", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIEString", "test_method": "  public void testIEString() {\n    testSame(\"!+'\\\\v1'\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:524)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testIEString(PeepholeFoldConstantsTest.java:992)", "buggy_method": "312 static Double getStringNumberValue(String rawJsString) {\n313       // vertical tab is not always whitespace\n314 \n315     String s = trimJsWhiteSpace(rawJsString);\n316     // return ScriptRuntime.toNumber(s);\n317     if (s.length() == 0) {\n318       return 0.0;\n319     }\n320 \n321     if (s.length() > 2\n322         && s.charAt(0) == '0'\n323         && (s.charAt(1) == 'x' || s.charAt(1) == 'X')) {\n324       // Attempt to convert hex numbers.\n325       try {\n326         return Double.valueOf(Integer.parseInt(s.substring(2), 16));\n327       } catch (NumberFormatException e) {\n328         return Double.NaN;\n329       }\n330     }\n331 \n332     if (s.length() > 3\n333         && (s.charAt(0) == '-' || s.charAt(0) == '+')\n334         && s.charAt(1) == '0'\n335         && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n336       // hex numbers with explicit signs vary between browsers.\n337       return null;\n338     }\n339 \n340     // FireFox and IE treat the \"Infinity\" differently. FireFox is case\n341     // insensitive, but IE treats \"infinity\" as NaN.  So leave it alone.\n342     if (s.equals(\"infinity\")\n343         || s.equals(\"-infinity\")\n344         || s.equals(\"+infinity\")) {\n345       return null;\n346     }\n347 \n348     try {\n349       return Double.parseDouble(s);\n350     } catch (NumberFormatException e) {\n351       return Double.NaN;\n352     }\n353   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_76", "report_text": "> Assignments within conditions are sometimes incorrectly removed\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. See attachment.\r\n> 2. Run original.\r\n> 3. Run compiled.\r\n> \r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> \\* Both should return \"true\"\r\n> \\* Original does return \"true\"\r\n> \\* Compiled returns \"undefined\"\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 706\r\n> Built on: 2011/01/19 19:53\r\n> \r\n> Mac OS X 10.6\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> In the attached reduction if the \"echo\" functions aren't used then the entire body of the function is compiled away, they are there to demonstrate that the first assignment in the condition is removed.\r\n> \r\n> \r\n> Original:\r\n> \r\n> function reduction()\r\n> {\r\n>  var a, b;\r\n>  if (echo(b = true) || echo(b = false))\r\n>  a = b;\r\n>  else\r\n>  a = null;\r\n>  return a;\r\n> }\r\n> \r\n> \r\n> Compiled:\r\n> \r\n> function reduction() {\r\n>  var a;\r\n>  return echo(true) || echo(a = false) ? a: null\r\n> }", "test_name": "com.google.javascript.jscomp.DeadAssignmentsEliminationTest::testInExpression2", "test_method": "  public void testInExpression2() {\n    // This can be improved.  \"a = 1\" is dead but \"a\" is read in the following\n    // expression.\n    inFunction(\n        \"var a; a = 1; if ((a = 2) || (a = 3) || (a)) {}\",\n        \"var a; a = 1; if ((    2) || (a = 3) || (a)) {}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.DeadAssignmentsEliminationTest.inFunction(DeadAssignmentsEliminationTest.java:345)\n\tcom.google.javascript.jscomp.DeadAssignmentsEliminationTest.testInExpression2(DeadAssignmentsEliminationTest.java:459)", "buggy_method": "290 private boolean isVariableStillLiveWithinExpression(\n291       Node n, Node exprRoot, String variable) {\n292     while (n != exprRoot) {\n293       VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n294       switch (n.getParent().getType()) {\n295         case Token.OR:\n296         case Token.AND:\n297           // If the currently node is the first child of\n298           // AND/OR, be conservative only consider the READs\n299           // of the second operand.\n300 \n301         case Token.HOOK:\n302           // If current node is the condition, check each following\n303           // branch, otherwise it is a conditional branch and the\n304           // other branch can be ignored.\n305 \n306         default:\n307           for(Node sibling = n.getNext(); sibling != null;\n308               sibling = sibling.getNext()) {\n309             if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n310             state = isVariableReadBeforeKill(sibling, variable);\n311 \n312       // If we see a READ or KILL there is no need to continue.\n313       if (state == VariableLiveness.READ) {\n314         return true;\n315       } else if (state == VariableLiveness.KILL) {\n316         return false;\n317             }\n318           }\n319       }\n320       }\n321       n = n.getParent();\n322     }\n323     return false;\n324   }", "bm_classpath": "com.google.javascript.jscomp.DeadAssignmentsElimination"}, {"bug_name": "Closure_77", "report_text": "> \\0 \\x00 and \\u0000 are translated to null character\n> \n> **What steps will reproduce the problem?**\n> 1. write script with string constant \"\\0\" or \"\\x00\" or \"\\u0000\"\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I expected a string literal with \"\\0\" (or something like that)\r\n> and instead get a string literal with three null character values.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> compiler-20110119.zip on windows 7 x64\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> This is causing an issue with IE9 and jQuery.getScript. It causes IE9 to interpret the null character as the end of the file instead of a null character.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testZero", "test_method": "  public void testZero() {\n    assertPrint(\"var x ='\\\\0';\", \"var x=\\\"\\\\0\\\"\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x=\"\\[]0\"> but was:<var x=\"\\[u000]0\">\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:386)\n\tcom.google.javascript.jscomp.CodePrinterTest.testZero(CodePrinterTest.java:1179)", "buggy_method": "956 static String strEscape(String s, char quote,\n957                           String doublequoteEscape,\n958                           String singlequoteEscape,\n959                           String backslashEscape,\n960                           CharsetEncoder outputCharsetEncoder) {\n961     StringBuilder sb = new StringBuilder(s.length() + 2);\n962     sb.append(quote);\n963     for (int i = 0; i < s.length(); i++) {\n964       char c = s.charAt(i);\n965       switch (c) {\n966         case '\\n': sb.append(\"\\\\n\"); break;\n967         case '\\r': sb.append(\"\\\\r\"); break;\n968         case '\\t': sb.append(\"\\\\t\"); break;\n969         case '\\\\': sb.append(backslashEscape); break;\n970         case '\\\"': sb.append(doublequoteEscape); break;\n971         case '\\'': sb.append(singlequoteEscape); break;\n972         case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n973           if (i >= 2 &&\n974               ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n975                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n976             sb.append(\"\\\\>\");\n977           } else {\n978             sb.append(c);\n979           }\n980           break;\n981         case '<':\n982           // Break </script into <\\/script\n983           final String END_SCRIPT = \"/script\";\n984 \n985           // Break <!-- into <\\!--\n986           final String START_COMMENT = \"!--\";\n987 \n988           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n989                               END_SCRIPT.length())) {\n990             sb.append(\"<\\\\\");\n991           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n992                                      START_COMMENT.length())) {\n993             sb.append(\"<\\\\\");\n994           } else {\n995             sb.append(c);\n996           }\n997           break;\n998         default:\n999           // If we're given an outputCharsetEncoder, then check if the\n1000           //  character can be represented in this character set.\n1001           if (outputCharsetEncoder != null) {\n1002             if (outputCharsetEncoder.canEncode(c)) {\n1003               sb.append(c);\n1004             } else {\n1005               // Unicode-escape the character.\n1006               appendHexJavaScriptRepresentation(sb, c);\n1007             }\n1008           } else {\n1009             // No charsetEncoder provided - pass straight latin characters\n1010             // through, and escape the rest.  Doing the explicit character\n1011             // check is measurably faster than using the CharsetEncoder.\n1012             if (c > 0x1f && c <= 0x7f) {\n1013               sb.append(c);\n1014             } else {\n1015               // Other characters can be misinterpreted by some js parsers,\n1016               // or perhaps mangled by proxies along the way,\n1017               // so we play it safe and unicode escape them.\n1018               appendHexJavaScriptRepresentation(sb, c);\n1019             }\n1020           }\n1021       }\n1022     }\n1023     sb.append(quote);\n1024     return sb.toString();\n1025   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_78", "report_text": "> division by zero wrongly throws JSC_DIVIDE_BY_0_ERROR\n> \n> **What steps will reproduce the problem?**\n> \r\n> unaliased division by zero `1/0`\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> I expect minified code, but an error is thrown instead.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> appspot\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> Division by zero is a perfectly sane operation in ECMAScript. See 11.5.2 [0] of the ECMAScript 5 specification. Aliased division by zero `(n=1)/0` is permitted.\r\n> \r\n> [0] http://es5.github.com/#x11.5.2", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldArithmetic", "test_method": "  public void testFoldArithmetic() {\n    fold(\"x = 10 + 20\", \"x = 30\");\n    fold(\"x = 2 / 4\", \"x = 0.5\");\n    fold(\"x = 2.25 * 3\", \"x = 6.75\");\n    fold(\"z = x * y\", \"z = x * y\");\n    fold(\"x = y * 5\", \"x = y * 5\");\n    fold(\"x = 1 / 0\", \"x = 1 / 0\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR. Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:767)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.fold(PeepholeFoldConstantsTest.java:69)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testFoldArithmetic(PeepholeFoldConstantsTest.java:558)", "buggy_method": "664 private Node performArithmeticOp(int opType, Node left, Node right) {\n665     // Unlike other operations, ADD operands are not always converted\n666     // to Number.\n667     if (opType == Token.ADD\n668         && (NodeUtil.mayBeString(left, false)\n669             || NodeUtil.mayBeString(right, false))) {\n670       return null;\n671     }\n672 \n673     double result;\n674 \n675     // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n676     // to zero so this is a little akward here.\n677 \n678     Double lValObj = NodeUtil.getNumberValue(left);\n679     if (lValObj == null) {\n680       return null;\n681     }\n682     Double rValObj = NodeUtil.getNumberValue(right);\n683     if (rValObj == null) {\n684       return null;\n685     }\n686 \n687     double lval = lValObj;\n688     double rval = rValObj;\n689 \n690     switch (opType) {\n691       case Token.BITAND:\n692         result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n693         break;\n694       case Token.BITOR:\n695         result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n696         break;\n697       case Token.BITXOR:\n698         result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n699         break;\n700       case Token.ADD:\n701         result = lval + rval;\n702         break;\n703       case Token.SUB:\n704         result = lval - rval;\n705         break;\n706       case Token.MUL:\n707         result = lval * rval;\n708         break;\n709       case Token.MOD:\n710         if (rval == 0) {\n711           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n712           return null;\n713         }\n714         result = lval % rval;\n715         break;\n716       case Token.DIV:\n717         if (rval == 0) {\n718           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n719           return null;\n720         }\n721         result = lval / rval;\n722         break;\n723       default:\n724         throw new Error(\"Unexpected arithmetic operator\");\n725     }\n726 \n727     // TODO(johnlenz): consider removing the result length check.\n728     // length of the left and right value plus 1 byte for the operator.\n729     if (String.valueOf(result).length() <=\n730         String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n731 \n732         // Do not try to fold arithmetic for numbers > 2^53. After that\n733         // point, fixed-point math starts to break down and become inaccurate.\n734         Math.abs(result) <= MAX_FOLD_NUMBER) {\n735       Node newNumber = Node.newNumber(result);\n736       return newNumber;\n737     } else if (Double.isNaN(result)) {\n738       return Node.newString(Token.NAME, \"NaN\");\n739     } else if (result == Double.POSITIVE_INFINITY) {\n740       return Node.newString(Token.NAME, \"Infinity\");\n741     } else if (result == Double.NEGATIVE_INFINITY) {\n742       return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n743     }\n744 \n745     return null;\n746   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_79", "report_text": "> RuntimeException when compiling with extern prototype\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. java -jar compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --externs prototype.js --js bootloader.js\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(FUNCTION ): prototype.js:213:11\r\n>  function Str(key, holder, stack) {\r\n>  Parent(BLOCK): prototype.js:160:12\r\n> (function() {\r\n> \r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(FUNCTION ): prototype.js:213:11\r\n>  function Str(key, holder, stack) {\r\n>  Parent(BLOCK): prototype.js:160:12\r\n> (function() {\r\n> \r\n>  at com.google.common.base.Preconditions.checkState(Preconditions.java:129)\r\n>  at com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler.onRedeclaration(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Unknown Source)\r\n>  at com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.getScope(Unknown Source)\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Version: 706\r\n> Built on: 2011/01/19 19:53\r\n> \r\n> Mac OS X 10.6.0", "test_name": "com.google.javascript.jscomp.NormalizeTest::testIssue", "test_method": "  public void testIssue() {\n    super.allowExternsChanges(true);\n    test(\"var a,b,c; var a,b\", \"a(), b()\", \"a(), b()\", null, null); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: INTERNAL COMPILER ERROR.\n\tcom.google.common.base.Preconditions.checkState(Preconditions.java:129)\n\tcom.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler.onRedeclaration(Normalize.java:698)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.declareVar(SyntacticScopeCreator.java:238)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.scanVars(SyntacticScopeCreator.java:124)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.scanVars(SyntacticScopeCreator.java:166)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.scanVars(SyntacticScopeCreator.java:166)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.scanVars(SyntacticScopeCreator.java:166)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(SyntacticScopeCreator.java:110)\n\tcom.google.javascript.jscomp.SyntacticScopeCreator.createScope(SyntacticScopeCreator.java:74)\n\tcom.google.javascript.jscomp.NodeTraversal.getScope(NodeTraversal.java:563)\n\tcom.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(Normalize.java:760)\n\tcom.google.javascript.jscomp.NodeTraversal.pushScope(NodeTraversal.java:527)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:271)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:257)\n\tcom.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Normalize.java:633)\n\tcom.google.javascript.jscomp.Normalize.process(Normalize.java:142)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:749)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:374)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:351)", "buggy_method": "118 @Override\n119   public void process(Node externs, Node root) {\n120     new NodeTraversal(\n121         compiler, new NormalizeStatements(compiler, assertOnChange))\n122         .traverse(root);\n123     if (MAKE_LOCAL_NAMES_UNIQUE) {\n124       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n125       NodeTraversal t = new NodeTraversal(compiler, renamer);\n126       t.traverseRoots(externs, root);\n127     }\n128     // It is important that removeDuplicateDeclarations runs after\n129     // MakeDeclaredNamesUnique in order for catch block exception names to be\n130     // handled properly. Specifically, catch block exception names are\n131     // only valid within the catch block, but our currect Scope logic\n132     // has no concept of this and includes it in the containing function\n133     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n134     // names unique so that removeDuplicateDeclarations() will properly handle\n135     // cases where a function scope variable conflict with a exception name:\n136     //   function f() {\n137     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n138     //      var e = 1; // f scope 'e'\n139     //   }\n140     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n141     // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n142     removeDuplicateDeclarations(externs, root);\n143     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n144         .process(externs, root);\n145 \n146     if (!compiler.getLifeCycleStage().isNormalized()) {\n147       compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n148     }\n149   }", "bm_classpath": "com.google.javascript.jscomp.Normalize"}, {"bug_name": "Closure_80", "report_text": "> Unexpected expression nodeDELPROP 1\n> \n> As of version 20110119 of the closure compiler, the following code produces an error when it's compiled with advanced compilation enabled:\r\n> \r\n>  function x() { return delete a; }\r\n> \r\n> \r\n> The exact output of the compiler:\r\n> \r\n> \r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected expression nodeDELPROP 1 [sourcename: stdin]\r\n>  parent:RETURN 1 [sourcename: stdin]\r\n>  Node(RETURN): stdin:1:15\r\n> function x() { return delete a; }\r\n>  Parent(BLOCK): stdin:1:13\r\n> function x() { return delete a; }\r\n> \r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected expression nodeDELPROP 1 [sourcename: stdin]\r\n>  parent:RETURN 1 [sourcename: stdin]\r\n>  Node(RETURN): stdin:1:15\r\n> function x() { return delete a; }\r\n>  Parent(BLOCK): stdin:1:13\r\n> function x() { return delete a; }\r\n> \r\n>  at com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Unknown Source)\r\n>  at com.google.javascript.jscomp.PureFunctionIdentifier$FunctionAnalyzer.visit(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseFunction(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverse(Unknown Source)\r\n>  at com.google.javascript.jscomp.PureFunctionIdentifier.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PureFunctionIdentifier$Driver.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)\r\n>  at java.lang.Thread.run(Thread.java:680)\r\n> Caused by: java.lang.IllegalStateException: Unexpected expression nodeDELPROP 1 [sourcename: stdin]\r\n>  parent:RETURN 1 [sourcename: stdin]\r\n>  ... 23 more", "test_name": "com.google.javascript.jscomp.NodeUtilTest::testIsBooleanResult", "test_method": "  public void testIsBooleanResult() {\n\n\n\n    assertTrue(NodeUtil.isBooleanResult(getNode(\"delete a\"))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.NodeUtilTest.testIsBooleanResult(NodeUtilTest.java:1504)", "buggy_method": "1242 static boolean isBooleanResultHelper(Node n) {\n1243     switch (n.getType()) {\n1244       // Primitives\n1245       case Token.TRUE:\n1246       case Token.FALSE:\n1247       // Comparisons\n1248       case Token.EQ:\n1249       case Token.NE:\n1250       case Token.SHEQ:\n1251       case Token.SHNE:\n1252       case Token.LT:\n1253       case Token.GT:\n1254       case Token.LE:\n1255       case Token.GE:\n1256       // Queryies\n1257       case Token.IN:\n1258       case Token.INSTANCEOF:\n1259       // Inversion\n1260       case Token.NOT:\n1261       // delete operator returns a boolean.\n1262         return true;\n1263       default:\n1264         return false;\n1265     }\n1266   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_81", "report_text": "> An unnamed function statement statements should generate a parse error\n> \n> An unnamed function statement statements should generate a parse error, but it does not, for example:\r\n> \r\n> function () {};\r\n> \r\n> Note: Unnamed function expression are legal:\r\n> \r\n> (function(){});", "test_name": "com.google.javascript.jscomp.parsing.ParserTest::testUnnamedFunctionStatement", "test_method": "  public void testUnnamedFunctionStatement() {\n    // Statements\n    parseError(\"function() {};\", \"unnamed function statement\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.parsing.ParserTest.parseError(ParserTest.java:796)\n\tcom.google.javascript.jscomp.parsing.ParserTest.testUnnamedFunctionStatement(ParserTest.java:776)", "buggy_method": "512 @Override\n513     Node processFunctionNode(FunctionNode functionNode) {\n514       Name name = functionNode.getFunctionName();\n515       Boolean isUnnamedFunction = false;\n516       if (name == null) {\n517         name = new Name();\n518         name.setIdentifier(\"\");\n519         isUnnamedFunction = true;\n520       }\n521       Node node = newNode(Token.FUNCTION);\n522       Node newName = transform(name);\n523       if (isUnnamedFunction) {\n524         // Old Rhino tagged the empty name node with the line number of the\n525         // declaration.\n526         newName.setLineno(functionNode.getLineno());\n527         // TODO(bowdidge) Mark line number of paren correctly.\n528         // Same problem as below - the left paren might not be on the\n529         // same line as the function keyword.\n530         int lpColumn = functionNode.getAbsolutePosition() +\n531             functionNode.getLp();\n532         newName.setCharno(position2charno(lpColumn));\n533       }\n534 \n535       node.addChildToBack(newName);\n536       Node lp = newNode(Token.LP);\n537       // The left paren's complicated because it's not represented by an\n538       // AstNode, so there's nothing that has the actual line number that it\n539       // appeared on.  We know the paren has to appear on the same line as the\n540       // function name (or else a semicolon will be inserted.)  If there's no\n541       // function name, assume the paren was on the same line as the function.\n542       // TODO(bowdidge): Mark line number of paren correctly.\n543       Name fnName = functionNode.getFunctionName();\n544       if (fnName != null) {\n545         lp.setLineno(fnName.getLineno());\n546       } else {\n547         lp.setLineno(functionNode.getLineno());\n548       }\n549       int lparenCharno = functionNode.getLp() +\n550           functionNode.getAbsolutePosition();\n551 \n552       lp.setCharno(position2charno(lparenCharno));\n553       for (AstNode param : functionNode.getParams()) {\n554         lp.addChildToBack(transform(param));\n555       }\n556       node.addChildToBack(lp);\n557 \n558       Node bodyNode = transform(functionNode.getBody());\n559       parseDirectives(bodyNode);\n560       node.addChildToBack(bodyNode);\n561      return node;\n562     }", "bm_classpath": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher"}, {"bug_name": "Closure_82", "report_text": "> .indexOf fails to produce missing property warning\n> \n> The following code compiled with VERBOSE warnings or with the missingProperties check enabled fails to produce a warning or error:\r\n> \r\n> var s = new String(\"hello\");\r\n> alert(s.toLowerCase.indexOf(\"l\"));\r\n> \r\n> However, other string functions do properly produce the warning:\r\n> \r\n> var s = new String(\"hello\");\r\n> alert(s.toLowerCase.substr(0, 1));", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue301", "test_method": "  public void testIssue301() throws Exception {\n    testTypes(\n        \"Array.indexOf = function() {};\" +\n        \"var s = 'hello';\" +\n        \"alert(s.toLowerCase.indexOf('1'));\",\n        \"Property indexOf never defined on String.prototype.toLowerCase\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8370)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8350)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8291)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue301(TypeCheckTest.java:4955)", "buggy_method": "162 public final boolean isEmptyType() {\n163     return isNoType() || isNoObjectType() || isNoResolvedType();\n164   }", "bm_classpath": "com.google.javascript.rhino.jstype.JSType"}, {"bug_name": "Closure_83", "report_text": "> Cannot see version with --version\n> \n> **What steps will reproduce the problem?**\n> 1. Download sources of latest (r698) command-line version of closure compiler.\r\n> 2. Build (with ant from command line).\r\n> 3. Run compiler (java -jar compiler.jar --version).\r\n> \r\n> What is the expected output?\r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: 698\r\n> Built on: 2011/01/17 12:16\r\n> \r\n> What do you see instead?\r\n> \u041e\u043f\u0446\u0438\u044f \"--version\" \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\r\n> (Option \"--version\" requires operand)\r\n> and full list of options with description.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Latest source of command-line compiler from SVN (r698). OS Linux Mint 7, Sun Java 1.6.0\\_22.\r\n> \r\n> **Please provide any additional information below.**\n> When running compiler with\r\n> java -jar compiler.jar --version ?\r\n> it shows error message, then version info, then full list of options.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testVersionFlag2", "test_method": "  public void testVersionFlag2() {\n    lastArg = \"--version\";\n    testSame(\"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.compile(CommandLineRunnerTest.java:754)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:673)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:662)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:650)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:646)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testVersionFlag2(CommandLineRunnerTest.java:602)", "buggy_method": "332 @Override\n333       public int parseArguments(Parameters params) throws CmdLineException {\n334         String param = params.getParameter(0);\n335 \n336         if (param == null) {\n337           setter.addValue(true);\n338           return 0;\n339         } else {\n340           String lowerParam = param.toLowerCase();\n341           if (TRUES.contains(lowerParam)) {\n342             setter.addValue(true);\n343           } else if (FALSES.contains(lowerParam)) {\n344             setter.addValue(false);\n345           } else {\n346             setter.addValue(true);\n347             return 0;\n348           }\n349           return 1;\n350         }\n351       }", "bm_classpath": "com.google.javascript.jscomp.CommandLineRunner$Flags$BooleanOptionHandler"}, {"bug_name": "Closure_84", "report_text": "> Invalid left-hand side of assignment not detected\n> \n> **What steps will reproduce the problem?**\n> Compile this:\r\n>  var x=0,y=1;x||y=8\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I expect an error, because this is parsed as (x||y)=8, which is an invalid left-hand side of an assignment. Instead, I get\r\n>  var x=0,y=1;x||y=8;\r\n> which, like the input, is invalid code.", "test_name": "com.google.javascript.jscomp.parsing.ParserTest::testDestructuringAssignForbidden4", "test_method": "  public void testDestructuringAssignForbidden4() {\n    parseError(\"[x, y] = foo();\",\n        \"destructuring assignment forbidden\",\n        \"invalid assignment target\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.parsing.ParserTest.parseError(ParserTest.java:783)\n\tcom.google.javascript.jscomp.parsing.ParserTest.testDestructuringAssignForbidden4(ParserTest.java:625)", "buggy_method": "338 @Override\n339     Node processAssignment(Assignment assignmentNode) {\n340       Node assign = processInfixExpression(assignmentNode);\n341       return assign;\n342     }", "bm_classpath": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher"}, {"bug_name": "Closure_85", "report_text": "> Reproduceable crash with switch statement\n> \n> When attempting to compile the following code with default options (-jar compiler.jar --js filename) always produces the same error.\r\n> \r\n> function a(b) {\r\n>  switch (b.v) {\r\n>  case 'SWITCH':\r\n>  if (b.i >= 0) {\r\n>  return b.o;\r\n>  } else {\r\n>  return undefined;\r\n>  }\r\n>  break;\r\n>  }\r\n> }\r\n> \r\n> Whenever I try and compile the above script I get a RuntimeException thrown:\r\n> \r\n> INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> null\r\n>  Node(BREAK): C:\\test.js:11:3\r\n>  break;\r\n>  Parent: NULL\r\n> \r\n> The result of calling --version on compiler.jar:\r\n> \r\n> Version: 20100917 (revision 440)\r\n> Built on: 2010/09/17 17:55\r\n> \r\n> The result of calling -version on java.exe:\r\n> \r\n> java version \"1.6.0\\_11\"\r\n> Java(TM) SE Runtime Environment (build 1.6.0\\_11-b03)\r\n> Java HotSpot(TM) Client VM (build 11.0-b16, mixed mode, sharing)\r\n> \r\n> Anyone else with the same issue - to work around in the short term, comment out the \"break;\" line.", "test_name": "com.google.javascript.jscomp.UnreachableCodeEliminationTest::testCascadedRemovalOfUnlessUnconditonalJumps", "test_method": "  public void testCascadedRemovalOfUnlessUnconditonalJumps() {\n    test(\"switch (a) { case 'a': break; case 'b': break; case 'c': break }\",\n         \"switch (a) { case 'a': break; case 'b': case 'c': }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:818)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:398)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:323)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:280)\n\tcom.google.javascript.jscomp.UnreachableCodeEliminationTest.testCascadedRemovalOfUnlessUnconditonalJumps(UnreachableCodeEliminationTest.java:235)", "buggy_method": "130 @SuppressWarnings(\"fallthrough\")\n131   private Node tryRemoveUnconditionalBranching(Node n) {\n132     /*\n133      * For each of the unconditional branching control flow node, check to see\n134      * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n135      * the branching target. If it is, the branch node is safe to be removed.\n136      *\n137      * This is not as clever as MinimizeExitPoints because it doesn't do any\n138      * if-else conversion but it handles more complicated switch statements\n139      * much nicer.\n140      */\n141 \n142     // If n is null the target is the end of the function, nothing to do.\n143     if (n == null) {\n144        return n;\n145     }\n146 \n147     DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n148 \n149     if (gNode == null) {\n150       return n;\n151     }\n152 \n153     if (n.getParent() == null) {\n154       List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n155       if (outEdges.size() == 1) {\n156         return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n157       }\n158     }\n159     switch (n.getType()) {\n160       case Token.BLOCK:\n161         if (n.hasChildren()) {\n162           Node first = n.getFirstChild();\n163           return tryRemoveUnconditionalBranching(first);\n164         } else {\n165           return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n166         }\n167       case Token.RETURN:\n168         if (n.hasChildren()) {\n169           break;\n170         }\n171       case Token.BREAK:\n172       case Token.CONTINUE:\n173 \n174         // We are looking for a control flow changing statement that always\n175         // branches to the same node. If removing it the control flow still\n176         // branches to that same node. It is safe to remove it.\n177         List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n178         if (outEdges.size() == 1 &&\n179             // If there is a next node, there is no chance this jump is useless.\n180             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n181 \n182           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n183           Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n184           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n185           if (nextCfgNode == fallThrough) {\n186             removeDeadExprStatementSafely(n);\n187             return fallThrough;\n188           }\n189         }\n190     }\n191     return n;\n192   }", "bm_classpath": "com.google.javascript.jscomp.UnreachableCodeElimination"}, {"bug_name": "Closure_86", "report_text": "> side-effects analysis incorrectly removing function calls with side effects\n> \n> Sample Code:\r\n> ---\r\n> /\\*\\* @constructor \\*/\r\n> function Foo() {\r\n>  var self = this;\r\n>  window.setTimeout(function() {\r\n>  window.location = self.location;\r\n>  }, 0);\r\n> }\r\n> \r\n> Foo.prototype.setLocation = function(loc) {\r\n>  this.location = loc;\r\n> };\r\n> \r\n> (new Foo()).setLocation('http://www.google.com/');\r\n> ---\r\n> \r\n> The setLocation call will get removed in advanced mode.", "test_name": "com.google.javascript.jscomp.NodeUtilTest::testLocalValue1", "test_method": "  public void testLocalValue1() throws Exception {\n    // Names are not known to be local.\n\n    // We can't know if new objects are local unless we know\n    // that they don't alias themselves.\n    assertFalse(testLocalValue(\"new x()\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.NodeUtilTest.testLocalValue1(NodeUtilTest.java:1023)", "buggy_method": "2424 static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n2425     switch (value.getType()) {\n2426       case Token.ASSIGN:\n2427         // A result that is aliased by a non-local name, is the effectively the\n2428         // same as returning a non-local name, but this doesn't matter if the\n2429         // value is immutable.\n2430         return NodeUtil.isImmutableValue(value.getLastChild())\n2431             || (locals.apply(value)\n2432                 && evaluatesToLocalValue(value.getLastChild(), locals));\n2433       case Token.COMMA:\n2434         return evaluatesToLocalValue(value.getLastChild(), locals);\n2435       case Token.AND:\n2436       case Token.OR:\n2437         return evaluatesToLocalValue(value.getFirstChild(), locals)\n2438            && evaluatesToLocalValue(value.getLastChild(), locals);\n2439       case Token.HOOK:\n2440         return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n2441            && evaluatesToLocalValue(value.getLastChild(), locals);\n2442       case Token.INC:\n2443       case Token.DEC:\n2444         if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n2445           return evaluatesToLocalValue(value.getFirstChild(), locals);\n2446         } else {\n2447           return true;\n2448         }\n2449       case Token.THIS:\n2450         return locals.apply(value);\n2451       case Token.NAME:\n2452         return isImmutableValue(value) || locals.apply(value);\n2453       case Token.GETELEM:\n2454       case Token.GETPROP:\n2455         // There is no information about the locality of object properties.\n2456         return locals.apply(value);\n2457       case Token.CALL:\n2458         return callHasLocalResult(value)\n2459             || isToStringMethodCall(value)\n2460             || locals.apply(value);\n2461       case Token.NEW:\n2462         // TODO(nicksantos): This needs to be changed so that it\n2463         // returns true iff we're sure the value was never aliased from inside\n2464         // the constructor (similar to callHasLocalResult)\n2465         return true;\n2466       case Token.FUNCTION:\n2467       case Token.REGEXP:\n2468       case Token.ARRAYLIT:\n2469       case Token.OBJECTLIT:\n2470         // Literals objects with non-literal children are allowed.\n2471         return true;\n2472       case Token.IN:\n2473         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n2474         return true;\n2475       default:\n2476         // Other op force a local value:\n2477         //  x = '' + g (x is now an local string)\n2478         //  x -= g (x is now an local number)\n2479         if (isAssignmentOp(value)\n2480             || isSimpleOperator(value)\n2481             || isImmutableValue(value)) {\n2482           return true;\n2483         }\n2484 \n2485         throw new IllegalStateException(\n2486             \"Unexpected expression node\" + value +\n2487             \"\\n parent:\" + value.getParent());\n2488     }\n2489   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_87", "report_text": "> IE8 error: Object doesn't support this action\n> \n> **What steps will reproduce the problem?**\n> 1. Use script with fragment like\r\n>  if (e.onchange) {\r\n>  e.onchange({\r\n>  \\_extendedByPrototype: Prototype.emptyFunction,\r\n>  target: e\r\n>  });\r\n>  }\r\n> 2. Compile with Compiler (command-line, latest version)\r\n> 3. Use in IE8\r\n> \r\n> What is the expected output?\r\n> Script:\r\n> if(b.onchange){b.onchange({\\_extendedByPrototype:Prototype.emptyFunction,target\r\n> :b})}\r\n> \r\n> What do you see instead?\r\n> Script:\r\n> b.onchange&&b.onchange({\\_extendedByPrototype:Prototype.emptyFunction,target\r\n> :b})\r\n> IE8:\r\n> Error message \"Object doesn't support this action\"\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Version: 20100917 (revision 440)\r\n> Built on: 2010/09/17 17:55", "test_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testIssue291", "test_method": "  public void testIssue291() {\n    fold(\"if (true) { f.onchange(); }\", \"if (1) f.onchange();\");\n    foldSame(\"if (f) { f.onchange(); }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:818)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:398)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:323)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:280)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:512)\n\tcom.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest.foldSame(PeepholeSubstituteAlternateSyntaxTest.java:66)\n\tcom.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest.testIssue291(PeepholeSubstituteAlternateSyntaxTest.java:568)", "buggy_method": "519 private boolean isFoldableExpressBlock(Node n) {\n520     if (n.getType() == Token.BLOCK) {\n521       if (n.hasOneChild()) {\n522         Node maybeExpr = n.getFirstChild();\n523           // IE has a bug where event handlers behave differently when\n524           // their return value is used vs. when their return value is in\n525           // an EXPR_RESULT. It's pretty freaking weird. See:\n526           // http://code.google.com/p/closure-compiler/issues/detail?id=291\n527           // We try to detect this case, and not fold EXPR_RESULTs\n528           // into other expressions.\n529 \n530             // We only have to worry about methods with an implicit 'this'\n531             // param, or this doesn't happen.\n532 \n533           return NodeUtil.isExpressionNode(maybeExpr);\n534       }\n535     }\n536 \n537     return false;\n538   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"}, {"bug_name": "Closure_88", "report_text": "> Incorrect assignment removal from expression in simple mode.\n> \n> function closureCompilerTest(someNode) {\r\n>  var nodeId;\r\n>  return ((nodeId=someNode.id) && (nodeId=parseInt(nodeId.substr(1))) && nodeId>0);\r\n> }\r\n> \r\n> COMPILES TO:\r\n> \r\n> function closureCompilerTest(b){var a;return b.id&&(a=parseInt(a.substr(1)))&&a>0};\r\n> \r\n> \"nodeId=someNode.id\" is replaced with simply \"b.id\" which is incorrect as the value of \"nodeId\" is used.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testIssue297", "test_method": "  public void testIssue297() {\n    args.add(\"--compilation_level=SIMPLE_OPTIMIZATIONS\");\n    test(\"function f(p) {\" +\n         \" var x;\" +\n         \" return ((x=p.id) && (x=parseInt(x.substr(1))) && x>0);\" +\n         \"}\",\n         \"function f(b) {\" +\n         \" var a;\" +\n         \" return ((a=b.id) && (a=parseInt(a.substr(1))) && a>0);\" +\n         \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:655)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:626)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:618)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testIssue297(CommandLineRunnerTest.java:252)", "buggy_method": "323 private VariableLiveness isVariableReadBeforeKill(\n324       Node n, String variable) {\n325     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n326       if (NodeUtil.isLhs(n, n.getParent())) {\n327         // The expression to which the assignment is made is evaluated before\n328         // the RHS is evaluated (normal left to right evaluation) but the KILL\n329         // occurs after the RHS is evaluated.\n330         return VariableLiveness.KILL;\n331       } else {\n332         return VariableLiveness.READ;\n333       }\n334     }\n335 \n336     // Expressions are evaluated left-right, depth first.\n337     for (Node child = n.getFirstChild();\n338         child != null; child = child.getNext()) {\n339       if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n340         VariableLiveness state = isVariableReadBeforeKill(child, variable);\n341         if (state != VariableLiveness.MAYBE_LIVE) {\n342           return state;\n343         }\n344       }\n345     }\n346     return VariableLiveness.MAYBE_LIVE;\n347   }", "bm_classpath": "com.google.javascript.jscomp.DeadAssignmentsElimination"}, {"bug_name": "Closure_89", "report_text": "> Compiler removes function properties that it should not\n> \n> The Compiler appears to remove properties that are added to functions. I do not believe that it should do such a thing. In the following example, I add a property named \"alwaysCall\" to a function that I check later. The property appears to be stripped, which changes the behavior of the program. To see this in action run the following through http://closure-compiler.appspot.com/home:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // @use\\_closure\\_library true\r\n> // @formatting pretty\\_print\r\n> // ==/ClosureCompiler==\r\n> \r\n> var lastMsg;\r\n> var map = {};\r\n> \r\n> var addToMap = function(key, func) {\r\n>  map[key] = func;\r\n> };\r\n> \r\n> var f1 = function() { alert('f1'); };\r\n> f1.alwaysCall = true;\r\n> var f2 = function() { alert('f2'); };\r\n> \r\n> addToMap('f1', f1);\r\n> addToMap('f2', f2);\r\n> \r\n> var callFunctionByKey = function(key) {\r\n>  var f = map[key];\r\n>  if (f.alwaysCall) f();\r\n> };\r\n> \r\n> callFunctionByKey(Math.random() > 0.5 ? 'f1' : 'f2');\r\n> \r\n> \r\n> The compiled code is:\r\n> \r\n> \r\n> var a = {};\r\n> a.f1 = function() {\r\n>  alert(\"f1\")\r\n> };\r\n> a.f2 = function() {\r\n>  alert(\"f2\")\r\n> };\r\n> var b = a[Math.random() > 0.5 ? \"f1\" : \"f2\"];\r\n> b.a && b();\r\n> \r\n> Note that a.f1 does not have a property defined on it anymore, though it still appears to be checked on this line of code:\r\n> \r\n> b.a && b();\r\n> \r\n> So it looks like it is missing the following:\r\n> \r\n> a.f1.a = true;\r\n> \r\n> For now, I can workaround this by quoting the property:\r\n> \r\n> f1['alwaysCall'] = true;\r\n> \r\n> // In callFunctionByKey:\r\n> if (f['alwaysCall']) f();\r\n> \r\n> But that seems as though it should not be necessary.", "test_name": "com.google.javascript.jscomp.CollapsePropertiesTest::testAddPropertyToChildOfUncollapsibleFunctionInLocalScope", "test_method": "  public void testAddPropertyToChildOfUncollapsibleFunctionInLocalScope() {\n    testSame(\n        \"function a() {} a.b = {x: 0}; var c = a;\" +\n        \"(function() {a.b.y = 0;})(); a.b.y;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tcom.google.javascript.jscomp.CollapsePropertiesTest.testAddPropertyToChildOfUncollapsibleFunctionInLocalScope(CollapsePropertiesTest.java:610)", "buggy_method": "477 private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n478     Node rvalue = ref.node.getNext();\n479     Node parent = ref.node.getParent();\n480     Node gramps = parent.getParent();\n481     Node greatGramps = gramps.getParent();\n482     Node greatGreatGramps = greatGramps.getParent();\n483 \n484 \n485     // Create the new alias node.\n486     Node nameNode = NodeUtil.newName(\n487         compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n488         refName.fullName());\n489     NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n490 \n491     if (gramps.getType() == Token.EXPR_RESULT) {\n492       // BEFORE: a.b.c = ...;\n493       //   exprstmt\n494       //     assign\n495       //       getprop\n496       //         getprop\n497       //           name a\n498       //           string b\n499       //         string c\n500       //       NODE\n501       // AFTER: var a$b$c = ...;\n502       //   var\n503       //     name a$b$c\n504       //       NODE\n505 \n506       // Remove the rvalue (NODE).\n507       parent.removeChild(rvalue);\n508       nameNode.addChildToFront(rvalue);\n509 \n510       Node varNode = new Node(Token.VAR, nameNode);\n511       greatGramps.replaceChild(gramps, varNode);\n512     } else {\n513       // This must be a complex assignment.\n514       Preconditions.checkNotNull(ref.getTwin());\n515 \n516       // BEFORE:\n517       // ... (x.y = 3);\n518       //\n519       // AFTER:\n520       // var x$y;\n521       // ... (x$y = 3);\n522 \n523       Node current = gramps;\n524       Node currentParent = gramps.getParent();\n525       for (; currentParent.getType() != Token.SCRIPT &&\n526              currentParent.getType() != Token.BLOCK;\n527            current = currentParent,\n528            currentParent = currentParent.getParent()) {}\n529 \n530       // Create a stub variable declaration right\n531       // before the current statement.\n532       Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n533           .copyInformationFrom(nameNode);\n534       currentParent.addChildBefore(stubVar, current);\n535 \n536       parent.replaceChild(ref.node, nameNode);\n537     }\n538 \n539     compiler.reportCodeChange();\n540   }", "bm_classpath": "com.google.javascript.jscomp.CollapseProperties"}, {"bug_name": "Closure_90", "report_text": "> @this emits warning when used with a typedef\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Compile this with r520:\r\n> \r\n> goog.provide('bug');\r\n> \r\n> /\\*\\*\r\n>  \\* @this {bug.Thing}\r\n>  \\*/\r\n> bug.sharedMethod = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> bug.A = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> bug.B = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @type {bug.A|bug.B}\r\n>  \\*/\r\n> bug.Thing = goog.typedef;\r\n> \r\n> 2. Observe this warning:\r\n> \r\n> Oct 28, 2010 9:59:15 PM com.google.javascript.jscomp.PhaseOptimizer$NamedPass process\r\n> INFO: sanityCheckVars\r\n> Oct 28, 2010 9:59:15 PM com.google.javascript.jscomp.LoggerErrorManager println\r\n> WARNING: /home/elf/JSPATH/compiler\\_bug\\_this\\_typedef.js:6: WARNING - @this type of a function must be an object\r\n> Actual type: (bug.A|bug.B|null)\r\n> bug.sharedMethod = function() {};\r\n> \r\n> \r\n> Note that @this {!bug.Thing} doesn't work either, while @this {bug.A|bug.B} works. This code did not emit a warning in r481.\r\n> \r\n> This code is what caused me to run into http://code.google.com/p/closure-compiler/issues/detail?id=268", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse8", "test_method": "  public void testBackwardsTypedefUse8() throws Exception {\n    // Tehnically, this isn't quite right, because the JS runtime\n    // will coerce null -> the global object. But we'll punt on that for now.\n    testTypes(\n        \"/** @param {!Array} x */ function g(x) {}\" +\n        \"/** @this {goog.MyTypedef} */ function f() { g(this); }\" +\n        \"var goog = {};\" +\n        \"/** @typedef {(Array|null|undefined)} */ goog.MyTypedef;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7752)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7726)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7670)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7666)\n\tcom.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse8(TypeCheckTest.java:2670)", "buggy_method": "176 @Override\n177     public boolean apply(JSType type) {\n178       // TODO(user): Doing an instanceof check here is too\n179       // restrictive as (Date,Error) is, for instance, an object type\n180       // even though its implementation is a UnionType. Would need to\n181       // create interfaces JSType, ObjectType, FunctionType etc and have\n182       // separate implementation instead of the class hierarchy, so that\n183       // union types can also be object types, etc.\n184       if (!type.isSubtype(\n185               typeRegistry.getNativeType(OBJECT_TYPE))) {\n186         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n187         return false;\n188       }\n189       return true;\n190     }", "bm_classpath": "com.google.javascript.jscomp.FunctionTypeBuilder$ThisTypeValidator"}, {"bug_name": "Closure_91", "report_text": "> support @lends annotation\n> \n> Some javascript toolkits (dojo, base, etc.) have a special way of declaring (what java calls) classes, for example in dojo:\r\n> \r\n> dojo.declare(\"MyClass\", [superClass1, superClass2], { \r\n>  foo: function(){ ... } \r\n>  bar: function(){ ... } \r\n> }); \r\n> \r\n> JSDoc (or at least JSDoc toolkit) supports this via annotations: \r\n> \r\n> /\\*\\* \r\n>  \\* @name MyClass \r\n>  \\* @class \r\n>  \\* @extends superClass1 \r\n>  \\* @extends superClass2 \r\n>  \\*/ \r\n> dojo.declare(\"MyClass\", [superClass1, superClass2], /\\*\\* @lends \r\n> MyClass.prototype \\*/ { \r\n>  foo: function(){ ... } \r\n>  bar: function(){ ... } \r\n> }); \r\n> \r\n> The @lends keyword in particular is useful since it tells JSDoc that foo and bar are part of MyClass's prototype. But closure compiler isn't picking up on that, thus I get a bunch of errors about \"dangerous use of this\" inside of foo() and bar(). \r\n> \r\n> So, can @lends support be added to the closure compiler?\r\n> \r\n> The workaround is to use @this on every method, but not sure if that is sufficient to make advanced mode compilation work correctly.", "test_name": "com.google.javascript.jscomp.CheckGlobalThisTest::testLendsAnnotation3", "test_method": "  public void testLendsAnnotation3() {\n    testSame(\"/** @constructor */ function F() {}\" +\n        \"dojo.declare(F, /** @lends {F.prototype} */ (\" +\n        \"    {foo: function() { return this.foo; }}));\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS. dangerous use of the global this object at testcode line 1 : 110 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:733)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:306)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:275)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:263)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:491)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testLendsAnnotation3(CheckGlobalThisTest.java:236)", "buggy_method": "82 public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n83 \n84     if (n.getType() == Token.FUNCTION) {\n85       // Don't traverse functions that are constructors or have the @this\n86       // or @override annotation.\n87       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n88       if (jsDoc != null &&\n89           (jsDoc.isConstructor() ||\n90            jsDoc.isInterface() ||\n91            jsDoc.hasThisType() ||\n92            jsDoc.isOverride())) {\n93         return false;\n94       }\n95 \n96       // Don't traverse functions unless they would normally\n97       // be able to have a @this annotation associated with them. e.g.,\n98       // var a = function() { }; // or\n99       // function a() {} // or\n100       // a.x = function() {}; // or\n101       // var a = {x: function() {}};\n102       int pType = parent.getType();\n103       if (!(pType == Token.BLOCK ||\n104             pType == Token.SCRIPT ||\n105             pType == Token.NAME ||\n106             pType == Token.ASSIGN ||\n107 \n108             // object literal keys\n109             pType == Token.STRING ||\n110             pType == Token.NUMBER)) {\n111         return false;\n112       }\n113 \n114       // Don't traverse functions that are getting lent to a prototype.\n115     }\n116 \n117     if (parent != null && parent.getType() == Token.ASSIGN) {\n118       Node lhs = parent.getFirstChild();\n119       Node rhs = lhs.getNext();\n120 \n121       if (n == lhs) {\n122         // Always traverse the left side of the assignment. To handle\n123         // nested assignments properly (e.g., (a = this).property = c;),\n124         // assignLhsChild should not be overridden.\n125         if (assignLhsChild == null) {\n126           assignLhsChild = lhs;\n127         }\n128       } else {\n129         // Only traverse the right side if it's not an assignment to a prototype\n130         // property or subproperty.\n131         if (NodeUtil.isGet(lhs)) {\n132           if (lhs.getType() == Token.GETPROP &&\n133               lhs.getLastChild().getString().equals(\"prototype\")) {\n134             return false;\n135           }\n136           Node llhs = lhs.getFirstChild();\n137           if (llhs.getType() == Token.GETPROP &&\n138               llhs.getLastChild().getString().equals(\"prototype\")) {\n139             return false;\n140           }\n141         }\n142       }\n143     }\n144 \n145     return true;\n146   }", "bm_classpath": "com.google.javascript.jscomp.CheckGlobalThis"}, {"bug_name": "Closure_92", "report_text": "> bug with implicit namespaces across modules\n> \n> If there are three modules, the latter two of which depend on the root module:\r\n> \r\n> // Module A\r\n> goog.provide('apps');\r\n> \r\n> // Module B\r\n> goog.provide('apps.foo.bar.B');\r\n> \r\n> // Module C\r\n> goog.provide('apps.foo.bar.C');\r\n> \r\n> and this is compiled in SIMPLE\\_OPTIMIZATIONS mode, the following code will be produced:\r\n> \r\n> // Module A\r\n> var apps={};apps.foo.bar={};apps.foo={};\r\n> \r\n> // Module B\r\n> apps.foo.bar.B={};\r\n> \r\n> // Module C\r\n> apps.foo.bar.C={};\r\n> \r\n> This will result in a runtime error in Module A because apps.foo.bar is assigned before apps.foo.\r\n> \r\n> The patch for the fix (with regression test) is available at:\r\n> http://codereview.appspot.com/2416041", "test_name": "com.google.javascript.jscomp.ProcessClosurePrimitivesTest::testProvideInIndependentModules4", "test_method": "  public void testProvideInIndependentModules4() {\n    // Regression test for bug 261:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=261\n    test(\n        createModuleStar(\n            \"goog.provide('apps');\",\n            \"goog.provide('apps.foo.bar.B');\",\n            \"goog.provide('apps.foo.bar.C');\"),\n        new String[] {\n            \"var apps = {};apps.foo = {};apps.foo.bar = {}\",\n            \"apps.foo.bar.B = {};\",\n            \"apps.foo.bar.C = {};\",\n        }); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:645)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:482)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:463)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:450)\n\tcom.google.javascript.jscomp.ProcessClosurePrimitivesTest.testProvideInIndependentModules4(ProcessClosurePrimitivesTest.java:777)", "buggy_method": "747 void replace() {\n748       if (firstNode == null) {\n749         // Don't touch the base case ('goog').\n750         replacementNode = candidateDefinition;\n751         return;\n752       }\n753 \n754       // Handle the case where there is a duplicate definition for an explicitly\n755       // provided symbol.\n756       if (candidateDefinition != null && explicitNode != null) {\n757         explicitNode.detachFromParent();\n758         compiler.reportCodeChange();\n759 \n760         // Does this need a VAR keyword?\n761         replacementNode = candidateDefinition;\n762         if (NodeUtil.isExpressionNode(candidateDefinition)) {\n763           candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n764           Node assignNode = candidateDefinition.getFirstChild();\n765           Node nameNode = assignNode.getFirstChild();\n766           if (nameNode.getType() == Token.NAME) {\n767             // Need to convert this assign to a var declaration.\n768             Node valueNode = nameNode.getNext();\n769             assignNode.removeChild(nameNode);\n770             assignNode.removeChild(valueNode);\n771             nameNode.addChildToFront(valueNode);\n772             Node varNode = new Node(Token.VAR, nameNode);\n773             varNode.copyInformationFrom(candidateDefinition);\n774             candidateDefinition.getParent().replaceChild(\n775                 candidateDefinition, varNode);\n776             nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n777             compiler.reportCodeChange();\n778             replacementNode = varNode;\n779           }\n780         }\n781       } else {\n782         // Handle the case where there's not a duplicate definition.\n783         replacementNode = createDeclarationNode();\n784         if (firstModule == minimumModule) {\n785           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n786         } else {\n787           // In this case, the name was implicitly provided by two independent\n788           // modules. We need to move this code up to a common module.\n789           int indexOfDot = namespace.indexOf('.');\n790           if (indexOfDot == -1) {\n791             // Any old place is fine.\n792             compiler.getNodeForCodeInsertion(minimumModule)\n793                 .addChildToBack(replacementNode);\n794           } else {\n795             // Add it after the parent namespace.\n796             ProvidedName parentName =\n797                 providedNames.get(namespace.substring(0, indexOfDot));\n798             Preconditions.checkNotNull(parentName);\n799             Preconditions.checkNotNull(parentName.replacementNode);\n800             parentName.replacementNode.getParent().addChildAfter(\n801                 replacementNode, parentName.replacementNode);\n802           }\n803         }\n804         if (explicitNode != null) {\n805           explicitNode.detachFromParent();\n806         }\n807         compiler.reportCodeChange();\n808       }\n809     }", "bm_classpath": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName"}, {"bug_name": "Closure_94", "report_text": "> closure-compiler @define annotation does not allow line to be split on 80 characters.\n> \n> **What steps will reproduce the problem?**\n> 1. Create a JavaScript file with the followiing:\r\n> /\\*\\* @define {string} \\*/\r\n> var CONSTANT = \"some very long string name that I want to wrap \" +\r\n>  \"and so break using a + since I don't want to \" +\r\n>  \"introduce a newline into the string.\"\r\n> 2. Run closure-compiler on the .js file.\r\n> 3. See it generate an error on the '+'.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> It should work, since the line is assigning a constant value to the var.\r\n> \r\n> **Please provide any additional information below.**\n> Removing the '+' and making the string all one line does work correctly.", "test_name": "com.google.javascript.jscomp.NodeUtilTest::testValidDefine", "test_method": "  public void testValidDefine() {\n    \n    \n    assertTrue(testValidDefineValue(\"1 + 8\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.NodeUtilTest.testValidDefine(NodeUtilTest.java:1086)", "buggy_method": "320 static boolean isValidDefineValue(Node val, Set<String> defines) {\n321     switch (val.getType()) {\n322       case Token.STRING:\n323       case Token.NUMBER:\n324       case Token.TRUE:\n325       case Token.FALSE:\n326         return true;\n327 \n328       // Binary operators are only valid if both children are valid.\n329       case Token.BITAND:\n330       case Token.BITNOT:\n331       case Token.BITOR:\n332       case Token.BITXOR:\n333 \n334       // Uniary operators are valid if the child is valid.\n335       case Token.NOT:\n336       case Token.NEG:\n337         return isValidDefineValue(val.getFirstChild(), defines);\n338 \n339       // Names are valid if and only if they are defines themselves.\n340       case Token.NAME:\n341       case Token.GETPROP:\n342         if (val.isQualifiedName()) {\n343           return defines.contains(val.getQualifiedName());\n344         }\n345     }\n346     return false;\n347   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_95", "report_text": "> Use @public tag to prevent compression of symbol names\n> \n> Given this input code:\r\n> \r\n>  Glow = {};\r\n>  /\\*\\* @public \\*/ Glow.versions = [1,2,3];\r\n>  Glow.showVersions = function() { alert(Glow.versions); }\r\n>  \r\n>  // exports\r\n>  window['Glow'] = Glow;\r\n>  Glow['versions'] = Glow.versions;\r\n>  Glow['showVersions'] = Glow.showVersions;\r\n> \r\n> The compiler (with ADVANCED\\_OPTIMIZATIONS on) will produce the following\r\n> output code:\r\n> \r\n>  Glow = {};\r\n>  Glow.a = [1, 2, 3];\r\n>  Glow.b = function() { alert(Glow.a) };\r\n>  window.Glow = Glow;\r\n>  Glow.versions = Glow.a;\r\n>  Glow.showVersions = Glow.b\r\n> \r\n> From outside the Glow library, a user may do the following (in their own,\r\n> uncompressed code):\r\n> \r\n>  Glow.versions = [4,5,6];\r\n>  Glow.showVersions();\r\n> \r\n> Only in the compiled code will the user-code produces \"1,2,3\" instead of\r\n> the expected \"4,5,6\". This is because the compiler renamed the reference to\r\n> [1,2,3] in `showVersions()` to \"Glow.a\", whilst the user assigned a new\r\n> array to \"Glow.versions\", and therefore the two different names now refer\r\n> to two different arrays.\r\n> \r\n> I can avoid this by using the stringy-name to refer to Glow[\"versions\"],\r\n> but I would then have to do that everywhere in my code which is a annoying\r\n> and bug-prone (if I or someone else should ever forget). I'd prefer to tell\r\n> the compiler once about my wish to have a property name left uncompresed,\r\n> rather than relying on a side effect (the fact that the compiler won't\r\n> compress stringy-named properties) and then having to invoke that\r\n> side-effect consistently everywhere.\r\n> \r\n> Instead I'm requesting that when the compiler sees a property is marked by\r\n> the author as @public it should then leave that name uncompressed everywhere.\r\n> \r\n> So, given the input code above, the desired output would be:\r\n> \r\n>  Glow = {};\r\n>  Glow.versions = [1, 2, 3];\r\n>  Glow.b = function() { alert(Glow.versions) };\r\n>  window.Glow = Glow;\r\n>  Glow.versions = Glow.versions; // not needed now\r\n>  Glow.showVersions = Glow.b\r\n> \r\n> I'm not fixed on a particular tag, but @public seems an obvious choice, and\r\n> I'd prefer to use tags that already exist in JsDoc Toolkit.\r\n> \r\n> Note that my proposed feature is different than the `@export Glow.versions`\r\n> tag proposal, as that tag would merely be a shortcut for \"Glow['versions']\r\n> = Glow.versions;\", which, as I've shown above, doesn't solve this problem.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testQualifiedNameInference5", "test_method": "  public void testQualifiedNameInference5() throws Exception {\n    testTypes(\n        \"var ns = {}; \" +\n        \"(function() { \" +\n        \"    /** @param {number} x */ ns.foo = function(x) {}; })();\" +\n        \"(function() { ns.foo(true); })();\",\n        \"actual parameter 1 of ns.foo does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7365)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7345)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7298)\n\tcom.google.javascript.jscomp.TypeCheckTest.testQualifiedNameInference5(TypeCheckTest.java:4761)", "buggy_method": "872 void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n873       Preconditions.checkArgument(inferred || type != null);\n874 \n875       // Only allow declarations of NAMEs and qualfied names.\n876       boolean shouldDeclareOnGlobalThis = false;\n877       if (n.getType() == Token.NAME) {\n878         Preconditions.checkArgument(\n879             parent.getType() == Token.FUNCTION ||\n880             parent.getType() == Token.VAR ||\n881             parent.getType() == Token.LP ||\n882             parent.getType() == Token.CATCH);\n883         shouldDeclareOnGlobalThis = scope.isGlobal() &&\n884             (parent.getType() == Token.VAR ||\n885              parent.getType() == Token.FUNCTION);\n886       } else {\n887         Preconditions.checkArgument(\n888             n.getType() == Token.GETPROP &&\n889             (parent.getType() == Token.ASSIGN ||\n890              parent.getType() == Token.EXPR_RESULT));\n891       }\n892       String variableName = n.getQualifiedName();\n893       Preconditions.checkArgument(!variableName.isEmpty());\n894 \n895       // If n is a property, then we should really declare it in the\n896       // scope where the root object appears. This helps out people\n897       // who declare \"global\" names in an anonymous namespace.\n898       Scope scopeToDeclareIn = scope;\n899 \n900         // don't try to declare in the global scope if there's\n901         // already a symbol there with this name.\n902 \n903       // declared in closest scope?\n904       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n905         Var oldVar = scopeToDeclareIn.getVar(variableName);\n906         validator.expectUndeclaredVariable(\n907             sourceName, n, parent, oldVar, variableName, type);\n908       } else {\n909         if (!inferred) {\n910           setDeferredType(n, type);\n911         }\n912         CompilerInput input = compiler.getInput(sourceName);\n913         scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n914 \n915         if (shouldDeclareOnGlobalThis) {\n916           ObjectType globalThis =\n917               typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n918           boolean isExtern = input.isExtern();\n919           if (inferred) {\n920             globalThis.defineInferredProperty(variableName,\n921                 type == null ?\n922                     getNativeType(JSTypeNative.NO_TYPE) :\n923                     type,\n924                 isExtern);\n925           } else {\n926             globalThis.defineDeclaredProperty(variableName, type, isExtern);\n927           }\n928         }\n929 \n930         // If we're in the global scope, also declare var.prototype\n931         // in the scope chain.\n932         if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n933           FunctionType fnType = (FunctionType) type;\n934           if (fnType.isConstructor() || fnType.isInterface()) {\n935             FunctionType superClassCtor = fnType.getSuperClassConstructor();\n936             scopeToDeclareIn.declare(variableName + \".prototype\", n,\n937                 fnType.getPrototype(), compiler.getInput(sourceName),\n938                 /* declared iff there's an explicit supertype */\n939                 superClassCtor == null ||\n940                 superClassCtor.getInstanceType().equals(\n941                     getNativeType(OBJECT_TYPE)));\n942           }\n943         }\n944       }\n945     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_96", "report_text": "> Missing type-checks for var_args notation\n> \n> **What steps will reproduce the problem?**\n> 1. Compile this:\r\n> //-------------------------------------\r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @warning\\_level VERBOSE\r\n> // @output\\_file\\_name default.js\r\n> // @formatting pretty\\_print\r\n> // ==/ClosureCompiler==\r\n> \r\n> /\\*\\*\r\n> \\* @param {...string} var\\_args\r\n> \\*/\r\n> function foo(var\\_args) {\r\n>  return arguments.length;\r\n> }\r\n> \r\n> foo('hello'); // no warning - ok\r\n> foo(123); // warning - ok\r\n> foo('hello', 123); // no warning! error.\r\n> //-------------------------------------\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Should get a type-mismatch warning for the second parameter in the third foo() call.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Both online compiler and the 20100616 release.\r\n> \r\n> **Please provide any additional information below.**\n> Seems like the type-checker treats 'var\\_args' as a single param and thus fails to type check the subsequent parameters.\r\n> \r\n> // Fredrik", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testFunctionArguments16", "test_method": "  public void testFunctionArguments16() throws Exception {\n    testTypes(\n        \"/** @param {...number} var_args */\" +\n        \"function g(var_args) {} g(1, true);\",\n        \"actual parameter 2 of g does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: (number|undefined)\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7294)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7274)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7227)\n\tcom.google.javascript.jscomp.TypeCheckTest.testFunctionArguments16(TypeCheckTest.java:1362)", "buggy_method": "1399 private void visitParameterList(NodeTraversal t, Node call,\n1400       FunctionType functionType) {\n1401     Iterator<Node> arguments = call.children().iterator();\n1402     arguments.next(); // skip the function name\n1403 \n1404     Iterator<Node> parameters = functionType.getParameters().iterator();\n1405     int ordinal = 0;\n1406     Node parameter = null;\n1407     Node argument = null;\n1408     while (arguments.hasNext() &&\n1409            parameters.hasNext()) {\n1410       // If there are no parameters left in the list, then the while loop\n1411       // above implies that this must be a var_args function.\n1412         parameter = parameters.next();\n1413       argument = arguments.next();\n1414       ordinal++;\n1415 \n1416       validator.expectArgumentMatchesParameter(t, argument,\n1417           getJSType(argument), getJSType(parameter), call, ordinal);\n1418     }\n1419 \n1420     int numArgs = call.getChildCount() - 1;\n1421     int minArgs = functionType.getMinArguments();\n1422     int maxArgs = functionType.getMaxArguments();\n1423     if (minArgs > numArgs || maxArgs < numArgs) {\n1424       report(t, call, WRONG_ARGUMENT_COUNT,\n1425               validator.getReadableJSTypeName(call.getFirstChild(), false),\n1426               String.valueOf(numArgs), String.valueOf(minArgs),\n1427               maxArgs != Integer.MAX_VALUE ?\n1428               \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n1429     }\n1430   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_97", "report_text": "> Unsigned Shift Right (>>>) bug operating on negative numbers\n> \n> **What steps will reproduce the problem?**\n> i = -1 >>> 0 ;\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Expected: i = -1 >>> 0 ; // or // i = 4294967295 ;\r\n> Instead: i = -1 ;\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> The UI version as of 7/18/2001 (http://closure-compiler.appspot.com/home)\r\n> \r\n> **Please provide any additional information below.**\n> -1 >>> 0 == 4294967295 == Math.pow( 2, 32 ) - 1\r\n> Test in any browser and/or See ECMA-262-5 11.7.3", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldBitShifts", "test_method": "  public void testFoldBitShifts() {\n    fold(\"x = 1 << 0\", \"x = 1\");\n    fold(\"x = -1 << 0\", \"x = -1\");\n    fold(\"x = 1 << 1\", \"x = 2\");\n    fold(\"x = 3 << 1\", \"x = 6\");\n    fold(\"x = 1 << 8\", \"x = 256\");\n\n    fold(\"x = 1 >> 0\", \"x = 1\");\n    fold(\"x = -1 >> 0\", \"x = -1\");\n    fold(\"x = 1 >> 1\", \"x = 0\");\n    fold(\"x = 2 >> 1\", \"x = 1\");\n    fold(\"x = 5 >> 1\", \"x = 2\");\n    fold(\"x = 127 >> 3\", \"x = 15\");\n    fold(\"x = 3 >> 1\", \"x = 1\");\n    fold(\"x = 3 >> 2\", \"x = 0\");\n    fold(\"x = 10 >> 1\", \"x = 5\");\n    fold(\"x = 10 >> 2\", \"x = 2\");\n    fold(\"x = 10 >> 5\", \"x = 0\");\n\n    fold(\"x = 10 >>> 1\", \"x = 5\");\n    fold(\"x = 10 >>> 2\", \"x = 2\");\n    fold(\"x = 10 >>> 5\", \"x = 0\");\n    fold(\"x = -1 >>> 1\", \"x = 2147483647\"); // 0x7fffffff\n    fold(\"x = -1 >>> 0\", \"x = 4294967295\"); // 0xffffffff // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:792)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:258)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.fold(PeepholeFoldConstantsTest.java:58)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testFoldBitShifts(PeepholeFoldConstantsTest.java:263)", "buggy_method": "652 private Node tryFoldShift(Node n, Node left, Node right) {\n653     if (left.getType() == Token.NUMBER &&\n654         right.getType() == Token.NUMBER) {\n655 \n656       double result;\n657       double lval = left.getDouble();\n658       double rval = right.getDouble();\n659 \n660       // check ranges.  We do not do anything that would clip the double to\n661       // a 32-bit range, since the user likely does not intend that.\n662       if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n663         error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n664         return n;\n665       }\n666 \n667       // only the lower 5 bits are used when shifting, so don't do anything\n668       // if the shift amount is outside [0,32)\n669       if (!(rval >= 0 && rval < 32)) {\n670         error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n671         return n;\n672       }\n673 \n674       // Convert the numbers to ints\n675       int lvalInt = (int) lval;\n676       if (lvalInt != lval) {\n677         error(FRACTIONAL_BITWISE_OPERAND, left);\n678         return n;\n679       }\n680 \n681       int rvalInt = (int) rval;\n682       if (rvalInt != rval) {\n683         error(FRACTIONAL_BITWISE_OPERAND, right);\n684         return n;\n685       }\n686 \n687       switch (n.getType()) {\n688         case Token.LSH:\n689           result = lvalInt << rvalInt;\n690           break;\n691         case Token.RSH:\n692           result = lvalInt >> rvalInt;\n693           break;\n694         case Token.URSH:\n695           // JavaScript handles zero shifts on signed numbers differently than\n696           // Java as an Java int can not represent the unsigned 32-bit number\n697           // where JavaScript can so use a long here.\n698           result = lvalInt >>> rvalInt;\n699           break;\n700         default:\n701           throw new AssertionError(\"Unknown shift operator: \" +\n702               Node.tokenToName(n.getType()));\n703       }\n704 \n705       Node newNumber = Node.newNumber(result);\n706       n.getParent().replaceChild(n, newNumber);\n707       reportCodeChange();\n708 \n709       return newNumber;\n710     }\n711 \n712     return n;\n713   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_98", "report_text": "> bad variable inlining in closure\n> \n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // @formatting pretty\\_print\r\n> // ==/ClosureCompiler==\r\n> \r\n> function foo() {\r\n>  var arr = [1, 2, 3, 4, 5];\r\n>  for (var i = 0, l = arr.length; i < l; i++) {\r\n>  var j = arr[i];\r\n>  (function() {\r\n>  var k = j;\r\n>  setTimeout(function() { console.log(k); }, 0);\r\n>  })();\r\n>  }\r\n> }\r\n> foo();\r\n> \r\n> \"k\" will get incorrectly inlined.", "test_name": "com.google.javascript.jscomp.InlineVariablesTest::testNoInlineAliasesInLoop", "test_method": "  public void testNoInlineAliasesInLoop() {\n    testSame(\n        \"function f() { \" +\n        \"  for (var i = 0; i < 5; i++) {\" +\n        \"    var x = extern();\" +\n        \"    (function() {\" +\n        \"       var y = x; window.setTimeout(function() { extern(y); }, 0);\" +\n        \"     })();\" +\n        \"  }\" +\n        \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:777)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:258)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)\n\tcom.google.javascript.jscomp.InlineVariablesTest.testNoInlineAliasesInLoop(InlineVariablesTest.java:617)", "buggy_method": "354 boolean isAssignedOnceInLifetime() {\n355       Reference ref = getOneAndOnlyAssignment();\n356       if (ref == null) {\n357         return false;\n358       }\n359 \n360       // Make sure this assignment is not in a loop.\n361 \n362       return true;\n363     }", "bm_classpath": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceCollection"}, {"bug_name": "Closure_99", "report_text": "> Prototypes declared with quotes produce a JSC_USED_GLOBAL_THIS warning.\n> \n> Compiling the following code (in advanced optimizations with VERBOSE\r\n> warning levels):\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> function MyClass() {}\r\n> MyClass.prototype[\"MyMethod\"] = function(a) {\r\n>  this.a = a;\r\n> }\r\n> window[\"MyClass\"] = MyClass;\r\n> \r\n> Results in the following warning: \"dangerous use of the global this\r\n> object.\" This notation is convenient to declare a prototype that is purely\r\n> used for export purposes. The warning can be suppressed by using an @this\r\n> notation.\r\n> \r\n> Given the following externs:\r\n> \r\n> /\\*\\*@interface \\*/\r\n> function MyParent() {}\r\n> /\\*\\* @param {\\*} a \\*/\r\n> MyParent.prototype.MyMethod = function(a) {}\r\n> \r\n> And the following code:\r\n> \r\n> /\\*\\*\r\n> \\* @constructor\r\n> \\* @implements {MyParent}\r\n> \\*/\r\n> function MyClass() {}\r\n> MyClass.prototype[\"MyMethod\"] = function(a) {\r\n>  this.a2 = a;\r\n> }\r\n> window[\"MyClass\"] = MyClass;\r\n> \r\n> The compiler also produces the waring: \"property MyMethod on interface\r\n> MyParent is not implemented by type MyClass\".", "test_name": "com.google.javascript.jscomp.CheckGlobalThisTest::testPropertyOfMethod", "test_method": "  public void testPropertyOfMethod() {\n    testFailure(\"a.protoype.b = {}; \" +\n        \"a.prototype.b.c = function() { this.foo = 3; };\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:817)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testFailure(CheckGlobalThisTest.java:36)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testPropertyOfMethod(CheckGlobalThisTest.java:158)", "buggy_method": "84 public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n85 \n86     if (n.getType() == Token.FUNCTION) {\n87       // Don't traverse functions that are constructors or have the @this\n88       // or @override annotation.\n89       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n90       if (jsDoc != null &&\n91           (jsDoc.isConstructor() ||\n92            jsDoc.hasThisType() ||\n93            jsDoc.isOverride())) {\n94         return false;\n95       }\n96 \n97       // Don't traverse functions unless they would normally\n98       // be able to have a @this annotation associated with them. e.g.,\n99       // var a = function() { }; // or\n100       // function a() {} // or\n101       // a.x = function() {};\n102       int pType = parent.getType();\n103       if (!(pType == Token.BLOCK ||\n104             pType == Token.SCRIPT ||\n105             pType == Token.NAME ||\n106             pType == Token.ASSIGN)) {\n107         return false;\n108       }\n109     }\n110 \n111     if (parent != null && parent.getType() == Token.ASSIGN) {\n112       Node lhs = parent.getFirstChild();\n113       Node rhs = lhs.getNext();\n114       \n115       if (n == lhs) {\n116         // Always traverse the left side of the assignment. To handle\n117         // nested assignments properly (e.g., (a = this).property = c;),\n118         // assignLhsChild should not be overridden.\n119         if (assignLhsChild == null) {\n120           assignLhsChild = lhs;\n121         }\n122       } else {\n123         // Only traverse the right side if it's not an assignment to a prototype\n124         // property or subproperty.\n125           if (lhs.getType() == Token.GETPROP &&\n126               lhs.getLastChild().getString().equals(\"prototype\")) {\n127             return false;\n128           }\n129           if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n130             return false;\n131           }\n132       }\n133     }\n134 \n135     return true;\n136   }", "bm_classpath": "com.google.javascript.jscomp.CheckGlobalThis"}, {"bug_name": "Closure_100", "report_text": "> Only assignment to \"this\" issues a \"dangerous use of the global this object\" warning.\n> \n> **What steps will reproduce the problem?**\n> 1. Compile this:\r\n> //////////////////////////////////////////\r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> function Foo()\r\n> {\r\n>  this.\\_bar = null;\r\n> };\r\n> \r\n> /\\*\\* @this {Foo} \\*/\r\n> function writeMethodWithAnnotation()\r\n> {\r\n>  this.\\_bar = 123; // no warning. ok\r\n> }\r\n> \r\n> /\\*\\* @this {Foo} \\*/\r\n> function readMethodWithAnnotation()\r\n> {\r\n>  return this.\\_bar; // no warning. ok\r\n> }\r\n> \r\n> //----\r\n> \r\n> function writeMethodWithoutAnnotation()\r\n> {\r\n>  this.\\_bar = 123; // warning. ok.\r\n> }\r\n> \r\n> function readMethodWithoutAnnotation()\r\n> {\r\n>  return this.\\_bar; // <- No warning!\r\n> }\r\n> //////////////////////////////////////////\r\n> \r\n> **What is the expected output? What do you see instead?**\n> - Should get two \"dangerous use of the global this object\" warnings in the \r\n> readMethodWithAnnotation and writeMethodWithoutAnnotation functions.\r\n> - Only writeMethodWithoutAnnotation warns.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Both 20100330 and online compiler.\r\n> \r\n> **Please provide any additional information below.**\n> ref: http://code.google.com/closure/compiler/docs/js-for-compiler.html \r\n> \"To prevent compiler warnings, you must use a @this annotation whenever \r\n> this appears in a function that is neither a prototype method nor a \r\n> function marked as a @constructor.\"\r\n> \r\n> This also means the example code in the docs won't trig a warning.\r\n> -----\r\n> /\\*\\*\r\n>  \\* Returns the roster widget element.\r\n>  \\* @this {Widget} <-- currently this doesn't matter\r\n>  \\* @return {Element}\r\n>  \\*/\r\n> function() {\r\n>  return this.getComponent().getElement();\r\n> });\r\n> ------\r\n> \r\n> // Fredrik", "test_name": "com.google.javascript.jscomp.CheckGlobalThisTest::testStaticFunction6", "test_method": "  public void testStaticFunction6() {\n    testSame(\"function a() { return function() { this = 8; } }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS. dangerous use of the global this object at testcode line 1 : 35 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:712)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:258)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:486)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testStaticFunction6(CheckGlobalThisTest.java:88)", "buggy_method": "84 public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n85 \n86     if (n.getType() == Token.FUNCTION) {\n87       // Don't traverse functions that are constructors or have the @this\n88       // annotation.\n89       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n90       if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n91         return false;\n92       }\n93 \n94       // Don't traverse functions unless they would normally\n95       // be able to have a @this annotation associated with them. e.g.,\n96       // var a = function() { }; // or\n97       // function a() {} // or\n98       // a.x = function() {};\n99     }\n100 \n101     if (parent != null && parent.getType() == Token.ASSIGN) {\n102       Node lhs = parent.getFirstChild();\n103       Node rhs = lhs.getNext();\n104       \n105       if (n == lhs) {\n106         // Always traverse the left side of the assignment. To handle\n107         // nested assignments properly (e.g., (a = this).property = c;),\n108         // assignLhsChild should not be overridden.\n109         if (assignLhsChild == null) {\n110           assignLhsChild = lhs;\n111         }\n112       } else {\n113         // Only traverse the right side if it's not an assignment to a prototype\n114         // property or subproperty.\n115         if (lhs.getType() == Token.GETPROP) {\n116           if (lhs.getLastChild().getString().equals(\"prototype\")) {\n117             return false;\n118           }\n119           String leftName = lhs.getQualifiedName();\n120           if (leftName != null && leftName.contains(\".prototype.\")) {\n121             return false;\n122           }\n123         }\n124       }\n125     }\n126 \n127     return true;\n128   }", "bm_classpath": "com.google.javascript.jscomp.CheckGlobalThis"}, {"bug_name": "Closure_101", "report_text": "> --process_closure_primitives can't be set to false\n> \n> **What steps will reproduce the problem?**\n> 1. compile a file with \"--process\\_closure\\_primitives false\"\r\n> 2. compile a file with \"--process\\_closure\\_primitives true\" (default)\r\n> 3. result: primitives are processed in both cases.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> The file should still have its goog.provide/require tags in place.\r\n> Instead they are processed.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> current SVN (also tried two of the preceding binary releases with same \r\n> result)\r\n> \r\n> **Please provide any additional information below.**\n> Flag can't be set to false due to a missing \"else\" in the command-line \r\n> parser.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testProcessClosurePrimitives", "test_method": "  public void testProcessClosurePrimitives() {\n    test(\"var goog = {}; goog.provide('goog.dom');\",\n         \"var goog = {}; goog.dom = {};\");\n    args.add(\"--process_closure_primitives=false\");\n    testSame(\"var goog = {}; goog.provide('goog.dom');\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:254)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:230)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:226)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testProcessClosurePrimitives(CommandLineRunnerTest.java:158)", "buggy_method": "418 @Override\n419   protected CompilerOptions createOptions() {\n420     CompilerOptions options = new CompilerOptions();\n421     options.setCodingConvention(new ClosureCodingConvention());\n422     CompilationLevel level = flags.compilation_level;\n423     level.setOptionsForCompilationLevel(options);\n424     if (flags.debug) {\n425       level.setDebugOptionsForCompilationLevel(options);\n426     }\n427 \n428     WarningLevel wLevel = flags.warning_level;\n429     wLevel.setOptionsForWarningLevel(options);\n430     for (FormattingOption formattingOption : flags.formatting) {\n431       formattingOption.applyToOptions(options);\n432     }\n433     if (flags.process_closure_primitives) {\n434       options.closurePass = true;\n435     }\n436 \n437     initOptionsFromFlags(options);\n438     return options;\n439   }", "bm_classpath": "com.google.javascript.jscomp.CommandLineRunner"}, {"bug_name": "Closure_102", "report_text": "> compiler assumes that 'arguments' can be shadowed\n> \n> The code:\r\n> function name() {\r\n>  var arguments = Array.prototype.slice.call(arguments, 0);\r\n> }\r\n> \r\n> gets compiled to:\r\n> function name(){ var c=Array.prototype.slice.call(c,0); }\r\n> \r\n> Thanks to tescosquirrel for the report.", "test_name": "com.google.javascript.jscomp.CompilerRunnerTest::testIssue115", "test_method": "  public void testIssue115() {\n    CompilerRunner.FLAG_compilation_level.setForTest(\n        CompilationLevel.SIMPLE_OPTIMIZATIONS);\n    CompilerRunner.FLAG_warning_level.setForTest(\n        WarningLevel.VERBOSE);\n    test(\"function f() { \" +\n         \"  var arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\",\n         \"function f() { \" +\n         \"  arguments = Array.prototype.slice.call(arguments, 0);\" +\n         \"  return arguments[0]; \" +\n         \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerRunnerTest.test(CompilerRunnerTest.java:268)\n\tcom.google.javascript.jscomp.CompilerRunnerTest.test(CompilerRunnerTest.java:248)\n\tcom.google.javascript.jscomp.CompilerRunnerTest.testIssue115(CompilerRunnerTest.java:186)", "buggy_method": "86 @Override\n87   public void process(Node externs, Node root) {\n88     NodeTraversal.traverse(compiler, root, this);\n89     if (MAKE_LOCAL_NAMES_UNIQUE) {\n90       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n91       NodeTraversal t = new NodeTraversal(compiler, renamer);\n92       t.traverseRoots(externs, root);\n93     }\n94     removeDuplicateDeclarations(root);\n95     new PropogateConstantAnnotations(compiler, assertOnChange)\n96         .process(externs, root);\n97   }", "bm_classpath": "com.google.javascript.jscomp.Normalize"}, {"bug_name": "Closure_103", "report_text": "> Compiler gives false error with respect to unreachable code\n> \n> Try compiling the following in the Closure Compiler UI:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> function instanceOf(value, type) {\r\n>  try {\r\n>  // first try built-in test -- if it succeeds, we're golden.\r\n>  if (value instanceof type) {\r\n>  return true;\r\n>  }\r\n>  } catch (exception) {\r\n>  if (exception instanceof TypeError) {\r\n>  throw exception; // indicates that \"type\" is not a type\r\n>  }\r\n>  // Otherwise, assume the exception was caused by \r\n>  // the Firefox 1.0.3 bug. Work around it.\r\n>  return (type === Object);\r\n>  }\r\n> }\r\n> \r\n> The Compiler issues the following warning:\r\n> \r\n> JSC\\_UNREACHABLE\\_CODE: unreachable code at line 7 character 0\r\n>  } catch (exception) {\r\n> \r\n> This code is from a Firefox extension (Chickenfoot) where (at least\r\n> historically) calling instanceof in this manner could throw a security\r\n> exception (or something else, I forget what -- Chickenfoot has been around\r\n> since Firefox 1.0) which is why the catch blocks is there and is indeed\r\n> reachable.", "test_name": "com.google.javascript.jscomp.CheckUnreachableCodeTest::testInstanceOfThrowsException", "test_method": "  public void testInstanceOfThrowsException() {\n    testSame(\"function f() {try { if (value instanceof type) return true; } \" +\n             \"catch (e) { }}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_UNREACHABLE_CODE. unreachable code at testcode line 1 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:688)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:278)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:247)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:235)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:462)\n\tcom.google.javascript.jscomp.CheckUnreachableCodeTest.testInstanceOfThrowsException(CheckUnreachableCodeTest.java:140)", "buggy_method": "884 private static boolean mayThrowException(Node n) {\n885     switch (n.getType()) {\n886       case Token.CALL:\n887       case Token.GETPROP:\n888       case Token.GETELEM:\n889       case Token.THROW:\n890       case Token.NEW:\n891       case Token.ASSIGN:\n892       case Token.INC:\n893       case Token.DEC:\n894         return true;\n895       case Token.FUNCTION:\n896         return false;\n897     }\n898     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n899       if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n900         return true;\n901       }\n902     }\n903     return false;\n904   }", "bm_classpath": "com.google.javascript.jscomp.ControlFlowAnalysis"}, {"bug_name": "Closure_104", "report_text": "> Typos in externs/html5.js\n> \n> Line 354:\r\n> CanvasRenderingContext2D.prototype.globalCompositingOperation;\r\n> \r\n> Line 366:\r\n> CanvasRenderingContext2D.prototype.mitreLimit;\r\n> \r\n> They should be globalCompositeOperation and miterLimit, respectively.", "test_name": "com.google.javascript.rhino.jstype.UnionTypeTest::testGreatestSubtypeUnionTypes5", "test_method": "  public void testGreatestSubtypeUnionTypes5() throws Exception {\n    JSType errUnion = createUnionType(EVAL_ERROR_TYPE, URI_ERROR_TYPE);\n    assertEquals(NO_OBJECT_TYPE,\n        errUnion.getGreatestSubtype(STRING_OBJECT_TYPE)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<NoObject> but was:<None>\n\tcom.google.javascript.rhino.jstype.UnionTypeTest.testGreatestSubtypeUnionTypes5(UnionTypeTest.java:159)", "buggy_method": "273 JSType meet(JSType that) {\n274     UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n275     for (JSType alternate : alternates) {\n276       if (alternate.isSubtype(that)) {\n277         builder.addAlternate(alternate);\n278       }\n279     }\n280 \n281     if (that instanceof UnionType) {\n282       for (JSType otherAlternate : ((UnionType) that).alternates) {\n283         if (otherAlternate.isSubtype(this)) {\n284           builder.addAlternate(otherAlternate);\n285         }\n286       }\n287     } else if (that.isSubtype(this)) {\n288       builder.addAlternate(that);\n289     }\n290     JSType result = builder.build();\n291     if (result != null) {\n292       return result;\n293     } else if (this.isObject() && that.isObject()) {\n294       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n295     } else {\n296       return getNativeType(JSTypeNative.NO_TYPE);\n297     }\n298   }", "bm_classpath": "com.google.javascript.rhino.jstype.UnionType"}, {"bug_name": "Closure_105", "report_text": "> Array Join Munged Incorrectly\n> \n> $.fn.hasClass = function(selector) {\r\n>  return ( this.length > 0 ? \r\n>  !( ( ['', this[0].className, ''].join(' ') ).indexOf( ['', selector, \r\n> ''].join(' ') ) == -1 )\r\n>  : false );\r\n> };\r\n> \r\n> munges into\r\n> \r\n> $.fn.hasClass=function(a){return this.length>0?\r\n> (\"\"+this[0].className).indexOf(\"\"+a)!=-1:false};\r\n> \r\n> which is not identical. Looks like there might be an issue with join and ' '.", "test_name": "com.google.javascript.jscomp.FoldConstantsTest::testStringJoinAdd", "test_method": "  public void testStringJoinAdd() {\n    fold(\"x = ['a', 'b', 'c'].join('')\", \"x = \\\"abc\\\"\");\n    fold(\"x = [].join(',')\", \"x = \\\"\\\"\");\n    fold(\"x = ['a'].join(',')\", \"x = \\\"a\\\"\");\n    fold(\"x = ['a', 'b', 'c'].join(',')\", \"x = \\\"a,b,c\\\"\");\n    fold(\"x = ['a', foo, 'b', 'c'].join(',')\", \"x = [\\\"a\\\",foo,\\\"b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = [foo, 'a', 'b', 'c'].join(',')\", \"x = [foo,\\\"a,b,c\\\"].join(\\\",\\\")\");\n    fold(\"x = ['a', 'b', 'c', foo].join(',')\", \"x = [\\\"a,b,c\\\",foo].join(\\\",\\\")\");\n\n    // Works with numbers\n    fold(\"x = ['a=', 5].join('')\", \"x = \\\"a=5\\\"\");\n    fold(\"x = ['a', '5'].join(7)\", \"x = \\\"a75\\\"\");\n\n    // Works on boolean\n    fold(\"x = ['a=', false].join('')\", \"x = \\\"a=false\\\"\");\n    fold(\"x = ['a', '5'].join(true)\", \"x = \\\"atrue5\\\"\");\n    fold(\"x = ['a', '5'].join(false)\", \"x = \\\"afalse5\\\"\");\n\n    // Only optimize if it's a size win.\n    fold(\"x = ['a', '5', 'c'].join('a very very very long chain')\",\n         \"x = [\\\"a\\\",\\\"5\\\",\\\"c\\\"].join(\\\"a very very very long chain\\\")\");\n    \n    // TODO(user): Its possible to fold this better.\n    foldSame(\"x = ['', foo].join(',')\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:758)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:278)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:247)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:235)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:462)\n\tcom.google.javascript.jscomp.FoldConstantsTest.foldSame(FoldConstantsTest.java:48)\n\tcom.google.javascript.jscomp.FoldConstantsTest.testStringJoinAdd(FoldConstantsTest.java:646)", "buggy_method": "1461 void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n1462                          Node parent) {\n1463     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n1464       return;\n1465     }\n1466 \n1467     Node arrayNode = left.getFirstChild();\n1468     Node functionName = arrayNode.getNext();\n1469 \n1470     if ((arrayNode.getType() != Token.ARRAYLIT) ||\n1471         !functionName.getString().equals(\"join\")) {\n1472       return;\n1473     }\n1474 \n1475     String joinString = NodeUtil.getStringValue(right);\n1476     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n1477     StringBuilder sb = new StringBuilder();\n1478     int foldedSize = 0;\n1479     Node elem = arrayNode.getFirstChild();\n1480     // Merges adjacent String nodes.\n1481     while (elem != null) {\n1482       if (NodeUtil.isImmutableValue(elem)) {\n1483         if (sb.length() > 0) {\n1484           sb.append(joinString);\n1485         }\n1486         sb.append(NodeUtil.getStringValue(elem));\n1487       } else {\n1488         if (sb.length() > 0) {\n1489           // + 2 for the quotes.\n1490           foldedSize += sb.length() + 2;\n1491           arrayFoldedChildren.add(Node.newString(sb.toString()));\n1492           sb = new StringBuilder();\n1493         }\n1494         foldedSize += InlineCostEstimator.getCost(elem);\n1495         arrayFoldedChildren.add(elem);\n1496       }\n1497       elem = elem.getNext();\n1498     }\n1499 \n1500     if (sb.length() > 0) {\n1501       // + 2 for the quotes.\n1502       foldedSize += sb.length() + 2;\n1503       arrayFoldedChildren.add(Node.newString(sb.toString()));\n1504     }\n1505     // one for each comma.\n1506     foldedSize += arrayFoldedChildren.size() - 1;\n1507 \n1508     int originalSize = InlineCostEstimator.getCost(n);\n1509     switch (arrayFoldedChildren.size()) {\n1510       case 0:\n1511         Node emptyStringNode = Node.newString(\"\");\n1512         parent.replaceChild(n, emptyStringNode);\n1513         break;\n1514 \n1515       case 1:\n1516         Node foldedStringNode = arrayFoldedChildren.remove(0);\n1517         if (foldedSize > originalSize) {\n1518           return;\n1519         }\n1520         arrayNode.detachChildren();\n1521         if (foldedStringNode.getType() != Token.STRING) {\n1522           // If the Node is not a string literal, ensure that\n1523           // it is coerced to a string.\n1524           Node replacement = new Node(Token.ADD,\n1525               Node.newString(\"\"), foldedStringNode);\n1526           foldedStringNode = replacement;\n1527         }\n1528         parent.replaceChild(n, foldedStringNode);\n1529         break;\n1530 \n1531       default:\n1532         // No folding could actually be performed.\n1533         if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n1534           return;\n1535         }\n1536         int kJoinOverhead = \"[].join()\".length();\n1537         foldedSize += kJoinOverhead;\n1538         foldedSize += InlineCostEstimator.getCost(right);\n1539         if (foldedSize > originalSize) {\n1540           return;\n1541         }\n1542         arrayNode.detachChildren();\n1543         for (Node node : arrayFoldedChildren) {\n1544           arrayNode.addChildToBack(node);\n1545         }\n1546         break;\n1547     }\n1548     t.getCompiler().reportCodeChange();\n1549   }", "bm_classpath": "com.google.javascript.jscomp.FoldConstants"}, {"bug_name": "Closure_106", "report_text": "> Exception thrown from com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties\n> \n> The attached javascript file results in a Java exception being thrown when compiling with ADVANCED\\_OPTIMIZATIONS\r\n> \r\n> [~/Projects/Music Theory/trunk] # java -jar ./ext/closure-compiler/compiler.jar --js /tmp/musictheory.net/v2/js/core.js --compilation\\_level \r\n> ADVANCED\\_OPTIMIZATIONS\r\n> java.lang.RuntimeException: java.lang.IllegalArgumentException\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCompilerRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCompilerRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CompilerRunner.main(Unknown Source)\r\n> Caused by: java.lang.IllegalArgumentException\r\n>  at com.google.common.base.Preconditions.checkArgument(Preconditions.java:71)\r\n>  at com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclarationAtAssignNode(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclaration(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Unknown Source)\r\n>  at com.google.javascript.jscomp.CollapseProperties.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)\r\n>  at java.lang.Thread.run(Thread.java:637)\r\n> \r\n> I'm guessing that I did something wrong in my script which adds the goog.exportSymbol() calls, but it probably should give me a nice warning or error instead \r\n> of throwing a Java exception ;)", "test_name": "com.google.javascript.jscomp.CheckSideEffectsTest::testJSDocComments", "test_method": "  public void testJSDocComments() {\n    test(\"function A() { /** This is a jsdoc comment */ this.foo; }\", ok); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USELESS_CODE. Suspicious code. This code lacks side-effects. Is there a bug? at testcode line 1 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:659)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:326)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:256)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:225)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.test(CheckSideEffectsTest.java:33)\n\tcom.google.javascript.jscomp.CheckSideEffectsTest.testJSDocComments(CheckSideEffectsTest.java:86)", "buggy_method": "899 boolean canCollapseUnannotatedChildNames() {\n900       if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n901         return false;\n902       }\n903 \n904       // Don't try to collapse if the one global set is a twin reference.\n905       // We could theoretically handle this case in CollapseProperties, but\n906       // it's probably not worth the effort.\n907 \n908       if (isClassOrEnum) {\n909         return true;\n910       }\n911       return (type == Type.FUNCTION || aliasingGets == 0) &&\n912           (parent == null || parent.canCollapseUnannotatedChildNames());\n913     }", "bm_classpath": "com.google.javascript.jscomp.GlobalNamespace$Name"}, {"bug_name": "Closure_107", "report_text": "> Variable names prefixed with MSG_ cause error with advanced optimizations\n> \n> Variables named something with MSG\\_ seem to cause problems with the module system, even if no modules are used in the code.\r\n> \r\n> $ echo \"var MSG\\_foo='bar'\" | closure --compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> stdin:1: ERROR - message not initialized using goog.getMsg\r\n> var MSG\\_foo='bar'\r\n>  ^\r\n> \r\n> It works fine with msg\\_foo, MSG2\\_foo, etc.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testGetMsgWiringNoWarnings", "test_method": "  public void testGetMsgWiringNoWarnings() throws Exception {\n    args.add(\"--compilation_level=ADVANCED_OPTIMIZATIONS\");\n    test(\"/** @desc A bad foo. */ var MSG_FOO = 1;\", \"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected no warnings or errors\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1256)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1242)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:1234)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testGetMsgWiringNoWarnings(CommandLineRunnerTest.java:395)", "buggy_method": "805 @Override\n806   protected CompilerOptions createOptions() {\n807     CompilerOptions options = new CompilerOptions();\n808     if (flags.processJqueryPrimitives) {\n809       options.setCodingConvention(new JqueryCodingConvention());\n810     } else {\n811       options.setCodingConvention(new ClosureCodingConvention());\n812     }\n813 \n814     options.setExtraAnnotationNames(flags.extraAnnotationName);\n815 \n816     CompilationLevel level = flags.compilationLevel;\n817     level.setOptionsForCompilationLevel(options);\n818 \n819     if (flags.debug) {\n820       level.setDebugOptionsForCompilationLevel(options);\n821     }\n822 \n823     if (flags.useTypesForOptimization) {\n824       level.setTypeBasedOptimizationOptions(options);\n825     }\n826 \n827     if (flags.generateExports) {\n828       options.setGenerateExports(flags.generateExports);\n829     }\n830 \n831     WarningLevel wLevel = flags.warningLevel;\n832     wLevel.setOptionsForWarningLevel(options);\n833     for (FormattingOption formattingOption : flags.formatting) {\n834       formattingOption.applyToOptions(options);\n835     }\n836 \n837     options.closurePass = flags.processClosurePrimitives;\n838 \n839     options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n840         flags.processJqueryPrimitives;\n841 \n842     options.angularPass = flags.angularPass;\n843 \n844     if (!flags.translationsFile.isEmpty()) {\n845       try {\n846         options.messageBundle = new XtbMessageBundle(\n847             new FileInputStream(flags.translationsFile),\n848             flags.translationsProject);\n849       } catch (IOException e) {\n850         throw new RuntimeException(\"Reading XTB file\", e);\n851       }\n852     } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n853       // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n854       // translations file, they might reasonably try to write their own\n855       // implementation of goog.getMsg that makes the substitution at\n856       // run-time.\n857       //\n858       // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n859       // so we might as well inline it. But shut off the i18n warnings,\n860       // because the user didn't really ask for i18n.\n861       options.messageBundle = new EmptyMessageBundle();\n862     }\n863 \n864     return options;\n865   }", "bm_classpath": "com.google.javascript.jscomp.CommandLineRunner"}, {"bug_name": "Closure_108", "report_text": "> precondition crash: goog.scope local with aliased in the type declaration\n> \n> var goog = {};\r\n> goog.scope;\r\n> \r\n> var ns = {};\r\n> ns.sub = {};\r\n> /\\*\\* @constructor \\*/\r\n> ns.sub.C = function() {};\r\n> \r\n> \r\n> goog.scope(function() {\r\n>  var sub = ns.sub;\r\n>  /\\*\\* @type {sub.C} \\*/\r\n>  var x = null;\r\n> });\r\n> \r\n> \r\n> produces:\r\n> \r\n> java.lang.IllegalStateException at com.google.common.base.Preconditions.checkState(Preconditions.java:137) at com.google.javascript.jscomp.ScopedAliases$AliasedTypeNode.applyAlias(ScopedAliases.java:236) at com.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:147) at com.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:128) at", "test_name": "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1144", "test_method": "  public void testIssue1144() {\n    test(\"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"goog.scope(function () {\" +\n         \"  var sub = ns.sub;\" +\n         \"  /** @type {sub.C} */\" +\n         \"  var x = null;\" +\n         \"});\",\n         SCOPE_NAMESPACE +\n         \"var ns = {};\" +\n         \"ns.sub = {};\" +\n         \"/** @constructor */ ns.sub.C = function () {};\" +\n         \"$jscomp.scope.x = null;\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException\n\tcom.google.common.base.Preconditions.checkState(Preconditions.java:134)\n\tcom.google.javascript.jscomp.ScopedAliases$AliasedTypeNode.applyAlias(ScopedAliases.java:236)\n\tcom.google.javascript.jscomp.ScopedAliases.hotSwapScript(ScopedAliases.java:147)\n\tcom.google.javascript.jscomp.ScopedAliases.process(ScopedAliases.java:128)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:845)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testIssue1144(ScopedAliasesTest.java:570)", "buggy_method": "308 @Override\n309     public void exitScope(NodeTraversal t) {\n310       if (t.getScopeDepth() > 2) {\n311         findNamespaceShadows(t);\n312       }\n313 \n314       if (t.getScopeDepth() == 2) {\n315         renameNamespaceShadows(t);\n316         aliases.clear();\n317         forbiddenLocals.clear();\n318         transformation = null;\n319         hasNamespaceShadows = false;\n320       }\n321     }", "bm_classpath": "com.google.javascript.jscomp.ScopedAliases$Traversal"}, {"bug_name": "Closure_109", "report_text": "> Constructor types that return all or unknown fail to parse\n> \n> Constructor types that return the all type or the unknown type currently fail to parse:\r\n> \r\n> /\\*\\* @type {function(new:?)} \\*/ var foo = function() {};\r\n> /\\*\\* @type {function(new:\\*)} \\*/ var bar = function() {};\r\n> \r\n> foo.js:1: ERROR - Bad type annotation. type not recognized due to syntax error\r\n> /\\*\\* @type {function(new:?)} \\*/ var foo = function() {};\r\n>  ^\r\n> \r\n> foo.js:2: ERROR - Bad type annotation. type not recognized due to syntax error\r\n> /\\*\\* @type {function(new:\\*)} \\*/ var bar = function() {};\r\n>  ^\r\n> \r\n> This is an issue for a code generator that I'm working on.", "test_name": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testStructuralConstructor2", "test_method": "  public void testStructuralConstructor2() throws Exception {\n    JSType type = testParseType(\n        \"function (new:?)\",\n        // toString skips unknowns, but isConstructor reveals the truth.\n        \"function (): ?\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: extra warning: Bad type annotation. type not recognized due to syntax error\n\tcom.google.javascript.jscomp.testing.TestErrorReporter.warning(TestErrorReporter.java:64)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser$ErrorReporterParser.addTypeWarning(JsDocInfoParser.java:83)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.reportTypeSyntaxWarning(JsDocInfoParser.java:2399)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.reportGenericTypeSyntaxWarning(JsDocInfoParser.java:2404)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(JsDocInfoParser.java:1949)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseContextTypeExpression(JsDocInfoParser.java:1908)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseFunctionType(JsDocInfoParser.java:2012)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(JsDocInfoParser.java:1931)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(JsDocInfoParser.java:1888)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(JsDocInfoParser.java:1808)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(JsDocInfoParser.java:1717)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocInfoParser.java:1334)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocInfoParser.java:1270)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseAnnotation(JsDocInfoParser.java:951)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parseHelperLoop(JsDocInfoParser.java:248)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:238)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:3236)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:3213)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:3208)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.testParseType(JsDocInfoParserTest.java:716)", "buggy_method": "1907 private Node parseContextTypeExpression(JsDocToken token) {\n1908           return parseTypeName(token);\n1909   }", "bm_classpath": "com.google.javascript.jscomp.parsing.JsDocInfoParser"}, {"bug_name": "Closure_110", "report_text": "> Allow @private top-level functions in goog.scope\n> \n> **What steps will reproduce the problem?**\n> **1.**\n> goog.scope(function() {\r\n>  /\\* @private \\*/\r\n>  function test() {}\r\n> });\r\n> \r\n> **2.**\n> The code above gives an error \"The local variable test is in a goog.scope and is not an alias.\"\r\n> \r\n> What is the expected output?\r\n> \r\n> The code above should compile, and function test() be referenceable only from inside the file in question. If I replace \"function test\" with \"var test = function\", the code compiles.", "test_name": "com.google.javascript.jscomp.ScopedAliasesTest::testHoistedFunctionDeclaration", "test_method": "  public void testHoistedFunctionDeclaration() {\n    testScoped(\" g(f); function f() {} \",\n               SCOPE_NAMESPACE +\n               \" $jscomp.scope.f = function () {}; \" +\n               \"g($jscomp.scope.f); \"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testScoped(ScopedAliasesTest.java:55)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testHoistedFunctionDeclaration(ScopedAliasesTest.java:522)", "buggy_method": "352 private void findAliases(NodeTraversal t) {\n353       Scope scope = t.getScope();\n354       for (Var v : scope.getVarIterable()) {\n355         Node n = v.getNode();\n356         Node parent = n.getParent();\n357         boolean isVar = parent.isVar();\n358         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n359           recordAlias(v);\n360         } else if (v.isBleedingFunction()) {\n361           // Bleeding functions already get a BAD_PARAMETERS error, so just\n362           // do nothing.\n363         } else if (parent.getType() == Token.LP) {\n364           // Parameters of the scope function also get a BAD_PARAMETERS\n365           // error.\n366         } else if (isVar) {\n367           Node grandparent = parent.getParent();\n368           Node value = n.hasChildren() ?\n369               v.getInitialValue().detachFromParent() :\n370               null;\n371           Node varNode = parent;\n372 \n373           String name = n.getString();\n374           int nameCount = scopedAliasNames.count(name);\n375           scopedAliasNames.add(name);\n376           String globalName =\n377               \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n378 \n379           compiler.ensureLibraryInjected(\"base\");\n380 \n381           // First, we need to free up the function expression (EXPR)\n382           // to be used in another expression.\n383             // Replace \"function NAME() { ... }\" with \"var NAME;\".\n384 \n385             // We can't keep the local name on the function expression,\n386             // because IE is buggy and will leak the name into the global\n387             // scope. This is covered in more detail here:\n388             // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n389             //\n390             // This will only cause problems if this is a hoisted, recursive\n391             // function, and the programmer is using the hoisting.\n392 \n393               // If this is a VAR, we can just detach the expression and\n394               // the tree will still be valid.\n395 \n396           // Add $jscomp.scope.name = EXPR;\n397           // Make sure we copy over all the jsdoc and debug info.\n398           if (value != null || v.getJSDocInfo() != null) {\n399             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n400                 compiler.getCodingConvention(),\n401                 globalName,\n402                 value,\n403                 v.getJSDocInfo())\n404                 .useSourceInfoIfMissingFromForTree(n);\n405             NodeUtil.setDebugInformation(\n406                 newDecl.getFirstChild().getFirstChild(), n, name);\n407 \n408               grandparent.addChildBefore(newDecl, varNode);\n409           }\n410 \n411           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n412           v.getNameNode().addChildToFront(\n413               NodeUtil.newQualifiedNameNode(\n414                   compiler.getCodingConvention(), globalName, n, name));\n415 \n416           recordAlias(v);\n417         } else {\n418           // Do not other kinds of local symbols, like catch params.\n419           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n420         }\n421       }\n422     }", "bm_classpath": "com.google.javascript.jscomp.ScopedAliases$Traversal"}, {"bug_name": "Closure_111", "report_text": "> goog.isArray doesn't hint compiler\n> \n> **What steps will reproduce the problem?**\n> **1.**\n> \r\n> /\\*\\*\r\n>  \\* @param {\\*} object\r\n>  \\* @return {\\*}\r\n>  \\*/\r\n> var test = function(object) {\r\n>  if (goog.isArray(object)) {\r\n>  /\\*\\* @type {Array} \\*/ var x = object;\r\n>  return x;\r\n>  }\r\n> };\r\n> \r\n> 2. ADVANCED\\_OPTIMIZATIONS\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> ERROR - initializing variable\r\n> found : \\*\r\n> required: (Array|null)\r\n>  /\\*\\* @type {Array} \\*/ var x = object;\r\n>  ^\r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Closure Compiler (http://code.google.com/closure/compiler)\r\n> Version: v20130411-90-g4e19b4e\r\n> Built on: 2013/06/03 12:07\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> goog.is\\* is supposed to help the compiler to check which type we're dealing with.", "test_name": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsArray2", "test_method": "  public void testGoogIsArray2() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        ALL_TYPE,\n        ARRAY_TYPE,\n        ALL_TYPE); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: Array\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:106)\n\tcom.google.javascript.rhino.testing.Asserts.assertTypeEquals(Asserts.java:96)\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testClosureFunction(ClosureReverseAbstractInterpreterTest.java:288)\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testGoogIsArray2(ClosureReverseAbstractInterpreterTest.java:206)", "buggy_method": "52 @Override\n53         protected JSType caseTopType(JSType topType) {\n54           return topType;\n55         }", "bm_classpath": "com.google.javascript.jscomp.type.ClosureReverseAbstractInterpreter$1"}, {"bug_name": "Closure_112", "report_text": "> Template types on methods incorrectly trigger inference of a template on the class if that template type is unknown\n> \n> See i.e.\r\n> \r\n> \r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @template CLASS\r\n>  \\*/\r\n> var Class = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @param {function(CLASS):CLASS} a\r\n>  \\* @template T\r\n>  \\*/\r\n> Class.prototype.foo = function(a) {\r\n>  return 'string';\r\n> };\r\n> \r\n> /\\*\\* @param {number} a\r\n>  \\* @return {string} \\*/\r\n> var a = function(a) { return '' };\r\n> \r\n> new Class().foo(a);\r\n> \r\n> \r\n> The CLASS type is never specified. If the @template T line is removed from the foo method, the block compiles with but with the @annotation on the method, the compiler seems to try to infer CLASS from the usage and fails compilation.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1058", "test_method": "  public void testIssue1058() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \"  * @constructor\\n\" +\n        \"  * @template CLASS\\n\" +\n        \"  */\\n\" +\n        \"var Class = function() {};\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \"  * @param {function(CLASS):CLASS} a\\n\" +\n        \"  * @template T\\n\" +\n        \"  */\\n\" +\n        \"Class.prototype.foo = function(a) {\\n\" +\n        \"  return 'string';\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"/** @param {number} a\\n\" +\n        \"  * @return {string} */\\n\" +\n        \"var a = function(a) { return '' };\\n\" +\n        \"\\n\" +\n        \"new Class().foo(a);\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12407)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12381)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12317)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12313)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue1058(TypeCheckTest.java:12160)", "buggy_method": "1183 private boolean inferTemplatedTypesForCall(\n1184       Node n, FunctionType fnType) {\n1185     final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n1186         .getTemplateKeys();\n1187     if (keys.isEmpty()) {\n1188       return false;\n1189     }\n1190 \n1191     // Try to infer the template types\n1192     Map<TemplateType, JSType> inferred = \n1193         inferTemplateTypesFromParameters(fnType, n);\n1194 \n1195 \n1196     // Replace all template types. If we couldn't find a replacement, we\n1197     // replace it with UNKNOWN.\n1198     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n1199         registry, inferred);\n1200     Node callTarget = n.getFirstChild();\n1201 \n1202     FunctionType replacementFnType = fnType.visit(replacer)\n1203         .toMaybeFunctionType();\n1204     Preconditions.checkNotNull(replacementFnType);\n1205 \n1206     callTarget.setJSType(replacementFnType);\n1207     n.setJSType(replacementFnType.getReturnType());\n1208 \n1209     return replacer.madeChanges;\n1210   }", "bm_classpath": "com.google.javascript.jscomp.TypeInference"}, {"bug_name": "Closure_113", "report_text": "> Bug in require calls processing\n> \n> The Problem\r\n> \r\n> ProcessClosurePrimitives pass has a bug in processRequireCall method.\r\n> The method processes goog.require calls. If a require symbol is invalid i.e is not provided anywhere, the method collects it for further error reporting. If the require symbol is valid, the method removes it from the ast.\r\n> \r\n> All invalid require calls must be left for further using/checking of the code! The related comment in the code confirms this.\r\n> \r\n> Nevertheless, the second condition (requiresLevel.isOn() -> see source code) is invalid and always causes removing of the requires when we want to check these requires.\r\n> \r\n> In any case, the method should not use the requiresLevel to decide if we need removing. The requiresLevel should be used to check if we need error reporting. \r\n> \r\n> The Solution\r\n> \r\n> Remove the condition.\r\n> Please see the attached patch.", "test_name": "com.google.javascript.jscomp.VarCheckTest::testNoUndeclaredVarWhenUsingClosurePass", "test_method": "  public void testNoUndeclaredVarWhenUsingClosurePass() {\n    enableClosurePass();\n    // We don't want to get goog as an undeclared var here.\n    test(\"goog.require('namespace.Class1');\\n\", null,\n        ProcessClosurePrimitives.MISSING_PROVIDE_ERROR); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one error. required \"namespace.Class1\" namespace never provided\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:999)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.VarCheckTest.testNoUndeclaredVarWhenUsingClosurePass(VarCheckTest.java:371)", "buggy_method": "295 private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n296     Node left = n.getFirstChild();\n297     Node arg = left.getNext();\n298     if (verifyLastArgumentIsString(t, left, arg)) {\n299       String ns = arg.getString();\n300       ProvidedName provided = providedNames.get(ns);\n301       if (provided == null || !provided.isExplicitlyProvided()) {\n302         unrecognizedRequires.add(\n303             new UnrecognizedRequire(n, ns, t.getSourceName()));\n304       } else {\n305         JSModule providedModule = provided.explicitModule;\n306 \n307         // This must be non-null, because there was an explicit provide.\n308         Preconditions.checkNotNull(providedModule);\n309 \n310         JSModule module = t.getModule();\n311         if (moduleGraph != null &&\n312             module != providedModule &&\n313             !moduleGraph.dependsOn(module, providedModule)) {\n314           compiler.report(\n315               t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n316                   providedModule.getName(),\n317                   module.getName()));\n318         }\n319       }\n320 \n321       maybeAddToSymbolTable(left);\n322       maybeAddStringNodeToSymbolTable(arg);\n323 \n324       // Requires should be removed before further processing.\n325       // Some clients run closure pass multiple times, first with\n326       // the checks for broken requires turned off. In these cases, we\n327       // allow broken requires to be preserved by the first run to\n328       // let them be caught in the subsequent run.\n329       if (provided != null) {\n330         parent.detachFromParent();\n331         compiler.reportCodeChange();\n332       }\n333     }\n334   }", "bm_classpath": "com.google.javascript.jscomp.ProcessClosurePrimitives"}, {"bug_name": "Closure_114", "report_text": "> Crash on the web closure compiler\n> \n> With the web application (http://closure-compiler.appspot.com/home)\r\n> \r\n> Config:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @output\\_file\\_name default.js\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // ==/ClosureCompiler==\r\n> \r\n> \r\n> Code:\r\n> \r\n> var g=function(m){return m\\*Math.random()|0},d=document,h=d.getElementById('h'),c=d.getElementById('c'),l;\r\n> (l=function(){requestAnimationFrame(l);h.style.textShadow=\"0 0 1px #000,\"+(g(10)-5)+\"px \"+(g(10)-5)+\"px 0 #888,0 0 180px rgb(\"+g(255)+\",\"+g(255)+\",\"+g(255)+\")\"})();\r\n> d.addEventListener('mousemove',function(v){c.style.marginTop=(v.pageY/10+15|0)+'px'})\r\n> \r\n> \r\n> Cause:\r\n> \r\n> var l; // D\u00e9clare l variable\r\n> \r\n> // Store function in l var and call\r\n> (l = function(){ ... }) ();\r\n> \r\n> \r\n> Crash repport: (long)\r\n> \r\n> 23: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected variable l\r\n>  Node(NAME l): Input\\_0:2:36\r\n> (l=function(){requestAnimationFrame(l);h.style.textShadow=\"0 0 1px #000,\"+(g(10)-5)+\"px \"+(g(10)-5)+\"px 0 #888,0 0 180px rgb(\"+g(255)+\",\"+g(255)+\",\"+g(255)+\")\"})();\r\n>  Parent(CALL): Input\\_0:2:14\r\n> (l=function(){requestAnimationFrame(l);h.style.textShadow=\"0 0 1px #000,\"+(g(10)-5)+\"px \"+(g(10)-5)+\"px 0 #888,0 0 180px rgb(\"+g(255)+\",\"+g(255)+\",\"+g(255)+\")\"})();\r\n> \r\n>  at com.google.javascript.jscomp.VarCheck.visit(VarCheck.java:159)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:544)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:538)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:318)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:507)\r\n>  at com.google.javascript.jscomp.VarCheck.process(VarCheck.java:102)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:271)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:215)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1918)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:751)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:85)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:652)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:649)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:709)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:649)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:605)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilerInvokerImpl.compile(CompilerInvokerImpl.java:47)\r\n>  at com.google.javascript.jscomp.webservice.backend.ServerController.executeRequest(ServerController.java:174)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.serviceParsedRequest(CompilationRequestHandler.java:180)\r\n>  at com.google.javascript.jscomp.webservice.backend.CompilationRequestHandler.service(CompilationRequestHandler.java:162)\r\n>  at com.google.javascript.jscomp.webservice.frontend.CompilationServlet.doPost(CompilationServlet.java:83)\r\n>  at javax.servlet.http.HttpServlet.service(HttpServlet.java:637)\r\n>  at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)\r\n>  at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:511)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1166)\r\n>  at com.google.apphosting.utils.servlet.ParseBlobUploadFilter.doFilter(ParseBlobUploadFilter.java:125)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at com.google.apphosting.runtime.jetty.SaveSessionFilter.doFilter(SaveSessionFilter.java:35)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at com.google.apphosting.utils.servlet.JdbcMySqlConnectionCleanupFilter.doFilter(JdbcMySqlConnectionCleanupFilter.java:60)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at com.google.apphosting.utils.servlet.TransactionCleanupFilter.doFilter(TransactionCleanupFilter.java:43)\r\n>  at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)\r\n>  at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:388)\r\n>  at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)\r\n>  at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:182)\r\n>  at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)\r\n>  at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:418)\r\n>  at com.google.apphosting.runtime.jetty.AppVersionHandlerMap.handle(AppVersionHandlerMap.java:266)\r\n>  at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)\r\n>  at org.mortbay.jetty.Server.handle(Server.java:326)\r\n>  at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)\r\n>  at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:923)\r\n>  at com.google.apphosting.runtime.jetty.RpcRequestParser.parseAvailable(RpcRequestParser.java:76)\r\n>  at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)\r\n>  at com.google.apphosting.runtime.jetty.JettyServletEngineAdapter.serviceRequest(JettyServletEngineAdapter.java:146)\r\n>  at com.google.apphosting.runtime.JavaRuntime$RequestRunnable.run(JavaRuntime.java:439)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable.runInContext(TraceContext.java:435)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable$1.run(TraceContext.java:442)\r\n>  at com.google.tracing.CurrentContext.runInContext(CurrentContext.java:186)\r\n>  at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContextNoUnref(TraceContext.java:306)\r\n>  at com.google.tracing.TraceContext$AbstractTraceContextCallback.runInInheritedContext(TraceContext.java:298)\r\n>  at com.google.tracing.TraceContext$TraceContextRunnable.run(TraceContext.java:439)\r\n>  at com.google.apphosting.runtime.ThreadGroupPool$PoolEntry.run(ThreadGroupPool.java:251)\r\n>  at java.lang.Thread.run(Thread.java:722)\r\n> Caused by: java.lang.IllegalStateException: Unexpected variable l\r\n>  ... 58 more\r\n> \r\n> Original Post Data: \r\n> output\\_format=json&output\\_info=compiled\\_code&output\\_info=warnings&output\\_info=errors&output\\_info=statistics&compilation\\_level=ADVANCED\\_OPTIMIZATIONS&warning\\_level=verbose&output\\_file\\_name=default.js&js\\_code=var%20g%3Dfunction(m)%7Breturn%20m\\*Math.random()%7C0%7D%2Cd%3Ddocument%2Ch%3Dd.getElementById('h')%2Cc%3Dd.getElementById('c')%2Cl%3B%0A(l%3Dfunction()%7BrequestAnimationFrame(l)%3Bh.style.textShadow%3D%220%200%201px%20%23000%2C%22%2B(g(10)-5)%2B%22px%20%22%2B(g(10)-5)%2B%22px%200%20%23888%2C0%200%20180px%20rgb(%22%2Bg(255)%2B%22%2C%22%2Bg(255)%2B%22%2C%22%2Bg(255)%2B%22)%22%7D)()%3B%0Ad.addEventListener('mousemove'%2Cfunction(v)%7Bc.style.marginTop%3D(v.pageY%2F10%2B15%7C0)%2B'px'%7D)", "test_name": "com.google.javascript.jscomp.NameAnalyzerTest::testAssignWithCall", "test_method": "  public void testAssignWithCall() {\n    test(\"var fun, x; (fun = function(){ x; })();\",\n        \"var x; (function(){ x; })();\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:957)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.NameAnalyzerTest.testAssignWithCall(NameAnalyzerTest.java:1236)", "buggy_method": "558 private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n559       Node nameNode = n.getFirstChild();\n560       Node parent = n.getParent();\n561       NameInformation ns = createNameInformation(t, nameNode);\n562       if (ns != null) {\n563         if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n564           // Patch for assignments that appear in the init,\n565           // condition or iteration part of a FOR loop.  Without\n566           // this change, all 3 of those parts try to claim the for\n567           // loop as their dependency scope.  The last assignment in\n568           // those three fields wins, which can result in incorrect\n569           // reference edges between referenced and assigned variables.\n570           //\n571           // TODO(user) revisit the dependency scope calculation\n572           // logic.\n573           if (parent.getFirstChild().getNext() != n) {\n574             recordDepScope(recordNode, ns);\n575           } else {\n576             recordDepScope(nameNode, ns);\n577           }\n578         } else {\n579           // The rhs of the assignment is the caller, so it's used by the\n580           // context. Don't associate it w/ the lhs.\n581           // FYI: this fixes only the specific case where the assignment is the\n582           // caller expression, but it could be nested deeper in the caller and\n583           // we would still get a bug.\n584           // See testAssignWithCall2 for an example of this.\n585           recordDepScope(recordNode, ns);\n586         }\n587       }\n588     }", "bm_classpath": "com.google.javascript.jscomp.NameAnalyzer$FindDependencyScopes"}, {"bug_name": "Closure_115", "report_text": "> Erroneous optimization in ADVANCED_OPTIMIZATIONS mode\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Create a file input.js with the following \"minimal\" test case:\r\n> \r\n>  window[\"anchor\"] = function (obj, modifiesProp) {\r\n>  return (function (saved) {\r\n>  return modifiesProp(obj) + saved;\r\n>  })(obj[\"prop\"]);\r\n>  }\r\n> \r\n> 2. Compile it with:\r\n> \r\n>  java -jar .../build/compiler.jar \\\r\n>  --compilation\\_level ADVANCED\\_OPTIMIZATIONS \\\r\n>  --warning\\_level VERBOSE \\\r\n>  --externs window.js \\\r\n>  --js input.js \\\r\n>  --js\\_output\\_file output.js\r\n> \r\n> 3. That's all!\r\n> \r\n> What is the expected output?\r\n> \r\n>  window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};\r\n> \r\n> What do you see instead?\r\n> \r\n>  window.foo=function(a,b){return b(a)+a.prop};\r\n> \r\n> Note how this is semantically very different if modifiesProp/b (whose\r\n> semantics are unknown to the compiler) side-effects a.prop.\r\n> \r\n> The evaluation order of + is well-defined in EcmaScript 5, but even\r\n> then, this happens even if one substitutes the , (comma) operator.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Git HEAD\r\n> \r\n>  commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95\r\n>  Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>\r\n>  Date: Wed Sep 25 14:52:28 2013 -0500\r\n>  \r\n>  Add history.state to html5 externs\r\n> \r\n> on Linux.", "test_name": "com.google.javascript.jscomp.InlineFunctionsTest::testBug4944818", "test_method": "  public void testBug4944818() {\n    test(\n        \"var getDomServices_ = function(self) {\\n\" +\n        \"  if (!self.domServices_) {\\n\" +\n        \"    self.domServices_ = goog$component$DomServices.get(\" +\n        \"        self.appContext_);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  return self.domServices_;\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"var getOwnerWin_ = function(self) {\\n\" +\n        \"  return getDomServices_(self).getDomHelper().getWindow();\\n\" +\n        \"};\\n\" +\n        \"\\n\" +\n        \"HangoutStarter.prototype.launchHangout = function() {\\n\" +\n        \"  var self = a.b;\\n\" +\n        \"  var myUrl = new goog.Uri(getOwnerWin_(self).location.href);\\n\" +\n        \"};\",\n        \"HangoutStarter.prototype.launchHangout = function() { \" +\n        \"  var self$$2 = a.b;\" +\n        \"  var JSCompiler_temp_const$$0 = goog.Uri;\" +\n        \"  var JSCompiler_inline_result$$1;\" +\n        \"  {\" +\n        \"  var self$$inline_2 = self$$2;\" +\n        \"  if (!self$$inline_2.domServices_) {\" +\n        \"    self$$inline_2.domServices_ = goog$component$DomServices.get(\" +\n        \"        self$$inline_2.appContext_);\" +\n        \"  }\" +\n        \"  JSCompiler_inline_result$$1=self$$inline_2.domServices_;\" +\n        \"  }\" +\n        \"  var myUrl = new JSCompiler_temp_const$$0(\" +\n        \"      JSCompiler_inline_result$$1.getDomHelper().\" +\n        \"          getWindow().location.href)\" +\n        \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:957)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.InlineFunctionsTest.testBug4944818(InlineFunctionsTest.java:2060)", "buggy_method": "689 private CanInlineResult canInlineReferenceDirectly(\n690       Node callNode, Node fnNode) {\n691     if (!isDirectCallNodeReplacementPossible(fnNode)) {\n692       return CanInlineResult.NO;\n693     }\n694 \n695     Node block = fnNode.getLastChild();\n696 \n697     boolean hasSideEffects = false;\n698     if (block.hasChildren()) {\n699       Preconditions.checkState(block.hasOneChild());\n700       Node stmt = block.getFirstChild();\n701       if (stmt.isReturn()) {\n702         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n703       }\n704     }\n705     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n706     Node cArg = callNode.getFirstChild().getNext();\n707 \n708     // Functions called via 'call' and 'apply' have a this-object as\n709     // the first parameter, but this is not part of the called function's\n710     // parameter list.\n711     if (!callNode.getFirstChild().isName()) {\n712       if (NodeUtil.isFunctionObjectCall(callNode)) {\n713         // TODO(johnlenz): Support replace this with a value.\n714         if (cArg == null || !cArg.isThis()) {\n715           return CanInlineResult.NO;\n716         }\n717         cArg = cArg.getNext();\n718       } else {\n719         // \".apply\" call should be filtered before this.\n720         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n721       }\n722     }\n723 \n724     // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n725     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n726     while (cArg != null || fnParam != null) {\n727       // For each named parameter check if a mutable argument use more than one.\n728       if (fnParam != null) {\n729         if (cArg != null) {\n730           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n731             return CanInlineResult.NO;\n732           }\n733           // Check for arguments that are evaluated more than once.\n734           // Note: Unlike block inlining, there it is not possible that a\n735           // parameter reference will be in a loop.\n736           if (NodeUtil.mayEffectMutableState(cArg, compiler)\n737               && NodeUtil.getNameReferenceCount(\n738                   block, fnParam.getString()) > 1) {\n739             return CanInlineResult.NO;\n740           }\n741         }\n742 \n743         // Move to the next name.\n744         fnParam = fnParam.getNext();\n745       }\n746 \n747       // For every call argument check for side-effects, even if there\n748       // isn't a named parameter to match.\n749       if (cArg != null) {\n750         if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n751           return CanInlineResult.NO;\n752         }\n753         cArg = cArg.getNext();\n754       }\n755     }\n756 \n757     return CanInlineResult.YES;\n758   }", "bm_classpath": "com.google.javascript.jscomp.FunctionInjector"}, {"bug_name": "Closure_116", "report_text": "> Erroneous optimization in ADVANCED_OPTIMIZATIONS mode\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Create a file input.js with the following \"minimal\" test case:\r\n> \r\n>  window[\"anchor\"] = function (obj, modifiesProp) {\r\n>  return (function (saved) {\r\n>  return modifiesProp(obj) + saved;\r\n>  })(obj[\"prop\"]);\r\n>  }\r\n> \r\n> 2. Compile it with:\r\n> \r\n>  java -jar .../build/compiler.jar \\\r\n>  --compilation\\_level ADVANCED\\_OPTIMIZATIONS \\\r\n>  --warning\\_level VERBOSE \\\r\n>  --externs window.js \\\r\n>  --js input.js \\\r\n>  --js\\_output\\_file output.js\r\n> \r\n> 3. That's all!\r\n> \r\n> What is the expected output?\r\n> \r\n>  window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};\r\n> \r\n> What do you see instead?\r\n> \r\n>  window.foo=function(a,b){return b(a)+a.prop};\r\n> \r\n> Note how this is semantically very different if modifiesProp/b (whose\r\n> semantics are unknown to the compiler) side-effects a.prop.\r\n> \r\n> The evaluation order of + is well-defined in EcmaScript 5, but even\r\n> then, this happens even if one substitutes the , (comma) operator.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Git HEAD\r\n> \r\n>  commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95\r\n>  Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>\r\n>  Date: Wed Sep 25 14:52:28 2013 -0500\r\n>  \r\n>  Add history.state to html5 externs\r\n> \r\n> on Linux.", "test_name": "com.google.javascript.jscomp.FunctionInjectorTest::testIssue1101a", "test_method": "  public void testIssue1101a() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n        INLINE_DIRECT); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<NO> but was:<YES>\n\tcom.google.javascript.jscomp.FunctionInjectorTest$1.call(FunctionInjectorTest.java:1404)\n\tcom.google.javascript.jscomp.FunctionInjectorTest$TestCallback.visit(FunctionInjectorTest.java:1545)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:540)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:287)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:494)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperCanInlineReferenceToFunction(FunctionInjectorTest.java:1411)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperCanInlineReferenceToFunction(FunctionInjectorTest.java:1375)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.testIssue1101a(FunctionInjectorTest.java:1347)", "buggy_method": "689 private CanInlineResult canInlineReferenceDirectly(\n690       Node callNode, Node fnNode) {\n691     if (!isDirectCallNodeReplacementPossible(fnNode)) {\n692       return CanInlineResult.NO;\n693     }\n694 \n695     Node block = fnNode.getLastChild();\n696 \n697 \n698     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n699     Node cArg = callNode.getFirstChild().getNext();\n700 \n701     // Functions called via 'call' and 'apply' have a this-object as\n702     // the first parameter, but this is not part of the called function's\n703     // parameter list.\n704     if (!callNode.getFirstChild().isName()) {\n705       if (NodeUtil.isFunctionObjectCall(callNode)) {\n706         // TODO(johnlenz): Support replace this with a value.\n707         if (cArg == null || !cArg.isThis()) {\n708           return CanInlineResult.NO;\n709         }\n710         cArg = cArg.getNext();\n711       } else {\n712         // \".apply\" call should be filtered before this.\n713         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n714       }\n715     }\n716 \n717     // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n718     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n719     while (cArg != null || fnParam != null) {\n720       // For each named parameter check if a mutable argument use more than one.\n721       if (fnParam != null) {\n722         if (cArg != null) {\n723 \n724           // Check for arguments that are evaluated more than once.\n725           // Note: Unlike block inlining, there it is not possible that a\n726           // parameter reference will be in a loop.\n727           if (NodeUtil.mayEffectMutableState(cArg, compiler)\n728               && NodeUtil.getNameReferenceCount(\n729                   block, fnParam.getString()) > 1) {\n730             return CanInlineResult.NO;\n731           }\n732         }\n733 \n734         // Move to the next name.\n735         fnParam = fnParam.getNext();\n736       }\n737 \n738       // For every call argument check for side-effects, even if there\n739       // isn't a named parameter to match.\n740       if (cArg != null) {\n741         if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n742           return CanInlineResult.NO;\n743         }\n744         cArg = cArg.getNext();\n745       }\n746     }\n747 \n748     return CanInlineResult.YES;\n749   }", "bm_classpath": "com.google.javascript.jscomp.FunctionInjector"}, {"bug_name": "Closure_117", "report_text": "> Wrong type name reported on missing property error.\n> \n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> function C2() {}\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> function C3(c2) {\r\n>  /\\*\\*\r\n>  \\* @type {C2} \r\n>  \\* @private\r\n>  \\*/\r\n>  this.c2\\_;\r\n> \r\n>  use(this.c2\\_.prop);\r\n> }\r\n> \r\n> Produces:\r\n> \r\n> Property prop never defined on C3.c2\\_\r\n> \r\n> But should be:\r\n> \r\n> Property prop never defined on C2", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1047", "test_method": "  public void testIssue1047() throws Exception {\n    testTypes(\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C2() {}\\n\" +\n        \"\\n\" +\n        \"/**\\n\" +\n        \" * @constructor\\n\" +\n        \" */\\n\" +\n        \"function C3(c2) {\\n\" +\n        \"  /**\\n\" +\n        \"   * @type {C2} \\n\" +\n        \"   * @private\\n\" +\n        \"   */\\n\" +\n        \"  this.c2_;\\n\" +\n        \"\\n\" +\n        \"  var x = this.c2_.prop;\\n\" +\n        \"}\",\n        \"Property prop never defined on C2\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...p never defined on C[2]> but was:<...p never defined on C[3.c2_]>\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12265)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12244)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12180)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue1047(TypeCheckTest.java:6852)", "buggy_method": "724 String getReadableJSTypeName(Node n, boolean dereference) {\n725 \n726     // The best type name is the actual type name.\n727 \n728     // If we're analyzing a GETPROP, the property may be inherited by the\n729     // prototype chain. So climb the prototype chain and find out where\n730     // the property was originally defined.\n731     if (n.isGetProp()) {\n732       ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n733       if (objectType != null) {\n734         String propName = n.getLastChild().getString();\n735         if (objectType.getConstructor() != null &&\n736             objectType.getConstructor().isInterface()) {\n737           objectType = FunctionType.getTopDefiningInterface(\n738               objectType, propName);\n739         } else {\n740           // classes\n741           while (objectType != null && !objectType.hasOwnProperty(propName)) {\n742             objectType = objectType.getImplicitPrototype();\n743           }\n744         }\n745 \n746         // Don't show complex function names or anonymous types.\n747         // Instead, try to get a human-readable type name.\n748         if (objectType != null &&\n749             (objectType.getConstructor() != null ||\n750              objectType.isFunctionPrototypeType())) {\n751           return objectType.toString() + \".\" + propName;\n752         }\n753       }\n754     }\n755 \n756     JSType type = getJSType(n);\n757     if (dereference) {\n758       ObjectType dereferenced = type.dereference();\n759       if (dereferenced != null) {\n760         type = dereferenced;\n761       }\n762     }\n763     if (type.isFunctionPrototypeType() ||\n764         (type.toObjectType() != null &&\n765          type.toObjectType().getConstructor() != null)) {\n766       return type.toString();\n767     }\n768     String qualifiedName = n.getQualifiedName();\n769     if (qualifiedName != null) {\n770       return qualifiedName;\n771     } else if (type.isFunctionType()) {\n772       // Don't show complex function names.\n773       return \"function\";\n774     } else {\n775       return type.toString();\n776     }\n777   }", "bm_classpath": "com.google.javascript.jscomp.TypeValidator"}, {"bug_name": "Closure_118", "report_text": "> Prototype method incorrectly removed\n> \n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // @formatting pretty\\_print\r\n> // ==/ClosureCompiler==\r\n> \r\n> /\\*\\* @const \\*/\r\n> var foo = {};\r\n> foo.bar = {\r\n>  'bar1': function() { console.log('bar1'); }\r\n> }\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> function foobar() {}\r\n> foobar.prototype = foo.bar;\r\n> \r\n> foo.foobar = new foobar;\r\n> \r\n> console.log(foo.foobar['bar1']);", "test_name": "com.google.javascript.jscomp.DisambiguatePropertiesTest::testOneType4", "test_method": "  public void testOneType4() {\n    String js = \"\"\n        + \"/** @constructor */ function Foo() {}\\n\"\n        + \"Foo.prototype = {'a': 0};\\n\"\n        + \"/** @type Foo */\\n\"\n        + \"var F = new Foo;\\n\"\n        + \"F['a'] = 0;\";\n    String expected = \"{}\";\n    testSets(false, js, js, expected); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[a=[[Foo.prototype]]]}>\n\tcom.google.javascript.jscomp.DisambiguatePropertiesTest.testSets(DisambiguatePropertiesTest.java:1372)\n\tcom.google.javascript.jscomp.DisambiguatePropertiesTest.testOneType4(DisambiguatePropertiesTest.java:128)", "buggy_method": "490 private void handleObjectLit(NodeTraversal t, Node n) {\n491       for (Node child = n.getFirstChild();\n492           child != null;\n493           child = child.getNext()) {\n494         // Maybe STRING, GET, SET\n495 \n496         // We should never see a mix of numbers and strings.\n497         String name = child.getString();\n498         T type = typeSystem.getType(getScope(), n, name);\n499 \n500         Property prop = getProperty(name);\n501         if (!prop.scheduleRenaming(child,\n502                                    processProperty(t, prop, type, null))) {\n503           // TODO(user): It doesn't look like the user can do much in this\n504           // case right now.\n505           if (propertiesToErrorFor.containsKey(name)) {\n506             compiler.report(JSError.make(\n507                 t.getSourceName(), child, propertiesToErrorFor.get(name),\n508                 Warnings.INVALIDATION, name,\n509                 (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n510           }\n511         }\n512       }\n513     }", "bm_classpath": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties"}, {"bug_name": "Closure_119", "report_text": "> catch(e) yields JSC_UNDEFINED_NAME warning when e is used in catch in advanced mode\n> \n> **What steps will reproduce the problem?**\n> 1. set closure for advanced compilation\r\n> 2. compile this:\r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> try {\r\n> var x = 5;\r\n> }\r\n> catch(e) {\r\n> var s = \"FAIL\" + e.name + \": \"+ e.message;\r\n> }\r\n> \r\n> **What is the expected output? What do you see instead?**\n> I expect no warning or error for this. Instead I see this:\r\n> \r\n> JSC\\_UNREACHABLE\\_CODE: unreachable code at line 4 character 0\r\n> catch(e) {\r\n> ^\r\n> JSC\\_UNDEFINED\\_NAME: e is never defined at line 5 character 17\r\n> var s = \"FAIL\" + e.name + \": \"+ e.message;\r\n>  ^\r\n> JSC\\_UNDEFINED\\_NAME: e is never defined at line 5 character 32\r\n> var s = \"FAIL\" + e.name + \": \"+ e.message;\r\n>  ^\r\n> In my case I'm especially complaining about the JSC\\_UNDEFINED\\_NAME warning... Also it seems the unreachable complaint isn't right, but i'm not sure.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> I'm using this url: http://closure-compiler.appspot.com/home\r\n> using chrome browser on windows: Version 28.0.1500.95 m \r\n> ... but this is a server side error from what I see...\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.CheckGlobalNamesTest::testGlobalCatch", "test_method": "  public void testGlobalCatch() throws Exception {\n    testSame(\n        \"try {\" +\n        \"  throw Error();\" +\n        \"} catch (e) {\" +\n        \"  console.log(e.name)\" +\n        \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected warning(s): JSC_UNDEFINED_NAME. e is never defined at testcode line 1 : 48\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:895)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:599)\n\tcom.google.javascript.jscomp.CheckGlobalNamesTest.testGlobalCatch(CheckGlobalNamesTest.java:341)", "buggy_method": "306 public void collect(JSModule module, Scope scope, Node n) {\n307       Node parent = n.getParent();\n308 \n309       String name;\n310       boolean isSet = false;\n311       Name.Type type = Name.Type.OTHER;\n312       boolean isPropAssign = false;\n313 \n314       switch (n.getType()) {\n315         case Token.GETTER_DEF:\n316         case Token.SETTER_DEF:\n317         case Token.STRING_KEY:\n318           // This may be a key in an object literal declaration.\n319           name = null;\n320           if (parent != null && parent.isObjectLit()) {\n321             name = getNameForObjLitKey(n);\n322           }\n323           if (name == null) {\n324             return;\n325           }\n326           isSet = true;\n327           switch (n.getType()) {\n328             case Token.STRING_KEY:\n329               type = getValueType(n.getFirstChild());\n330               break;\n331             case Token.GETTER_DEF:\n332               type = Name.Type.GET;\n333               break;\n334             case Token.SETTER_DEF:\n335               type = Name.Type.SET;\n336               break;\n337             default:\n338               throw new IllegalStateException(\"unexpected:\" + n);\n339           }\n340           break;\n341         case Token.NAME:\n342           // This may be a variable get or set.\n343           if (parent != null) {\n344             switch (parent.getType()) {\n345               case Token.VAR:\n346                 isSet = true;\n347                 Node rvalue = n.getFirstChild();\n348                 type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n349                 break;\n350               case Token.ASSIGN:\n351                 if (parent.getFirstChild() == n) {\n352                   isSet = true;\n353                   type = getValueType(n.getNext());\n354                 }\n355                 break;\n356               case Token.GETPROP:\n357                 return;\n358               case Token.FUNCTION:\n359                 Node gramps = parent.getParent();\n360                 if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n361                   return;\n362                 }\n363                 isSet = true;\n364                 type = Name.Type.FUNCTION;\n365                 break;\n366               case Token.INC:\n367               case Token.DEC:\n368                 isSet = true;\n369                 type = Name.Type.OTHER;\n370                 break;\n371               default:\n372                 if (NodeUtil.isAssignmentOp(parent) &&\n373                     parent.getFirstChild() == n) {\n374                   isSet = true;\n375                   type = Name.Type.OTHER;\n376                 }\n377             }\n378           }\n379           name = n.getString();\n380           break;\n381         case Token.GETPROP:\n382           // This may be a namespaced name get or set.\n383           if (parent != null) {\n384             switch (parent.getType()) {\n385               case Token.ASSIGN:\n386                 if (parent.getFirstChild() == n) {\n387                   isSet = true;\n388                   type = getValueType(n.getNext());\n389                   isPropAssign = true;\n390                 }\n391                 break;\n392               case Token.INC:\n393               case Token.DEC:\n394                 isSet = true;\n395                 type = Name.Type.OTHER;\n396                 break;\n397               case Token.GETPROP:\n398                 return;\n399               default:\n400                 if (NodeUtil.isAssignmentOp(parent) &&\n401                     parent.getFirstChild() == n) {\n402                   isSet = true;\n403                   type = Name.Type.OTHER;\n404                 }\n405             }\n406           }\n407           name = n.getQualifiedName();\n408           if (name == null) {\n409             return;\n410           }\n411           break;\n412         default:\n413           return;\n414       }\n415 \n416       // We are only interested in global names.\n417       if (!isGlobalNameReference(name, scope)) {\n418         return;\n419       }\n420 \n421       if (isSet) {\n422         if (isGlobalScope(scope)) {\n423           handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n424         } else {\n425           handleSetFromLocal(module, scope, n, parent, name);\n426         }\n427       } else {\n428         handleGet(module, scope, n, parent, name);\n429       }\n430     }", "bm_classpath": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace"}, {"bug_name": "Closure_120", "report_text": "> Overzealous optimization confuses variables\n> \n> The following code:\r\n> \r\n>  // ==ClosureCompiler==\r\n>  // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n>  // ==/ClosureCompiler==\r\n>  var uid;\r\n>  function reset() {\r\n>  uid = Math.random();\r\n>  }\r\n>  function doStuff() {\r\n>  reset();\r\n>  var \\_uid = uid;\r\n> \r\n>  if (uid < 0.5) {\r\n>  doStuff();\r\n>  }\r\n> \r\n>  if (\\_uid !== uid) {\r\n>  throw 'reset() was called';\r\n>  }\r\n>  }\r\n>  doStuff();\r\n> \r\n> ...gets optimized to:\r\n> \r\n>  var a;function b(){a=Math.random();0.5>a&&b();if(a!==a)throw\"reset() was called\";}b();\r\n> \r\n> Notice how \\_uid gets optimized away and (uid!==\\_uid) becomes (a!==a) even though doStuff() might have been called and uid's value may have changed and become different from \\_uid.\r\n> \r\n> As an aside, replacing the declaration with \"var \\_uid = +uid;\" fixes it, as does adding an extra \"uid = \\_uid\" after \"var \\_uid = uid\".", "test_name": "com.google.javascript.jscomp.InlineVariablesTest::testExternalIssue1053", "test_method": "  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:957)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:599)\n\tcom.google.javascript.jscomp.InlineVariablesTest.testExternalIssue1053(InlineVariablesTest.java:1069)", "buggy_method": "421 boolean isAssignedOnceInLifetime() {\n422       Reference ref = getOneAndOnlyAssignment();\n423       if (ref == null) {\n424         return false;\n425       }\n426 \n427       // Make sure this assignment is not in a loop.\n428       for (BasicBlock block = ref.getBasicBlock();\n429            block != null; block = block.getParent()) {\n430         if (block.isFunction) {\n431           break;\n432         } else if (block.isLoop) {\n433           return false;\n434         }\n435       }\n436 \n437       return true;\n438     }", "bm_classpath": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceCollection"}, {"bug_name": "Closure_121", "report_text": "> Overzealous optimization confuses variables\n> \n> The following code:\r\n> \r\n>  // ==ClosureCompiler==\r\n>  // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n>  // ==/ClosureCompiler==\r\n>  var uid;\r\n>  function reset() {\r\n>  uid = Math.random();\r\n>  }\r\n>  function doStuff() {\r\n>  reset();\r\n>  var \\_uid = uid;\r\n> \r\n>  if (uid < 0.5) {\r\n>  doStuff();\r\n>  }\r\n> \r\n>  if (\\_uid !== uid) {\r\n>  throw 'reset() was called';\r\n>  }\r\n>  }\r\n>  doStuff();\r\n> \r\n> ...gets optimized to:\r\n> \r\n>  var a;function b(){a=Math.random();0.5>a&&b();if(a!==a)throw\"reset() was called\";}b();\r\n> \r\n> Notice how \\_uid gets optimized away and (uid!==\\_uid) becomes (a!==a) even though doStuff() might have been called and uid's value may have changed and become different from \\_uid.\r\n> \r\n> As an aside, replacing the declaration with \"var \\_uid = +uid;\" fixes it, as does adding an extra \"uid = \\_uid\" after \"var \\_uid = uid\".", "test_name": "com.google.javascript.jscomp.InlineVariablesTest::testExternalIssue1053", "test_method": "  public void testExternalIssue1053() {\n    testSame(\n        \"var u; function f() { u = Random(); var x = u; f(); alert(x===u)}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:957)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:599)\n\tcom.google.javascript.jscomp.InlineVariablesTest.testExternalIssue1053(InlineVariablesTest.java:1069)", "buggy_method": "254 private void inlineNonConstants(\n255         Var v, ReferenceCollection referenceInfo,\n256         boolean maybeModifiedArguments) {\n257       int refCount = referenceInfo.references.size();\n258       Reference declaration = referenceInfo.references.get(0);\n259       Reference init = referenceInfo.getInitializingReference();\n260       int firstRefAfterInit = (declaration == init) ? 2 : 3;\n261 \n262       if (refCount > 1 &&\n263           isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n264         // if the variable is referenced more than once, we can only\n265         // inline it if it's immutable and never defined before referenced.\n266         Node value;\n267         if (init != null) {\n268           value = init.getAssignedValue();\n269         } else {\n270           // Create a new node for variable that is never initialized.\n271           Node srcLocation = declaration.getNode();\n272           value = NodeUtil.newUndefinedNode(srcLocation);\n273         }\n274         Preconditions.checkNotNull(value);\n275         inlineWellDefinedVariable(v, value, referenceInfo.references);\n276         staleVars.add(v);\n277       } else if (refCount == firstRefAfterInit) {\n278         // The variable likely only read once, try some more\n279         // complex inlining heuristics.\n280         Reference reference = referenceInfo.references.get(\n281             firstRefAfterInit - 1);\n282         if (canInline(declaration, init, reference)) {\n283           inline(v, declaration, init, reference);\n284           staleVars.add(v);\n285         }\n286       } else if (declaration != init && refCount == 2) {\n287         if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n288           // The only reference is the initialization, remove the assignment and\n289           // the variable declaration.\n290           Node value = init.getAssignedValue();\n291           Preconditions.checkNotNull(value);\n292           inlineWellDefinedVariable(v, value, referenceInfo.references);\n293           staleVars.add(v);\n294         }\n295       }\n296 \n297       // If this variable was not inlined normally, check if we can\n298       // inline an alias of it. (If the variable was inlined, then the\n299       // reference data is out of sync. We're better off just waiting for\n300       // the next pass.)\n301       if (!maybeModifiedArguments &&\n302           !staleVars.contains(v) &&\n303           referenceInfo.isWellDefined() &&\n304           referenceInfo.isAssignedOnceInLifetime()) {\n305           // Inlining the variable based solely on well-defined and assigned\n306           // once is *NOT* correct. We relax the correctness requirement if\n307           // the variable is declared constant.\n308         List<Reference> refs = referenceInfo.references;\n309         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n310           Node nameNode = refs.get(i).getNode();\n311           if (aliasCandidates.containsKey(nameNode)) {\n312             AliasCandidate candidate = aliasCandidates.get(nameNode);\n313             if (!staleVars.contains(candidate.alias) &&\n314                 !isVarInlineForbidden(candidate.alias)) {\n315               Reference aliasInit;\n316               aliasInit = candidate.refInfo.getInitializingReference();\n317               Node value = aliasInit.getAssignedValue();\n318               Preconditions.checkNotNull(value);\n319               inlineWellDefinedVariable(candidate.alias,\n320                   value,\n321                   candidate.refInfo.references);\n322               staleVars.add(candidate.alias);\n323             }\n324           }\n325         }\n326       }\n327     }", "bm_classpath": "com.google.javascript.jscomp.InlineVariables$InliningBehavior"}, {"bug_name": "Closure_122", "report_text": "> Inconsistent handling of non-JSDoc comments\n> \n> **What steps will reproduce the problem?**\n> **1.**\n> **2.**\n> **3.**\n> **What is the expected output? What do you see instead?**\n> \r\n> When given:\r\n> \r\n>  /\\* @preserve Foo License \\*/\r\n>  alert(\"foo\");\r\n> \r\n> It spits out:\r\n> \r\n>  stdin:1: WARNING - Parse error. Non-JSDoc comment has annotations. Did you mean to start it with '/\\*\\*'?\r\n>  /\\* @license Foo License \\*/\r\n>  ^\r\n>  \r\n>  0 error(s), 1 warning(s)\r\n>  alert(\"foo\");\r\n> \r\n> If I take the suggestion and change the opening of the comment to '/\\*\\*', everything is great. However, if I change it to '/\\*!', the warning goes away, but it doesn't preserve the comment either.\r\n> \r\n> I expect it to print the above warning, or preserve the comment. That it does neither when starting with \"/\\*!\" (and every other character I tried) is confusing.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Tested with my compilation of the \"v20130603\" tag:\r\n> \r\n>  Closure Compiler (http://code.google.com/closure/compiler)\r\n>  Version: v20130603\r\n>  Built on: 2013/07/07 15:04\r\n> \r\n> And with the provided binary:\r\n> \r\n>  Closure Compiler (http://code.google.com/closure/compiler)\r\n>  Version: v20130411-90-g4e19b4e\r\n>  Built on: 2013/06/03 12:07\r\n> \r\n> I'm on Parabola GNU/Linux-libre with Java:\r\n> \r\n>  java version \"1.7.0\\_40\"\r\n>  OpenJDK Runtime Environment (IcedTea 2.4.0) (ArchLinux build 7.u40\\_2.4.0-1-i686)\r\n>  OpenJDK Server VM (build 24.0-b40, mixed mode)\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.parsing.ParserTest::testSuspiciousBlockCommentWarning3", "test_method": "  public void testSuspiciousBlockCommentWarning3() {\n    parse(\"/* \\n *@type {number} */ var x = 3;\", SUSPICIOUS_COMMENT_WARNING); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.parsing.ParserTest.parse(ParserTest.java:1163)\n\tcom.google.javascript.jscomp.parsing.ParserTest.testSuspiciousBlockCommentWarning3(ParserTest.java:695)", "buggy_method": "251 private void handleBlockComment(Comment comment) {\n252     if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n253       errorReporter.warning(\n254           SUSPICIOUS_COMMENT_WARNING,\n255           sourceName,\n256           comment.getLineno(), \"\", 0);\n257     }\n258   }", "bm_classpath": "com.google.javascript.jscomp.parsing.IRFactory"}, {"bug_name": "Closure_123", "report_text": "> Generates code with invalid for/in left-hand assignment\n> \n> **What steps will reproduce the problem?**\n> 1. Compile this:\r\n> \r\n> window.Foo = function(A, B, C, D) {\r\n>  if ( A ) { \r\n>  if ( B ) {\r\n>  C = 0;\r\n>  } else {\r\n>  C = 0 in D;\r\n>  }\r\n>  while ( C-- ) {}\r\n>  }\r\n> }\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expected: Something that doesn't have a syntax error, maybe\r\n> \r\n> window.Foo=function(b,c,a,d){if(b)for(a=c?0:(0 in d);a--;);};\r\n> \r\n> Actual:\r\n> \r\n> window.Foo=function(b,c,a,d){if(b)for(a=c?0:0 in d;a--;);};\r\n> \r\n> SyntaxError: Unexpected token ; (Chrome)\r\n> invalid for/in left-hand side (Firefox)\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> http://closure-compiler.appspot.com/home\r\n> \r\n> \r\n> **Please provide any additional information below.**\n> \r\n> I noticed this while attempting to minify jquery", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testPrintInOperatorInForLoop", "test_method": "  public void testPrintInOperatorInForLoop() {\n    // Check for in expression in for's init expression.\n    // Check alone, with + (higher precedence), with ?: (lower precedence),\n    // and with conditional.\n\n    // Test works with unary operators and calls.\n\n    // Test we correctly handle an in operator in the test clause.\n\n    // Test we correctly handle an in operator inside a comma.\n\n    // And in operator inside a hook.\n    assertPrintSame(\"for(a=c?0:(0 in d);;)foo()\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:480)\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrintSame(CodePrinterTest.java:485)\n\tcom.google.javascript.jscomp.CodePrinterTest.testPrintInOperatorInForLoop(CodePrinterTest.java:471)", "buggy_method": "107 void add(Node n, Context context) {\n108     if (!cc.continueProcessing()) {\n109       return;\n110     }\n111 \n112     int type = n.getType();\n113     String opstr = NodeUtil.opToStr(type);\n114     int childCount = n.getChildCount();\n115     Node first = n.getFirstChild();\n116     Node last = n.getLastChild();\n117 \n118     // Handle all binary operators\n119     if (opstr != null && first != last) {\n120       Preconditions.checkState(\n121           childCount == 2,\n122           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n123           opstr, childCount);\n124       int p = NodeUtil.precedence(type);\n125 \n126       // For right-hand-side of operations, only pass context if it's\n127       // the IN_FOR_INIT_CLAUSE one.\n128       Context rhsContext = getContextForNoInOperator(context);\n129 \n130       // Handle associativity.\n131       // e.g. if the parse tree is a * (b * c),\n132       // we can simply generate a * b * c.\n133       if (last.getType() == type &&\n134           NodeUtil.isAssociative(type)) {\n135         addExpr(first, p, context);\n136         cc.addOp(opstr, true);\n137         addExpr(last, p, rhsContext);\n138       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n139         // Assignments are the only right-associative binary operators\n140         addExpr(first, p, context);\n141         cc.addOp(opstr, true);\n142         addExpr(last, p, rhsContext);\n143       } else {\n144         unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n145       }\n146       return;\n147     }\n148 \n149     cc.startSourceMapping(n);\n150 \n151     switch (type) {\n152       case Token.TRY: {\n153         Preconditions.checkState(first.getNext().isBlock() &&\n154                 !first.getNext().hasMoreThanOneChild());\n155         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n156 \n157         add(\"try\");\n158         add(first, Context.PRESERVE_BLOCK);\n159 \n160         // second child contains the catch block, or nothing if there\n161         // isn't a catch block\n162         Node catchblock = first.getNext().getFirstChild();\n163         if (catchblock != null) {\n164           add(catchblock);\n165         }\n166 \n167         if (childCount == 3) {\n168           add(\"finally\");\n169           add(last, Context.PRESERVE_BLOCK);\n170         }\n171         break;\n172       }\n173 \n174       case Token.CATCH:\n175         Preconditions.checkState(childCount == 2);\n176         add(\"catch(\");\n177         add(first);\n178         add(\")\");\n179         add(last, Context.PRESERVE_BLOCK);\n180         break;\n181 \n182       case Token.THROW:\n183         Preconditions.checkState(childCount == 1);\n184         add(\"throw\");\n185         add(first);\n186 \n187         // Must have a ';' after a throw statement, otherwise safari can't\n188         // parse this.\n189         cc.endStatement(true);\n190         break;\n191 \n192       case Token.RETURN:\n193         add(\"return\");\n194         if (childCount == 1) {\n195           add(first);\n196         } else {\n197           Preconditions.checkState(childCount == 0);\n198         }\n199         cc.endStatement();\n200         break;\n201 \n202       case Token.VAR:\n203         if (first != null) {\n204           add(\"var \");\n205           addList(first, false, getContextForNoInOperator(context));\n206         }\n207         break;\n208 \n209       case Token.LABEL_NAME:\n210         Preconditions.checkState(!n.getString().isEmpty());\n211         addIdentifier(n.getString());\n212         break;\n213 \n214       case Token.NAME:\n215         if (first == null || first.isEmpty()) {\n216           addIdentifier(n.getString());\n217         } else {\n218           Preconditions.checkState(childCount == 1);\n219           addIdentifier(n.getString());\n220           cc.addOp(\"=\", true);\n221           if (first.isComma()) {\n222             addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n223           } else {\n224             // Add expression, consider nearby code at lowest level of\n225             // precedence.\n226             addExpr(first, 0, getContextForNoInOperator(context));\n227           }\n228         }\n229         break;\n230 \n231       case Token.ARRAYLIT:\n232         add(\"[\");\n233         addArrayList(first);\n234         add(\"]\");\n235         break;\n236 \n237       case Token.PARAM_LIST:\n238         add(\"(\");\n239         addList(first);\n240         add(\")\");\n241         break;\n242 \n243       case Token.COMMA:\n244         Preconditions.checkState(childCount == 2);\n245         unrollBinaryOperator(n, Token.COMMA, \",\", context,\n246             getContextForNoInOperator(context), 0, 0);\n247         break;\n248 \n249       case Token.NUMBER:\n250         Preconditions.checkState(childCount == 0);\n251         cc.addNumber(n.getDouble());\n252         break;\n253 \n254       case Token.TYPEOF:\n255       case Token.VOID:\n256       case Token.NOT:\n257       case Token.BITNOT:\n258       case Token.POS: {\n259         // All of these unary operators are right-associative\n260         Preconditions.checkState(childCount == 1);\n261         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n262         addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n263         break;\n264       }\n265 \n266       case Token.NEG: {\n267         Preconditions.checkState(childCount == 1);\n268 \n269         // It's important to our sanity checker that the code\n270         // we print produces the same AST as the code we parse back.\n271         // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n272         if (n.getFirstChild().isNumber()) {\n273           cc.addNumber(-n.getFirstChild().getDouble());\n274         } else {\n275           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n276           addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n277         }\n278 \n279         break;\n280       }\n281 \n282       case Token.HOOK: {\n283         Preconditions.checkState(childCount == 3);\n284         int p = NodeUtil.precedence(type);\n285         Context rhsContext = Context.OTHER;\n286         addExpr(first, p + 1, context);\n287         cc.addOp(\"?\", true);\n288         addExpr(first.getNext(), 1, rhsContext);\n289         cc.addOp(\":\", true);\n290         addExpr(last, 1, rhsContext);\n291         break;\n292       }\n293 \n294       case Token.REGEXP:\n295         if (!first.isString() ||\n296             !last.isString()) {\n297           throw new Error(\"Expected children to be strings\");\n298         }\n299 \n300         String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n301 \n302         // I only use one .add because whitespace matters\n303         if (childCount == 2) {\n304           add(regexp + last.getString());\n305         } else {\n306           Preconditions.checkState(childCount == 1);\n307           add(regexp);\n308         }\n309         break;\n310 \n311       case Token.FUNCTION:\n312         if (n.getClass() != Node.class) {\n313           throw new Error(\"Unexpected Node subclass.\");\n314         }\n315         Preconditions.checkState(childCount == 3);\n316         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n317         if (funcNeedsParens) {\n318           add(\"(\");\n319         }\n320 \n321         add(\"function\");\n322         add(first);\n323 \n324         add(first.getNext());\n325         add(last, Context.PRESERVE_BLOCK);\n326         cc.endFunction(context == Context.STATEMENT);\n327 \n328         if (funcNeedsParens) {\n329           add(\")\");\n330         }\n331         break;\n332 \n333       case Token.GETTER_DEF:\n334       case Token.SETTER_DEF:\n335         Preconditions.checkState(n.getParent().isObjectLit());\n336         Preconditions.checkState(childCount == 1);\n337         Preconditions.checkState(first.isFunction());\n338 \n339         // Get methods are unnamed\n340         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n341         if (type == Token.GETTER_DEF) {\n342           // Get methods have no parameters.\n343           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n344           add(\"get \");\n345         } else {\n346           // Set methods have one parameter.\n347           Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n348           add(\"set \");\n349         }\n350 \n351         // The name is on the GET or SET node.\n352         String name = n.getString();\n353         Node fn = first;\n354         Node parameters = fn.getChildAtIndex(1);\n355         Node body = fn.getLastChild();\n356 \n357         // Add the property name.\n358         if (!n.isQuotedString() &&\n359             TokenStream.isJSIdentifier(name) &&\n360             // do not encode literally any non-literal characters that were\n361             // Unicode escaped.\n362             NodeUtil.isLatin(name)) {\n363           add(name);\n364         } else {\n365           // Determine if the string is a simple number.\n366           double d = getSimpleNumber(name);\n367           if (!Double.isNaN(d)) {\n368             cc.addNumber(d);\n369           } else {\n370             addJsString(n);\n371           }\n372         }\n373 \n374         add(parameters);\n375         add(body, Context.PRESERVE_BLOCK);\n376         break;\n377 \n378       case Token.SCRIPT:\n379       case Token.BLOCK: {\n380         if (n.getClass() != Node.class) {\n381           throw new Error(\"Unexpected Node subclass.\");\n382         }\n383         boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n384         if (preserveBlock) {\n385           cc.beginBlock();\n386         }\n387 \n388         boolean preferLineBreaks =\n389             type == Token.SCRIPT ||\n390             (type == Token.BLOCK &&\n391                 !preserveBlock &&\n392                 n.getParent() != null &&\n393                 n.getParent().isScript());\n394         for (Node c = first; c != null; c = c.getNext()) {\n395           add(c, Context.STATEMENT);\n396 \n397           // VAR doesn't include ';' since it gets used in expressions\n398           if (c.isVar()) {\n399             cc.endStatement();\n400           }\n401 \n402           if (c.isFunction()) {\n403             cc.maybeLineBreak();\n404           }\n405 \n406           // Prefer to break lines in between top-level statements\n407           // because top-level statements are more homogeneous.\n408           if (preferLineBreaks) {\n409             cc.notePreferredLineBreak();\n410           }\n411         }\n412         if (preserveBlock) {\n413           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n414         }\n415         break;\n416       }\n417 \n418       case Token.FOR:\n419         if (childCount == 4) {\n420           add(\"for(\");\n421           if (first.isVar()) {\n422             add(first, Context.IN_FOR_INIT_CLAUSE);\n423           } else {\n424             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n425           }\n426           add(\";\");\n427           add(first.getNext());\n428           add(\";\");\n429           add(first.getNext().getNext());\n430           add(\")\");\n431           addNonEmptyStatement(\n432               last, getContextForNonEmptyExpression(context), false);\n433         } else {\n434           Preconditions.checkState(childCount == 3);\n435           add(\"for(\");\n436           add(first);\n437           add(\"in\");\n438           add(first.getNext());\n439           add(\")\");\n440           addNonEmptyStatement(\n441               last, getContextForNonEmptyExpression(context), false);\n442         }\n443         break;\n444 \n445       case Token.DO:\n446         Preconditions.checkState(childCount == 2);\n447         add(\"do\");\n448         addNonEmptyStatement(first, Context.OTHER, false);\n449         add(\"while(\");\n450         add(last);\n451         add(\")\");\n452         cc.endStatement();\n453         break;\n454 \n455       case Token.WHILE:\n456         Preconditions.checkState(childCount == 2);\n457         add(\"while(\");\n458         add(first);\n459         add(\")\");\n460         addNonEmptyStatement(\n461             last, getContextForNonEmptyExpression(context), false);\n462         break;\n463 \n464       case Token.EMPTY:\n465         Preconditions.checkState(childCount == 0);\n466         break;\n467 \n468       case Token.GETPROP: {\n469         Preconditions.checkState(\n470             childCount == 2,\n471             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n472         Preconditions.checkState(\n473             last.isString(),\n474             \"Bad GETPROP: RHS should be STRING\");\n475         boolean needsParens = (first.isNumber());\n476         if (needsParens) {\n477           add(\"(\");\n478         }\n479         addExpr(first, NodeUtil.precedence(type), context);\n480         if (needsParens) {\n481           add(\")\");\n482         }\n483         if (this.languageMode == LanguageMode.ECMASCRIPT3\n484             && TokenStream.isKeyword(last.getString())) {\n485           // Check for ECMASCRIPT3 keywords.\n486           add(\"[\");\n487           add(last);\n488           add(\"]\");\n489         } else {\n490           add(\".\");\n491           addIdentifier(last.getString());\n492         }\n493         break;\n494       }\n495 \n496       case Token.GETELEM:\n497         Preconditions.checkState(\n498             childCount == 2,\n499             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n500         addExpr(first, NodeUtil.precedence(type), context);\n501         add(\"[\");\n502         add(first.getNext());\n503         add(\"]\");\n504         break;\n505 \n506       case Token.WITH:\n507         Preconditions.checkState(childCount == 2);\n508         add(\"with(\");\n509         add(first);\n510         add(\")\");\n511         addNonEmptyStatement(\n512             last, getContextForNonEmptyExpression(context), false);\n513         break;\n514 \n515       case Token.INC:\n516       case Token.DEC: {\n517         Preconditions.checkState(childCount == 1);\n518         String o = type == Token.INC ? \"++\" : \"--\";\n519         int postProp = n.getIntProp(Node.INCRDECR_PROP);\n520         // A non-zero post-prop value indicates a post inc/dec, default of zero\n521         // is a pre-inc/dec.\n522         if (postProp != 0) {\n523           addExpr(first, NodeUtil.precedence(type), context);\n524           cc.addOp(o, false);\n525         } else {\n526           cc.addOp(o, false);\n527           add(first);\n528         }\n529         break;\n530       }\n531 \n532       case Token.CALL:\n533         // We have two special cases here:\n534         // 1) If the left hand side of the call is a direct reference to eval,\n535         // then it must have a DIRECT_EVAL annotation. If it does not, then\n536         // that means it was originally an indirect call to eval, and that\n537         // indirectness must be preserved.\n538         // 2) If the left hand side of the call is a property reference,\n539         // then the call must not a FREE_CALL annotation. If it does, then\n540         // that means it was originally an call without an explicit this and\n541         // that must be preserved.\n542         if (isIndirectEval(first)\n543             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n544           add(\"(0,\");\n545           addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n546           add(\")\");\n547         } else {\n548           addExpr(first, NodeUtil.precedence(type), context);\n549         }\n550         add(\"(\");\n551         addList(first.getNext());\n552         add(\")\");\n553         break;\n554 \n555       case Token.IF:\n556         boolean hasElse = childCount == 3;\n557         boolean ambiguousElseClause =\n558             context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n559         if (ambiguousElseClause) {\n560           cc.beginBlock();\n561         }\n562 \n563         add(\"if(\");\n564         add(first);\n565         add(\")\");\n566 \n567         if (hasElse) {\n568           addNonEmptyStatement(\n569               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n570           add(\"else\");\n571           addNonEmptyStatement(\n572               last, getContextForNonEmptyExpression(context), false);\n573         } else {\n574           addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n575           Preconditions.checkState(childCount == 2);\n576         }\n577 \n578         if (ambiguousElseClause) {\n579           cc.endBlock();\n580         }\n581         break;\n582 \n583       case Token.NULL:\n584         Preconditions.checkState(childCount == 0);\n585         cc.addConstant(\"null\");\n586         break;\n587 \n588       case Token.THIS:\n589         Preconditions.checkState(childCount == 0);\n590         add(\"this\");\n591         break;\n592 \n593       case Token.FALSE:\n594         Preconditions.checkState(childCount == 0);\n595         cc.addConstant(\"false\");\n596         break;\n597 \n598       case Token.TRUE:\n599         Preconditions.checkState(childCount == 0);\n600         cc.addConstant(\"true\");\n601         break;\n602 \n603       case Token.CONTINUE:\n604         Preconditions.checkState(childCount <= 1);\n605         add(\"continue\");\n606         if (childCount == 1) {\n607           if (!first.isLabelName()) {\n608             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n609           }\n610           add(\" \");\n611           add(first);\n612         }\n613         cc.endStatement();\n614         break;\n615 \n616       case Token.DEBUGGER:\n617         Preconditions.checkState(childCount == 0);\n618         add(\"debugger\");\n619         cc.endStatement();\n620         break;\n621 \n622       case Token.BREAK:\n623         Preconditions.checkState(childCount <= 1);\n624         add(\"break\");\n625         if (childCount == 1) {\n626           if (!first.isLabelName()) {\n627             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n628           }\n629           add(\" \");\n630           add(first);\n631         }\n632         cc.endStatement();\n633         break;\n634 \n635       case Token.EXPR_RESULT:\n636         Preconditions.checkState(childCount == 1);\n637         add(first, Context.START_OF_EXPR);\n638         cc.endStatement();\n639         break;\n640 \n641       case Token.NEW:\n642         add(\"new \");\n643         int precedence = NodeUtil.precedence(type);\n644 \n645         // If the first child contains a CALL, then claim higher precedence\n646         // to force parentheses. Otherwise, when parsed, NEW will bind to the\n647         // first viable parentheses (don't traverse into functions).\n648         if (NodeUtil.containsType(\n649             first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n650           precedence = NodeUtil.precedence(first.getType()) + 1;\n651         }\n652         addExpr(first, precedence, Context.OTHER);\n653 \n654         // '()' is optional when no arguments are present\n655         Node next = first.getNext();\n656         if (next != null) {\n657           add(\"(\");\n658           addList(next);\n659           add(\")\");\n660         }\n661         break;\n662 \n663       case Token.STRING_KEY:\n664         Preconditions.checkState(\n665             childCount == 1, \"Object lit key must have 1 child\");\n666         addJsString(n);\n667         break;\n668 \n669       case Token.STRING:\n670         Preconditions.checkState(\n671             childCount == 0, \"A string may not have children\");\n672         addJsString(n);\n673         break;\n674 \n675       case Token.DELPROP:\n676         Preconditions.checkState(childCount == 1);\n677         add(\"delete \");\n678         add(first);\n679         break;\n680 \n681       case Token.OBJECTLIT: {\n682         boolean needsParens = (context == Context.START_OF_EXPR);\n683         if (needsParens) {\n684           add(\"(\");\n685         }\n686         add(\"{\");\n687         for (Node c = first; c != null; c = c.getNext()) {\n688           if (c != first) {\n689             cc.listSeparator();\n690           }\n691 \n692           if (c.isGetterDef() || c.isSetterDef()) {\n693             add(c);\n694           } else {\n695             Preconditions.checkState(c.isStringKey());\n696             String key = c.getString();\n697             // Object literal property names don't have to be quoted if they\n698             // are not JavaScript keywords\n699             if (!c.isQuotedString()\n700                 && !(languageMode == LanguageMode.ECMASCRIPT3\n701                     && TokenStream.isKeyword(key))\n702                 && TokenStream.isJSIdentifier(key)\n703                 // do not encode literally any non-literal characters that\n704                 // were Unicode escaped.\n705                 && NodeUtil.isLatin(key)) {\n706               add(key);\n707             } else {\n708               // Determine if the string is a simple number.\n709               double d = getSimpleNumber(key);\n710               if (!Double.isNaN(d)) {\n711                 cc.addNumber(d);\n712               } else {\n713                 addExpr(c, 1, Context.OTHER);\n714               }\n715             }\n716             add(\":\");\n717             addExpr(c.getFirstChild(), 1, Context.OTHER);\n718           }\n719         }\n720         add(\"}\");\n721         if (needsParens) {\n722           add(\")\");\n723         }\n724         break;\n725       }\n726 \n727       case Token.SWITCH:\n728         add(\"switch(\");\n729         add(first);\n730         add(\")\");\n731         cc.beginBlock();\n732         addAllSiblings(first.getNext());\n733         cc.endBlock(context == Context.STATEMENT);\n734         break;\n735 \n736       case Token.CASE:\n737         Preconditions.checkState(childCount == 2);\n738         add(\"case \");\n739         add(first);\n740         addCaseBody(last);\n741         break;\n742 \n743       case Token.DEFAULT_CASE:\n744         Preconditions.checkState(childCount == 1);\n745         add(\"default\");\n746         addCaseBody(first);\n747         break;\n748 \n749       case Token.LABEL:\n750         Preconditions.checkState(childCount == 2);\n751         if (!first.isLabelName()) {\n752           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n753         }\n754         add(first);\n755         add(\":\");\n756         addNonEmptyStatement(\n757             last, getContextForNonEmptyExpression(context), true);\n758         break;\n759 \n760       case Token.CAST:\n761         add(\"(\");\n762         add(first);\n763         add(\")\");\n764         break;\n765 \n766       default:\n767         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n768     }\n769 \n770     cc.endSourceMapping(n);\n771   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_124", "report_text": "> Different output from RestAPI and command line jar\n> \n> When I compile using the jar file from the command line I get a result that is not correct. However, when I test it via the REST API or the Web UI I get a correct output. I've attached a file with the code that we are compiling.\r\n> \r\n> **What steps will reproduce the problem?**\n> 1. Compile the attached file with \"java -jar compiler.jar --js test.js\"\r\n> 2. Compile the content of the attached file on http://closure-compiler.appspot.com/home\r\n> 3. Compare the output, note how the following part is converted in the two cases:\r\n> \r\n> \"var foreignObject = gfx.parentNode.parentNode;\r\n> var parentContainer = foreignObject.parentNode.parentNode;\"\r\n> \r\n> **What is the expected output? What do you see instead?**\n> The Web UI converts the lines into: if(b){if(a=b.parentNode.parentNode,b=a.parentNode.parentNode,null!==b)\r\n> The command line converts it into: var b=a=a.parentNode.parentNode;\r\n> The Web UI results in correct code, the other results in code that tries to do \"c.appendChild(b)\" with c = b (c=a=a.parentNode.parentNode)\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> compiler.jar: v20130411-90-g4e19b4e\r\n> Mac OSX 10.8.3\r\n> Java: java 1.6.0\\_45\r\n> \r\n> **Please provide any additional information below.**\n> We are also using the compiler form within our java code, with the same result.\r\n> Web UI was called with:\r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level SIMPLE\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==", "test_name": "com.google.javascript.jscomp.ExploitAssignsTest::testIssue1017", "test_method": "  public void testIssue1017() {\n    testSame(\"x = x.parentNode.parentNode; x = x.parentNode.parentNode;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:957)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:599)\n\tcom.google.javascript.jscomp.ExploitAssignsTest.testIssue1017(ExploitAssignsTest.java:161)", "buggy_method": "206 private boolean isSafeReplacement(Node node, Node replacement) {\n207     // No checks are needed for simple names.\n208     if (node.isName()) {\n209       return true;\n210     }\n211     Preconditions.checkArgument(node.isGetProp());\n212 \n213       node = node.getFirstChild();\n214     if (node.isName()\n215         && isNameAssignedTo(node.getString(), replacement)) {\n216       return false;\n217     }\n218 \n219     return true;\n220   }", "bm_classpath": "com.google.javascript.jscomp.ExploitAssigns"}, {"bug_name": "Closure_125", "report_text": "> IllegalStateException at com.google.javascript.rhino.jstype.FunctionType.getInstanceType\n> \n> > What steps will reproduce the problem?\r\n> 1. Unpack attached test case.\r\n> 2. Ensure make, wget, unzip, and java are on your PATH\r\n> 3. make prep (or just set up the build manually, it's not complicated)\r\n> 4. make crash\r\n> \r\n> > What is the expected output? What do you see instead?\r\n> Expected output: either successful compilation, or a compilation error.\r\n> Actual output: \r\n> $ java \\\r\n>  -jar ./compiler.jar \\\r\n>  --js crash.js \\\r\n>  --warning\\_level=VERBOSE \\\r\n>  --compilation\\_level=SIMPLE\\_OPTIMIZATIONS\r\n> java.lang.RuntimeException: java.lang.IllegalStateException\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:715)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:647)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:603)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:783)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:379)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:972)\r\n> Caused by: java.lang.IllegalStateException\r\n>  at com.google.common.base.Preconditions.checkState(Preconditions.java:133)\r\n>  at com.google.javascript.rhino.jstype.FunctionType.getInstanceType(FunctionType.java:1071)\r\n>  at com.google.javascript.jscomp.TypeCheck.visitNew(TypeCheck.java:1567)\r\n>  at com.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:569)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:569)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:522)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:353)\r\n>  at com.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:400)\r\n>  at com.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:371)\r\n>  at com.google.javascript.jscomp.DefaultPassConfig$30$1.process(DefaultPassConfig.java:1237)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:293)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:237)\r\n>  at com.google.javascript.jscomp.Compiler.check(Compiler.java:830)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:742)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Compiler.java:83)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:650)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:647)\r\n>  at com.google.javascript.jscomp.Compiler$3.call(Compiler.java:677)\r\n>  at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)\r\n>  at java.util.concurrent.FutureTask.run(FutureTask.java:138)\r\n>  at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)\r\n>  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)\r\n>  at java.lang.Thread.run(Thread.java:680)\r\n> make: \\*\\*\\* [crash] Error 254\r\n> \r\n> > What version of the product are you using? On what operating system?\r\n> closure-compiler release 20130411. I have also encountered this error on earlier versions of closure-compiler, but the above repro recipe uses 20130411. I'm currently testing on OS X but this probably happens on other platforms too.\r\n> \r\n> > Please provide any additional information below.\r\n> \r\n> Here's the contents of crash.js (included in the attached archive):\r\n> \r\n> -----begin snip-----\r\n> var test = {};\r\n> \r\n> /\\*\\*\r\n>  \\* @interface\r\n>  \\*/\r\n> test.T = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @implements {test.T}\r\n>  \\*/\r\n> test.A = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @implements {test.T}\r\n>  \\*/\r\n> test.B = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> test.X = function() {\r\n>  this.type = test.A;\r\n>  this.t = this.f();\r\n> };\r\n> \r\n> /\\*\\*\r\n>  \\* @return {test.T}\r\n>  \\*/\r\n> test.X.prototype.f = function() {\r\n>  if (this.type === test.A) {\r\n>  return new test.A();\r\n>  } else if (this.type === test.B) {\r", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1002", "test_method": "  public void testIssue1002() throws Exception {\n    testTypes(\n        \"/** @interface */\" +\n        \"var I = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var A = function() {};\" +\n        \"/** @constructor @implements {I} */\" +\n        \"var B = function() {};\" +\n        \"var f = function() {\" +\n        \"  if (A === B) {\" +\n        \"    new B();\" +\n        \"  }\" +\n        \"};\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException\n\tcom.google.common.base.Preconditions.checkState(Preconditions.java:133)\n\tcom.google.javascript.rhino.jstype.FunctionType.getInstanceType(FunctionType.java:1071)\n\tcom.google.javascript.jscomp.TypeCheck.visitNew(TypeCheck.java:1663)\n\tcom.google.javascript.jscomp.TypeCheck.visit(TypeCheck.java:591)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:540)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseFunction(NodeTraversal.java:574)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:528)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseWithScope(NodeTraversal.java:353)\n\tcom.google.javascript.jscomp.TypeCheck.check(TypeCheck.java:422)\n\tcom.google.javascript.jscomp.TypeCheck.process(TypeCheck.java:393)\n\tcom.google.javascript.jscomp.TypeCheck.processForTesting(TypeCheck.java:411)\n\tcom.google.javascript.jscomp.TypeCheckTest.parseAndTypeCheckWithScope(TypeCheckTest.java:12021)\n\tcom.google.javascript.jscomp.TypeCheckTest.parseAndTypeCheck(TypeCheckTest.java:11993)", "buggy_method": "1656 private void visitNew(NodeTraversal t, Node n) {\n1657     Node constructor = n.getFirstChild();\n1658     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n1659     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n1660       FunctionType fnType = type.toMaybeFunctionType();\n1661       if (fnType != null) {\n1662         visitParameterList(t, n, fnType);\n1663         ensureTyped(t, n, fnType.getInstanceType());\n1664       } else {\n1665         ensureTyped(t, n);\n1666       }\n1667     } else {\n1668       report(t, n, NOT_A_CONSTRUCTOR);\n1669       ensureTyped(t, n);\n1670     }\n1671   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_126", "report_text": "> Break in finally block isn't optimized properly\n> \n> b: try { throw(\"throw me\") } finally { /\\* fake catcher \\*/ ; break b }; console.log(\"ok then...\")\r\n> \r\n> ... gets optimized into ...\r\n> \r\n>  throw\"throw me\";\r\n> \r\n> ... which is not the same.\r\n> \r\n> The break in the finally block should prevent the exception from being passed on. The expected result is:\r\n> \r\n>  console.log(\"ok then...\")\r\n> \r\n> ECMA-262 says:\r\n> \r\n> The production TryStatement : try Block Finally is evaluated as follows:\r\n> \r\n> Let B be the result of evaluating Block.\r\n> Let F be the result of evaluating Finally.\r\n> If F.type is normal, return B.\r\n> Return F.\r\n> \r\n> F.type in this case would be 'break' and not 'normal', so 'break' overrides the 'throw' of B\r\n> \r\n> This is with the build available for download on Feb 28 2013.", "test_name": "com.google.javascript.jscomp.MinimizeExitPointsTest::testDontRemoveBreakInTryFinally", "test_method": "  public void testDontRemoveBreakInTryFinally() throws Exception {\n    foldSame(\"function f() {b:try{throw 9} finally {break b} return 1;}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:928)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:460)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:386)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:355)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:343)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:582)\n\tcom.google.javascript.jscomp.MinimizeExitPointsTest.foldSame(MinimizeExitPointsTest.java:47)\n\tcom.google.javascript.jscomp.MinimizeExitPointsTest.testDontRemoveBreakInTryFinally(MinimizeExitPointsTest.java:276)", "buggy_method": "106 void tryMinimizeExits(Node n, int exitType, String labelName) {\n107 \n108     // Just an 'exit'.\n109     if (matchingExitNode(n, exitType, labelName)) {\n110       NodeUtil.removeChild(n.getParent(), n);\n111       compiler.reportCodeChange();\n112       return;\n113     }\n114 \n115     // Just an 'if'.\n116     if (n.isIf()) {\n117       Node ifBlock = n.getFirstChild().getNext();\n118       tryMinimizeExits(ifBlock, exitType, labelName);\n119       Node elseBlock = ifBlock.getNext();\n120       if (elseBlock != null) {\n121         tryMinimizeExits(elseBlock, exitType, labelName);\n122       }\n123       return;\n124     }\n125 \n126     // Just a 'try/catch/finally'.\n127     if (n.isTry()) {\n128       Node tryBlock = n.getFirstChild();\n129       tryMinimizeExits(tryBlock, exitType, labelName);\n130       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n131       if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n132         Preconditions.checkState(allCatchNodes.hasOneChild());\n133         Node catchNode = allCatchNodes.getFirstChild();\n134         Node catchCodeBlock = catchNode.getLastChild();\n135         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n136       }\n137       /* Don't try to minimize the exits of finally blocks, as this\n138        * can cause problems if it changes the completion type of the finally\n139        * block. See ECMA 262 Sections 8.9 & 12.14\n140        */\n141       if (NodeUtil.hasFinally(n)) {\n142         Node finallyBlock = n.getLastChild();\n143         tryMinimizeExits(finallyBlock, exitType, labelName);\n144       }\n145     }\n146 \n147     // Just a 'label'.\n148     if (n.isLabel()) {\n149       Node labelBlock = n.getLastChild();\n150       tryMinimizeExits(labelBlock, exitType, labelName);\n151     }\n152 \n153     // TODO(johnlenz): The last case of SWITCH statement?\n154 \n155     // The rest assumes a block with at least one child, bail on anything else.\n156     if (!n.isBlock() || n.getLastChild() == null) {\n157       return;\n158     }\n159 \n160     // Multiple if-exits can be converted in a single pass.\n161     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n162     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n163     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n164     for (Node c : n.children()) {\n165 \n166       // An 'if' block to process below.\n167       if (c.isIf()) {\n168         Node ifTree = c;\n169         Node trueBlock, falseBlock;\n170 \n171         // First, the true condition block.\n172         trueBlock = ifTree.getFirstChild().getNext();\n173         falseBlock = trueBlock.getNext();\n174         tryMinimizeIfBlockExits(trueBlock, falseBlock,\n175             ifTree, exitType, labelName);\n176 \n177         // Now the else block.\n178         // The if blocks may have changed, get them again.\n179         trueBlock = ifTree.getFirstChild().getNext();\n180         falseBlock = trueBlock.getNext();\n181         if (falseBlock != null) {\n182           tryMinimizeIfBlockExits(falseBlock, trueBlock,\n183               ifTree, exitType, labelName);\n184         }\n185       }\n186 \n187       if (c == n.getLastChild()) {\n188         break;\n189       }\n190     }\n191 \n192     // Now try to minimize the exits of the last child, if it is removed\n193     // look at what has become the last child.\n194     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n195       tryMinimizeExits(c, exitType, labelName);\n196       // If the node is still the last child, we are done.\n197       if (c == n.getLastChild()) {\n198         break;\n199       }\n200     }\n201   }", "bm_classpath": "com.google.javascript.jscomp.MinimizeExitPoints"}, {"bug_name": "Closure_127", "report_text": "> Break in finally block isn't optimized properly\n> \n> b: try { throw(\"throw me\") } finally { /\\* fake catcher \\*/ ; break b }; console.log(\"ok then...\")\r\n> \r\n> ... gets optimized into ...\r\n> \r\n>  throw\"throw me\";\r\n> \r\n> ... which is not the same.\r\n> \r\n> The break in the finally block should prevent the exception from being passed on. The expected result is:\r\n> \r\n>  console.log(\"ok then...\")\r\n> \r\n> ECMA-262 says:\r\n> \r\n> The production TryStatement : try Block Finally is evaluated as follows:\r\n> \r\n> Let B be the result of evaluating Block.\r\n> Let F be the result of evaluating Finally.\r\n> If F.type is normal, return B.\r\n> Return F.\r\n> \r\n> F.type in this case would be 'break' and not 'normal', so 'break' overrides the 'throw' of B\r\n> \r\n> This is with the build available for download on Feb 28 2013.", "test_name": "com.google.javascript.jscomp.UnreachableCodeEliminationTest::testIssue4177428_return", "test_method": "  public void testIssue4177428_return() {\n    test(\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +  // Keep this...\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"  alert(action)\\n\" + // and remove this.\n        \"};\",\n        \"f = function() {\\n\" +\n        \"  var action;\\n\" +\n        \"  a: {\\n\" +\n        \"    var proto = null;\\n\" +\n        \"    try {\\n\" +\n        \"      proto = new Proto\\n\" +\n        \"    } finally {\\n\" +\n        \"      action = proto;\\n\" +\n        \"      return\\n\" +\n        \"    }\\n\" +\n        \"  }\\n\" +\n        \"};\"\n        ); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:928)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:460)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:386)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:355)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:343)\n\tcom.google.javascript.jscomp.UnreachableCodeEliminationTest.testIssue4177428_return(UnreachableCodeEliminationTest.java:362)", "buggy_method": "128 @SuppressWarnings(\"fallthrough\")\n129     private void tryRemoveUnconditionalBranching(Node n) {\n130       /*\n131        * For each unconditional branching control flow node, check to see\n132        * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n133        * the branching target. If it is, the branch node is safe to be removed.\n134        *\n135        * This is not as clever as MinimizeExitPoints because it doesn't do any\n136        * if-else conversion but it handles more complicated switch statements\n137        * much more nicely.\n138        */\n139 \n140       // If n is null the target is the end of the function, nothing to do.\n141       if (n == null) {\n142          return;\n143       }\n144 \n145       DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n146 \n147       if (gNode == null) {\n148         return;\n149       }\n150 \n151       switch (n.getType()) {\n152         case Token.RETURN:\n153           if (n.hasChildren()) {\n154             break;\n155           }\n156         case Token.BREAK:\n157         case Token.CONTINUE:\n158           // We are looking for a control flow changing statement that always\n159           // branches to the same node. If after removing it control still\n160           // branches to the same node, it is safe to remove.\n161           List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n162           if (outEdges.size() == 1 &&\n163               // If there is a next node, this jump is not useless.\n164               (n.getNext() == null || n.getNext().isFunction())) {\n165 \n166             Preconditions.checkState(\n167                 outEdges.get(0).getValue() == Branch.UNCOND);\n168             Node fallThrough = computeFollowing(n);\n169             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n170             if (nextCfgNode == fallThrough) {\n171               removeNode(n);\n172             }\n173           }\n174       }\n175     }", "bm_classpath": "com.google.javascript.jscomp.UnreachableCodeElimination$EliminationPass"}, {"bug_name": "Closure_128", "report_text": "> The compiler quotes the \"0\" keys in object literals\n> \n> **What steps will reproduce the problem?**\n> 1. Compile alert({0:0, 1:1});\r\n> \r\n> What is the expected output?\r\n> alert({0:0, 1:1});\r\n> \r\n> What do you see instead?\r\n> alert({\"0\":0, 1:1});\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Latest version on Goobuntu.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testIssue942", "test_method": "  public void testIssue942() {\n    assertPrint(\"var x = {0: 1};\", \"var x={0:1}\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x={[0]:1}> but was:<var x={[\"0\"]:1}>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:465)\n\tcom.google.javascript.jscomp.CodePrinterTest.testIssue942(CodePrinterTest.java:1423)", "buggy_method": "783 static boolean isSimpleNumber(String s) {\n784     int len = s.length();\n785     for (int index = 0; index < len; index++) {\n786       char c = s.charAt(index);\n787       if (c < '0' || c > '9') {\n788         return false;\n789       }\n790     }\n791     return len > 0 && s.charAt(0) != '0';\n792   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_129", "report_text": "> Casting a function before calling it produces bad code and breaks plugin code\n> \n> 1. Compile this code with ADVANCED\\_OPTIMIZATIONS:\r\n> console.log( /\\*\\* @type {function(!string):!string} \\*/ ((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable'])( '$version' ) );\r\n> \r\n> produces:\r\n> \r\n> 'use strict';console.log((0,(new window.ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\")).GetVariable)(\"$version\"));\r\n> \r\n> 2. Compare with this code:\r\n> console.log( /\\*\\* @type {!string} \\*/ ((new window.ActiveXObject( 'ShockwaveFlash.ShockwaveFlash' ))['GetVariable']( '$version' )) )\r\n> \r\n> produces:\r\n> \r\n> 'use strict';console.log((new window.ActiveXObject(\"ShockwaveFlash.ShockwaveFlash\")).GetVariable(\"$version\"));\r\n> \r\n> \r\n> Notice the (0,...) wrapping around the GetVariable function in the first example. This causes the call to fail in every browser (this code is IE-only but it's just for a minimal example). The second version produces a warning that the type of GetVariable could not be determined (I enabled type warnings), and it wouldn't be possible to define these in an externs file without making a horrible mess.\r\n> \r\n> This applies to all cases where functions are cast, but only causes problems (other than bloat) with plugins like this. It seems to serve no purpose whatsoever, so I assume it is a bug.\r\n> \r\n> Running on a mac, not sure what version but it reports Built on: 2013/02/12 17:00, so will have been downloaded about that time.", "test_name": "com.google.javascript.jscomp.IntegrationTest::testIssue937", "test_method": "  public void testIssue937() {\n    CompilerOptions options = createCompilerOptions();\n    CompilationLevel level = CompilationLevel.SIMPLE_OPTIMIZATIONS;\n    level.setOptionsForCompilationLevel(options);\n    WarningLevel warnings = WarningLevel.DEFAULT;\n    warnings.setOptionsForWarningLevel(options);\n\n    String code = \"\" +\n        \"console.log(\" +\n            \"/** @type {function():!string} */ ((new x())['abc'])() );\";\n    String result = \"\" +\n        \"console.log((new x()).abc());\";\n    test(options, code, result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:97)\n\tcom.google.javascript.jscomp.IntegrationTestCase.test(IntegrationTestCase.java:79)\n\tcom.google.javascript.jscomp.IntegrationTest.testIssue937(IntegrationTest.java:2430)", "buggy_method": "158 private void annotateCalls(Node n) {\n159       Preconditions.checkState(n.isCall());\n160 \n161       // Keep track of of the \"this\" context of a call.  A call without an\n162       // explicit \"this\" is a free call.\n163       Node first = n.getFirstChild();\n164 \n165       // ignore cast nodes.\n166 \n167       if (!NodeUtil.isGet(first)) {\n168         n.putBooleanProp(Node.FREE_CALL, true);\n169       }\n170 \n171       // Keep track of the context in which eval is called. It is important\n172       // to distinguish between \"(0, eval)()\" and \"eval()\".\n173       if (first.isName() &&\n174           \"eval\".equals(first.getString())) {\n175         first.putBooleanProp(Node.DIRECT_EVAL, true);\n176       }\n177     }", "bm_classpath": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations"}, {"bug_name": "Closure_130", "report_text": "> arguments is moved to another scope\n> \n> Using ADVANCED\\_OPTIMIZATIONS with CompilerOptions.collapsePropertiesOnExternTypes = true a script I used broke, it was something like:\r\n> \r\n> function () {\r\n>  return function () {\r\n>  var arg = arguments;\r\n>  setTimeout(function() { alert(args); }, 0);\r\n>  }\r\n> }\r\n> \r\n> Unfortunately it was rewritten to:\r\n> \r\n> function () {\r\n>  return function () {\r\n>  setTimeout(function() { alert(arguments); }, 0);\r\n>  }\r\n> }\r\n> \r\n> arguments should not be collapsed.", "test_name": "com.google.javascript.jscomp.CollapsePropertiesTest::testIssue931", "test_method": "  public void testIssue931() {\n    collapsePropertiesOnExternTypes = true;\n    testSame(\n      \"function f() {\\n\" +\n      \"  return function () {\\n\" +\n      \"    var args = arguments;\\n\" +\n      \"    setTimeout(function() { alert(args); }, 0);\\n\" +\n      \"  }\\n\" +\n      \"};\\n\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:924)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:459)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:385)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:354)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:342)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:581)\n\tcom.google.javascript.jscomp.CollapsePropertiesTest.testIssue931(CollapsePropertiesTest.java:1101)", "buggy_method": "161 private void inlineAliases(GlobalNamespace namespace) {\n162     // Invariant: All the names in the worklist meet condition (a).\n163     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n164     while (!workList.isEmpty()) {\n165       Name name = workList.pop();\n166 \n167       // Don't attempt to inline a getter or setter property as a variable.\n168       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n169         continue;\n170       }\n171 \n172       if (name.globalSets == 1 && name.localSets == 0 &&\n173           name.aliasingGets > 0) {\n174         // {@code name} meets condition (b). Find all of its local aliases\n175         // and try to inline them.\n176         List<Ref> refs = Lists.newArrayList(name.getRefs());\n177         for (Ref ref : refs) {\n178           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n179             // {@code name} meets condition (c). Try to inline it.\n180             if (inlineAliasIfPossible(ref, namespace)) {\n181               name.removeRef(ref);\n182             }\n183           }\n184         }\n185       }\n186 \n187       // Check if {@code name} has any aliases left after the\n188       // local-alias-inlining above.\n189       if ((name.type == Name.Type.OBJECTLIT ||\n190            name.type == Name.Type.FUNCTION) &&\n191           name.aliasingGets == 0 && name.props != null) {\n192         // All of {@code name}'s children meet condition (a), so they can be\n193         // added to the worklist.\n194         workList.addAll(name.props);\n195       }\n196     }\n197   }", "bm_classpath": "com.google.javascript.jscomp.CollapseProperties"}, {"bug_name": "Closure_131", "report_text": "> unicode characters in property names result in invalid output\n> \n> **What steps will reproduce the problem?**\n> 1. use unicode characters in a property name for an object, like this:\r\n> var test={\"a\\u0004b\":\"c\"};\r\n> \r\n> 2. compile\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Because unicode characters are not allowed in property names without quotes, the output should be the same as the input. However, the compiler converts the string \\u0004 to the respective unicode character, and the output is: \r\n> var test={a\u0004b:\"c\"}; // unicode character between a and b can not be displayed here\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> newest current snapshot on multiple os (OSX/linux)\r\n> \r\n> **Please provide any additional information below.**", "test_name": "com.google.javascript.jscomp.ConvertToDottedPropertiesTest::testQuotedProps", "test_method": "  public void testQuotedProps() {\n    testSame(\"({'':0})\");\n    testSame(\"({'1.0':0})\");\n    testSame(\"({'\\u1d17A':0})\");\n    testSame(\"({'a\\u0004b':0})\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:924)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:459)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:385)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:354)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:342)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:581)\n\tcom.google.javascript.jscomp.ConvertToDottedPropertiesTest.testQuotedProps(ConvertToDottedPropertiesTest.java:72)", "buggy_method": "190 public static boolean isJSIdentifier(String s) {\n191       int length = s.length();\n192 \n193       if (length == 0 ||\n194           !Character.isJavaIdentifierStart(s.charAt(0))) {\n195         return false;\n196       }\n197 \n198       for (int i = 1; i < length; i++) {\n199         if (\n200             !Character.isJavaIdentifierPart(s.charAt(i))) {\n201           return false;\n202         }\n203       }\n204 \n205       return true;\n206     }", "bm_classpath": "com.google.javascript.rhino.TokenStream"}, {"bug_name": "Closure_132", "report_text": "> if statement\n> \n> **What steps will reproduce the problem?**\n> INPUT:\r\n> if( es[--esi][ es[esi+1] ] === 1)\r\n> {\r\n>  es[esi] = 0;\r\n> }\r\n> else\r\n> {\r\n>  es[esi] = 1;\r\n> }\r\n> OUTPUT:\r\n> \r\n> es[esi] = 1 === es[--esi][es[esi + 1]] ? 0 : 1;\r\n> \r\n> BUT MUST BE\r\n> es[--esi] = 1 === es[esi][es[esi + 1]] ? 0 : 1;\r\n> \r\n> Im using latest version on windows", "test_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest::testIssue925", "test_method": "  public void testIssue925() {\n    test(\n        \"if (x[--y] === 1) {\\n\" +\n        \"    x[y] = 0;\\n\" +\n        \"} else {\\n\" +\n        \"    x[y] = 1;\\n\" +\n        \"}\",\n        \"(x[--y] === 1) ? x[y] = 0 : x[y] = 1;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:924)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:459)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:385)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:354)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:342)\n\tcom.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest.testIssue925(PeepholeSubstituteAlternateSyntaxTest.java:967)", "buggy_method": "636 private Node tryMinimizeIf(Node n) {\n637 \n638     Node parent = n.getParent();\n639 \n640     Node cond = n.getFirstChild();\n641 \n642     /* If the condition is a literal, we'll let other\n643      * optimizations try to remove useless code.\n644      */\n645     if (NodeUtil.isLiteralValue(cond, true)) {\n646       return n;\n647     }\n648 \n649     Node thenBranch = cond.getNext();\n650     Node elseBranch = thenBranch.getNext();\n651 \n652     if (elseBranch == null) {\n653       if (isFoldableExpressBlock(thenBranch)) {\n654         Node expr = getBlockExpression(thenBranch);\n655         if (!late && isPropertyAssignmentInExpression(expr)) {\n656           // Keep opportunities for CollapseProperties such as\n657           // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n658           // until CollapseProperties has been run.\n659           return n;\n660         }\n661 \n662         if (cond.isNot()) {\n663           // if(!x)bar(); -> x||bar();\n664           if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n665               isLowerPrecedenceInExpression(expr.getFirstChild(),\n666                   OR_PRECEDENCE)) {\n667             // It's not okay to add two sets of parentheses.\n668             return n;\n669           }\n670 \n671           Node or = IR.or(\n672               cond.removeFirstChild(),\n673               expr.removeFirstChild()).srcref(n);\n674           Node newExpr = NodeUtil.newExpr(or);\n675           parent.replaceChild(n, newExpr);\n676           reportCodeChange();\n677 \n678           return newExpr;\n679         }\n680 \n681         // if(x)foo(); -> x&&foo();\n682         if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n683             isLowerPrecedenceInExpression(expr.getFirstChild(),\n684                 AND_PRECEDENCE)) {\n685           // One additional set of parentheses is worth the change even if\n686           // there is no immediate code size win. However, two extra pair of\n687           // {}, we would have to think twice. (unless we know for sure the\n688           // we can further optimize its parent.\n689           return n;\n690         }\n691 \n692         n.removeChild(cond);\n693         Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n694         Node newExpr = NodeUtil.newExpr(and);\n695         parent.replaceChild(n, newExpr);\n696         reportCodeChange();\n697 \n698         return newExpr;\n699       } else {\n700 \n701         // Try to combine two IF-ELSE\n702         if (NodeUtil.isStatementBlock(thenBranch) &&\n703             thenBranch.hasOneChild()) {\n704           Node innerIf = thenBranch.getFirstChild();\n705 \n706           if (innerIf.isIf()) {\n707             Node innerCond = innerIf.getFirstChild();\n708             Node innerThenBranch = innerCond.getNext();\n709             Node innerElseBranch = innerThenBranch.getNext();\n710 \n711             if (innerElseBranch == null &&\n712                  !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n713                    isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n714               n.detachChildren();\n715               n.addChildToBack(\n716                   IR.and(\n717                       cond,\n718                       innerCond.detachFromParent())\n719                       .srcref(cond));\n720               n.addChildrenToBack(innerThenBranch.detachFromParent());\n721               reportCodeChange();\n722               // Not worth trying to fold the current IF-ELSE into && because\n723               // the inner IF-ELSE wasn't able to be folded into && anyways.\n724               return n;\n725             }\n726           }\n727         }\n728       }\n729 \n730       return n;\n731     }\n732 \n733     /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n734      * peephole optimization. This should probably get moved to another pass.\n735      */\n736     tryRemoveRepeatedStatements(n);\n737 \n738     // if(!x)foo();else bar(); -> if(x)bar();else foo();\n739     // An additional set of curly braces isn't worth it.\n740     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n741       n.replaceChild(cond, cond.removeFirstChild());\n742       n.removeChild(thenBranch);\n743       n.addChildToBack(thenBranch);\n744       reportCodeChange();\n745       return n;\n746     }\n747 \n748     // if(x)return 1;else return 2; -> return x?1:2;\n749     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n750       Node thenExpr = getBlockReturnExpression(thenBranch);\n751       Node elseExpr = getBlockReturnExpression(elseBranch);\n752       n.removeChild(cond);\n753       thenExpr.detachFromParent();\n754       elseExpr.detachFromParent();\n755 \n756       // note - we ignore any cases with \"return;\", technically this\n757       // can be converted to \"return undefined;\" or some variant, but\n758       // that does not help code size.\n759       Node returnNode = IR.returnNode(\n760                             IR.hook(cond, thenExpr, elseExpr)\n761                                 .srcref(n));\n762       parent.replaceChild(n, returnNode);\n763       reportCodeChange();\n764       return returnNode;\n765     }\n766 \n767     boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n768     boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n769 \n770     if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n771       Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n772       Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n773       if (thenOp.getType() == elseOp.getType()) {\n774         // if(x)a=1;else a=2; -> a=x?1:2;\n775         if (NodeUtil.isAssignmentOp(thenOp)) {\n776           Node lhs = thenOp.getFirstChild();\n777           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n778               // if LHS has side effects, don't proceed [since the optimization\n779               // evaluates LHS before cond]\n780               // NOTE - there are some circumstances where we can\n781               // proceed even if there are side effects...\n782               !mayEffectMutableState(lhs)) {\n783 \n784             n.removeChild(cond);\n785             Node assignName = thenOp.removeFirstChild();\n786             Node thenExpr = thenOp.removeFirstChild();\n787             Node elseExpr = elseOp.getLastChild();\n788             elseOp.removeChild(elseExpr);\n789 \n790             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n791             Node assign = new Node(thenOp.getType(), assignName, hookNode)\n792                               .srcref(thenOp);\n793             Node expr = NodeUtil.newExpr(assign);\n794             parent.replaceChild(n, expr);\n795             reportCodeChange();\n796 \n797             return expr;\n798           }\n799         }\n800       }\n801       // if(x)foo();else bar(); -> x?foo():bar()\n802       n.removeChild(cond);\n803       thenOp.detachFromParent();\n804       elseOp.detachFromParent();\n805       Node expr = IR.exprResult(\n806           IR.hook(cond, thenOp, elseOp).srcref(n));\n807       parent.replaceChild(n, expr);\n808       reportCodeChange();\n809       return expr;\n810     }\n811 \n812     boolean thenBranchIsVar = isVarBlock(thenBranch);\n813     boolean elseBranchIsVar = isVarBlock(elseBranch);\n814 \n815     // if(x)var y=1;else y=2  ->  var y=x?1:2\n816     if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n817         getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n818 \n819       Node var = getBlockVar(thenBranch);\n820       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n821 \n822       Node name1 = var.getFirstChild();\n823       Node maybeName2 = elseAssign.getFirstChild();\n824 \n825       if (name1.hasChildren()\n826           && maybeName2.isName()\n827           && name1.getString().equals(maybeName2.getString())) {\n828         Node thenExpr = name1.removeChildren();\n829         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n830         cond.detachFromParent();\n831         Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n832                             .srcref(n);\n833         var.detachFromParent();\n834         name1.addChildrenToBack(hookNode);\n835         parent.replaceChild(n, var);\n836         reportCodeChange();\n837         return var;\n838       }\n839 \n840     // if(x)y=1;else var y=2  ->  var y=x?1:2\n841     } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n842         getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n843 \n844       Node var = getBlockVar(elseBranch);\n845       Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n846 \n847       Node maybeName1 = thenAssign.getFirstChild();\n848       Node name2 = var.getFirstChild();\n849 \n850       if (name2.hasChildren()\n851           && maybeName1.isName()\n852           && maybeName1.getString().equals(name2.getString())) {\n853         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n854         Node elseExpr = name2.removeChildren();\n855         cond.detachFromParent();\n856         Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n857                             .srcref(n);\n858         var.detachFromParent();\n859         name2.addChildrenToBack(hookNode);\n860         parent.replaceChild(n, var);\n861         reportCodeChange();\n862 \n863         return var;\n864       }\n865     }\n866 \n867     return n;\n868   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax"}, {"bug_name": "Closure_133", "report_text": "> Exception when parsing erroneous jsdoc: /**@return {@code foo} bar   *    baz. */\n> \n> The following causes an exception in JSDocInfoParser.\r\n> \r\n> /\\*\\* \r\n>  \\* @return {@code foo} bar \r\n>  \\* baz. \\*/\r\n> var x;\r\n> \r\n> \r\n> \r\n> Fix to follow.", "test_name": "com.google.javascript.jscomp.parsing.JsDocInfoParserTest::testTextExtents", "test_method": "  public void testTextExtents() {\n    parse(\"@return {@code foo} bar \\n *    baz. */\",\n        true, \"Bad type annotation. type not recognized due to syntax error\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: Recorded bad position information\n\tcom.google.javascript.rhino.SourcePosition.setPositionInformation(SourcePosition.java:87)\n\tcom.google.javascript.rhino.JSDocInfoBuilder.markText(JSDocInfoBuilder.java:172)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocInfoParser.java:1503)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocInfoParser.java:1379)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParser.parse(JsDocInfoParser.java:958)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2984)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.parse(JsDocInfoParserTest.java:2961)\n\tcom.google.javascript.jscomp.parsing.JsDocInfoParserTest.testTextExtents(JsDocInfoParserTest.java:2756)", "buggy_method": "2399 private String getRemainingJSDocLine() {\n2400     String result = stream.getRemainingJSDocLine();\n2401     return result;\n2402   }", "bm_classpath": "com.google.javascript.jscomp.parsing.JsDocInfoParser"}, {"bug_name": "Closure_134", "report_text": "> @inheritDoc doesn't play well with interfaces\n> \n> If I use interface inheritance with @inheritDoc, the compiler doesn't \r\n> know about the types used in the method signature.\r\n> \r\n> Sample code:\r\n> \r\n> /\\*\\*\r\n>  \\* Interface\r\n>  \\* @interface\r\n>  \\*/\r\n> A = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @param {string} a\r\n>  \\*/\r\n> A.prototype.foo = function(a) {};\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @implements {A}\r\n>  \\*/\r\n> B = function() {};\r\n> \r\n> /\\*\\*\r\n>  \\* @inheritDoc\r\n>  \\*/\r\n> B.prototype.foo = function(a) {\r\n>  alert(a.substring(0)); // ERROR - could not determine the type of \r\n> this expression\r\n> };", "test_name": "com.google.javascript.jscomp.AmbiguatePropertiesTest::testImplementsAndExtends", "test_method": "  public void testImplementsAndExtends() {\n    String js = \"\"\n        + \"/** @interface */ function Foo() {}\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" */\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.y = function() { return 3; };\\n\"\n        + \"/**\\n\"\n        + \" * @constructor\\n\"\n        + \" * @extends {Bar}\\n\"\n        + \" * @implements {Foo}\\n\"\n        + \" */\\n\"\n        + \"function SubBar(){ }\\n\"\n        + \"/** @param {Foo} x */ function f(x) { x.z = 3; }\\n\"\n        + \"/** @param {SubBar} x */ function g(x) { x.z = 3; }\";\n    String output = \"\"\n        + \"function Foo(){}\\n\"\n        + \"function Bar(){}\\n\"\n        + \"Bar.prototype.b = function() { return 3; };\\n\"\n        + \"function SubBar(){}\\n\"\n        + \"function f(x) { x.a = 3; }\\n\"\n        + \"function g(x) { x.a = 3; }\";\n    test(js, output); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:745)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:338)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:268)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:237)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:225)\n\tcom.google.javascript.jscomp.AmbiguatePropertiesTest.testImplementsAndExtends(AmbiguatePropertiesTest.java:431)", "buggy_method": "195 public void process(Node externs, Node root) {\n196     NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n197     NodeTraversal.traverse(compiler, root, new ProcessProperties());\n198 \n199     Set<String> reservedNames =\n200         new HashSet<String>(externedNames.size() + quotedNames.size());\n201     reservedNames.addAll(externedNames);\n202     reservedNames.addAll(quotedNames);\n203 \n204     int numRenamedPropertyNames = 0;\n205     int numSkippedPropertyNames = 0;\n206     Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n207     for (Property p : propertyMap.values()) {\n208       if (!p.skipAmbiguating) {\n209         ++numRenamedPropertyNames;\n210         computeRelatedTypes(p.type);\n211         propsByFreq.add(p);\n212       } else {\n213         ++numSkippedPropertyNames;\n214         reservedNames.add(p.oldName);\n215       }\n216     }\n217 \n218     PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n219     GraphColoring<Property, Void> coloring =\n220         new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n221     int numNewPropertyNames = coloring.color();\n222 \n223     NameGenerator nameGen = new NameGenerator(\n224         reservedNames, \"\", reservedCharacters);\n225     for (int i = 0; i < numNewPropertyNames; ++i) {\n226       colorMap.put(i, nameGen.generateNextName());\n227     }\n228     for (GraphNode<Property, Void> node : graph.getNodes()) {\n229       node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n230       renamingMap.put(node.getValue().oldName, node.getValue().newName);\n231     }\n232 \n233     // Update the string nodes.\n234     for (Node n : stringNodesToRename) {\n235       String oldName = n.getString();\n236       Property p = propertyMap.get(oldName);\n237       if (p != null && p.newName != null) {\n238         Preconditions.checkState(oldName.equals(p.oldName));\n239         if (!p.newName.equals(oldName)) {\n240           n.setString(p.newName);\n241           compiler.reportCodeChange();\n242         }\n243       }\n244     }\n245 \n246     logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \"\n247                 + numNewPropertyNames + \" and skipped renaming \"\n248                 + numSkippedPropertyNames + \" properties.\");\n249   }", "bm_classpath": "com.google.javascript.jscomp.AmbiguateProperties"}, {"bug_name": "Closure_135", "report_text": "> Inheritance not detected when prototype directly assigned\n> \n> Given the following input JS:\r\n> //--------------------------\r\n> /\\*\\*\r\n> \\* @constructor\r\n> \\*/\r\n> function SuperClass () {\r\n> }\r\n> \r\n> SuperClass.prototype.CustomMethod = function() {\r\n> }\r\n> \r\n> /\\*\\*\r\n> \\* @constructor\r\n> \\* @extends {SuperClass}\r\n> \\*/\r\n> function SubClass () {\r\n> }\r\n> SubClass.prototype = new SuperClass();\r\n> \r\n> /\\*\\*\r\n> \\* @override\r\n> \\*/\r\n> SubClass.prototype.CustomMethod = function() {\r\n>  this.myProperty = \"value\";\r\n> }\r\n> \r\n> window['SubClassInstance'] = new SubClass();\r\n> //---------------------------------\r\n> \r\n> When compiled with ADVANCED\\_OPTIMIZATIONS produces the warning:\r\n> JSC\\_UNKNOWN\\_OVERRIDE: property CustomMethod not defined on any superclass\r\n> of SubClass\r\n> \r\n> This error has been reproduced in both the downloaded compiler and the\r\n> Compiler Service UI.\r\n> \r\n> When the prototype assignment is wrapped in a function, it is correctly\r\n> detected. See below:\r\n> //---------------------------------\r\n> function inherit(Child, Parent) {\r\n>  Child.prototype = new Parent();\r\n> } \r\n> inherit(SubClass, SuperClass);\r\n> //---------------------------------", "test_name": "com.google.javascript.jscomp.DevirtualizePrototypeMethodsTest::testRewritePrototypeMethods2", "test_method": "  public void testRewritePrototypeMethods2() throws Exception {\n    // type checking on\n    enableTypeCheck(CheckLevel.ERROR);\n    checkTypes(RewritePrototypeMethodTestInput.INPUT,\n               RewritePrototypeMethodTestInput.EXPECTED,\n               RewritePrototypeMethodTestInput.EXPECTED_TYPE_CHECKING_ON); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = a, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = a, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]> but was:<[FUNCTION a = function (this:a): ?, NAME JSCompiler_StaticMethods_foo$self = null, FUNCTION JSCompiler_StaticMethods_foo = function (a): number, NAME JSCompiler_StaticMethods_bar$self = null, FUNCTION JSCompiler_StaticMethods_bar = function (a, number): number, FUNCTION JSCompiler_StaticMethods_baz = function (a): ?, NEW a = a, CALL JSCompiler_StaticMethods_foo = number, CALL JSCompiler_StaticMethods_bar = number, CALL JSCompiler_StaticMethods_baz = ?]>\n\tcom.google.javascript.jscomp.DevirtualizePrototypeMethodsTest.checkTypes(DevirtualizePrototypeMethodsTest.java:545)\n\tcom.google.javascript.jscomp.DevirtualizePrototypeMethodsTest.testRewritePrototypeMethods2(DevirtualizePrototypeMethodsTest.java:144)", "buggy_method": "354 private void replaceReferencesToThis(Node node, String name) {\n355     if (NodeUtil.isFunction(node)) {\n356       return;\n357     }\n358 \n359     for (Node child : node.children()) {\n360       if (NodeUtil.isThis(child)) {\n361         Node newName = Node.newString(Token.NAME, name);\n362         node.replaceChild(child, newName);\n363       } else {\n364         replaceReferencesToThis(child, name);\n365       }\n366     }\n367   }", "bm_classpath": "com.google.javascript.jscomp.DevirtualizePrototypeMethods"}, {"bug_name": "Closure_136", "report_text": "> $super is replaced when it should not be replaced\n> \n> **What steps will reproduce the problem?**\n> 1. Have javascript using prototype's $super\r\n> 2. Compile with advanced\\_optimizations\r\n> 3. See that $super is replaced by for example $super$$4\r\n> \r\n> **What is the expected output? What do you see instead?**\n> $super should not be renamed as it is used by prototype.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Latest from svn.\r\n> \r\n> **Please provide any additional information below.**\n> Personally I made a quick fix in MakeDeclaredNamesUnique.java line 79:\r\n> if (t.getCompiler().getCodingConvention().isExported(name)) { continue; }\r\n> This fixed it for me, but not sure if that's the right place or method to\r\n> solve this, as I am unfamiliar with the project.", "test_name": "com.google.javascript.jscomp.InlineGettersTest::testIssue2508576_1", "test_method": "  public void testIssue2508576_1() {\n    // Method defined by an extern should be left alone.\n    String externs = \"function alert(a) {}\";\n    testSame(externs, \"({a:alert,b:alert}).a(\\\"a\\\")\", null); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[({a:alert,b:alert}).a(\"a\")]> but was:<[]>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:544)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:525)\n\tcom.google.javascript.jscomp.InlineGettersTest.testIssue2508576_1(InlineGettersTest.java:238)", "buggy_method": "101 private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n102     boolean signatureAdded = false;\n103     if (node.getType() == Token.FUNCTION) {\n104       // The node we're looking at is a function, so we can add it directly\n105       addSignature(name, node, t.getSourceName());\n106       signatureAdded = true;\n107     } else if (node.getType() == Token.NAME) {\n108       String functionName = node.getString();\n109       Scope.Var v = t.getScope().getVar(functionName);\n110       if (v == null) {\n111         if (compiler.isIdeMode()) {\n112           return;\n113         } else {\n114           throw new IllegalStateException(\n115               \"VarCheck should have caught this undefined function\");\n116         }\n117       }\n118       Node function = v.getInitialValue();\n119       if (function != null &&\n120           function.getType() == Token.FUNCTION) {\n121         addSignature(name, function, v.getInputName());\n122         signatureAdded = true;\n123       }\n124     }\n125     if (!signatureAdded) {\n126       nonMethodProperties.add(name);\n127     }\n128   }", "bm_classpath": "com.google.javascript.jscomp.MethodCompilerPass"}, {"bug_name": "Closure_137", "report_text": "> Invalid JSC_DETERMINISTIC_TEST\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Compile following code:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @output\\_file\\_name default.js\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // ==/ClosureCompiler==\r\n> \r\n> var t = null;\r\n> \r\n> window.test = function()\r\n> {\r\n>  if (t != null)\r\n>  {\r\n>  t = null;\r\n>  }\r\n> \r\n>  t = 1;\r\n> };\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Code should be compiled without warnings, but I see \r\n> \"JSC\\_DETERMINISTIC\\_TEST: condition always evaluates to false\".", "test_name": "com.google.javascript.jscomp.MakeDeclaredNamesUniqueTest::testOnlyInversion3", "test_method": "  public void testOnlyInversion3() {\n    invert = true;\n    test(\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a$$2;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a$$3;\" +\n        \"  }\" +\n        \"}\",\n        \"function x1() {\" +\n        \"  var a$$1;\" +\n        \"  function x2() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"  function x3() {\" +\n        \"    var a;\" +\n        \"  }\" +\n        \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tcom.google.javascript.jscomp.MakeDeclaredNamesUniqueTest.testOnlyInversion3(MakeDeclaredNamesUniqueTest.java:282)", "buggy_method": "266 private static String getOrginalNameInternal(String name, int index) {\n267       return name.substring(0, index);\n268     }", "bm_classpath": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter"}, {"bug_name": "Closure_138", "report_text": "> Invalid JSC_DETERMINISTIC_TEST\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Compile following code:\r\n> \r\n> // ==ClosureCompiler==\r\n> // @output\\_file\\_name default.js\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // ==/ClosureCompiler==\r\n> \r\n> var t = null;\r\n> \r\n> window.test = function()\r\n> {\r\n>  if (t != null)\r\n>  {\r\n>  t = null;\r\n>  }\r\n> \r\n>  t = 1;\r\n> };\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Code should be compiled without warnings, but I see \r\n> \"JSC\\_DETERMINISTIC\\_TEST: condition always evaluates to false\".", "test_name": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest::testGoogIsArrayOnNull", "test_method": "  public void testGoogIsArrayOnNull() throws Exception {\n    testClosureFunction(\"goog.isArray\",\n        null,\n        ARRAY_TYPE,\n        null); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Array> but was:<null>\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testClosureFunction(ClosureReverseAbstractInterpreterTest.java:164)\n\tcom.google.javascript.jscomp.ClosureReverseAbstractInterpreterTest.testGoogIsArrayOnNull(ClosureReverseAbstractInterpreterTest.java:125)", "buggy_method": "200 @Override\n201   public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n202       FlowScope blindScope, boolean outcome) {\n203     if (condition.getType() == CALL && condition.getChildCount() == 2) {\n204       Node callee = condition.getFirstChild();\n205       Node param = condition.getLastChild();\n206       if (callee.getType() == GETPROP && param.isQualifiedName()) {\n207         JSType paramType =  getTypeIfRefinable(param, blindScope);\n208         if (paramType != null) {\n209         Node left = callee.getFirstChild();\n210         Node right = callee.getLastChild();\n211         if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n212             right.getType() == STRING) {\n213           Function<TypeRestriction, JSType> restricter =\n214               restricters.get(right.getString());\n215           if (restricter != null) {\n216             return restrictParameter(param, paramType, blindScope, restricter,\n217                 outcome);\n218             }\n219           }\n220         }\n221       }\n222     }\n223     return nextPreciserScopeKnowingConditionOutcome(\n224         condition, blindScope, outcome);\n225   }", "bm_classpath": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreter"}, {"bug_name": "Closure_139", "report_text": "> Redefinition of a function in third party code can be miscompiled\n> \n> **What steps will reproduce the problem?**\n> 1. Run this code snippet and observe that it doesn't raise an error:\r\n> \r\n> function assert(b) {if (!b) throw \"error\"}\r\n> \r\n> assert(f() === 1)\r\n> var f = function() {return 2;}\r\n> assert(f() === 2)\r\n> \r\n> function f() {return 1;}\r\n> \r\n> 2. Compile it as third\\_party:\r\n> 3. Observe that the first definition of f has been changed from an assignment to a declaration, and that the code now raises an error.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> r8\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> This bug is originally from a blog comment[1], I don't know if it has hit anyone in the wild yet.\r\n> \r\n> 1) http://webreflection.blogspot.com/2009/11/google-closure-im-not-impressed.html#1604178721861066706", "test_name": "com.google.javascript.jscomp.NormalizeTest::testNormalizeFunctionDeclarations", "test_method": "  public void testNormalizeFunctionDeclarations() throws Exception {\n    testSame(\"function f() {}\");\n    testSame(\"var f = function () {}\");\n    test(\"var f = function f() {}\",\n         \"var f = function f$$1() {}\");\n    testSame(\"var f = function g() {}\");\n    test(\"a:function g() {}\",\n         \"a:{ var g = function () {} }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tcom.google.javascript.jscomp.NormalizeTest.testNormalizeFunctionDeclarations(NormalizeTest.java:167)", "buggy_method": "268 @Override\n269     public void visit(NodeTraversal t, Node n, Node parent) {\n270       switch (n.getType()) {\n271         case Token.WHILE:\n272           if (CONVERT_WHILE_TO_FOR) {\n273             Node expr = n.getFirstChild();\n274             n.setType(Token.FOR);\n275             n.addChildBefore(new Node(Token.EMPTY), expr);\n276             n.addChildAfter(new Node(Token.EMPTY), expr);\n277             reportCodeChange(\"WHILE node\");\n278           }\n279           break;\n280 \n281       }\n282     }", "bm_classpath": "com.google.javascript.jscomp.Normalize$NormalizeStatements"}, {"bug_name": "Closure_140", "report_text": "> Google Common Loader Extern\n> \n> I needed this for one of my projects.\r\n> \r\n> Chad Killingsworth", "test_name": "com.google.javascript.jscomp.CrossModuleCodeMotionTest::testEmptyModule", "test_method": "  public void testEmptyModule() {\n    // When the dest module is empty, it might try to move the code to the\n    // one of the modules that the empty module depends on. In some cases\n    // this might ended up to be the same module as the definition of the code.\n    // When that happens, CrossMooduleCodeMotion might report a code change\n    // while nothing is moved. This should not be a problem if we know all\n    // modules are non-empty.\n    JSModule m1 = new JSModule(\"m1\");\n    m1.add(JSSourceFile.fromCode(\"m1\", \"function x() {}\"));\n    \n    JSModule empty = new JSModule(\"empty\");\n    empty.addDependency(m1);\n    \n    JSModule m2 = new JSModule(\"m2\");\n    m2.add(JSSourceFile.fromCode(\"m2\", \"x()\"));\n    m2.addDependency(empty);\n    \n    JSModule m3 = new JSModule(\"m3\");\n    m3.add(JSSourceFile.fromCode(\"m3\", \"x()\"));\n    m3.addDependency(empty);\n    \n    test(new JSModule[] {m1,empty,m2,m3},\n        new String[] {\n          \"\",\n          \"function x() {}\",\n          \"x()\",\n          \"x()\"\n    }); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: compiler.reportCodeChange() was called even though nothing changed\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:771)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:622)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:458)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:445)\n\tcom.google.javascript.jscomp.CrossModuleCodeMotionTest.testEmptyModule(CrossModuleCodeMotionTest.java:678)", "buggy_method": "259 public void init(JSSourceFile[] externs, JSModule[] modules,\n260       CompilerOptions options) {\n261     initOptions(options);\n262 \n263     checkFirstModule(modules);\n264 \n265     this.externs = makeCompilerInput(externs, true);\n266     this.modules = modules;\n267     // Generate the module graph, and report any errors in the module\n268     // specification as errors.\n269     try {\n270       this.moduleGraph = new JSModuleGraph(modules);\n271     } catch (JSModuleGraph.ModuleDependenceException e) {\n272       // problems with the module format.  Report as an error.  The\n273       // message gives all details.\n274       report(JSError.make(MODULE_DEPENDENCY_ERROR,\n275           e.getModule().getName(), e.getDependentModule().getName()));\n276       return;\n277     }\n278     this.inputs = getAllInputsFromModules();\n279     initBasedOnOptions();\n280 \n281     initInputsByNameMap();\n282   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_141", "report_text": "> The side effects of function1||function2 are not calculated\n> \n> **What steps will reproduce the problem?**\n> 1. Compile (Math.sin||Math.cos)(0)\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Empty output.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> The closure-compiler web service at r114.\r\n> \r\n> **Please provide any additional information below.**\n> As a result of this issue goog.now() is considered to have side effects.", "test_name": "com.google.javascript.jscomp.ExpresssionDecomposerTest::testCanExposeExpression2", "test_method": "  public void testCanExposeExpression2() {\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"var x = foo()\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"if(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"switch(foo()){}\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"function (){ return foo();}\", \"foo\");\n\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() && 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() || 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"x = foo() ? 0 : 1\", \"foo\");\n    helperCanExposeExpression(\n        DecompositionType.MOVABLE, \"(function(a){b = a})(foo())\", \"foo\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<MOVABLE> but was:<DECOMPOSABLE>\n\tcom.google.javascript.jscomp.ExpresssionDecomposerTest.helperCanExposeExpression(ExpresssionDecomposerTest.java:388)\n\tcom.google.javascript.jscomp.ExpresssionDecomposerTest.helperCanExposeExpression(ExpresssionDecomposerTest.java:334)\n\tcom.google.javascript.jscomp.ExpresssionDecomposerTest.testCanExposeExpression2(ExpresssionDecomposerTest.java:85)", "buggy_method": "584 static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n585     switch (n.getType()) {\n586       case Token.CALL:\n587       case Token.NEW:\n588         // Function calls or constructor can reference changed values.\n589         // TODO(johnlenz): Add some mechanism for determining that functions\n590         // are unaffected by side effects.\n591         return true;\n592       case Token.NAME:\n593         // Non-constant names values may have been changed.\n594         return !NodeUtil.isConstantName(n)\n595             && !knownConstants.contains(n.getString());\n596 \n597       // Properties on constant NAMEs can still be side-effected.\n598       case Token.GETPROP:\n599       case Token.GETELEM:\n600         return true;\n601 \n602         // Anonymous functions definitions are not changed by side-effects,\n603         // and named functions are not part of expressions.\n604     }\n605 \n606     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n607       if (canBeSideEffected(c, knownConstants)) {\n608         return true;\n609       }\n610     }\n611 \n612     return false;\n613   }", "bm_classpath": "com.google.javascript.jscomp.NodeUtil"}, {"bug_name": "Closure_142", "report_text": "> Internet Explorer runtime error after compilation.\n> \n> **What steps will reproduce the problem?**\n> See attached HTML file in IE6+ (does not work in IE8 unless Compatibility View is turned \\*on\\* for \r\n> some reason).\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Expected output is on the left-hand side of the page (it is generated by the raw source). Google \r\n> Closure's output is on the right-hand side of the page.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> I downloaded compiler-latest.zip today (Nov. 24, 2009, ~ 12:00 PM EST)\r\n> \r\n> **Please provide any additional information below.**\n> There is a variable called \"threshold\" which is used to generate an array of arrays in the attached \r\n> HTML file. If it is a small number, IE seems to pass arrays into the sort method (sorting an array \r\n> of arrays) by value like all other browsers do. But when threshold is large enough (on my \r\n> machine that happens around 250) IE starts passing the arrays in by value. Google Closure \r\n> compiler has changed my original source from making local copies to modifying the arguments \r\n> being passed into the sort comparator ... but as a result of this IE behavior the Closure compiled \r\n> code breaks.", "test_name": "com.google.javascript.jscomp.CoalesceVariableNamesTest::testParameter4", "test_method": "  public void testParameter4() {\n    // Make sure that we do not merge two-arg functions because of the\n    // IE sort bug (see comments in computeEscaped)\n    test(\"function FUNC(x, y) {var a,b; y; a=0; a; x; b=0; b}\",\n         \"function FUNC(x, y) {var a; y; a=0; a; x; a=0; a}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:782)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:302)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:271)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:259)\n\tcom.google.javascript.jscomp.CoalesceVariableNamesTest.testParameter4(CoalesceVariableNamesTest.java:191)", "buggy_method": "90 @Override\n91   public void enterScope(NodeTraversal t) {\n92     // TODO(user): We CAN do this in the global scope, just need to be\n93     // careful when something is exported. Liveness uses bit-vector for live\n94     // sets so I don't see compilation time will be a problem for running this\n95     // pass in the global scope.\n96     Scope scope = t.getScope();\n97     if (scope.isGlobal()) {\n98       return;\n99     }\n100     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n101 \n102     LiveVariablesAnalysis liveness =\n103         new LiveVariablesAnalysis(cfg, scope, compiler);\n104     // If the function has exactly 2 params, mark them as escaped. This is\n105     // a work-around for an IE bug where it throws an exception if you\n106     // write to the parameters of the callback in a sort(). See:\n107     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n108     liveness.analyze();\n109 \n110     UndiGraph<Var, Void> interferenceGraph =\n111         computeVariableNamesInterferenceGraph(\n112             t, cfg, liveness.getEscapedLocals());\n113 \n114     GraphColoring<Var, Void> coloring =\n115         new GreedyGraphColoring<Var, Void>(interferenceGraph,\n116             coloringTieBreaker);\n117 \n118     coloring.color();\n119     colorings.push(coloring);\n120   }", "bm_classpath": "com.google.javascript.jscomp.CoalesceVariableNames"}, {"bug_name": "Closure_143", "report_text": "> @define does not support strings\n> \n> $ java -jar compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --define='test.VERSION=1.0.0' --js\\_output\\_file \r\n> test-min.js --js test.js\r\n> java.lang.RuntimeException: --define flag syntax invalid: test.VERSION=1.0.0\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.createDefineReplacements(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.initOptionsFromFlags(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.createOptions(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n> \r\n> test.js:\r\n> /\\*\\* @define {string} \\*/\r\n> test.VERSION = \"\";\r\n> \r\n> \r\n> I have tried both of these:\r\n> --define='test.VERSION=1.0.0'\r\n> --define='test.VERSION=\"1.0.0\"'\r\n> \r\n> Both generate the same error.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testDefineFlag3", "test_method": "  public void testDefineFlag3() {\n    args.add(\"--define=FOO=\\\"x'\\\"\");\n    test(\"/** @define {string} */ var FOO = \\\"a\\\";\",\n         \"var FOO = \\\"x'\\\";\"); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException: --define flag syntax invalid: FOO=\"x'\"\n\tcom.google.javascript.jscomp.AbstractCommandLineRunner.createDefineReplacements(AbstractCommandLineRunner.java:892)\n\tcom.google.javascript.jscomp.AbstractCommandLineRunner.initOptionsFromFlags(AbstractCommandLineRunner.java:138)\n\tcom.google.javascript.jscomp.CommandLineRunner.createOptions(CommandLineRunner.java:437)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.compile(CommandLineRunnerTest.java:309)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:254)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:246)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testDefineFlag3(CommandLineRunnerTest.java:143)", "buggy_method": "847 @VisibleForTesting\n848   static void createDefineReplacements(List<String> definitions,\n849       CompilerOptions options) {\n850     // Parse the definitions\n851     for (String override : definitions) {\n852       String[] assignment = override.split(\"=\", 2);\n853       String defName = assignment[0];\n854 \n855       if (defName.length() > 0) {\n856         if (assignment.length == 1) {\n857           options.setDefineToBooleanLiteral(defName, true);\n858           continue;\n859         } else {\n860           String defValue = assignment[1];\n861 \n862           if (defValue.equals(\"true\")) {\n863             options.setDefineToBooleanLiteral(defName, true);\n864             continue;\n865           } else if (defValue.equals(\"false\")) {\n866             options.setDefineToBooleanLiteral(defName, false);\n867             continue;\n868           } else if (defValue.length() > 1\n869               && ((defValue.charAt(0) == '\\'' &&\n870                   defValue.charAt(defValue.length() - 1) == '\\'')\n871             )) {\n872             // If the value starts and ends with a single quote,\n873             // we assume that it's a string.\n874             String maybeStringVal =\n875                 defValue.substring(1, defValue.length() - 1);\n876             if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n877               options.setDefineToStringLiteral(defName, maybeStringVal);\n878               continue;\n879             }\n880           } else {\n881             try {\n882               options.setDefineToDoubleLiteral(defName,\n883                   Double.parseDouble(defValue));\n884               continue;\n885             } catch (NumberFormatException e) {\n886               // do nothing, it will be caught at the end\n887             }\n888           }\n889         }\n890       }\n891 \n892       throw new RuntimeException(\n893           \"--define flag syntax invalid: \" + override);\n894     }\n895   }", "bm_classpath": "com.google.javascript.jscomp.AbstractCommandLineRunner"}, {"bug_name": "Closure_144", "report_text": "> Auto-identify void functions\n> \n> function f() {\r\n> }\r\n> \r\n> alert(f());\r\n> \r\n> should emit a warning", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testTypeAnnotationsAssign", "test_method": "  public void testTypeAnnotationsAssign() {\n    assertTypeAnnotations(\"/** @constructor */ var Foo = function(){}\",\n        \"/**\\n * @return {undefined}\\n * @constructor\\n */\\n\"\n        + \"var Foo = function() {\\n}\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:</**\n\tcom.google.javascript.jscomp.CodePrinterTest.assertTypeAnnotations(CodePrinterTest.java:799)\n\tcom.google.javascript.jscomp.CodePrinterTest.testTypeAnnotationsAssign(CodePrinterTest.java:613)", "buggy_method": "198 FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n199     returnType = info != null && info.hasReturnType() ?\n200         info.getReturnType().evaluate(scope, typeRegistry) :\n201         typeRegistry.getNativeType(UNKNOWN_TYPE);\n202     if (templateTypeName != null &&\n203         returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n204       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n205     }\n206     return this;\n207   }", "bm_classpath": "com.google.javascript.jscomp.FunctionTypeBuilder"}, {"bug_name": "Closure_145", "report_text": "> Bug with labeled loops and breaks\n> \n> **What steps will reproduce the problem?**\n> Try to compile this code with the closure compiler : \r\n> var i = 0; \r\n> lab1: do{ \r\n>  lab2: do{ \r\n>  i++; \r\n>  if (1) { \r\n>  break lab2; \r\n>  } else { \r\n>  break lab1; \r\n>  } \r\n>  } while(false); \r\n> } while(false); \r\n> \r\n> console.log(i); \r\n> \r\n> **What is the expected output? What do you see instead?**\n> The generated code produced is :\r\n> var a=0;do b:do{a++;break b}while(0);while(0);console.log(a); \r\n> \r\n> Which works on all browsers except IE (Looks like IE doesn't like \r\n> the missing brackets just after the first do instruction).\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> I am using the version of Jun 16 (latest) on ubuntu 10\r\n> \r\n> **Please provide any additional information below.**\n> Strangely, this bug doesn't happen when I use PRETTY\\_PRINT formatting option.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testFunctionSafariCompatiblity", "test_method": "  public void testFunctionSafariCompatiblity() {\n    // Functions within IFs cause syntax errors on Safari.\n\n\n\n\n    assertPrint(\"if(e1)A:function goo(){return true}\",\n        \"if(e1){A:function goo(){return true}}\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<if(e1)[{A:function goo(){return true}]}> but was:<if(e1)[A:function goo(){return true]}>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:342)\n\tcom.google.javascript.jscomp.CodePrinterTest.testFunctionSafariCompatiblity(CodePrinterTest.java:958)", "buggy_method": "708 private boolean isOneExactlyFunctionOrDo(Node n) {\n709         // For labels with block children, we need to ensure that a\n710         // labeled FUNCTION or DO isn't generated when extraneous BLOCKs \n711         // are skipped. \n712           // Either a empty statement or an block with more than one child,\n713           // way it isn't a FUNCTION or DO.\n714       return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n715   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_146", "report_text": "> bad type inference for != undefined\n> \n> **What steps will reproduce the problem?**\n> \r\n> // ==ClosureCompiler==\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // @output\\_file\\_name default.js\r\n> // ==/ClosureCompiler==\r\n> \r\n> /\\*\\* @param {string} x \\*/\r\n> function g(x) {}\r\n> \r\n> /\\*\\* @param {undefined} x \\*/\r\n> function f(x) {\r\n>  if (x != undefined) { g(x); }\r\n> }\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> JSC\\_DETERMINISTIC\\_TEST: condition always evaluates to false\r\n> left : undefined\r\n> right: undefined at line 6 character 6\r\n> if (x != undefined) { g(x); }\r\n>  ^\r\n> JSC\\_TYPE\\_MISMATCH: actual parameter 1 of g does not match formal parameter\r\n> found : undefined\r\n> required: string at line 6 character 24\r\n> if (x != undefined) { g(x); }\r\n>  ^\r\n> \r\n> the second warning is bogus.", "test_name": "com.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest::testEqCondition4", "test_method": "  @SuppressWarnings(\"unchecked\")\n  public void testEqCondition4() throws Exception {\n    FlowScope blind = newScope();\n    testBinop(blind,\n        Token.EQ,\n        createVar(blind, \"a\", VOID_TYPE),\n        createVar(blind, \"b\", VOID_TYPE),\n        Sets.newHashSet(\n            new TypedName(\"a\", VOID_TYPE),\n            new TypedName(\"b\", VOID_TYPE)),\n        Sets.newHashSet(\n            new TypedName(\"a\", NO_TYPE),\n            new TypedName(\"b\", NO_TYPE))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<None> but was:<undefined>\n\tcom.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest.testBinop(SemanticReverseAbstractInterpreterTest.java:536)\n\tcom.google.javascript.jscomp.SemanticReverseAbstractInterpreterTest.testEqCondition4(SemanticReverseAbstractInterpreterTest.java:341)", "buggy_method": "696 public TypePair getTypesUnderInequality(JSType that) {\n697     // unions types\n698     if (that instanceof UnionType) {\n699       TypePair p = that.getTypesUnderInequality(this);\n700       return new TypePair(p.typeB, p.typeA);\n701     }\n702 \n703     // other types\n704     switch (this.testForEquality(that)) {\n705       case TRUE:\n706         return new TypePair(null, null);\n707 \n708       case FALSE:\n709       case UNKNOWN:\n710         return new TypePair(this, that);\n711     }\n712 \n713     // switch case is exhaustive\n714     throw new IllegalStateException();\n715   }", "bm_classpath": "com.google.javascript.rhino.jstype.JSType"}, {"bug_name": "Closure_147", "report_text": "> Lost a JSC_USED_GLOBAL_THIS warning in 0616 release vs 0514\n> \n> **What steps will reproduce the problem?**\n> //------------------\r\n> // should warn \"JSC\\_USED\\_GLOBAL\\_THIS: dangerous use of the global this object\" in both methods\r\n> // none of these warns in 0616 release\r\n> var NS = {\r\n>  read: function()\r\n>  {\r\n>  return this.foo; // does not warn in 0514 release\r\n>  },\r\n> \r\n>  write: function()\r\n>  {\r\n>  this.foo = 123; // warns in 0514 release\r\n>  }\r\n> };\r\n> \r\n> // only the non-inline notation warns in 0616 release\r\n> NS.write2 = function()\r\n> {\r\n>  this.foo = 123;\r\n> };\r\n> \r\n> //-----------------------\r\n> **What is the expected output? What do you see instead?**\n> Since the 0514 release warned in in the \"write\" case above I would expect the 0616 to also report this. \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> As said above, 20100514 and 20100616 releases.\r\n> \r\n> **Please provide any additional information below.**\n> I understand that the status is that inline-notation isn't preferred, though I wouldn't expect a previous, correct, warning to disappear. (Since I reported issue #144 I'm also aware of the previous limitation in global this).", "test_name": "com.google.javascript.jscomp.CheckGlobalThisTest::testIssue182a", "test_method": "  public void testIssue182a() {\n    testFailure(\"var NS = {read: function() { return this.foo; }};\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: There should be one error.  expected:<1> but was:<0>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:832)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testFailure(CheckGlobalThisTest.java:36)\n\tcom.google.javascript.jscomp.CheckGlobalThisTest.testIssue182a(CheckGlobalThisTest.java:208)", "buggy_method": "84 public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n85 \n86     if (n.getType() == Token.FUNCTION) {\n87       // Don't traverse functions that are constructors or have the @this\n88       // or @override annotation.\n89       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n90       if (jsDoc != null &&\n91           (jsDoc.isConstructor() ||\n92            jsDoc.isInterface() ||\n93            jsDoc.hasThisType() ||\n94            jsDoc.isOverride())) {\n95         return false;\n96       }\n97 \n98       // Don't traverse functions unless they would normally\n99       // be able to have a @this annotation associated with them. e.g.,\n100       // var a = function() { }; // or\n101       // function a() {} // or\n102       // a.x = function() {}; // or\n103       // var a = {x: function() {}};\n104       int pType = parent.getType();\n105       if (!(pType == Token.BLOCK ||\n106             pType == Token.SCRIPT ||\n107             pType == Token.NAME ||\n108             pType == Token.ASSIGN)) {\n109         return false;\n110       }\n111     }\n112 \n113     if (parent != null && parent.getType() == Token.ASSIGN) {\n114       Node lhs = parent.getFirstChild();\n115       Node rhs = lhs.getNext();\n116 \n117       if (n == lhs) {\n118         // Always traverse the left side of the assignment. To handle\n119         // nested assignments properly (e.g., (a = this).property = c;),\n120         // assignLhsChild should not be overridden.\n121         if (assignLhsChild == null) {\n122           assignLhsChild = lhs;\n123         }\n124       } else {\n125         // Only traverse the right side if it's not an assignment to a prototype\n126         // property or subproperty.\n127         if (NodeUtil.isGet(lhs)) {\n128           if (lhs.getType() == Token.GETPROP &&\n129               lhs.getLastChild().getString().equals(\"prototype\")) {\n130             return false;\n131           }\n132           Node llhs = lhs.getFirstChild();\n133           if (llhs.getType() == Token.GETPROP &&\n134               llhs.getLastChild().getString().equals(\"prototype\")) {\n135             return false;\n136           }\n137         }\n138       }\n139     }\n140 \n141     return true;\n142   }", "bm_classpath": "com.google.javascript.jscomp.CheckGlobalThis"}, {"bug_name": "Closure_148", "report_text": "> CSS3 'writingMode' not recognised in advanced mode\n> \n> element.style.writingMode was defined in CSS3 but later dropped. However it is supported by IE7 (possibly earlier). It's a useful way to achieve vertical text in IE.\r\n> \r\n> Closure Compiler will change references of element.style.writingMode to element.style.a, breaking implementation.\r\n> \r\n> I've attached a patch adding this to the IE css properties.\r\n> \r\n> Cheers,\r\n> Jake.", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testFoldTypeof", "test_method": "  public void testFoldTypeof() {\n    fold(\"x = typeof 1\", \"x = \\\"number\\\"\");\n    fold(\"x = typeof 'foo'\", \"x = \\\"string\\\"\");\n    fold(\"x = typeof true\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof false\", \"x = \\\"boolean\\\"\");\n    fold(\"x = typeof null\", \"x = \\\"object\\\"\");\n    fold(\"x = typeof undefined\", \"x = \\\"undefined\\\"\");\n    fold(\"x = typeof void 0\", \"x = \\\"undefined\\\"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:792)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:301)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:270)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:258)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.fold(PeepholeFoldConstantsTest.java:58)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testFoldTypeof(PeepholeFoldConstantsTest.java:552)", "buggy_method": "156 private Node tryFoldTypeof(Node originalTypeofNode) {\n157     Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n158 \n159     Node argumentNode = originalTypeofNode.getFirstChild();\n160     if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n161       return originalTypeofNode;\n162     }\n163 \n164     String typeNameString = null;\n165 \n166     switch (argumentNode.getType()) {\n167       case Token.STRING:\n168         typeNameString = \"string\";\n169         break;\n170       case Token.NUMBER:\n171         typeNameString = \"number\";\n172         break;\n173       case Token.TRUE:\n174       case Token.FALSE:\n175         typeNameString = \"boolean\";\n176         break;\n177       case Token.NULL:\n178       case Token.OBJECTLIT:\n179       case Token.ARRAYLIT:\n180         typeNameString = \"object\";\n181         break;\n182       case Token.NAME:\n183         // We assume here that programs don't change the value of the\n184         // keyword undefined to something other than the value undefined.\n185         if (\"undefined\".equals(argumentNode.getString())) {\n186           typeNameString = \"undefined\";\n187         }\n188         break;\n189     }\n190 \n191     if (typeNameString != null) {\n192       Node newNode = Node.newString(typeNameString);\n193       originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n194       reportCodeChange();\n195 \n196       return newNode;\n197     }\n198 \n199     return originalTypeofNode;\n200   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_149", "report_text": "> Add option to turn off string escaping\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. I'm having large files with strings (patterns for hyphenation, see http://code.google.com/p/hyphenator/) and no-ASCII-characters.\r\n> 2. Minifying with closure compiler makes them bigger\r\n>  ru.js (orig): 41'216 Bytes\r\n>  ru.js (orig, gzip): 17'124 Bytes\r\n>  ru.js (mini): 110'770 Bytes\r\n>  ru.js (mini, gzip): 18'860 Bytes\r\n> \r\n> What is the expected output?\r\n> I'd like to be able to turn OFF the string escaping mechanism.\r\n> \r\n> Thanks", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testCharSetExpansion", "test_method": "  public void testCharSetExpansion() {\n    testSame(\"\");\n    assertEquals(\"US-ASCII\", lastCompiler.getOptions().outputCharset); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<US-ASCII> but was:<null>\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testCharSetExpansion(CommandLineRunnerTest.java:385)", "buggy_method": "141 final protected void setRunOptions(CompilerOptions options)\n142       throws FlagUsageException, IOException {\n143     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n144 \n145     diagnosticGroups.setWarningLevels(\n146         options, config.jscompError, CheckLevel.ERROR);\n147     diagnosticGroups.setWarningLevels(\n148         options, config.jscompWarning, CheckLevel.WARNING);\n149     diagnosticGroups.setWarningLevels(\n150         options, config.jscompOff, CheckLevel.OFF);\n151 \n152     createDefineReplacements(config.define, options);\n153 \n154     options.manageClosureDependencies = config.manageClosureDependencies;\n155     options.devMode = config.jscompDevMode;\n156     options.setCodingConvention(config.codingConvention);\n157     options.setSummaryDetailLevel(config.summaryDetailLevel);\n158 \n159     inputCharset = getInputCharset();\n160 \n161     if (config.jsOutputFile.length() > 0) {\n162       options.jsOutputFile = config.jsOutputFile;\n163     }\n164 \n165     if (config.createSourceMap.length() > 0) {\n166       options.sourceMapOutputPath = config.createSourceMap;\n167     }\n168     options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n169 \n170     if (!config.variableMapInputFile.equals(\"\")) {\n171       options.inputVariableMapSerialized =\n172           VariableMap.load(config.variableMapInputFile).toBytes();\n173     }\n174 \n175     if (!config.propertyMapInputFile.equals(\"\")) {\n176       options.inputPropertyMapSerialized =\n177           VariableMap.load(config.propertyMapInputFile).toBytes();\n178     }\n179   }", "bm_classpath": "com.google.javascript.jscomp.AbstractCommandLineRunner"}, {"bug_name": "Closure_150", "report_text": "> Type checker misses annotations on functions defined within functions\n> \n> **What steps will reproduce the problem?**\n> 1. Compile the following code under --warning\\_level VERBOSE\r\n> \r\n> var ns = {};\r\n> \r\n> /\\*\\* @param {string=} b \\*/\r\n> ns.a = function(b) {}\r\n> \r\n> function d() {\r\n>  ns.a();\r\n>  ns.a(123);\r\n> }\r\n> \r\n> 2. Observe that the type checker correctly emits one warning, as 123 \r\n> doesn't match the type {string}\r\n> \r\n> 3. Now compile the code with ns.a defined within an anonymous function, \r\n> like so:\r\n> \r\n> var ns = {};\r\n> \r\n> (function() {\r\n>  /\\*\\* @param {string=} b \\*/\r\n>  ns.a = function(b) {}\r\n> })();\r\n> \r\n> function d() {\r\n>  ns.a();\r\n>  ns.a(123);\r\n> }\r\n> \r\n> 4. Observe that a warning is emitted for calling ns.a with 0 parameters, and \r\n> not for the type error, as though the @param declaration were ignored. \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> r15\r\n> \r\n> **Please provide any additional information below.**\n> \r\n> This sort of module pattern is common enough that it strikes me as worth \r\n> supporting.\r\n> \r\n> One last note to make matters stranger: if the calling code isn't itself within \r\n> a function, no warnings are emitted at all:\r\n> \r\n> var ns = {};\r\n> \r\n> (function() {\r\n>  /\\*\\* @param {string=} b \\*/\r\n>  ns.a = function(b) {}\r\n> })();\r\n> \r\n> ns.a();\r\n> ns.a(123);", "test_name": "com.google.javascript.jscomp.TypedScopeCreatorTest::testNamespacedFunctionStubLocal", "test_method": "  public void testNamespacedFunctionStubLocal() {\n    testSame(\n        \"(function() {\" +\n        \"var goog = {};\" +\n        \"/** @param {number} x */ goog.foo;\" +\n        \"});\");\n\n    ObjectType goog = (ObjectType) findNameType(\"goog\", lastLocalScope);\n    assertTrue(goog.hasProperty(\"foo\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.TypedScopeCreatorTest.testNamespacedFunctionStubLocal(TypedScopeCreatorTest.java:251)", "buggy_method": "1443 @Override public void visit(NodeTraversal t, Node n, Node parent) {\n1444       if (n == scope.getRootNode()) return;\n1445 \n1446       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n1447         handleFunctionInputs(parent);\n1448         return;\n1449       }\n1450 \n1451       attachLiteralTypes(n);\n1452       switch (n.getType()) {\n1453         case Token.FUNCTION:\n1454           if (parent.getType() == Token.NAME) {\n1455             return;\n1456           }\n1457           defineDeclaredFunction(n, parent);\n1458           break;\n1459         case Token.CATCH:\n1460           defineCatch(n, parent);\n1461           break;\n1462         case Token.VAR:\n1463           defineVar(n, parent);\n1464           break;\n1465       }\n1466     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder"}, {"bug_name": "Closure_151", "report_text": "> Add a --version option for the compiler.\n> \n> **What steps will reproduce the problem?**\n> 1. Run java -jar compiler.jar --version\r\n> \r\n> **What is the expected output? What do you see instead?**\n> Expected: A version statement.\r\n> Actual: An error that --version is not supported.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> See above. This is a compiler.jar I downloaded from this project (didn't \r\n> build it myself), file is dated 04/12/2009.\r\n> On Windows XP.\r\n> \r\n> **Please provide any additional information below.**\n> This information doesn't seem to be given anywhere, don't see it on --help \r\n> either.\r\n> \r\n> This is an enhancement request, not a bug report.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testVersionFlag", "test_method": "  public void testVersionFlag() {\n    args.add(\"--version\");\n    testSame(\"\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.compile(CommandLineRunnerTest.java:570)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:490)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:479)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:467)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testSame(CommandLineRunnerTest.java:463)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testVersionFlag(CommandLineRunnerTest.java:451)", "buggy_method": "385 private void initConfigFromFlags(String[] args, PrintStream err) {\n386     // Args4j has a different format that the old command-line parser.\n387     // So we use some voodoo to get the args into the format that args4j\n388     // expects.\n389     Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n390     Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n391     List<String> processedArgs = Lists.newArrayList();\n392     for (String arg : args) {\n393       Matcher matcher = argPattern.matcher(arg);\n394       if (matcher.matches()) {\n395         processedArgs.add(matcher.group(1));\n396 \n397         String value = matcher.group(2);\n398         Matcher quotesMatcher = quotesPattern.matcher(value);\n399         if (quotesMatcher.matches()) {\n400           processedArgs.add(quotesMatcher.group(1));\n401         } else {\n402           processedArgs.add(value);\n403         }\n404       } else {\n405         processedArgs.add(arg);\n406       }\n407     }\n408 \n409     CmdLineParser parser = new CmdLineParser(flags);\n410     isConfigValid = true;\n411     try {\n412       parser.parseArgument(processedArgs.toArray(new String[] {}));\n413     } catch (CmdLineException e) {\n414       err.println(e.getMessage());\n415       isConfigValid = false;\n416     }\n417 \n418 \n419     if (!isConfigValid || flags.display_help) {\n420       isConfigValid = false;\n421       parser.printUsage(err);\n422     } else {\n423       getCommandLineConfig()\n424           .setPrintTree(flags.print_tree)\n425           .setComputePhaseOrdering(flags.compute_phase_ordering)\n426           .setPrintAst(flags.print_ast)\n427           .setPrintPassGraph(flags.print_pass_graph)\n428           .setJscompDevMode(flags.jscomp_dev_mode)\n429           .setLoggingLevel(flags.logging_level)\n430           .setExterns(flags.externs)\n431           .setJs(flags.js)\n432           .setJsOutputFile(flags.js_output_file)\n433           .setModule(flags.module)\n434           .setVariableMapInputFile(flags.variable_map_input_file)\n435           .setPropertyMapInputFile(flags.property_map_input_file)\n436           .setVariableMapOutputFile(flags.variable_map_output_file)\n437           .setCreateNameMapFiles(flags.create_name_map_files)\n438           .setPropertyMapOutputFile(flags.property_map_output_file)\n439           .setCodingConvention(flags.third_party ?\n440                new DefaultCodingConvention() :\n441                new ClosureCodingConvention())\n442           .setSummaryDetailLevel(flags.summary_detail_level)\n443           .setOutputWrapper(flags.output_wrapper)\n444           .setOutputWrapperMarker(flags.output_wrapper_marker)\n445           .setModuleWrapper(flags.module_wrapper)\n446           .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n447           .setCreateSourceMap(flags.create_source_map)\n448           .setJscompError(flags.jscomp_error)\n449           .setJscompWarning(flags.jscomp_warning)\n450           .setJscompOff(flags.jscomp_off)\n451           .setDefine(flags.define)\n452           .setCharset(flags.charset)\n453           .setManageClosureDependencies(flags.manage_closure_dependencies)\n454           .setOutputManifest(flags.output_manifest);\n455     }\n456   }", "bm_classpath": "com.google.javascript.jscomp.CommandLineRunner"}, {"bug_name": "Closure_152", "report_text": "> resolveTypes: jstype.UnionType cannot be cast to jstype.ObjectType\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Compile a bunch of JavaScript files that I can't release with these options: ['--create\\_name\\_map\\_files', 'true', '--jscomp\\_warning', 'missingProperties', '--jscomp\\_warning', 'undefinedVars', '--jscomp\\_warning', 'checkTypes', '--warning\\_level', 'VERBOSE', '--summary\\_detail\\_level', '3', '--process\\_closure\\_primitives', 'true', '--jscomp\\_error', 'strictModuleDepCheck', '--jscomp\\_error', 'invalidCasts', '--logging\\_level', 'ALL', '--compilation\\_level', 'ADVANCED\\_OPTIMIZATIONS']\r\n> \r\n> 2. During this pass:\r\n> \r\n>  Oct 26, 2010 12:09:38 AM com.google.javascript.jscomp.PhaseOptimizer$NamedPass process\r\n>  INFO: resolveTypes\r\n> \r\n> , compilation terminates with:\r\n> \r\n>  java.lang.RuntimeException: java.lang.ClassCastException: com.google.javascript.rhino.jstype.UnionType cannot be cast to com.google.javascript.rhino.jstype.ObjectType\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n>  Caused by: java.lang.ClassCastException: com.google.javascript.rhino.jstype.UnionType cannot be cast to com.google.javascript.rhino.jstype.ObjectType\r\n>  at com.google.javascript.rhino.jstype.FunctionType.resolveInternal(Unknown Source)\r\n>  at com.google.javascript.rhino.jstype.JSType.resolve(Unknown Source)\r\n>  at com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType.resolve(Unknown Source)\r\n>  at com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveTypes(Unknown Source)\r\n>  at com.google.javascript.jscomp.TypedScopeCreator.createScope(Unknown Source)\r\n>  at com.google.javascript.jscomp.MemoizedScopeCreator.createScope(Unknown Source)\r\n>  at com.google.javascript.jscomp.DefaultPassConfig$GlobalTypeResolver.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.check(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)\r\n>  at java.lang.Thread.run(Thread.java:662)\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> I'm using Closure Compiler r506. The problem first appeared in r482.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testBackwardsTypedefUse1", "test_method": "  public void testBackwardsTypedefUse1() throws Exception {\n    testTypes(\n        \"/** @this {MyTypedef} */ function f() {}\" +\n        \"/** @typedef {string} */ var MyTypedef;\",\n        \"@this type of a function must be an object\\n\" +\n        \"Actual type: string\"); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: com.google.javascript.rhino.jstype.StringType cannot be cast to com.google.javascript.rhino.jstype.ObjectType\n\tcom.google.javascript.rhino.jstype.FunctionType.resolveInternal(FunctionType.java:871)\n\tcom.google.javascript.rhino.jstype.JSType.resolve(JSType.java:894)\n\tcom.google.javascript.jscomp.TypedScopeCreator$DeferredSetType.resolve(TypedScopeCreator.java:146)\n\tcom.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveTypes(TypedScopeCreator.java:367)\n\tcom.google.javascript.jscomp.TypedScopeCreator.createScope(TypedScopeCreator.java:188)\n\tcom.google.javascript.jscomp.MemoizedScopeCreator.createScope(MemoizedScopeCreator.java:53)\n\tcom.google.javascript.jscomp.TypeCheck.processForTesting(TypeCheck.java:354)\n\tcom.google.javascript.jscomp.TypeCheckTest.parseAndTypeCheckWithScope(TypeCheckTest.java:7676)\n\tcom.google.javascript.jscomp.TypeCheckTest.parseAndTypeCheck(TypeCheckTest.java:7649)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7616)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7611)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:7555)\n\tcom.google.javascript.jscomp.TypeCheckTest.testBackwardsTypedefUse1(TypeCheckTest.java:2610)", "buggy_method": "861 @Override\n862   JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n863     setResolvedTypeInternal(this);\n864 \n865     call = (ArrowType) safeResolve(call, t, scope);\n866     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n867 \n868     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n869     // is handled further upstream.\n870     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n871     typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n872 \n873     boolean changed = false;\n874     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n875         ImmutableList.builder();\n876     for (ObjectType iface : implementedInterfaces) {\n877       ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n878       resolvedInterfaces.add(resolvedIface);\n879       changed |= (resolvedIface != iface);\n880     }\n881     if (changed) {\n882       implementedInterfaces = resolvedInterfaces.build();\n883     }\n884 \n885     if (subTypes != null) {\n886       for (int i = 0; i < subTypes.size(); i++) {\n887         subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n888       }\n889     }\n890 \n891     return super.resolveInternal(t, scope);\n892   }", "bm_classpath": "com.google.javascript.rhino.jstype.FunctionType"}, {"bug_name": "Closure_153", "report_text": "> Namespace definition in Prototype is broken\n> \n> **What steps will reproduce the problem?**\n> 1. Namespace definition in prototype.js (Prototype library) looks like:\r\n> if (!Node) var Node = { };\r\n> 2. Compile with latest command line compiler (Version: 20100917 (revision 440) Built on: 2010/09/17 17:55), with default options\r\n> 3. Open html which uses this script in IE8 - IE will show error message (something like \"Node - definition is missing\", I use localized version and cannot write exact english message).\r\n> \r\n> What is the expected output?\r\n> Something like:\r\n> if(!Node)var Node={};\r\n> \r\n> What do you see instead?\r\n> Node||(Node={});\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> Command line compiler (Version: 20100917 (revision 440) Built on: 2010/09/17 17:55), with default options, OS Linux Mint 7.", "test_name": "com.google.javascript.jscomp.NormalizeTest::testDuplicateVarInExterns", "test_method": "  public void testDuplicateVarInExterns() {\n    test(\"var extern;\",\n         \"/** @suppress {duplicate} */ var extern = 3;\", \"var extern = 3;\",\n         null, null); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:797)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:377)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:345)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:322)\n\tcom.google.javascript.jscomp.NormalizeTest.testDuplicateVarInExterns(NormalizeTest.java:95)", "buggy_method": "636 @Override\n637     public void onRedeclaration(\n638         Scope s, String name, Node n, Node parent, Node gramps,\n639         Node nodeWithLineNumber) {\n640       Preconditions.checkState(n.getType() == Token.NAME);\n641       Var v = s.getVar(name);\n642 \n643         // We allow variables to be duplicate declared if one\n644         // declaration appears in source and the other in externs.\n645         // This deals with issues where a browser built-in is declared\n646         // in one browser but not in another.\n647 \n648       // If name is \"arguments\", Var maybe null.\n649       if (v != null && v.getParentNode().getType() == Token.CATCH) {\n650         // Redeclaration of a catch expression variable is hard to model\n651         // without support for \"with\" expressions.\n652         // The EcmaScript spec (section 12.14), declares that a catch\n653         // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n654         // \"var e\" would refer to the scope variable, but any following\n655         // reference would still refer to \"e\" of the catch expression.\n656         // Until we have support for this disallow it.\n657         // Currently the Scope object adds the catch expression to the\n658         // function scope, which is technically not true but a good\n659         // approximation for most uses.\n660 \n661         // TODO(johnlenz): Consider improving how scope handles catch\n662         // expression.\n663 \n664         // Use the name of the var before it was made unique.\n665         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n666             name);\n667         compiler.report(\n668             JSError.make(\n669                 NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n670                 CATCH_BLOCK_VAR_ERROR, name));\n671       } else if (v != null && parent.getType() == Token.FUNCTION) {\n672         if (v.getParentNode().getType() == Token.VAR) {\n673           s.undeclare(v);\n674           s.declare(name, n, n.getJSType(), v.input);\n675           replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n676               v.getParentNode().getParent());\n677         }\n678       } else if (parent.getType() == Token.VAR) {\n679         Preconditions.checkState(parent.hasOneChild());\n680 \n681         replaceVarWithAssignment(n, parent, gramps);\n682       }\n683     }", "bm_classpath": "com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler"}, {"bug_name": "Closure_154", "report_text": "> Add support for data members on interfaces\n> \n> /\\*\\*\r\n>  \\* @interface\r\n>  \\*/\r\n> function I() {};\r\n> \r\n> /\\*\\* @type {string} \\*/\r\n> I.prototype.foobar;\r\n> \r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\* @implements {I}\r\n>  \\*/\r\n> function C() {\r\n>  // No warning generated here.\r\n>  this.foobar = 2;\r\n> };\r\n> \r\n> /\\*\\* @type {I} \\*/\r\n> var test = new C(); \r\n> alert(test.foobar);", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testInterfaceInheritanceCheck12", "test_method": "  public void testInterfaceInheritanceCheck12() throws Exception {\n    testTypes(\n        \"/** @interface */ function I() {};\\n\" +\n        \"/** @type {string} */ I.prototype.foobar;\\n\" +\n        \"/** \\n * @constructor \\n * @implements {I} */\\n\" +\n        \"function C() {\\n\" +\n        \"/** \\n * @type {number} */ this.foobar = 2;};\\n\" +\n        \"/** @type {I} */ \\n var test = new C(); alert(test.foobar);\",\n        \"mismatch of the foobar property type and the type of the property\" +\n        \" it overrides from interface I\\n\" +\n        \"original: string\\n\" +\n        \"override: number\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8391)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8371)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:8312)\n\tcom.google.javascript.jscomp.TypeCheckTest.testInterfaceInheritanceCheck12(TypeCheckTest.java:6717)", "buggy_method": "1014 private void checkDeclaredPropertyInheritance(\n1015       NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n1016       JSDocInfo info, JSType propertyType) {\n1017     // If the supertype doesn't resolve correctly, we've warned about this\n1018     // already.\n1019     if (hasUnknownOrEmptySupertype(ctorType)) {\n1020       return;\n1021     }\n1022 \n1023     FunctionType superClass = ctorType.getSuperClassConstructor();\n1024     boolean superClassHasProperty = superClass != null &&\n1025         superClass.getPrototype().hasProperty(propertyName);\n1026     boolean declaredOverride = info != null && info.isOverride();\n1027 \n1028     boolean foundInterfaceProperty = false;\n1029     if (ctorType.isConstructor()) {\n1030       for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n1031         if (implementedInterface.isUnknownType() ||\n1032             implementedInterface.isEmptyType()) {\n1033           continue;\n1034         }\n1035         FunctionType interfaceType =\n1036             implementedInterface.toObjectType().getConstructor();\n1037         Preconditions.checkNotNull(interfaceType);\n1038         boolean interfaceHasProperty =\n1039             interfaceType.getPrototype().hasProperty(propertyName);\n1040         foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n1041         if (reportMissingOverride.isOn() && !declaredOverride &&\n1042             interfaceHasProperty) {\n1043           // @override not present, but the property does override an interface\n1044           // property\n1045           compiler.report(t.makeError(n, reportMissingOverride,\n1046               HIDDEN_INTERFACE_PROPERTY, propertyName,\n1047               interfaceType.getTopMostDefiningType(propertyName).toString()));\n1048         }\n1049         if (interfaceHasProperty) {\n1050           JSType interfacePropType =\n1051               interfaceType.getPrototype().getPropertyType(propertyName);\n1052           if (!propertyType.canAssignTo(interfacePropType)) {\n1053             compiler.report(t.makeError(n,\n1054                 HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName,\n1055                 interfaceType.getTopMostDefiningType(propertyName).toString(),\n1056                 interfacePropType.toString(), propertyType.toString()));\n1057           }\n1058         }\n1059       }\n1060     }\n1061 \n1062     if (!declaredOverride && !superClassHasProperty) {\n1063       // nothing to do here, it's just a plain new property\n1064       return;\n1065     }\n1066 \n1067     JSType topInstanceType = superClassHasProperty ?\n1068         superClass.getTopMostDefiningType(propertyName) : null;\n1069     if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n1070         !declaredOverride && superClassHasProperty) {\n1071       // @override not present, but the property does override a superclass\n1072       // property\n1073       compiler.report(t.makeError(n, reportMissingOverride,\n1074           HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n1075           topInstanceType.toString()));\n1076     }\n1077     if (!declaredOverride) {\n1078       // there's no @override to check\n1079       return;\n1080     }\n1081     // @override is present and we have to check that it is ok\n1082     if (superClassHasProperty) {\n1083       // there is a superclass implementation\n1084       JSType superClassPropType =\n1085           superClass.getPrototype().getPropertyType(propertyName);\n1086       if (!propertyType.canAssignTo(superClassPropType)) {\n1087         compiler.report(\n1088             t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n1089                 propertyName, topInstanceType.toString(),\n1090                 superClassPropType.toString(), propertyType.toString()));\n1091       }\n1092     } else if (!foundInterfaceProperty) {\n1093       // there is no superclass nor interface implementation\n1094       compiler.report(\n1095           t.makeError(n, UNKNOWN_OVERRIDE,\n1096               propertyName, ctorType.getInstanceType().toString()));\n1097     }\n1098   }", "bm_classpath": "com.google.javascript.jscomp.TypeCheck"}, {"bug_name": "Closure_155", "report_text": "> Overzealous arguments optimisation\n> \n> Consider the following JavaScript code:\r\n> \r\n> function d3\\_call(callback) {\r\n>  var f = callback;\r\n>  arguments[0] = this;\r\n>  f.apply(this, arguments);\r\n>  return this;\r\n> }\r\n> \r\n> This is optimised to:\r\n> \r\n> function d3\\_call(a){arguments[0]=this;a.apply(this,arguments);return this};\r\n> \r\n> However, the use of a temporary variable `f` is necessary to avoid `arguments[0] = this` from overwriting the first argument.\r\n> \r\n> In the above optimised code, `arguments[0] = this` causes `this` to be assigned to `a`.\r\n> \r\n> Verified on latest SVN r878.\r\n> \r\n> See also: https://github.com/mbostock/d3/issues/closed#issue/68", "test_name": "com.google.javascript.jscomp.InlineVariablesTest::testArgumentsModifiedInInnerFunction", "test_method": "  public void testArgumentsModifiedInInnerFunction() {\n    test(\n      \"function g(callback) {\\n\" +\n      \"  var f = callback;\\n\" +\n      \"  f.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\",\n      \"function g(callback) {\\n\" +\n      \"  callback.apply(this, arguments);\\n\" +\n      \"  function inner(callback) {\" +\n      \"    var x = callback;\\n\" +\n      \"    arguments[0] = this;\\n\" +\n      \"    x.apply(this);\\n\" +\n      \"  }\" +\n      \"}\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:304)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:292)\n\tcom.google.javascript.jscomp.InlineVariablesTest.testArgumentsModifiedInInnerFunction(InlineVariablesTest.java:1035)", "buggy_method": "196 private void doInlinesForScope(NodeTraversal t,\n197         Map<Var, ReferenceCollection> referenceMap) {\n198 \n199       for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n200         Var v = it.next();\n201 \n202         ReferenceCollection referenceInfo = referenceMap.get(v);\n203 \n204         // referenceInfo will be null if we're in constants-only mode\n205         // and the variable is not a constant.\n206         if (referenceInfo == null || isVarInlineForbidden(v)) {\n207           // Never try to inline exported variables or variables that\n208           // were not collected or variables that have already been inlined.\n209           continue;\n210         } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n211           Reference init = referenceInfo.getInitializingReferenceForConstants();\n212           Node value = init.getAssignedValue();\n213           inlineDeclaredConstant(v, value, referenceInfo.references);\n214           staleVars.add(v);\n215         } else if (mode == Mode.CONSTANTS_ONLY) {\n216           // If we're in constants-only mode, don't run more aggressive\n217           // inlining heuristics. See InlineConstantsTest.\n218           continue;\n219         } else {\n220           inlineNonConstants(v, referenceInfo);\n221         }\n222       }\n223     }", "bm_classpath": "com.google.javascript.jscomp.InlineVariables$InliningBehavior"}, {"bug_name": "Closure_156", "report_text": "> Compiler crashes on assign statement\n> \n> It is a large app (containing the entire Dojo Toolkit library). Code fragment that fails:\r\n> \r\n> /\\*\\* @constructor\r\n>  \\* @param {...Object} params\r\n>  \\*/\r\n> dojox.gfx.shape.Shape = function(params) {};\r\n> dojox.gfx.shape.Shape = dojo.declare(\"dojox.gfx.shape.Shape\", null, /\\*\\* @lends dojox.gfx.shape.Shape.prototype \\*/ { .......\r\n> \r\n> \r\n> Error message:\r\n> \r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected variable dojox$gfx$shape$Shape\r\n>  Node(NAME dojox$gfx$shape$Shape): release\\src\\dijit.js.uncompressed.js:15135:0\r\n> dojox.gfx.shape.Shape = dojo.declare(\"dojox.gfx.shape.Shape\", null, /\\*\\* @lends dojox.gfx.shape.Shape.prototype \\*/ {\r\n>  Parent(ASSIGN): release\\src\\dijit.js.uncompressed.js:15135:22\r\n> dojox.gfx.shape.Shape = dojo.declare(\"dojox.gfx.shape.Shape\", null, /\\*\\* @lends dojox.gfx.shape.Shape.prototype \\*/ {\r\n> \r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(Unknown Source)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(Unknown Source)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(Unknown Source)\r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected variable dojox$gfx$shape$Shape\r\n>  Node(NAME dojox$gfx$shape$Shape): release\\src\\dijit.js.uncompressed.js:15135:0\r\n> dojox.gfx.shape.Shape = dojo.declare(\"dojox.gfx.shape.Shape\", null, /\\*\\* @lends dojox.gfx.shape.Shape.prototype \\*/ {\r\n>  Parent(ASSIGN): release\\src\\dijit.js.uncompressed.js:15135:22\r\n> dojox.gfx.shape.Shape = dojo.declare(\"dojox.gfx.shape.Shape\", null, /\\*\\* @lends dojox.gfx.shape.Shape.prototype \\*/ {\r\n> \r\n>  at com.google.javascript.jscomp.VarCheck.visit(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(Unknown Source)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(Unknown Source)\r\n>  at com.google.javascript.jscomp.VarCheck.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler.access$000(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$1.call(Unknown Source)\r\n>  at com.google.javascript.jscomp.Compiler$2.run(Unknown Source)\r\n>  at java.lang.Thread.run(Unknown Source)\r\n> Caused by: java.lang.IllegalStateException: Unexpected variable dojox$gfx$shape$Shape\r\n>  ... 47 more", "test_name": "com.google.javascript.jscomp.CollapsePropertiesTest::testAliasedTopLevelEnum", "test_method": "  public void testAliasedTopLevelEnum() {\n    test(\n        \"function alias() {}\" +\n        \"var dojo = {};\" +\n        \"dojo.gfx = {};\" +\n        \"dojo.declare = function() {};\" +\n        \"/** @enum {number} */\" +\n        \"dojo.gfx.Shape = {SQUARE: 2};\" +\n        \"dojo.gfx.Shape = dojo.declare('dojo.gfx.Shape');\" +\n        \"alias(dojo);\" +\n        \"alias(dojo.gfx.Shape.SQUARE);\",\n        \"function alias() {}\" +\n        \"var dojo = {};\" +\n        \"dojo.gfx = {};\" +\n        \"dojo.declare = function() {};\" +\n        \"/** @constructor */\" +\n        \"var dojo$gfx$Shape = {SQUARE: 2};\" +\n        \"dojo$gfx$Shape = dojo.declare('dojo.gfx.Shape');\" +\n        \"alias(dojo);\" +\n        \"alias(dojo$gfx$Shape.SQUARE);\",\n        null,\n        CollapseProperties.UNSAFE_NAMESPACE_WARNING); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:843)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:410)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:335)\n\tcom.google.javascript.jscomp.CollapsePropertiesTest.testAliasedTopLevelEnum(CollapsePropertiesTest.java:1309)", "buggy_method": "451 private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\n452     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n453 \n454     // Handle this name first so that nested object literals get unrolled.\n455     if (n.canCollapse() && canCollapseChildNames) {\n456       updateObjLitOrFunctionDeclaration(n, alias);\n457     }\n458 \n459     if (n.props != null) {\n460       for (Name p : n.props) {\n461         // Recurse first so that saved node ancestries are intact when needed.\n462         collapseDeclarationOfNameAndDescendants(\n463             p, appendPropForAlias(alias, p.name));\n464 \n465         if (!p.inExterns && canCollapseChildNames && p.declaration != null &&\n466             p.declaration.node != null &&\n467             p.declaration.node.getParent() != null &&\n468             p.declaration.node.getParent().getType() == Token.ASSIGN) {\n469           updateSimpleDeclaration(\n470               appendPropForAlias(alias, p.name), p, p.declaration);\n471         }\n472       }\n473     }\n474   }", "bm_classpath": "com.google.javascript.jscomp.CollapseProperties"}, {"bug_name": "Closure_157", "report_text": "> Numbers and quoted property names reject for get and set properties.\n> \n> - Use --language\\_in=ECMASCRIPT5.\r\n> - Note that these definitions cause parse errors:\r\n> \r\n> var x = { get 'x'() { return 1 } };\r\n> var x = { get 1() { return 1 } };\r\n> \r\n> ES5 allow these. The Rhino parser needs to be updated.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testObjectLit2", "test_method": "  public void testObjectLit2() {\n    assertPrint(\"var x={'1':1}\", \"var x={1:1}\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var x={[1]:1}> but was:<var x={[\"1\"]:1}>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:386)\n\tcom.google.javascript.jscomp.CodePrinterTest.testObjectLit2(CodePrinterTest.java:1127)", "buggy_method": "82 void add(Node n, Context context) {\n83     if (!cc.continueProcessing()) {\n84       return;\n85     }\n86 \n87     int type = n.getType();\n88     String opstr = NodeUtil.opToStr(type);\n89     int childCount = n.getChildCount();\n90     Node first = n.getFirstChild();\n91     Node last = n.getLastChild();\n92 \n93     // Handle all binary operators\n94     if (opstr != null && first != last) {\n95       Preconditions.checkState(\n96           childCount == 2,\n97           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n98           opstr, childCount);\n99       int p = NodeUtil.precedence(type);\n100       addLeftExpr(first, p, context);\n101       cc.addOp(opstr, true);\n102 \n103       // For right-hand-side of operations, only pass context if it's\n104       // the IN_FOR_INIT_CLAUSE one.\n105       Context rhsContext = getContextForNoInOperator(context);\n106 \n107       // Handle associativity.\n108       // e.g. if the parse tree is a * (b * c),\n109       // we can simply generate a * b * c.\n110       if (last.getType() == type &&\n111           NodeUtil.isAssociative(type)) {\n112         addExpr(last, p, rhsContext);\n113       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n114         // Assignments are the only right-associative binary operators\n115         addExpr(last, p, rhsContext);\n116       } else {\n117         addExpr(last, p + 1, rhsContext);\n118       }\n119       return;\n120     }\n121 \n122     cc.startSourceMapping(n);\n123 \n124     switch (type) {\n125       case Token.TRY: {\n126         Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n127                 !first.getNext().hasMoreThanOneChild());\n128         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n129 \n130         add(\"try\");\n131         add(first, Context.PRESERVE_BLOCK);\n132 \n133         // second child contains the catch block, or nothing if there\n134         // isn't a catch block\n135         Node catchblock = first.getNext().getFirstChild();\n136         if (catchblock != null) {\n137           add(catchblock);\n138         }\n139 \n140         if (childCount == 3) {\n141           add(\"finally\");\n142           add(last, Context.PRESERVE_BLOCK);\n143         }\n144         break;\n145       }\n146 \n147       case Token.CATCH:\n148         Preconditions.checkState(childCount == 2);\n149         add(\"catch(\");\n150         add(first);\n151         add(\")\");\n152         add(last, Context.PRESERVE_BLOCK);\n153         break;\n154 \n155       case Token.THROW:\n156         Preconditions.checkState(childCount == 1);\n157         add(\"throw\");\n158         add(first);\n159 \n160         // Must have a ';' after a throw statement, otherwise safari can't\n161         // parse this.\n162         cc.endStatement(true);\n163         break;\n164 \n165       case Token.RETURN:\n166         add(\"return\");\n167         if (childCount == 1) {\n168           add(first);\n169         } else {\n170           Preconditions.checkState(childCount == 0);\n171         }\n172         cc.endStatement();\n173         break;\n174 \n175       case Token.VAR:\n176         if (first != null) {\n177           add(\"var \");\n178           addList(first, false, getContextForNoInOperator(context));\n179         }\n180         break;\n181 \n182       case Token.LABEL_NAME:\n183         Preconditions.checkState(!n.getString().isEmpty());\n184         addIdentifier(n.getString());\n185         break;\n186 \n187       case Token.NAME:\n188         if (first == null || first.getType() == Token.EMPTY) {\n189           addIdentifier(n.getString());\n190         } else {\n191           Preconditions.checkState(childCount == 1);\n192           addIdentifier(n.getString());\n193           cc.addOp(\"=\", true);\n194           if (first.getType() == Token.COMMA) {\n195             addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n196           } else {\n197             // Add expression, consider nearby code at lowest level of\n198             // precedence.\n199             addExpr(first, 0, getContextForNoInOperator(context));\n200           }\n201         }\n202         break;\n203 \n204       case Token.ARRAYLIT:\n205         add(\"[\");\n206         addArrayList(first);\n207         add(\"]\");\n208         break;\n209 \n210       case Token.LP:\n211         add(\"(\");\n212         addList(first);\n213         add(\")\");\n214         break;\n215 \n216       case Token.COMMA:\n217         Preconditions.checkState(childCount == 2);\n218         addList(first, false, context);\n219         break;\n220 \n221       case Token.NUMBER:\n222         Preconditions.checkState(\n223             childCount ==\n224             ((n.getParent() != null &&\n225               n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0));\n226         cc.addNumber(n.getDouble());\n227         break;\n228 \n229       case Token.TYPEOF:\n230       case Token.VOID:\n231       case Token.NOT:\n232       case Token.BITNOT:\n233       case Token.POS: {\n234         // All of these unary operators are right-associative\n235         Preconditions.checkState(childCount == 1);\n236         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n237         addExpr(first, NodeUtil.precedence(type));\n238         break;\n239       }\n240 \n241       case Token.NEG: {\n242         Preconditions.checkState(childCount == 1);\n243 \n244         // It's important to our sanity checker that the code\n245         // we print produces the same AST as the code we parse back.\n246         // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n247         if (n.getFirstChild().getType() == Token.NUMBER) {\n248           cc.addNumber(-n.getFirstChild().getDouble());\n249         } else {\n250           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n251           addExpr(first, NodeUtil.precedence(type));\n252         }\n253 \n254         break;\n255       }\n256 \n257       case Token.HOOK: {\n258         Preconditions.checkState(childCount == 3);\n259         int p = NodeUtil.precedence(type);\n260         addLeftExpr(first, p + 1, context);\n261         cc.addOp(\"?\", true);\n262         addExpr(first.getNext(), 1);\n263         cc.addOp(\":\", true);\n264         addExpr(last, 1);\n265         break;\n266       }\n267 \n268       case Token.REGEXP:\n269         if (first.getType() != Token.STRING ||\n270             last.getType() != Token.STRING) {\n271           throw new Error(\"Expected children to be strings\");\n272         }\n273 \n274         String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n275 \n276         // I only use one .add because whitespace matters\n277         if (childCount == 2) {\n278           add(regexp + last.getString());\n279         } else {\n280           Preconditions.checkState(childCount == 1);\n281           add(regexp);\n282         }\n283         break;\n284 \n285       case Token.GET_REF:\n286         add(first);\n287         break;\n288 \n289       case Token.REF_SPECIAL:\n290         Preconditions.checkState(childCount == 1);\n291         add(first);\n292         add(\".\");\n293         add((String) n.getProp(Node.NAME_PROP));\n294         break;\n295 \n296       case Token.FUNCTION:\n297         if (n.getClass() != Node.class) {\n298           throw new Error(\"Unexpected Node subclass.\");\n299         }\n300         Preconditions.checkState(childCount == 3);\n301         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n302         if (funcNeedsParens) {\n303           add(\"(\");\n304         }\n305 \n306         add(\"function\");\n307         add(first);\n308 \n309         add(first.getNext());\n310         add(last, Context.PRESERVE_BLOCK);\n311         cc.endFunction(context == Context.STATEMENT);\n312 \n313         if (funcNeedsParens) {\n314           add(\")\");\n315         }\n316         break;\n317 \n318       case Token.GET:\n319       case Token.SET:\n320         Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n321         Preconditions.checkState(childCount == 1);\n322         Preconditions.checkState(first.getType() == Token.FUNCTION);\n323 \n324         // Get methods are unnamed\n325         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n326         if (type == Token.GET) {\n327           // Get methods have no parameters.\n328           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n329           add(\"get \");\n330         } else {\n331           // Set methods have one parameter.\n332           Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n333           add(\"set \");\n334         }\n335 \n336         // The name is on the GET or SET node.\n337         String name = n.getString();\n338         Node fn = first;\n339         Node parameters = fn.getChildAtIndex(1);\n340         Node body = fn.getLastChild();\n341 \n342         // Add the property name.\n343         if (TokenStream.isJSIdentifier(name) &&\n344             // do not encode literally any non-literal characters that were\n345             // unicode escaped.\n346             NodeUtil.isLatin(name)) {\n347           add(name);\n348         } else {\n349           // Determine if the string is a simple number.\n350           add(jsString(n.getString(), outputCharsetEncoder));\n351         }\n352 \n353         add(parameters);\n354         add(body, Context.PRESERVE_BLOCK);\n355         break;\n356 \n357       case Token.SCRIPT:\n358       case Token.BLOCK: {\n359         if (n.getClass() != Node.class) {\n360           throw new Error(\"Unexpected Node subclass.\");\n361         }\n362         boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n363         if (preserveBlock) {\n364           cc.beginBlock();\n365         }\n366 \n367         boolean preferLineBreaks =\n368             type == Token.SCRIPT ||\n369             (type == Token.BLOCK &&\n370                 !preserveBlock &&\n371                 n.getParent() != null &&\n372                 n.getParent().getType() == Token.SCRIPT);\n373         for (Node c = first; c != null; c = c.getNext()) {\n374           add(c, Context.STATEMENT);\n375 \n376           // VAR doesn't include ';' since it gets used in expressions\n377           if (c.getType() == Token.VAR) {\n378             cc.endStatement();\n379           }\n380 \n381           if (c.getType() == Token.FUNCTION) {\n382             cc.maybeLineBreak();\n383           }\n384 \n385           // Prefer to break lines in between top-level statements\n386           // because top level statements are more homogeneous.\n387           if (preferLineBreaks) {\n388             cc.notePreferredLineBreak();\n389           }\n390         }\n391         if (preserveBlock) {\n392           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n393         }\n394         break;\n395       }\n396 \n397       case Token.FOR:\n398         if (childCount == 4) {\n399           add(\"for(\");\n400           if (first.getType() == Token.VAR) {\n401             add(first, Context.IN_FOR_INIT_CLAUSE);\n402           } else {\n403             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n404           }\n405           add(\";\");\n406           add(first.getNext());\n407           add(\";\");\n408           add(first.getNext().getNext());\n409           add(\")\");\n410           addNonEmptyStatement(\n411               last, getContextForNonEmptyExpression(context), false);\n412         } else {\n413           Preconditions.checkState(childCount == 3);\n414           add(\"for(\");\n415           add(first);\n416           add(\"in\");\n417           add(first.getNext());\n418           add(\")\");\n419           addNonEmptyStatement(\n420               last, getContextForNonEmptyExpression(context), false);\n421         }\n422         break;\n423 \n424       case Token.DO:\n425         Preconditions.checkState(childCount == 2);\n426         add(\"do\");\n427         addNonEmptyStatement(first, Context.OTHER, false);\n428         add(\"while(\");\n429         add(last);\n430         add(\")\");\n431         cc.endStatement();\n432         break;\n433 \n434       case Token.WHILE:\n435         Preconditions.checkState(childCount == 2);\n436         add(\"while(\");\n437         add(first);\n438         add(\")\");\n439         addNonEmptyStatement(\n440             last, getContextForNonEmptyExpression(context), false);\n441         break;\n442 \n443       case Token.EMPTY:\n444         Preconditions.checkState(childCount == 0);\n445         break;\n446 \n447       case Token.GETPROP: {\n448         Preconditions.checkState(\n449             childCount == 2,\n450             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n451         Preconditions.checkState(\n452             last.getType() == Token.STRING,\n453             \"Bad GETPROP: RHS should be STRING\");\n454         boolean needsParens = (first.getType() == Token.NUMBER);\n455         if (needsParens) {\n456           add(\"(\");\n457         }\n458         addLeftExpr(first, NodeUtil.precedence(type), context);\n459         if (needsParens) {\n460           add(\")\");\n461         }\n462         add(\".\");\n463         addIdentifier(last.getString());\n464         break;\n465       }\n466 \n467       case Token.GETELEM:\n468         Preconditions.checkState(\n469             childCount == 2,\n470             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n471         addLeftExpr(first, NodeUtil.precedence(type), context);\n472         add(\"[\");\n473         add(first.getNext());\n474         add(\"]\");\n475         break;\n476 \n477       case Token.WITH:\n478         Preconditions.checkState(childCount == 2);\n479         add(\"with(\");\n480         add(first);\n481         add(\")\");\n482         addNonEmptyStatement(\n483             last, getContextForNonEmptyExpression(context), false);\n484         break;\n485 \n486       case Token.INC:\n487       case Token.DEC: {\n488         Preconditions.checkState(childCount == 1);\n489         String o = type == Token.INC ? \"++\" : \"--\";\n490         int postProp = n.getIntProp(Node.INCRDECR_PROP);\n491         // A non-zero post-prop value indicates a post inc/dec, default of zero\n492         // is a pre-inc/dec.\n493         if (postProp != 0) {\n494           addLeftExpr(first, NodeUtil.precedence(type), context);\n495           cc.addOp(o, false);\n496         } else {\n497           cc.addOp(o, false);\n498           add(first);\n499         }\n500         break;\n501       }\n502 \n503       case Token.CALL:\n504         // We have two special cases here:\n505         // 1) If the left hand side of the call is a direct reference to eval,\n506         // then it must have a DIRECT_EVAL annotation. If it does not, then\n507         // that means it was originally an indirect call to eval, and that\n508         // indirectness must be preserved.\n509         // 2) If the left hand side of the call is a property reference,\n510         // then the call must not a FREE_CALL annotation. If it does, then\n511         // that means it was originally an call without an explicit this and\n512         // that must be preserved.\n513         if (isIndirectEval(first)\n514             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n515           add(\"(0,\");\n516           addExpr(first, NodeUtil.precedence(Token.COMMA));\n517           add(\")\");\n518         } else {\n519           addLeftExpr(first, NodeUtil.precedence(type), context);\n520         }\n521         add(\"(\");\n522         addList(first.getNext());\n523         add(\")\");\n524         break;\n525 \n526       case Token.IF:\n527         boolean hasElse = childCount == 3;\n528         boolean ambiguousElseClause =\n529             context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n530         if (ambiguousElseClause) {\n531           cc.beginBlock();\n532         }\n533 \n534         add(\"if(\");\n535         add(first);\n536         add(\")\");\n537 \n538         if (hasElse) {\n539           addNonEmptyStatement(\n540               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n541           add(\"else\");\n542           addNonEmptyStatement(\n543               last, getContextForNonEmptyExpression(context), false);\n544         } else {\n545           addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n546           Preconditions.checkState(childCount == 2);\n547         }\n548 \n549         if (ambiguousElseClause) {\n550           cc.endBlock();\n551         }\n552         break;\n553 \n554       case Token.NULL:\n555       case Token.THIS:\n556       case Token.FALSE:\n557       case Token.TRUE:\n558         Preconditions.checkState(childCount == 0);\n559         add(Node.tokenToName(type));\n560         break;\n561 \n562       case Token.CONTINUE:\n563         Preconditions.checkState(childCount <= 1);\n564         add(\"continue\");\n565         if (childCount == 1) {\n566           if (first.getType() != Token.LABEL_NAME) {\n567             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n568           }\n569           add(\" \");\n570           add(first);\n571         }\n572         cc.endStatement();\n573         break;\n574 \n575       case Token.DEBUGGER:\n576         Preconditions.checkState(childCount == 0);\n577         add(\"debugger\");\n578         cc.endStatement();\n579         break;\n580 \n581       case Token.BREAK:\n582         Preconditions.checkState(childCount <= 1);\n583         add(\"break\");\n584         if (childCount == 1) {\n585           if (first.getType() != Token.LABEL_NAME) {\n586             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n587           }\n588           add(\" \");\n589           add(first);\n590         }\n591         cc.endStatement();\n592         break;\n593 \n594       case Token.EXPR_VOID:\n595         throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n596 \n597       case Token.EXPR_RESULT:\n598         Preconditions.checkState(childCount == 1);\n599         add(first, Context.START_OF_EXPR);\n600         cc.endStatement();\n601         break;\n602 \n603       case Token.NEW:\n604         add(\"new \");\n605         int precedence = NodeUtil.precedence(type);\n606 \n607         // If the first child contains a CALL, then claim higher precedence\n608         // to force parentheses. Otherwise, when parsed, NEW will bind to the\n609         // first viable parentheses (don't traverse into functions).\n610         if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n611           precedence = NodeUtil.precedence(first.getType()) + 1;\n612         }\n613         addExpr(first, precedence);\n614 \n615         // '()' is optional when no arguments are present\n616         Node next = first.getNext();\n617         if (next != null) {\n618           add(\"(\");\n619           addList(next);\n620           add(\")\");\n621         }\n622         break;\n623 \n624       case Token.STRING:\n625         if (childCount !=\n626             ((n.getParent() != null &&\n627               n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n628           throw new IllegalStateException(\n629               \"Unexpected String children: \" + n.getParent().toStringTree());\n630         }\n631         add(jsString(n.getString(), outputCharsetEncoder));\n632         break;\n633 \n634       case Token.DELPROP:\n635         Preconditions.checkState(childCount == 1);\n636         add(\"delete \");\n637         add(first);\n638         break;\n639 \n640       case Token.OBJECTLIT: {\n641         boolean needsParens = (context == Context.START_OF_EXPR);\n642         if (needsParens) {\n643           add(\"(\");\n644         }\n645         add(\"{\");\n646         for (Node c = first; c != null; c = c.getNext()) {\n647           if (c != first) {\n648             cc.listSeparator();\n649           }\n650 \n651           if (c.getType() == Token.GET || c.getType() == Token.SET) {\n652             add(c);\n653           } else {\n654             // Object literal property names don't have to be quoted if they\n655             // are not JavaScript keywords\n656             if (c.getType() == Token.STRING &&\n657                 !c.isQuotedString() &&\n658                 !TokenStream.isKeyword(c.getString()) &&\n659                 TokenStream.isJSIdentifier(c.getString()) &&\n660                 // do not encode literally any non-literal characters that\n661                 // were unicode escaped.\n662                 NodeUtil.isLatin(c.getString())) {\n663               add(c.getString());\n664             } else {\n665               // Determine if the string is a simple number.\n666               addExpr(c, 1);\n667             }\n668             add(\":\");\n669             addExpr(c.getFirstChild(), 1);\n670           }\n671         }\n672         add(\"}\");\n673         if (needsParens) {\n674           add(\")\");\n675         }\n676         break;\n677       }\n678 \n679       case Token.SWITCH:\n680         add(\"switch(\");\n681         add(first);\n682         add(\")\");\n683         cc.beginBlock();\n684         addAllSiblings(first.getNext());\n685         cc.endBlock(context == Context.STATEMENT);\n686         break;\n687 \n688       case Token.CASE:\n689         Preconditions.checkState(childCount == 2);\n690         add(\"case \");\n691         add(first);\n692         addCaseBody(last);\n693         break;\n694 \n695       case Token.DEFAULT:\n696         Preconditions.checkState(childCount == 1);\n697         add(\"default\");\n698         addCaseBody(first);\n699         break;\n700 \n701       case Token.LABEL:\n702         Preconditions.checkState(childCount == 2);\n703         if (first.getType() != Token.LABEL_NAME) {\n704           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n705         }\n706         add(first);\n707         add(\":\");\n708         addNonEmptyStatement(\n709             last, getContextForNonEmptyExpression(context), true);\n710         break;\n711 \n712       // This node is auto generated in anonymous functions and should just get\n713       // ignored for our purposes.\n714       case Token.SETNAME:\n715         break;\n716 \n717       default:\n718         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n719     }\n720 \n721     cc.endSourceMapping(n);\n722   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_158", "report_text": "> Order of jscomp_error, jscomp_warning, jscomp_off flags are not preserved\n> \n> \"off\" always takes precedence over \"warning\", and \"warning\" always takes precedence over \"error\"\r\n> \r\n> This should be changed so that the last arguments always has highest precedence.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testWarningGuardOrdering2", "test_method": "  public void testWarningGuardOrdering2() {\n    args.add(\"--jscomp_off=globalThis\");\n    args.add(\"--jscomp_error=globalThis\");\n    test(\"function f() { this.a = 3; }\", CheckGlobalThis.GLOBAL_THIS); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exactly one warning or error Errors:\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:806)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:798)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testWarningGuardOrdering2(CommandLineRunnerTest.java:126)", "buggy_method": "193 final protected void setRunOptions(CompilerOptions options)\n194       throws FlagUsageException, IOException {\n195     DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n196 \n197     diagnosticGroups.setWarningLevels(\n198         options, config.jscompError, CheckLevel.ERROR);\n199     diagnosticGroups.setWarningLevels(\n200         options, config.jscompWarning, CheckLevel.WARNING);\n201     diagnosticGroups.setWarningLevels(\n202         options, config.jscompOff, CheckLevel.OFF);\n203 \n204     createDefineOrTweakReplacements(config.define, options, false);\n205 \n206     options.setTweakProcessing(config.tweakProcessing);\n207     createDefineOrTweakReplacements(config.tweak, options, true);\n208 \n209     options.manageClosureDependencies = config.manageClosureDependencies;\n210     if (config.closureEntryPoints.size() > 0) {\n211       options.setManageClosureDependencies(config.closureEntryPoints);\n212     }\n213     options.devMode = config.jscompDevMode;\n214     options.setCodingConvention(config.codingConvention);\n215     options.setSummaryDetailLevel(config.summaryDetailLevel);\n216 \n217     outputCharset = options.outputCharset = getOutputCharset();\n218     inputCharset = getInputCharset();\n219 \n220     if (config.jsOutputFile.length() > 0) {\n221       options.jsOutputFile = config.jsOutputFile;\n222     }\n223 \n224     if (config.createSourceMap.length() > 0) {\n225       options.sourceMapOutputPath = config.createSourceMap;\n226     }\n227     options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n228     options.sourceMapFormat = config.sourceMapFormat;\n229 \n230     if (!config.variableMapInputFile.equals(\"\")) {\n231       options.inputVariableMapSerialized =\n232           VariableMap.load(config.variableMapInputFile).toBytes();\n233     }\n234 \n235     if (!config.propertyMapInputFile.equals(\"\")) {\n236       options.inputPropertyMapSerialized =\n237           VariableMap.load(config.propertyMapInputFile).toBytes();\n238     }\n239 \n240     if (config.languageIn.length() > 0) {\n241       if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") ||\n242           config.languageIn.equals(\"ES5_STRICT\")) {\n243         options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n244       } else if (config.languageIn.equals(\"ECMASCRIPT5\") ||\n245           config.languageIn.equals(\"ES5\")) {\n246         options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n247       } else if (config.languageIn.equals(\"ECMASCRIPT3\") ||\n248                  config.languageIn.equals(\"ES3\")) {\n249         options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n250       } else {\n251         throw new FlagUsageException(\"Unknown language `\" + config.languageIn +\n252                                      \"' specified.\");\n253       }\n254     }\n255 \n256     options.acceptConstKeyword = config.acceptConstKeyword;\n257   }", "bm_classpath": "com.google.javascript.jscomp.AbstractCommandLineRunner"}, {"bug_name": "Closure_159", "report_text": "> Closure Compiler failed to translate all instances of a function name\n> \n> **What steps will reproduce the problem?**\n> 1. Compile the attached jQuery Multicheck plugin using SIMPLE optimization.\r\n> \r\n> **What is the expected output? What do you see instead?**\n> You expect that the function preload\\_check\\_all() gets its name translated appropriately. In fact, the Closure Compiler breaks the code by changing the function declaration but NOT changing the call to the function on line 76.", "test_name": "com.google.javascript.jscomp.InlineFunctionsTest::testIssue423", "test_method": "  public void testIssue423() {\n    test(\n        \"(function($) {\\n\" +\n        \"  $.fn.multicheck = function(options) {\\n\" +\n        \"    initialize.call(this, options);\\n\" +\n        \"  };\\n\" +\n        \"\\n\" +\n        \"  function initialize(options) {\\n\" +\n        \"    options.checkboxes = $(this).siblings(':checkbox');\\n\" +\n        \"    preload_check_all.call(this);\\n\" +\n        \"  }\\n\" +\n        \"\\n\" +\n        \"  function preload_check_all() {\\n\" +\n        \"    $(this).data('checkboxes');\\n\" +\n        \"  }\\n\" +\n        \"})(jQuery)\",\n        \"(function($){\" +\n        \"  $.fn.multicheck=function(options$$1){\" +\n        \"    {\" +\n        \"     options$$1.checkboxes=$(this).siblings(\\\":checkbox\\\");\" +\n        \"     {\" +\n        \"       $(this).data(\\\"checkboxes\\\")\" +\n        \"     }\" +\n        \"    }\" +\n        \"  }\" +\n        \"})(jQuery)\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:862)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.InlineFunctionsTest.testIssue423(InlineFunctionsTest.java:1668)", "buggy_method": "773 private void findCalledFunctions(\n774       Node node, Set<String> changed) {\n775     Preconditions.checkArgument(changed != null);\n776     // For each referenced function, add a new reference\n777     if (node.getType() == Token.CALL) {\n778       Node child = node.getFirstChild();\n779       if (child.getType() == Token.NAME) {\n780         changed.add(child.getString());\n781       }\n782     }\n783 \n784     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n785       findCalledFunctions(c, changed);\n786     }\n787   }", "bm_classpath": "com.google.javascript.jscomp.InlineFunctions"}, {"bug_name": "Closure_160", "report_text": "> checkVars / undefinedVars diagnostics not working from command line\n> \n> It seems that setting neither checkVars nor undefinedVars via the jscomp\\_warning command line argument does anything. The check(s) do work when \"warning\\_level VERBOSE\" is set though. Other diagnostic groups, such as globalThis, do work however.\r\n> \r\n> Here's what I'm seeing on the console:\r\n> \r\n> ---------------------\r\n> \r\n> >java -jar compiler.jar --js test.js\r\n> foo={bar:function(){alert(this.baz)}};\r\n> \r\n> >java -jar compiler.jar --js test.js --warning\\_level VERBOSE\r\n> test.js:2: WARNING - dangerous use of the global this object\r\n> \r\n> test.js:1: ERROR - variable foo is undefined\r\n> foo = {};\r\n> ^\r\n> \r\n> 1 error(s), 1 warning(s)\r\n> \r\n> >java -jar compiler.jar --js test.js --jscomp\\_warning globalThis\r\n> test.js:2: WARNING - dangerous use of the global this object\r\n> \r\n> 0 error(s), 1 warning(s)\r\n> foo={bar:function(){alert(this.baz)}};\r\n> \r\n> >java -jar compiler.jar --js test.js --jscomp\\_warning checkVars\r\n> foo={bar:function(){alert(this.baz)}};\r\n> \r\n> >java -jar compiler.jar --js test.js --jscomp\\_warning undefinedVars\r\n> foo={bar:function(){alert(this.baz)}};\r\n> \r\n> ---------------------\r\n> \r\n> My test.js file looks like this:\r\n> \r\n> ---------------------\r\n> \r\n> foo = {};\r\n> foo.bar = function() { alert(this.baz); };\r\n> \r\n> ---------------------\r\n> \r\n> Tested against r1123 which was committed 5/20/11.", "test_name": "com.google.javascript.jscomp.CommandLineRunnerTest::testCheckSymbolsOverrideForQuiet", "test_method": "  public void testCheckSymbolsOverrideForQuiet() {\n    args.add(\"--warning_level=QUIET\");\n    args.add(\"--jscomp_error=undefinedVars\");\n    test(\"x = 3;\", VarCheck.UNDEFINED_VAR_ERROR); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exactly one warning or error Errors:\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:856)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.test(CommandLineRunnerTest.java:848)\n\tcom.google.javascript.jscomp.CommandLineRunnerTest.testCheckSymbolsOverrideForQuiet(CommandLineRunnerTest.java:230)", "buggy_method": "226 public void initOptions(CompilerOptions options) {\n227     this.options = options;\n228     if (errorManager == null) {\n229       if (outStream == null) {\n230         setErrorManager(\n231             new LoggerErrorManager(createMessageFormatter(), logger));\n232       } else {\n233         PrintStreamErrorManager printer =\n234             new PrintStreamErrorManager(createMessageFormatter(), outStream);\n235         printer.setSummaryDetailLevel(options.summaryDetailLevel);\n236         setErrorManager(printer);\n237       }\n238     }\n239 \n240     // DiagnosticGroups override the plain checkTypes option.\n241     if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n242       options.checkTypes = true;\n243     } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n244       options.checkTypes = false;\n245     } else if (!options.checkTypes) {\n246       // If DiagnosticGroups did not override the plain checkTypes\n247       // option, and checkTypes is enabled, then turn off the\n248       // parser type warnings.\n249       options.setWarningLevel(\n250           DiagnosticGroup.forType(\n251               RhinoErrorReporter.TYPE_PARSE_ERROR),\n252           CheckLevel.OFF);\n253     }\n254 \n255     if (options.checkGlobalThisLevel.isOn()) {\n256       options.setWarningLevel(\n257           DiagnosticGroups.GLOBAL_THIS,\n258           options.checkGlobalThisLevel);\n259     }\n260 \n261     // Initialize the warnings guard.\n262     List<WarningsGuard> guards = Lists.newArrayList();\n263     guards.add(\n264         new SuppressDocWarningsGuard(\n265             getDiagnosticGroups().getRegisteredGroups()));\n266     guards.add(options.getWarningsGuard());\n267 \n268 \n269     // All passes must run the variable check. This synthesizes\n270     // variables later so that the compiler doesn't crash. It also\n271     // checks the externs file for validity. If you don't want to warn\n272     // about missing variable declarations, we shut that specific\n273     // error off.\n274     if (!options.checkSymbols &&\n275         (warningsGuard == null || !warningsGuard.disables(\n276             DiagnosticGroups.CHECK_VARIABLES))) {\n277       guards.add(new DiagnosticGroupWarningsGuard(\n278           DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n279     }\n280 \n281     this.warningsGuard = new ComposeWarningsGuard(guards);\n282   }", "bm_classpath": "com.google.javascript.jscomp.Compiler"}, {"bug_name": "Closure_161", "report_text": "> peephole constants folding pass is trying to fold [][11] as if it were a property lookup instead of a property assignment\n> \n> **What steps will reproduce the problem?**\n> 1.Try on line CC with Advance\r\n> 2.On the following 2-line code\r\n> **3.**\n> **What is the expected output? What do you see instead?**\n> // ==ClosureCompiler==\r\n> // @output\\_file\\_name default.js\r\n> // @compilation\\_level ADVANCED\\_OPTIMIZATIONS\r\n> // ==/ClosureCompiler==\r\n> \r\n> \r\n> var Mdt=[];\r\n> Mdt[11] = ['22','19','19','16','21','18','16','20','17','17','21','17'];\r\n> \r\n> The error:\r\n> JSC\\_INDEX\\_OUT\\_OF\\_BOUNDS\\_ERROR: Array index out of bounds: NUMBER 11.0\r\n> 2 [sourcename: Input\\_0] : number at line 2 character 4\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> The online version on 201.07.27", "test_name": "com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIssue522", "test_method": "  public void testIssue522() {\n    testSame(\"[][1] = 1;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR. Array index out of bounds: NUMBER 1.0 1 [source_file: testcode] at testcode line 1 : 3 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:786)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:348)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:317)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:305)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:537)\n\tcom.google.javascript.jscomp.PeepholeFoldConstantsTest.testIssue522(PeepholeFoldConstantsTest.java:927)", "buggy_method": "1278 private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n1279     Node parent = n.getParent();\n1280     // If GETPROP/GETELEM is used as assignment target the array literal is\n1281     // acting as a temporary we can't fold it here:\n1282     //    \"[][0] += 1\"\n1283 \n1284     if (right.getType() != Token.NUMBER) {\n1285       // Sometimes people like to use complex expressions to index into\n1286       // arrays, or strings to index into array methods.\n1287       return n;\n1288     }\n1289 \n1290     double index = right.getDouble();\n1291     int intIndex = (int) index;\n1292     if (intIndex != index) {\n1293       error(INVALID_GETELEM_INDEX_ERROR, right);\n1294       return n;\n1295     }\n1296 \n1297     if (intIndex < 0) {\n1298       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n1299       return n;\n1300     }\n1301 \n1302     Node elem = left.getFirstChild();\n1303     for (int i = 0; elem != null && i < intIndex; i++) {\n1304       elem = elem.getNext();\n1305     }\n1306 \n1307     if (elem == null) {\n1308       error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n1309       return n;\n1310     }\n1311 \n1312     if (elem.getType() == Token.EMPTY) {\n1313       elem = NodeUtil.newUndefinedNode(elem);\n1314     } else {\n1315       left.removeChild(elem);\n1316     }\n1317 \n1318     // Replace the entire GETELEM with the value\n1319     n.getParent().replaceChild(n, elem);\n1320     reportCodeChange();\n1321     return elem;\n1322   }", "bm_classpath": "com.google.javascript.jscomp.PeepholeFoldConstants"}, {"bug_name": "Closure_163", "report_text": "> VarCheck Crash When Using Modules\n> \n> java -jar \\users\\chad\\workspace\\closure-compiler\\build\\compiler.jar --compilation\\_level ADVANCED\\_OPTIMIZATIONS --formatting PRETTY\\_PRINT --debug --module jquery:1 --module core:1:jquery --module\\_output\\_path\\_prefix mod\\_ --js ..\\..\\dist\\jquery.js --js core.js --externs ..\\qunit\\_externs.js\r\n> \r\n> java.lang.RuntimeException: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected variable jQuery$$2\r\n>  Node(NAME jQuery$$2): core.js:100:12\r\n>  equal( jQuery(\" <div/> \").length, 1, \"Make sure whitespace is trimmed.\" );\r\n>  Parent(GETPROP): core.js:100:12\r\n>  equal( jQuery(\" <div/> \").length, 1, \"Make sure whitespace is trimmed.\" );\r\n> \r\n>  at com.google.javascript.jscomp.Compiler.runCallable(Compiler.java:628)\r\n>  at com.google.javascript.jscomp.Compiler.runInCompilerThread(Compiler.java:573)\r\n>  at com.google.javascript.jscomp.Compiler.compile(Compiler.java:555)\r\n>  at com.google.javascript.jscomp.Compiler.compileModules(Compiler.java:546)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.doRun(AbstractCommandLineRunner.java:709)\r\n>  at com.google.javascript.jscomp.AbstractCommandLineRunner.run(AbstractCommandLineRunner.java:329)\r\n>  at com.google.javascript.jscomp.CommandLineRunner.main(CommandLineRunner.java:825)\r\n> Caused by: java.lang.RuntimeException: INTERNAL COMPILER ERROR.\r\n> Please report this problem.\r\n> Unexpected variable jQuery$$2\r\n>  Node(NAME jQuery$$2): core.js:100:12\r\n>  equal( jQuery(\" <div/> \").length, 1, \"Make sure whitespace is trimmed.\" );\r\n>  Parent(GETPROP): core.js:100:12\r\n>  equal( jQuery(\" <div/> \").length, 1, \"Make sure whitespace is trimmed.\" );\r\n> \r\n>  at com.google.javascript.jscomp.VarCheck.visit(VarCheck.java:170)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:498)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:491)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:304)\r\n>  at com.google.javascript.jscomp.NodeTraversal.traverseRoots(NodeTraversal.java:464)\r\n>  at com.google.javascript.jscomp.VarCheck.process(VarCheck.java:108)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(PhaseOptimizer.java:273)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(PhaseOptimizer.java:250)\r\n>  at com.google.javascript.jscomp.PhaseOptimizer.process(PhaseOptimizer.java:168)\r\n>  at com.google.javascript.jscomp.Compiler.optimize(Compiler.java:1636)\r\n>  at com.google.javascript.jscomp.Compiler.compileInternal(Compiler.java:663)\r\n>  at com.google.javascript.jscomp.Compiler.access$1(Compiler.java:634)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:558)\r\n>  at com.google.javascript.jscomp.Compiler$2.call(Compiler.java:1)\r\n>  at com.google.javascript.jscomp.Compiler$3.run(Compiler.java:600)\r\n>  at java.lang.Thread.run(Unknown Source)\r\n> Caused by: java.lang.IllegalStateException: Unexpected variable jQuery$$2\r\n>  ... 21 more", "test_name": "com.google.javascript.jscomp.CrossModuleMethodMotionTest::testIssue600b", "test_method": "  public void testIssue600b() {\n    testSame(\n        createModuleChain(\n            \"var jQuery1 = (function() {\\n\" +\n            \"  var jQuery2 = function() {};\\n\" +\n            \"  jQuery2.prototype = {\\n\" +\n            \"    size: function() {\\n\" +\n            \"      return 1;\\n\" +\n            \"    }\\n\" +\n            \"  };\\n\" +\n            \"  return jQuery2;\\n\" +\n            \"})();\\n\",\n\n            \"(function() {\" +\n            \"  var div = jQuery1('div');\" +\n            \"  div.size();\" +\n            \"})();\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:866)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:696)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:532)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:677)\n\tcom.google.javascript.jscomp.CompilerTestCase.testSame(CompilerTestCase.java:659)\n\tcom.google.javascript.jscomp.CrossModuleMethodMotionTest.testIssue600b(CrossModuleMethodMotionTest.java:458)", "buggy_method": "201 private ProcessProperties() {\n202       symbolStack.push(new NameContext(globalNode));\n203     }", "bm_classpath": "com.google.javascript.jscomp.AnalyzePrototypeProperties$ProcessProperties"}, {"bug_name": "Closure_164", "report_text": "> {function(number, string)} should not be assignable to {function(number)}\n> \n> Consider the following snippet. I don't think the \"second call\" should compile. As a side note: it would be great if none of the compiled in some pseudo-strict compile mode.\r\n> \r\n> /\\*\\* @param {function(string,number):boolean} param \\*/\r\n> function func(param) {}\r\n> \r\n> /\\*\\* @type {function(string,number,boolean):boolean} \\*/\r\n> function paramFunc1() {}\r\n> \r\n> /\\*\\* @type {function(string):boolean} \\*/\r\n> function paramFunc2() {}\r\n> \r\n> // first call\r\n> func(paramFunc1);\r\n> \r\n> // second call\r\n> func(paramFunc2);", "test_name": "com.google.javascript.jscomp.LooseTypeCheckTest::testMethodInference7", "test_method": "  public void testMethodInference7() throws Exception {\n    testTypes(\n        \"/** @constructor */ function F() {}\" +\n        \"F.prototype.foo = function() { };\" +\n        \"/** @constructor \\n * @extends {F} */ \" +\n        \"function G() {}\" +\n        \"/** @override */ G.prototype.foo = function(x, y) { };\",\n        \"mismatch of the foo property type and the type of the property \" +\n        \"it overrides from superclass F\\n\" +\n        \"original: function (this:F): undefined\\n\" +\n        \"override: function (this:G, ?, ?): undefined\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7027)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:7007)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testTypes(LooseTypeCheckTest.java:6951)\n\tcom.google.javascript.jscomp.LooseTypeCheckTest.testMethodInference7(LooseTypeCheckTest.java:1782)", "buggy_method": "79 @Override\n80   public boolean isSubtype(JSType other) {\n81     if (!(other instanceof ArrowType)) {\n82       return false;\n83     }\n84 \n85     ArrowType that = (ArrowType) other;\n86 \n87     // This is described in Draft 2 of the ES4 spec,\n88     // Section 3.4.7: Subtyping Function Types.\n89 \n90     // this.returnType <: that.returnType (covariant)\n91     if (!this.returnType.isSubtype(that.returnType)) {\n92       return false;\n93     }\n94 \n95     // that.paramType[i] <: this.paramType[i] (contravariant)\n96     //\n97     // If this.paramType[i] is required,\n98     // then that.paramType[i] is required.\n99     //\n100     // In theory, the \"required-ness\" should work in the other direction as\n101     // well. In other words, if we have\n102     //\n103     // function f(number, number) {}\n104     // function g(number) {}\n105     //\n106     // Then f *should* not be a subtype of g, and g *should* not be\n107     // a subtype of f. But in practice, we do not implement it this way.\n108     // We want to support the use case where you can pass g where f is\n109     // expected, and pretend that g ignores the second argument.\n110     // That way, you can have a single \"no-op\" function, and you don't have\n111     // to create a new no-op function for every possible type signature.\n112     //\n113     // So, in this case, g < f, but f !< g\n114     Node thisParam = parameters.getFirstChild();\n115     Node thatParam = that.parameters.getFirstChild();\n116     while (thisParam != null && thatParam != null) {\n117       JSType thisParamType = thisParam.getJSType();\n118       JSType thatParamType = thatParam.getJSType();\n119       if (thisParamType != null) {\n120         if (thatParamType == null ||\n121             !thatParamType.isSubtype(thisParamType)) {\n122           return false;\n123         }\n124       }\n125 \n126       boolean thisIsVarArgs = thisParam.isVarArgs();\n127       boolean thatIsVarArgs = thatParam.isVarArgs();\n128 \n129       // \"that\" can't be a supertype, because it's missing a required argument.\n130         // NOTE(nicksantos): In our type system, we use {function(...?)} and\n131         // {function(...NoType)} to to indicate that arity should not be\n132         // checked. Strictly speaking, this is not a correct formulation,\n133         // because now a sub-function can required arguments that are var_args\n134         // in the super-function. So we special-case this.\n135 \n136       // don't advance if we have variable arguments\n137       if (!thisIsVarArgs) {\n138         thisParam = thisParam.getNext();\n139       }\n140       if (!thatIsVarArgs) {\n141         thatParam = thatParam.getNext();\n142       }\n143 \n144       // both var_args indicates the end\n145       if (thisIsVarArgs && thatIsVarArgs) {\n146         thisParam = null;\n147         thatParam = null;\n148       }\n149     }\n150 \n151     // \"that\" can't be a supertype, because it's missing a required arguement.\n152 \n153     return true;\n154   }", "bm_classpath": "com.google.javascript.rhino.jstype.ArrowType"}, {"bug_name": "Closure_165", "report_text": "> Properties defined on any record type applying to unrelated record types\n> \n> Consider the following code:\r\n> \r\n> /\\*\\* @typedef {{name: string, id: number}} \\*/\r\n> var RecordType1;\r\n> \r\n> /\\*\\*\r\n> \\* @param {RecordType1} rec\r\n> \\*/\r\n> var func = function(rec) {\r\n>  alert(rec.name2);\r\n> };\r\n> func({name: 'jim', id: 0});\r\n> \r\n> Compiled with: \r\n> java -jar build/compiler.jar --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --jscomp\\_error=accessControls --jscomp\\_error=checkTypes --jscomp\\_error=checkVars --js ~/Desktop/test.js\r\n> \r\n> Properly errors:\r\n> /Users/dolapo/Desktop/test.js:9: ERROR - Property name2 never defined on rec\r\n>  alert(rec.name2);\r\n> \r\n> \r\n> However, add another recordtype with name2 defined:\r\n> \r\n> /\\*\\* @typedef {{name: string, id: number}} \\*/\r\n> var RecordType1;\r\n> \r\n> /\\*\\* @typedef {{name2: string}} \\*/\r\n> var RecordType2;\r\n> \r\n> /\\*\\*\r\n> \\* @param {RecordType1} rec\r\n> \\*/\r\n> var func = function(rec) {\r\n>  alert(rec.name2);\r\n> };\r\n> func({name: 'jim', id: 0});\r\n> \r\n> \r\n> \r\n> and this compiles with no errors.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue725", "test_method": "  public void testIssue725() throws Exception {\n    testTypes(\n        \"/** @typedef {{name: string}} */ var RecordType1;\" +\n        \"/** @typedef {{name2: string}} */ var RecordType2;\" +\n        \"/** @param {RecordType1} rec */ function f(rec) {\" +\n        \"  alert(rec.name2);\" +\n        \"}\",\n        \"Property name2 never defined on rec\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10001)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9981)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:9919)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue725(TypeCheckTest.java:5852)", "buggy_method": "690 public boolean canPropertyBeDefined(JSType type, String propertyName) {\n691     if (typesIndexedByProperty.containsKey(propertyName)) {\n692       for (JSType alt :\n693                typesIndexedByProperty.get(propertyName).getAlternates()) {\n694         JSType greatestSubtype = alt.getGreatestSubtype(type);\n695         if (!greatestSubtype.isEmptyType()) {\n696           // We've found a type with this property. Now we just have to make\n697           // sure it's not a type used for internal bookkeeping.\n698 \n699           return true;\n700         }\n701       }\n702     }\n703     return false;\n704   }", "bm_classpath": "com.google.javascript.rhino.jstype.JSTypeRegistry"}, {"bug_name": "Closure_166", "report_text": "> anonymous object type inference inconsistency when used in union\n> \n> Code:\r\n> /\\*\\* @param {{prop: string, prop2: (string|undefined)}} record \\*/\r\n> var func = function(record) {\r\n>  window.console.log(record.prop);\r\n> }\r\n> \r\n> /\\*\\* @param {{prop: string, prop2: (string|undefined)}|string} record \\*/\r\n> var func2 = function(record) {\r\n>  if (typeof record == 'string') {\r\n>  window.console.log(record);\r\n>  } else {\r\n>  window.console.log(record.prop);\r\n>  }\r\n> }\r\n> \r\n> func({prop: 'a'});\r\n> func2({prop: 'a'});\r\n> \r\n> \r\n> \r\n> \r\n> errors with:\r\n> ERROR - actual parameter 1 of func2 does not match formal parameter\r\n> found : {prop: string}\r\n> required: (string|{prop: string, prop2: (string|undefined)})\r\n> func2({prop: 'a'});\r\n> \r\n> \r\n> the type of the record input to func and func2 are identical but the parameters to func2 allow some other type.", "test_name": "com.google.javascript.jscomp.TypeInferenceTest::testRecordInference", "test_method": "  public void testRecordInference() {\n    inFunction(\n        \"/** @param {{a: (boolean|undefined)}|{b: (string|undefined)}} x */\" +\n        \"function f(x) {}\" +\n        \"var out = {};\" +\n        \"f(out);\");\n    assertEquals(\"{a: (boolean|undefined), b: (string|undefined)}\",\n        getType(\"out\").toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{[a: (boolean|undefined), b: (string|undefined)]}> but was:<{[]}>\n\tcom.google.javascript.jscomp.TypeInferenceTest.testRecordInference(TypeInferenceTest.java:1013)", "buggy_method": "555 @Override\n556   public void matchConstraint(JSType constraint) {\n557     // We only want to match constraints on anonymous types.\n558     if (hasReferenceName()) {\n559       return;\n560     }\n561 \n562     // Handle the case where the constraint object is a record type.\n563     //\n564     // param constraint {{prop: (number|undefined)}}\n565     // function f(constraint) {}\n566     // f({});\n567     //\n568     // We want to modify the object literal to match the constraint, by\n569     // taking any each property on the record and trying to match\n570     // properties on this object.\n571     if (constraint.isRecordType()) {\n572       matchRecordTypeConstraint(constraint.toObjectType());\n573     }\n574   }", "bm_classpath": "com.google.javascript.rhino.jstype.PrototypeObjectType"}, {"bug_name": "Closure_167", "report_text": "> invalid property not erroring in for loop in prototype function\n> \n> I think this example can be simplified to use a typedef instead of externs, but using an extern for the repro case.\r\n> \r\n> Compile the attached with:\r\n> java -jar build/compiler.jar --formatting=PRETTY\\_PRINT --jscomp\\_error=checkTypes --jscomp\\_error=externsValidation --compilation\\_level=SIMPLE\\_OPTIMIZATIONS --externs=inloop-externs.js inloop.js (pasted below for completeness)\r\n> \r\n> I would expect an error on the line in the for loop in the doIt function, but this compiles just fine. The commented out line above it properly errors, and if the same code is outside a prototype function, it errors. It does not error within the prototype function.\r\n> \r\n> Thanks\r\n> \r\n> \r\n> /\\*\\*\r\n>  \\* @param {ns.Thing} thing\r\n>  \\* @constructor\r\n>  \\*/\r\n> ns.MyClass = function(thing) {\r\n>  /\\*\\* @type {ns.Thing} \\*/ this.thing\\_ = thing;\r\n> };\r\n> \r\n> ns.MyClass.prototype.doIt = function() {\r\n>  var subthing = this.thing\\_.subthing;\r\n>  // ERRORS:\r\n>  // window.console.log(subthing.noprop);\r\n> \r\n>  // NO ERROR:\r\n>  for (var i = 0; i < subthing.noprop; i++) {\r\n>  window.console.log(i);\r\n>  }\r\n> };\r\n> \r\n> var thing = /\\*\\* @type {ns.Thing} \\*/({subthing: {prop: 3}});\r\n> \r\n> /\\*\r\n>  ERRORS:\r\n>  var subthing = thing.subthing;\r\n>  for (var i = 0; i < subthing.noprop; i++) {\r\n>  window.console.log(i);\r\n>  } \\*/\r\n> \r\n> var c = new ns.MyClass(thing);\r\n> co.doIt();", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue783", "test_method": "  public void testIssue783() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"var Type = function () {\" +\n        \"  /** @type {Type} */\" +\n        \"  this.me_ = this;\" +\n        \"};\" +\n        \"Type.prototype.doIt = function() {\" +\n        \"  var me = this.me_;\" +\n        \"  for (var i = 0; i < me.unknownProp; i++) {}\" +\n        \"};\",\n        \"Property unknownProp never defined on Type\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10246)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10226)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10164)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue783(TypeCheckTest.java:5997)", "buggy_method": "272 private FlowScope caseEquality(Node left, Node right, FlowScope blindScope,\n273       Function<TypePair, TypePair> merging) {\n274     // left type\n275     JSType leftType = getTypeIfRefinable(left, blindScope);\n276     boolean leftIsRefineable;\n277     if (leftType != null) {\n278       leftIsRefineable = true;\n279     } else {\n280       leftIsRefineable = false;\n281       leftType = left.getJSType();\n282     }\n283 \n284     // right type\n285     JSType rightType = getTypeIfRefinable(right, blindScope);\n286     boolean rightIsRefineable;\n287     if (rightType != null) {\n288       rightIsRefineable = true;\n289     } else {\n290       rightIsRefineable = false;\n291       rightType = right.getJSType();\n292     }\n293 \n294     // merged types\n295     TypePair merged = merging.apply(new TypePair(leftType, rightType));\n296 \n297     // creating new scope\n298     if (merged != null) {\n299       return maybeRestrictTwoNames(\n300           blindScope,\n301           left, leftIsRefineable, merged.typeA,\n302           right, rightIsRefineable, merged.typeB);\n303     }\n304     return blindScope;\n305   }", "bm_classpath": "com.google.javascript.jscomp.type.SemanticReverseAbstractInterpreter"}, {"bug_name": "Closure_168", "report_text": "> Wrong argument count error not reported on this aliasing (on function with @this annotation)\n> \n> The following code (attached as test2-1.js) when compiled with:\r\n> java -jar build/compiler.jar --compilation\\_level=ADVANCED\\_OPTIMIZATIONS --jscomp\\_error=accessControls --jscomp\\_error=checkTypes --jscomp\\_error=checkVars --jscomp\\_error=uselessCode --jscomp\\_off=globalThis --js ~/Desktop/test2.js \r\n> \r\n> correctly fails with:\r\n> \r\n> /Users/dolapo/Desktop/test2.js:28: ERROR - Function Person.prototype.getName: called with 1 argument(s). Function requires at least 0 argument(s) and no more than 0 argument(s).\r\n> \r\n> However, if the say function is modified such that this is aliased and the function is called within a setTimeout (test2-2.js), the error is not caught\r\n> \r\n> \r\n> \r\n> \r\n> \r\n> test2-1.js:\r\n> var makeClass = function(protoMethods) {\r\n>  var clazz = function() {\r\n>  this.initialize.apply(this, arguments);\r\n>  }\r\n>  for (var i in protoMethods) {\r\n>  clazz.prototype[i] = protoMethods[i];\r\n>  }\r\n> \r\n>  return clazz;\r\n> }\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> var Person = function(name){};\r\n> Person = makeClass(/\\*\\* @lends Person.prototype \\*/ {\r\n>  /\\*\\* @this {Person} \\*/\r\n>  initialize: function(name) {\r\n>  this.name = name;\r\n>  },\r\n> \r\n>  /\\*\\* @this {Person} \\*/\r\n>  getName: function() { return this.name; },\r\n> \r\n>  /\\*\\*\r\n>  \\* @param {string} message\r\n>  \\* @this {Person}\r\n>  \\*/\r\n>  say: function(message) {\r\n>  window.console.log(this.getName(1) + ' says: ' + message);\r\n>  }\r\n> });\r\n> \r\n> \r\n> var joe = new Person('joe');\r\n> joe.say('hi');\r\n> var jane = new Person('jane');\r\n> jane.say('hello');\r\n> \r\n> \r\n> \r\n> test2-2.js:\r\n> \r\n> var makeClass = function(protoMethods) {\r\n>  var clazz = function() {\r\n>  this.initialize.apply(this, arguments);\r\n>  }\r\n>  for (var i in protoMethods) {\r\n>  clazz.prototype[i] = protoMethods[i];\r\n>  }\r\n> \r\n>  return clazz;\r\n> }\r\n> \r\n> /\\*\\* @constructor \\*/\r\n> var Person = function(name){};\r\n> Person = makeClass(/\\*\\* @lends Person.prototype \\*/ {\r\n>  /\\*\\* @this {Person} \\*/\r\n>  initialize: function(name) {\r\n>  this.name = name;\r\n>  },\r\n> \r\n>  /\\*\\* @this {Person} \\*/\r\n>  getName: function() { return this.name; },\r\n> \r\n>  /\\*\\*\r\n>  \\* @param {string} message\r\n>  \\* @this {Person}\r\n>  \\*/\r\n>  say: function(message) {\r\n>  // window.console.log(this.getName(1) + ' says: ' + message);\r\n>  var self = this;\r\n>  setTimeout(function() {\r\n>  window.console.log(self.getName(1) + ' says: ' + message);\r\n>  }, 500); \r\n>  }\r\n> });\r\n> \r\n> \r\n> var joe = new Person('joe');\r\n> joe.say('hi');\r\n> var jane = new Person('jane');\r\n> jane.say('hello');", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue726", "test_method": "  public void testIssue726() throws Exception {\n    testTypes(\n        \"/** @constructor */ function Foo() {}\" +\n        \"/** @param {number} x */ Foo.prototype.bar = function(x) {};\" +\n        \"/** @return {!Function} */ \" +\n        \"Foo.prototype.getDeferredBar = function() { \" +\n        \"  var self = this;\" +\n        \"  return function() {\" +\n        \"    self.bar(true);\" +\n        \"  };\" +\n        \"};\",\n        \"actual parameter 1 of Foo.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: number\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10290)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10270)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10208)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue726(TypeCheckTest.java:5977)", "buggy_method": "1987 @Override public void visit(NodeTraversal t, Node n, Node parent) {\n1988       if (t.inGlobalScope()) {\n1989         return;\n1990       }\n1991 \n1992       if (n.isReturn() && n.getFirstChild() != null) {\n1993         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n1994       }\n1995 \n1996       if (t.getScopeDepth() <= 2) {\n1997         // The first-order function analyzer looks at two types of variables:\n1998         //\n1999         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n2000         //\n2001         // 2) Local variables that are assigned more than once.\n2002         //\n2003         // We treat all global variables as escaped by default, so there's\n2004         // no reason to do this extra computation for them.\n2005         return;\n2006       }\n2007 \n2008       if (n.isName() && NodeUtil.isLValue(n) &&\n2009           // Be careful of bleeding functions, which create variables\n2010           // in the inner scope, not the scope where the name appears.\n2011           !NodeUtil.isBleedingFunctionName(n)) {\n2012         String name = n.getString();\n2013         Scope scope = t.getScope();\n2014         Var var = scope.getVar(name);\n2015         if (var != null) {\n2016           Scope ownerScope = var.getScope();\n2017           if (ownerScope.isLocal()) {\n2018             data.get(ownerScope.getRootNode()).recordAssignedName(name);\n2019           }\n2020 \n2021           if (scope != ownerScope && ownerScope.isLocal()) {\n2022             data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n2023           }\n2024         }\n2025       } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n2026           NodeUtil.isLValue(n)) {\n2027         String name = NodeUtil.getRootOfQualifiedName(n).getString();\n2028         Scope scope = t.getScope();\n2029         Var var = scope.getVar(name);\n2030         if (var != null) {\n2031           Scope ownerScope = var.getScope();\n2032           if (scope != ownerScope && ownerScope.isLocal()) {\n2033             data.get(ownerScope.getRootNode())\n2034                 .recordEscapedQualifiedName(n.getQualifiedName());\n2035           }\n2036         }\n2037       }\n2038     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$FirstOrderFunctionAnalyzer"}, {"bug_name": "Closure_169", "report_text": "> Strange \"wrong parameter\" warning for callback function\n> \n> **What steps will reproduce the problem?**\n> Compile the followed code:\r\n>  /\\*\\* @param {{func: function()}} obj \\*/\r\n>  function test1(obj) {};\r\n>  var fnStruc1 = {};\r\n>  fnStruc1.func = function() {};\r\n>  test1(fnStruc1); \r\n> \r\n> **What is the expected output? What do you see instead?**\n> Expected: compiled OK\r\n> I see:\r\n> WARNING - actual parameter 1 of func does not match formal parameter\r\n> found : {func: function (): undefined}\r\n> required: {func: function (): ?}\r\n> func(fnStruc);\r\n>  ^\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> r2102, Win7 x64\r\n> \r\n> **Please provide any additional information below.**\n> The followed code compiles OK:\r\n>  /\\*\\* @param {{func: function()}} obj \\*/\r\n>  function test2(obj) {};\r\n>  var fnStruc2 = { func: function() {} };\r\n>  test2(fnStruc2);\r\n> \r\n> Discussion: https://groups.google.com/d/topic/closure-compiler-discuss/JuzERhGo48I/discussion", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue791", "test_method": "  public void testIssue791() throws Exception {\n    testTypes(\n        \"/** @param {{func: function()}} obj */\" +\n        \"function test1(obj) {}\" +\n        \"var fnStruc1 = {};\" +\n        \"fnStruc1.func = function() {};\" +\n        \"test1(fnStruc1);\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10782)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10756)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10694)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:10690)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue791(TypeCheckTest.java:6423)", "buggy_method": "177 boolean hasEqualParameters(ArrowType that, boolean tolerateUnknowns) {\n178     Node thisParam = parameters.getFirstChild();\n179     Node otherParam = that.parameters.getFirstChild();\n180     while (thisParam != null && otherParam != null) {\n181       JSType thisParamType = thisParam.getJSType();\n182       JSType otherParamType = otherParam.getJSType();\n183       if (thisParamType != null) {\n184         // Both parameter lists give a type for this param, it should be equal\n185         if (otherParamType != null &&\n186             !thisParamType.checkEquivalenceHelper(\n187                 otherParamType, tolerateUnknowns)) {\n188           return false;\n189         }\n190       } else {\n191         if (otherParamType != null) {\n192           return false;\n193         }\n194       }\n195       thisParam = thisParam.getNext();\n196       otherParam = otherParam.getNext();\n197     }\n198     // One of the parameters is null, so the types are only equal if both\n199     // parameter lists are null (they are equal).\n200     return thisParam == otherParam;\n201   }", "bm_classpath": "com.google.javascript.rhino.jstype.ArrowType"}, {"bug_name": "Closure_170", "report_text": "> Overly aggressive comma removal\n> \n> When I compile the following code using simple optimizations, \r\n> function Test(n) {\r\n>  var i = 0;\r\n>  return typeof n !== \"undefined\" ? (i = n.length) : (n = \"foo\"), i\r\n> }\r\n> var dummy = \"6chars\";\r\n> console && console.log( Test(dummy) );\r\n> \r\n> I get this:\r\n> function Test(a) {\r\n>  return 0\r\n> }\r\n> var dummy = \"6chars\";\r\n> console && console.log(Test(dummy));\r\n> \r\n> Which provides a different result than the original code.", "test_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest::testVarAssinInsideHookIssue965", "test_method": "  public void testVarAssinInsideHookIssue965() {\n    noInline(\"var i = 0; return 1 ? (i = 5) : 0, i;\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:927)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:459)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:423)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:401)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.inline(FlowSensitiveInlineVariablesTest.java:589)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.noInline(FlowSensitiveInlineVariablesTest.java:585)\n\tcom.google.javascript.jscomp.FlowSensitiveInlineVariablesTest.testVarAssinInsideHookIssue965(FlowSensitiveInlineVariablesTest.java:578)", "buggy_method": "474 private void getNumUseInUseCfgNode(final Node cfgNode) {\n475 \n476       numUsesWithinCfgNode = 0;\n477       AbstractCfgNodeTraversalCallback gatherCb =\n478           new AbstractCfgNodeTraversalCallback() {\n479 \n480         @Override\n481         public void visit(NodeTraversal t, Node n, Node parent) {\n482           if (n.isName() && n.getString().equals(varName) &&\n483             // We make a special exception when the entire cfgNode is a chain\n484             // of assignments, since in that case the assignment statements\n485             // will happen after the inlining of the right hand side.\n486             // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n487             //   and remove this special case.\n488               !(parent.isAssign() &&\n489                (parent.getFirstChild() == n))) {\n490               // Don't count lhs of top-level assignment chain\n491               numUsesWithinCfgNode++;\n492           }\n493         }\n494 \n495       };\n496 \n497       NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n498     }", "bm_classpath": "com.google.javascript.jscomp.FlowSensitiveInlineVariables$Candidate"}, {"bug_name": "Closure_171", "report_text": "> Assigning object literals to obj.prototype in a immediately executed function not recognized.\n> \n> /\\*\\* @constructor \\*/\r\n> function foo() {}\r\n> (function() {\r\n>  foo.prototype = {\r\n>  alert: function() {\r\n>  alert(\"hello world\");\r\n>  }\r\n>  };\r\n> })()\r\n> window.console.log(foo.prototype.alert); //undefined property warning", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1023", "test_method": "  public void testIssue1023() throws Exception {\n    testTypes(\n        \"/** @constructor */\" +\n        \"function F() {}\" +\n        \"(function () {\" +\n        \"  F.prototype = {\" +\n        \"    /** @param {string} x */\" +\n        \"    bar: function (x) {  }\" +\n        \"  };\" +\n        \"})();\" +\n        \"(new F()).bar(true)\",\n        \"actual parameter 1 of F.prototype.bar does not match formal parameter\\n\" +\n        \"found   : boolean\\n\" +\n        \"required: string\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:11991)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:11971)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:11907)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue1023(TypeCheckTest.java:6756)", "buggy_method": "719 private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n720     JSType type = n.getJSType();\n721     Preconditions.checkNotNull(type);\n722 \n723     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n724       scope = traverse(name.getFirstChild(), scope);\n725     }\n726 \n727     // Object literals can be reflected on other types.\n728     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n729     // Ignore these types of literals.\n730     ObjectType objectType = ObjectType.cast(type);\n731     if (objectType == null) {\n732       return scope;\n733     }\n734     boolean hasLendsName = n.getJSDocInfo() != null &&\n735         n.getJSDocInfo().getLendsName() != null;\n736     if (objectType.hasReferenceName() && !hasLendsName) {\n737       return scope;\n738     }\n739 \n740     String qObjName = NodeUtil.getBestLValueName(\n741         NodeUtil.getBestLValue(n));\n742     for (Node name = n.getFirstChild(); name != null;\n743          name = name.getNext()) {\n744       String memberName = NodeUtil.getObjectLitKeyName(name);\n745       if (memberName != null) {\n746         JSType rawValueType =  name.getFirstChild().getJSType();\n747         JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n748             name, rawValueType);\n749         if (valueType == null) {\n750           valueType = unknownType;\n751         }\n752         objectType.defineInferredProperty(memberName, valueType, name);\n753 \n754         // Do normal flow inference if this is a direct property assignment.\n755         if (qObjName != null && name.isStringKey()) {\n756           String qKeyName = qObjName + \".\" + memberName;\n757           Var var = syntacticScope.getVar(qKeyName);\n758           JSType oldType = var == null ? null : var.getType();\n759           if (var != null && var.isTypeInferred()) {\n760             var.setType(oldType == null ?\n761                 valueType : oldType.getLeastSupertype(oldType));\n762           }\n763 \n764           scope.inferQualifiedSlot(name, qKeyName,\n765               oldType == null ? unknownType : oldType,\n766               valueType);\n767         }\n768       } else {\n769         n.setJSType(unknownType);\n770       }\n771     }\n772     return scope;\n773   }", "bm_classpath": "com.google.javascript.jscomp.TypeInference"}, {"bug_name": "Closure_172", "report_text": "> Type of prototype property incorrectly inferred to string\n> \n> **What steps will reproduce the problem?**\n> 1. Compile the following code:\r\n> \r\n> /\\*\\* @param {Object} a \\*/\r\n> function f(a) {\r\n>  a.prototype = '\\_\\_proto';\r\n> }\r\n> \r\n> /\\*\\* @param {Object} a \\*/\r\n> function g(a) {\r\n>  a.prototype = function(){};\r\n> }\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Should type check. Instead, gives error:\r\n> \r\n> WARNING - assignment to property prototype of Object\r\n> found : function (): undefined\r\n> required: string\r\n>  a.prototype = function(){};\r\n>  ^", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1024", "test_method": "  public void testIssue1024() throws Exception {\n     testTypes(\n        \"/** @param {Object} a */\\n\" +\n        \"function f(a) {\\n\" +\n        \"  a.prototype = '__proto'\\n\" +\n        \"}\\n\" +\n        \"/** @param {Object} b\\n\" +\n        \" *  @return {!Object}\\n\" +\n        \" */\\n\" +\n        \"function g(b) {\\n\" +\n        \"  return b.prototype\\n\" +\n        \"}\\n\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: unexpected warnings(s):\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12119)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12093)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12029)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12025)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue1024(TypeCheckTest.java:11993)", "buggy_method": "1661 private boolean isQualifiedNameInferred(\n1662         String qName, Node n, JSDocInfo info,\n1663         Node rhsValue, JSType valueType) {\n1664       if (valueType == null) {\n1665         return true;\n1666       }\n1667 \n1668       // Prototypes of constructors and interfaces are always declared.\n1669       if (qName != null && qName.endsWith(\".prototype\")) {\n1670           return false;\n1671       }\n1672 \n1673       boolean inferred = true;\n1674       if (info != null) {\n1675         inferred = !(info.hasType()\n1676             || info.hasEnumParameterType()\n1677             || (isConstantSymbol(info, n) && valueType != null\n1678                 && !valueType.isUnknownType())\n1679             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n1680       }\n1681 \n1682       if (inferred && rhsValue != null && rhsValue.isFunction()) {\n1683         if (info != null) {\n1684           return false;\n1685         } else if (!scope.isDeclared(qName, false) &&\n1686             n.isUnscopedQualifiedName()) {\n1687 \n1688           // Check if this is in a conditional block.\n1689           // Functions assigned in conditional blocks are inferred.\n1690           for (Node current = n.getParent();\n1691                !(current.isScript() || current.isFunction());\n1692                current = current.getParent()) {\n1693             if (NodeUtil.isControlStructure(current)) {\n1694               return true;\n1695             }\n1696           }\n1697 \n1698           // Check if this is assigned in an inner scope.\n1699           // Functions assigned in inner scopes are inferred.\n1700           AstFunctionContents contents =\n1701               getFunctionAnalysisResults(scope.getRootNode());\n1702           if (contents == null ||\n1703               !contents.getEscapedQualifiedNames().contains(qName)) {\n1704             return false;\n1705           }\n1706         }\n1707       }\n1708       return inferred;\n1709     }", "bm_classpath": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder"}, {"bug_name": "Closure_173", "report_text": "> Operator precedence breaks with certain combinations of *, / and %.\n> \n> **What steps will reproduce the problem?**\n> 1. Try to compile this: x = a % b / b \\* c \\* 2; using either simple or advanced optimizations\r\n> \r\n> **What is the expected output? What do you see instead?**\n> \r\n> Expected: probably x=a%b/b\\*c\\*2;\r\n> Actual: x=2\\*a%b/b\\*c; (2 is incorrectly bumped to the beginning)\r\n> \r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Happens on latest version and online. By the looks of things the change occurred somewhere between versions 20111003 and 20111114.\r\n> \r\n> \r\n> **Please provide any additional information below.**\n> \r\n> As \\*, / and % all have the same operator precedence they should be left-to-right, but hoisting the 2 to the beginning means it's on the wrong side of the modulus operator.", "test_name": "com.google.javascript.jscomp.CodePrinterTest::testPrint", "test_method": "  public void testPrint() {\n\n    // Safari: needs ';' at the end of a throw statement\n    // Safari 3 needs a \"{\" around a single function\n\n\n\n\n    // Associativity\n    assertPrint(\"var a,b,c; a || (b || c); a * (b * c); a | (b | c)\",\n        \"var a,b,c;a||(b||c);a*(b*c);a|(b|c)\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<var a,b,c;a||[(b||c);a*(b*c);a|(b|c)]> but was:<var a,b,c;a||[b||c;a*b*c;a|b|c]>\n\tcom.google.javascript.jscomp.CodePrinterTest.assertPrint(CodePrinterTest.java:482)\n\tcom.google.javascript.jscomp.CodePrinterTest.testPrint(CodePrinterTest.java:197)", "buggy_method": "107 void add(Node n, Context context) {\n108     if (!cc.continueProcessing()) {\n109       return;\n110     }\n111 \n112     int type = n.getType();\n113     String opstr = NodeUtil.opToStr(type);\n114     int childCount = n.getChildCount();\n115     Node first = n.getFirstChild();\n116     Node last = n.getLastChild();\n117 \n118     // Handle all binary operators\n119     if (opstr != null && first != last) {\n120       Preconditions.checkState(\n121           childCount == 2,\n122           \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n123           opstr, childCount);\n124       int p = NodeUtil.precedence(type);\n125 \n126       // For right-hand-side of operations, only pass context if it's\n127       // the IN_FOR_INIT_CLAUSE one.\n128       Context rhsContext = getContextForNoInOperator(context);\n129 \n130       if (last.getType() == type &&\n131           NodeUtil.isAssociative(type)) {\n132         addExpr(first, p, context);\n133         cc.addOp(opstr, true);\n134         addExpr(last, p, rhsContext);\n135       } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n136         // Assignments are the only right-associative binary operators\n137         addExpr(first, p, context);\n138         cc.addOp(opstr, true);\n139         addExpr(last, p, rhsContext);\n140       } else {\n141         unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n142       }\n143       return;\n144     }\n145 \n146     cc.startSourceMapping(n);\n147 \n148     switch (type) {\n149       case Token.TRY: {\n150         Preconditions.checkState(first.getNext().isBlock() &&\n151                 !first.getNext().hasMoreThanOneChild());\n152         Preconditions.checkState(childCount >= 2 && childCount <= 3);\n153 \n154         add(\"try\");\n155         add(first, Context.PRESERVE_BLOCK);\n156 \n157         // second child contains the catch block, or nothing if there\n158         // isn't a catch block\n159         Node catchblock = first.getNext().getFirstChild();\n160         if (catchblock != null) {\n161           add(catchblock);\n162         }\n163 \n164         if (childCount == 3) {\n165           add(\"finally\");\n166           add(last, Context.PRESERVE_BLOCK);\n167         }\n168         break;\n169       }\n170 \n171       case Token.CATCH:\n172         Preconditions.checkState(childCount == 2);\n173         add(\"catch(\");\n174         add(first);\n175         add(\")\");\n176         add(last, Context.PRESERVE_BLOCK);\n177         break;\n178 \n179       case Token.THROW:\n180         Preconditions.checkState(childCount == 1);\n181         add(\"throw\");\n182         add(first);\n183 \n184         // Must have a ';' after a throw statement, otherwise safari can't\n185         // parse this.\n186         cc.endStatement(true);\n187         break;\n188 \n189       case Token.RETURN:\n190         add(\"return\");\n191         if (childCount == 1) {\n192           add(first);\n193         } else {\n194           Preconditions.checkState(childCount == 0);\n195         }\n196         cc.endStatement();\n197         break;\n198 \n199       case Token.VAR:\n200         if (first != null) {\n201           add(\"var \");\n202           addList(first, false, getContextForNoInOperator(context));\n203         }\n204         break;\n205 \n206       case Token.LABEL_NAME:\n207         Preconditions.checkState(!n.getString().isEmpty());\n208         addIdentifier(n.getString());\n209         break;\n210 \n211       case Token.NAME:\n212         if (first == null || first.isEmpty()) {\n213           addIdentifier(n.getString());\n214         } else {\n215           Preconditions.checkState(childCount == 1);\n216           addIdentifier(n.getString());\n217           cc.addOp(\"=\", true);\n218           if (first.isComma()) {\n219             addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n220           } else {\n221             // Add expression, consider nearby code at lowest level of\n222             // precedence.\n223             addExpr(first, 0, getContextForNoInOperator(context));\n224           }\n225         }\n226         break;\n227 \n228       case Token.ARRAYLIT:\n229         add(\"[\");\n230         addArrayList(first);\n231         add(\"]\");\n232         break;\n233 \n234       case Token.PARAM_LIST:\n235         add(\"(\");\n236         addList(first);\n237         add(\")\");\n238         break;\n239 \n240       case Token.COMMA:\n241         Preconditions.checkState(childCount == 2);\n242         unrollBinaryOperator(n, Token.COMMA, \",\", context,\n243             getContextForNoInOperator(context), 0, 0);\n244         break;\n245 \n246       case Token.NUMBER:\n247         Preconditions.checkState(childCount == 0);\n248         cc.addNumber(n.getDouble());\n249         break;\n250 \n251       case Token.TYPEOF:\n252       case Token.VOID:\n253       case Token.NOT:\n254       case Token.BITNOT:\n255       case Token.POS: {\n256         // All of these unary operators are right-associative\n257         Preconditions.checkState(childCount == 1);\n258         cc.addOp(NodeUtil.opToStrNoFail(type), false);\n259         addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n260         break;\n261       }\n262 \n263       case Token.NEG: {\n264         Preconditions.checkState(childCount == 1);\n265 \n266         // It's important to our sanity checker that the code\n267         // we print produces the same AST as the code we parse back.\n268         // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n269         if (n.getFirstChild().isNumber()) {\n270           cc.addNumber(-n.getFirstChild().getDouble());\n271         } else {\n272           cc.addOp(NodeUtil.opToStrNoFail(type), false);\n273           addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n274         }\n275 \n276         break;\n277       }\n278 \n279       case Token.HOOK: {\n280         Preconditions.checkState(childCount == 3);\n281         int p = NodeUtil.precedence(type);\n282         Context rhsContext = getContextForNoInOperator(context);\n283         addExpr(first, p + 1, context);\n284         cc.addOp(\"?\", true);\n285         addExpr(first.getNext(), 1, rhsContext);\n286         cc.addOp(\":\", true);\n287         addExpr(last, 1, rhsContext);\n288         break;\n289       }\n290 \n291       case Token.REGEXP:\n292         if (!first.isString() ||\n293             !last.isString()) {\n294           throw new Error(\"Expected children to be strings\");\n295         }\n296 \n297         String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n298 \n299         // I only use one .add because whitespace matters\n300         if (childCount == 2) {\n301           add(regexp + last.getString());\n302         } else {\n303           Preconditions.checkState(childCount == 1);\n304           add(regexp);\n305         }\n306         break;\n307 \n308       case Token.FUNCTION:\n309         if (n.getClass() != Node.class) {\n310           throw new Error(\"Unexpected Node subclass.\");\n311         }\n312         Preconditions.checkState(childCount == 3);\n313         boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n314         if (funcNeedsParens) {\n315           add(\"(\");\n316         }\n317 \n318         add(\"function\");\n319         add(first);\n320 \n321         add(first.getNext());\n322         add(last, Context.PRESERVE_BLOCK);\n323         cc.endFunction(context == Context.STATEMENT);\n324 \n325         if (funcNeedsParens) {\n326           add(\")\");\n327         }\n328         break;\n329 \n330       case Token.GETTER_DEF:\n331       case Token.SETTER_DEF:\n332         Preconditions.checkState(n.getParent().isObjectLit());\n333         Preconditions.checkState(childCount == 1);\n334         Preconditions.checkState(first.isFunction());\n335 \n336         // Get methods are unnamed\n337         Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n338         if (type == Token.GETTER_DEF) {\n339           // Get methods have no parameters.\n340           Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n341           add(\"get \");\n342         } else {\n343           // Set methods have one parameter.\n344           Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n345           add(\"set \");\n346         }\n347 \n348         // The name is on the GET or SET node.\n349         String name = n.getString();\n350         Node fn = first;\n351         Node parameters = fn.getChildAtIndex(1);\n352         Node body = fn.getLastChild();\n353 \n354         // Add the property name.\n355         if (!n.isQuotedString() &&\n356             TokenStream.isJSIdentifier(name) &&\n357             // do not encode literally any non-literal characters that were\n358             // Unicode escaped.\n359             NodeUtil.isLatin(name)) {\n360           add(name);\n361         } else {\n362           // Determine if the string is a simple number.\n363           double d = getSimpleNumber(name);\n364           if (!Double.isNaN(d)) {\n365             cc.addNumber(d);\n366           } else {\n367             addJsString(n);\n368           }\n369         }\n370 \n371         add(parameters);\n372         add(body, Context.PRESERVE_BLOCK);\n373         break;\n374 \n375       case Token.SCRIPT:\n376       case Token.BLOCK: {\n377         if (n.getClass() != Node.class) {\n378           throw new Error(\"Unexpected Node subclass.\");\n379         }\n380         boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n381         if (preserveBlock) {\n382           cc.beginBlock();\n383         }\n384 \n385         boolean preferLineBreaks =\n386             type == Token.SCRIPT ||\n387             (type == Token.BLOCK &&\n388                 !preserveBlock &&\n389                 n.getParent() != null &&\n390                 n.getParent().isScript());\n391         for (Node c = first; c != null; c = c.getNext()) {\n392           add(c, Context.STATEMENT);\n393 \n394           // VAR doesn't include ';' since it gets used in expressions\n395           if (c.isVar()) {\n396             cc.endStatement();\n397           }\n398 \n399           if (c.isFunction()) {\n400             cc.maybeLineBreak();\n401           }\n402 \n403           // Prefer to break lines in between top-level statements\n404           // because top-level statements are more homogeneous.\n405           if (preferLineBreaks) {\n406             cc.notePreferredLineBreak();\n407           }\n408         }\n409         if (preserveBlock) {\n410           cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n411         }\n412         break;\n413       }\n414 \n415       case Token.FOR:\n416         if (childCount == 4) {\n417           add(\"for(\");\n418           if (first.isVar()) {\n419             add(first, Context.IN_FOR_INIT_CLAUSE);\n420           } else {\n421             addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n422           }\n423           add(\";\");\n424           add(first.getNext());\n425           add(\";\");\n426           add(first.getNext().getNext());\n427           add(\")\");\n428           addNonEmptyStatement(\n429               last, getContextForNonEmptyExpression(context), false);\n430         } else {\n431           Preconditions.checkState(childCount == 3);\n432           add(\"for(\");\n433           add(first);\n434           add(\"in\");\n435           add(first.getNext());\n436           add(\")\");\n437           addNonEmptyStatement(\n438               last, getContextForNonEmptyExpression(context), false);\n439         }\n440         break;\n441 \n442       case Token.DO:\n443         Preconditions.checkState(childCount == 2);\n444         add(\"do\");\n445         addNonEmptyStatement(first, Context.OTHER, false);\n446         add(\"while(\");\n447         add(last);\n448         add(\")\");\n449         cc.endStatement();\n450         break;\n451 \n452       case Token.WHILE:\n453         Preconditions.checkState(childCount == 2);\n454         add(\"while(\");\n455         add(first);\n456         add(\")\");\n457         addNonEmptyStatement(\n458             last, getContextForNonEmptyExpression(context), false);\n459         break;\n460 \n461       case Token.EMPTY:\n462         Preconditions.checkState(childCount == 0);\n463         break;\n464 \n465       case Token.GETPROP: {\n466         Preconditions.checkState(\n467             childCount == 2,\n468             \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n469         Preconditions.checkState(\n470             last.isString(),\n471             \"Bad GETPROP: RHS should be STRING\");\n472         boolean needsParens = (first.isNumber());\n473         if (needsParens) {\n474           add(\"(\");\n475         }\n476         addExpr(first, NodeUtil.precedence(type), context);\n477         if (needsParens) {\n478           add(\")\");\n479         }\n480         if (this.languageMode == LanguageMode.ECMASCRIPT3\n481             && TokenStream.isKeyword(last.getString())) {\n482           // Check for ECMASCRIPT3 keywords.\n483           add(\"[\");\n484           add(last);\n485           add(\"]\");\n486         } else {\n487           add(\".\");\n488           addIdentifier(last.getString());\n489         }\n490         break;\n491       }\n492 \n493       case Token.GETELEM:\n494         Preconditions.checkState(\n495             childCount == 2,\n496             \"Bad GETELEM: expected 2 children but got %s\", childCount);\n497         addExpr(first, NodeUtil.precedence(type), context);\n498         add(\"[\");\n499         add(first.getNext());\n500         add(\"]\");\n501         break;\n502 \n503       case Token.WITH:\n504         Preconditions.checkState(childCount == 2);\n505         add(\"with(\");\n506         add(first);\n507         add(\")\");\n508         addNonEmptyStatement(\n509             last, getContextForNonEmptyExpression(context), false);\n510         break;\n511 \n512       case Token.INC:\n513       case Token.DEC: {\n514         Preconditions.checkState(childCount == 1);\n515         String o = type == Token.INC ? \"++\" : \"--\";\n516         int postProp = n.getIntProp(Node.INCRDECR_PROP);\n517         // A non-zero post-prop value indicates a post inc/dec, default of zero\n518         // is a pre-inc/dec.\n519         if (postProp != 0) {\n520           addExpr(first, NodeUtil.precedence(type), context);\n521           cc.addOp(o, false);\n522         } else {\n523           cc.addOp(o, false);\n524           add(first);\n525         }\n526         break;\n527       }\n528 \n529       case Token.CALL:\n530         // We have two special cases here:\n531         // 1) If the left hand side of the call is a direct reference to eval,\n532         // then it must have a DIRECT_EVAL annotation. If it does not, then\n533         // that means it was originally an indirect call to eval, and that\n534         // indirectness must be preserved.\n535         // 2) If the left hand side of the call is a property reference,\n536         // then the call must not a FREE_CALL annotation. If it does, then\n537         // that means it was originally an call without an explicit this and\n538         // that must be preserved.\n539         if (isIndirectEval(first)\n540             || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n541           add(\"(0,\");\n542           addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n543           add(\")\");\n544         } else {\n545           addExpr(first, NodeUtil.precedence(type), context);\n546         }\n547         add(\"(\");\n548         addList(first.getNext());\n549         add(\")\");\n550         break;\n551 \n552       case Token.IF:\n553         boolean hasElse = childCount == 3;\n554         boolean ambiguousElseClause =\n555             context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n556         if (ambiguousElseClause) {\n557           cc.beginBlock();\n558         }\n559 \n560         add(\"if(\");\n561         add(first);\n562         add(\")\");\n563 \n564         if (hasElse) {\n565           addNonEmptyStatement(\n566               first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n567           add(\"else\");\n568           addNonEmptyStatement(\n569               last, getContextForNonEmptyExpression(context), false);\n570         } else {\n571           addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n572           Preconditions.checkState(childCount == 2);\n573         }\n574 \n575         if (ambiguousElseClause) {\n576           cc.endBlock();\n577         }\n578         break;\n579 \n580       case Token.NULL:\n581         Preconditions.checkState(childCount == 0);\n582         cc.addConstant(\"null\");\n583         break;\n584 \n585       case Token.THIS:\n586         Preconditions.checkState(childCount == 0);\n587         add(\"this\");\n588         break;\n589 \n590       case Token.FALSE:\n591         Preconditions.checkState(childCount == 0);\n592         cc.addConstant(\"false\");\n593         break;\n594 \n595       case Token.TRUE:\n596         Preconditions.checkState(childCount == 0);\n597         cc.addConstant(\"true\");\n598         break;\n599 \n600       case Token.CONTINUE:\n601         Preconditions.checkState(childCount <= 1);\n602         add(\"continue\");\n603         if (childCount == 1) {\n604           if (!first.isLabelName()) {\n605             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n606           }\n607           add(\" \");\n608           add(first);\n609         }\n610         cc.endStatement();\n611         break;\n612 \n613       case Token.DEBUGGER:\n614         Preconditions.checkState(childCount == 0);\n615         add(\"debugger\");\n616         cc.endStatement();\n617         break;\n618 \n619       case Token.BREAK:\n620         Preconditions.checkState(childCount <= 1);\n621         add(\"break\");\n622         if (childCount == 1) {\n623           if (!first.isLabelName()) {\n624             throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n625           }\n626           add(\" \");\n627           add(first);\n628         }\n629         cc.endStatement();\n630         break;\n631 \n632       case Token.EXPR_RESULT:\n633         Preconditions.checkState(childCount == 1);\n634         add(first, Context.START_OF_EXPR);\n635         cc.endStatement();\n636         break;\n637 \n638       case Token.NEW:\n639         add(\"new \");\n640         int precedence = NodeUtil.precedence(type);\n641 \n642         // If the first child contains a CALL, then claim higher precedence\n643         // to force parentheses. Otherwise, when parsed, NEW will bind to the\n644         // first viable parentheses (don't traverse into functions).\n645         if (NodeUtil.containsType(\n646             first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n647           precedence = NodeUtil.precedence(first.getType()) + 1;\n648         }\n649         addExpr(first, precedence, Context.OTHER);\n650 \n651         // '()' is optional when no arguments are present\n652         Node next = first.getNext();\n653         if (next != null) {\n654           add(\"(\");\n655           addList(next);\n656           add(\")\");\n657         }\n658         break;\n659 \n660       case Token.STRING_KEY:\n661         Preconditions.checkState(\n662             childCount == 1, \"Object lit key must have 1 child\");\n663         addJsString(n);\n664         break;\n665 \n666       case Token.STRING:\n667         Preconditions.checkState(\n668             childCount == 0, \"A string may not have children\");\n669         addJsString(n);\n670         break;\n671 \n672       case Token.DELPROP:\n673         Preconditions.checkState(childCount == 1);\n674         add(\"delete \");\n675         add(first);\n676         break;\n677 \n678       case Token.OBJECTLIT: {\n679         boolean needsParens = (context == Context.START_OF_EXPR);\n680         if (needsParens) {\n681           add(\"(\");\n682         }\n683         add(\"{\");\n684         for (Node c = first; c != null; c = c.getNext()) {\n685           if (c != first) {\n686             cc.listSeparator();\n687           }\n688 \n689           if (c.isGetterDef() || c.isSetterDef()) {\n690             add(c);\n691           } else {\n692             Preconditions.checkState(c.isStringKey());\n693             String key = c.getString();\n694             // Object literal property names don't have to be quoted if they\n695             // are not JavaScript keywords\n696             if (!c.isQuotedString()\n697                 && !(languageMode == LanguageMode.ECMASCRIPT3\n698                     && TokenStream.isKeyword(key))\n699                 && TokenStream.isJSIdentifier(key)\n700                 // do not encode literally any non-literal characters that\n701                 // were Unicode escaped.\n702                 && NodeUtil.isLatin(key)) {\n703               add(key);\n704             } else {\n705               // Determine if the string is a simple number.\n706               double d = getSimpleNumber(key);\n707               if (!Double.isNaN(d)) {\n708                 cc.addNumber(d);\n709               } else {\n710                 addExpr(c, 1, Context.OTHER);\n711               }\n712             }\n713             add(\":\");\n714             addExpr(c.getFirstChild(), 1, Context.OTHER);\n715           }\n716         }\n717         add(\"}\");\n718         if (needsParens) {\n719           add(\")\");\n720         }\n721         break;\n722       }\n723 \n724       case Token.SWITCH:\n725         add(\"switch(\");\n726         add(first);\n727         add(\")\");\n728         cc.beginBlock();\n729         addAllSiblings(first.getNext());\n730         cc.endBlock(context == Context.STATEMENT);\n731         break;\n732 \n733       case Token.CASE:\n734         Preconditions.checkState(childCount == 2);\n735         add(\"case \");\n736         add(first);\n737         addCaseBody(last);\n738         break;\n739 \n740       case Token.DEFAULT_CASE:\n741         Preconditions.checkState(childCount == 1);\n742         add(\"default\");\n743         addCaseBody(first);\n744         break;\n745 \n746       case Token.LABEL:\n747         Preconditions.checkState(childCount == 2);\n748         if (!first.isLabelName()) {\n749           throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n750         }\n751         add(first);\n752         add(\":\");\n753         addNonEmptyStatement(\n754             last, getContextForNonEmptyExpression(context), true);\n755         break;\n756 \n757       case Token.CAST:\n758         add(\"(\");\n759         add(first);\n760         add(\")\");\n761         break;\n762 \n763       default:\n764         throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n765     }\n766 \n767     cc.endSourceMapping(n);\n768   }", "bm_classpath": "com.google.javascript.jscomp.CodeGenerator"}, {"bug_name": "Closure_174", "report_text": "> compiler crash on goog.scope locals\n> \n> goog.provide(\"main\");\r\n> goog.scope (function (){\r\n>  var a = foo, b, c = 1;\r\n> });\r\n> \r\n> Reported by Thomas Fischer\r\n> \r\n> There are 2 separate issues here: that there's an error, and that the error make the compiler crash.", "test_name": "com.google.javascript.jscomp.ScopedAliasesTest::testIssue1103a", "test_method": "  public void testIssue1103a() {\n    test(\"goog.scope(function () {\" +\n         \"  var a;\" +\n         \"  foo.bar = function () { a = 1; };\" +\n         \"});\",\n         SCOPE_NAMESPACE + \"foo.bar = function () { $jscomp.scope.a = 1; }\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable a is in a goog.scope and is not an alias. at testcode line 1 : 30 expected:<0> but was:<1>\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:871)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:477)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:403)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:372)\n\tcom.google.javascript.jscomp.CompilerTestCase.test(CompilerTestCase.java:360)\n\tcom.google.javascript.jscomp.ScopedAliasesTest.testIssue1103a(ScopedAliasesTest.java:526)", "buggy_method": "81 private void parse(AbstractCompiler compiler) {\n82     try {\n83       ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n84           compiler.getParserConfig(),\n85           compiler.getDefaultErrorReporter(),\n86           logger_);\n87       root = result.ast;\n88       compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n89     } catch (IOException e) {\n90       compiler.report(\n91           JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n92     }\n93 \n94 \n95     if (root == null || compiler.hasHaltingErrors()) {\n96         // Most passes try to report as many errors as possible,\n97         // so there may already be errors. We only care if there were\n98         // errors in the code we just parsed.\n99       // There was a parse error or IOException, so use a dummy block.\n100       root = IR.script();\n101     } else {\n102       compiler.prepareAst(root);\n103     }\n104 \n105     // Set the source name so that the compiler passes can track\n106     // the source file and module.\n107     root.setStaticSourceFile(sourceFile);\n108   }", "bm_classpath": "com.google.javascript.jscomp.JsAst"}, {"bug_name": "Closure_175", "report_text": "> Erroneous optimization in ADVANCED_OPTIMIZATIONS mode\n> \n> **What steps will reproduce the problem?**\n> \r\n> 1. Create a file input.js with the following \"minimal\" test case:\r\n> \r\n>  window[\"anchor\"] = function (obj, modifiesProp) {\r\n>  return (function (saved) {\r\n>  return modifiesProp(obj) + saved;\r\n>  })(obj[\"prop\"]);\r\n>  }\r\n> \r\n> 2. Compile it with:\r\n> \r\n>  java -jar .../build/compiler.jar \\\r\n>  --compilation\\_level ADVANCED\\_OPTIMIZATIONS \\\r\n>  --warning\\_level VERBOSE \\\r\n>  --externs window.js \\\r\n>  --js input.js \\\r\n>  --js\\_output\\_file output.js\r\n> \r\n> 3. That's all!\r\n> \r\n> What is the expected output?\r\n> \r\n>  window.foo=function(a,b){var HOLD=a.prop;return b(a)+HOLD};\r\n> \r\n> What do you see instead?\r\n> \r\n>  window.foo=function(a,b){return b(a)+a.prop};\r\n> \r\n> Note how this is semantically very different if modifiesProp/b (whose\r\n> semantics are unknown to the compiler) side-effects a.prop.\r\n> \r\n> The evaluation order of + is well-defined in EcmaScript 5, but even\r\n> then, this happens even if one substitutes the , (comma) operator.\r\n> \r\n> **What version of the product are you using? On what operating system?**\n> \r\n> Git HEAD\r\n> \r\n>  commit 4a62ee4bca02169dd77a6f26ed64a624b3f05f95\r\n>  Author: Chad Killingsworth <chadkillingsworth@missouristate.edu>\r\n>  Date: Wed Sep 25 14:52:28 2013 -0500\r\n>  \r\n>  Add history.state to html5 externs\r\n> \r\n> on Linux.", "test_name": "com.google.javascript.jscomp.FunctionInjectorTest::testIssue1101a", "test_method": "  public void testIssue1101a() {\n    helperCanInlineReferenceToFunction(CanInlineResult.NO,\n        \"function foo(a){return modifiyX() + a;} foo(x);\", \"foo\",\n        INLINE_DIRECT); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<NO> but was:<YES>\n\tcom.google.javascript.jscomp.FunctionInjectorTest$1.call(FunctionInjectorTest.java:1402)\n\tcom.google.javascript.jscomp.FunctionInjectorTest$TestCallback.visit(FunctionInjectorTest.java:1543)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:540)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverseBranch(NodeTraversal.java:534)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:287)\n\tcom.google.javascript.jscomp.NodeTraversal.traverse(NodeTraversal.java:494)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperCanInlineReferenceToFunction(FunctionInjectorTest.java:1409)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.helperCanInlineReferenceToFunction(FunctionInjectorTest.java:1373)\n\tcom.google.javascript.jscomp.FunctionInjectorTest.testIssue1101a(FunctionInjectorTest.java:1346)", "buggy_method": "173 CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n174       Node callNode, Node fnNode, Set<String> needAliases,\n175       InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n176     // TODO(johnlenz): This function takes too many parameter, without\n177     // context.  Modify the API to take a structure describing the function.\n178 \n179     // Allow direct function calls or \"fn.call\" style calls.\n180     if (!isSupportedCallType(callNode)) {\n181       return CanInlineResult.NO;\n182     }\n183 \n184     // Limit where functions that contain functions can be inline.  Introducing\n185     // an inner function into another function can capture a variable and cause\n186     // a memory leak.  This isn't a problem in the global scope as those values\n187     // last until explicitly cleared.\n188     if (containsFunctions) {\n189       if (!assumeMinimumCapture && !t.inGlobalScope()) {\n190         // TODO(johnlenz): Allow inlining into any scope without local names or\n191         // inner functions.\n192         return CanInlineResult.NO;\n193       } else if (NodeUtil.isWithinLoop(callNode)) {\n194         // An inner closure maybe relying on a local value holding a value for a\n195         // single iteration through a loop.\n196         return CanInlineResult.NO;\n197       }\n198     }\n199 \n200     // TODO(johnlenz): Add support for 'apply'\n201     if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n202       // TODO(johnlenz): Allow 'this' references to be replaced with a\n203       // global 'this' object.\n204       return CanInlineResult.NO;\n205     }\n206 \n207     if (mode == InliningMode.DIRECT) {\n208       return canInlineReferenceDirectly(callNode, fnNode);\n209     } else {\n210       return canInlineReferenceAsStatementBlock(\n211           t, callNode, fnNode, needAliases);\n212     }\n213   }", "bm_classpath": "com.google.javascript.jscomp.FunctionInjector"}, {"bug_name": "Closure_176", "report_text": "> initial type of variable wrong when initialize in a \"var\" statement with type declaration.\n> \n> The following code doesn't give any warning even though it is an obvious bug:\r\n> \r\n> -------------===============================---------\r\n> /\\*\\*\r\n>  \\* @constructor\r\n>  \\*/\r\n> function MyClass() {\r\n>  this.value = 1;\r\n> }\r\n> \r\n> MyClass.prototype.show = function() {\r\n>  window.console.log(this.value)\r\n> }\r\n> \r\n> /\\*\\*\r\n>  \\* @type {MyClass}\r\n>  \\*/\r\n> var x = null;\r\n> x.show();\r\n> -------------===============================---------\r\n> \r\n> However, if you remove the @type from the var declaration, then closure realizes the problem and warns about x being null rather than an Object.\r\n> \r\n> In any case, since x \"can be null\", closure should warn about a potential null pointer error, and suggest to guard against the null value, like it does if we try to pass x as an argument where a non-null type is expected. That could be an optional behavior protected behind a flag, but it would definitely help catch lots of errors and write safer code.\r\n> \r\n> I am using the latest closure version available to date, on Ubuntu 13.04, on an amd64 machine.", "test_name": "com.google.javascript.jscomp.TypeCheckTest::testIssue1056", "test_method": "  public void testIssue1056() throws Exception {\n    testTypes(\n        \"/** @type {Array} */ var x = null;\" +\n        \"x.push('hi');\",\n        \"No properties on this expression\\n\" +\n        \"found   : null\\n\" +\n        \"required: Object\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected a warning\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12785)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12765)\n\tcom.google.javascript.jscomp.TypeCheckTest.testTypes(TypeCheckTest.java:12701)\n\tcom.google.javascript.jscomp.TypeCheckTest.testIssue1056(TypeCheckTest.java:6911)", "buggy_method": "523 private void updateScopeForTypeChange(\n524       FlowScope scope, Node left, JSType leftType, JSType resultType) {\n525     Preconditions.checkNotNull(resultType);\n526     switch (left.getType()) {\n527       case Token.NAME:\n528         String varName = left.getString();\n529         Var var = syntacticScope.getVar(varName);\n530         boolean isVarDeclaration = left.hasChildren();\n531 \n532         // When looking at VAR initializers for declared VARs, we tend\n533         // to use the declared type over the type it's being\n534         // initialized to in the global scope.\n535         //\n536         // For example,\n537         // /** @param {number} */ var f = goog.abstractMethod;\n538         // it's obvious that the programmer wants you to use\n539         // the declared function signature, not the inferred signature.\n540         //\n541         // Or,\n542         // /** @type {Object.<string>} */ var x = {};\n543         // the one-time anonymous object on the right side\n544         // is as narrow as it can possibly be, but we need to make\n545         // sure we back-infer the <string> element constraint on\n546         // the left hand side, so we use the left hand side.\n547 \n548         boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n549             // Makes it easier to check for NPEs.\n550 \n551         // TODO(nicksantos): This might be a better check once we have\n552         // back-inference of object/array constraints.  It will probably\n553         // introduce more type warnings.  It uses the result type iff it's\n554         // strictly narrower than the declared var type.\n555         //\n556         //boolean isVarTypeBetter = isVarDeclaration &&\n557         //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n558         //     || !resultType.isSubtype(varType));\n559 \n560 \n561         if (isVarTypeBetter) {\n562           redeclareSimpleVar(scope, left, resultType);\n563         }\n564         left.setJSType(isVarDeclaration || leftType == null ?\n565             resultType : null);\n566 \n567         if (var != null && var.isTypeInferred()) {\n568           JSType oldType = var.getType();\n569           var.setType(oldType == null ?\n570               resultType : oldType.getLeastSupertype(resultType));\n571         }\n572         break;\n573       case Token.GETPROP:\n574         String qualifiedName = left.getQualifiedName();\n575         if (qualifiedName != null) {\n576           scope.inferQualifiedSlot(left, qualifiedName,\n577               leftType == null ? unknownType : leftType,\n578               resultType);\n579         }\n580 \n581         left.setJSType(resultType);\n582         ensurePropertyDefined(left, resultType);\n583         break;\n584     }\n585   }", "bm_classpath": "com.google.javascript.jscomp.TypeInference"}, {"bug_name": "Codec_1", "report_text": "> Fix case-insensitive string handling\n> \n> The language codecs are platform-depedent, please see [Common Bug #3](http://www.nabble.com/Re%3A-Common-Bugs-p14931921s177.html) for details.", "test_name": "org.apache.commons.codec.language.CaverphoneTest::testLocaleIndependence", "test_method": "", "error_message": "junit.framework.ComparisonFailure: tr:  expected:<[A]111111111> but was:<[1]111111111>\n\torg.apache.commons.codec.StringEncoderAbstractTest.testLocaleIndependence(StringEncoderAbstractTest.java:91)", "buggy_method": "50 public String caverphone(String txt) {\n51         // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n52         // by commenting out the 2.0 lines and adding in the 1.0 lines\n53 \n54         if( txt == null || txt.length() == 0 ) {\n55             return \"1111111111\";\n56         }\n57 \n58         // 1. Convert to lowercase\n59         txt = txt.toLowerCase();\n60 \n61         // 2. Remove anything not A-Z\n62         txt = txt.replaceAll(\"[^a-z]\", \"\");\n63 \n64         // 2.5. Remove final e\n65         txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n66 \n67         // 3. Handle various start options\n68         txt = txt.replaceAll(\"^cough\", \"cou2f\");\n69         txt = txt.replaceAll(\"^rough\", \"rou2f\");\n70         txt = txt.replaceAll(\"^tough\", \"tou2f\");\n71         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n72         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n73         txt = txt.replaceAll(\"^gn\", \"2n\");\n74         txt = txt.replaceAll(\"^mb\", \"m2\");\n75 \n76         // 4. Handle replacements\n77         txt = txt.replaceAll(\"cq\", \"2q\");\n78         txt = txt.replaceAll(\"ci\", \"si\");\n79         txt = txt.replaceAll(\"ce\", \"se\");\n80         txt = txt.replaceAll(\"cy\", \"sy\");\n81         txt = txt.replaceAll(\"tch\", \"2ch\");\n82         txt = txt.replaceAll(\"c\", \"k\");\n83         txt = txt.replaceAll(\"q\", \"k\");\n84         txt = txt.replaceAll(\"x\", \"k\");\n85         txt = txt.replaceAll(\"v\", \"f\");\n86         txt = txt.replaceAll(\"dg\", \"2g\");\n87         txt = txt.replaceAll(\"tio\", \"sio\");\n88         txt = txt.replaceAll(\"tia\", \"sia\");\n89         txt = txt.replaceAll(\"d\", \"t\");\n90         txt = txt.replaceAll(\"ph\", \"fh\");\n91         txt = txt.replaceAll(\"b\", \"p\");\n92         txt = txt.replaceAll(\"sh\", \"s2\");\n93         txt = txt.replaceAll(\"z\", \"s\");\n94         txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n95         txt = txt.replaceAll(\"[aeiou]\", \"3\");\n96         txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n97         txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n98         txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n99         txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n100         txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n101         txt = txt.replaceAll(\"gh\", \"22\");\n102         txt = txt.replaceAll(\"g\", \"k\");\n103         txt = txt.replaceAll(\"s+\", \"S\");\n104         txt = txt.replaceAll(\"t+\", \"T\");\n105         txt = txt.replaceAll(\"p+\", \"P\");\n106         txt = txt.replaceAll(\"k+\", \"K\");\n107         txt = txt.replaceAll(\"f+\", \"F\");\n108         txt = txt.replaceAll(\"m+\", \"M\");\n109         txt = txt.replaceAll(\"n+\", \"N\");\n110         txt = txt.replaceAll(\"w3\", \"W3\");\n111         //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n112         txt = txt.replaceAll(\"wh3\", \"Wh3\");\n113         txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n114         //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n115         txt = txt.replaceAll(\"w\", \"2\");\n116         txt = txt.replaceAll(\"^h\", \"A\");\n117         txt = txt.replaceAll(\"h\", \"2\");\n118         txt = txt.replaceAll(\"r3\", \"R3\");\n119         txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n120         //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n121         txt = txt.replaceAll(\"r\", \"2\");\n122         txt = txt.replaceAll(\"l3\", \"L3\");\n123         txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n124         //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n125         txt = txt.replaceAll(\"l\", \"2\");\n126         //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n127         //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n128         //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n129 \n130         // 5. Handle removals\n131         txt = txt.replaceAll(\"2\", \"\");\n132         txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n133         txt = txt.replaceAll(\"3\", \"\");\n134 \n135         // 6. put ten 1s on the end\n136         txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n137 \n138         // 7. take the first six characters as the code\n139         return txt.substring(0, 10);          // 1.0 truncates to 6\n140     }", "bm_classpath": "org.apache.commons.codec.language.Caverphone"}, {"bug_name": "Codec_2", "report_text": "> Base64 bug with empty input (new byte[0])\n> \n> Base64.encode(new byte[0]) doesn't return an empty byte array back! It returns CRLF.", "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest::testBase64EmptyInputStream", "test_method": "    public void testBase64EmptyInputStream() throws Exception {\r\n        byte[] emptyEncoded = new byte[0];\r\n        byte[] emptyDecoded = new byte[0];\r\n        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: EOF expected:<-1> but was:<13>\n\torg.apache.commons.codec.binary.Base64InputStreamTest.testByteByByte(Base64InputStreamTest.java:142)\n\torg.apache.commons.codec.binary.Base64InputStreamTest.testBase64EmptyInputStream(Base64InputStreamTest.java:53)", "buggy_method": "414 void encode(byte[] in, int inPos, int inAvail) {\n415         if (eof) {\n416             return;\n417         }\n418         // inAvail < 0 is how we're informed of EOF in the underlying data we're\n419         // encoding.\n420         if (inAvail < 0) {\n421             eof = true;\n422             if (buf == null || buf.length - pos < encodeSize) {\n423                 resizeBuf();\n424             }\n425             switch (modulus) {\n426                 case 1:\n427                     buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n428                     buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n429                     // URL-SAFE skips the padding to further reduce size.\n430                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n431                         buf[pos++] = PAD;\n432                         buf[pos++] = PAD;\n433                     }\n434                     break;\n435 \n436                 case 2:\n437                     buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n438                     buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n439                     buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n440                     // URL-SAFE skips the padding to further reduce size.\n441                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n442                         buf[pos++] = PAD;\n443                     }\n444                     break;\n445             }\n446             if (lineLength > 0) {\n447                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n448                 pos += lineSeparator.length;\n449             }\n450         } else {\n451             for (int i = 0; i < inAvail; i++) {\n452                 if (buf == null || buf.length - pos < encodeSize) {\n453                     resizeBuf();\n454                 }\n455                 modulus = (++modulus) % 3;\n456                 int b = in[inPos++];\n457                 if (b < 0) { b += 256; }\n458                 x = (x << 8) + b;\n459                 if (0 == modulus) {\n460                     buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n461                     buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n462                     buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n463                     buf[pos++] = encodeTable[x & MASK_6BITS];\n464                     currentLinePos += 4;\n465                     if (lineLength > 0 && lineLength <= currentLinePos) {\n466                         System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n467                         pos += lineSeparator.length;\n468                         currentLinePos = 0;\n469                     }\n470                 }\n471             }\n472         }\n473     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_3", "report_text": "> Double Metaphone bugs in alternative encoding\n> \n> The new test case ([~~CODEC-83~~](https://issues.apache.org/jira/browse/CODEC-83 \"Improve Double Metaphone test coverage\")) has highlighted a number of issues with the \"alternative\" encoding in the Double Metaphone implementation\n> 1) Bug in the handleG method when \"G\" is followed by \"IER\" \n> * The alternative encoding of \"Angier\" results in \"ANKR\" rather than \"ANJR\"\n> * The alternative encoding of \"rogier\" results in \"RKR\" rather than \"RJR\"\n> The problem is in the handleG() method and is caused by the wrong length (4 instead of 3) being used in the contains() method:\n> ```\n>  } else if (contains(value, index + 1, 4, \"IER\")) {\n> ```\n> ...this should be\n> ```\n>  } else if (contains(value, index + 1, 3, \"IER\")) {\n> ```\n> 2) Bug in the handleL method\n> * The alternative encoding of \"cabrillo\" results in \"KPRL \" rather than \"KPR\"\n> The problem is that the first thing this method does is append an \"L\" to both primary & alternative encoding. When the conditionL0() method returns true then the \"L\" should not be appended for the alternative encoding\n> ```\n> result.append('L');\n> if (charAt(value, index + 1) == 'L') {\n>     if (conditionL0(value, index)) {\n>         result.appendAlternate(' ');\n>     }\n>     index += 2;\n> } else {\n>     index++;\n> }\n> return index;\n> ```\n> Suggest refeactoring this to\n> ```\n> if (charAt(value, index + 1) == 'L') {\n>     if (conditionL0(value, index)) {\n>         result.appendPrimary('L');\n>     } else {\n>         result.append('L');\n>     }\n>     index += 2;\n> } else {\n>     result.append('L');\n>     index++;\n> }\n> return index;\n> ```\n> 3) Bug in the conditionL0() method for words ending in \"AS\" and \"OS\"\n> * The alternative encoding of \"gallegos\" results in \"KLKS\" rather than \"KKS\"\n> The problem is caused by the wrong start position being used in the contains() method, which means its not checking the last two characters of the word but checks the previous & current position instead:\n> ```\n>         } else if ((contains(value, index - 1, 2, \"AS\", \"OS\") || \n> ```\n> ...this should be\n> ```\n>         } else if ((contains(value, value.length() - 2, 2, \"AS\", \"OS\") || \n> ```\n> I'll attach a patch for review", "test_name": "org.apache.commons.codec.language.DoubleMetaphone2Test::testDoubleMetaphoneAlternate", "test_method": "    public void testDoubleMetaphoneAlternate() {\n        String value = null;\n        for (int i = 0; i < TEST_DATA.length; i++) {\n            value = TEST_DATA[i][0];\n            assertEquals(\"Test [\" + i + \"]=\" + value, TEST_DATA[i][2], doubleMetaphone.doubleMetaphone(value, true));\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: Test [19]=Angier expected:<AN[J]R> but was:<AN[K]R>\n\torg.apache.commons.codec.language.DoubleMetaphone2Test.testDoubleMetaphoneAlternate(DoubleMetaphone2Test.java:84)", "buggy_method": "418 private int handleG(String value, \n419                         DoubleMetaphoneResult result, \n420                         int index, \n421                         boolean slavoGermanic) {\n422         if (charAt(value, index + 1) == 'H') {\n423             index = handleGH(value, result, index);\n424         } else if (charAt(value, index + 1) == 'N') {\n425             if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n426                 result.append(\"KN\", \"N\");\n427             } else if (!contains(value, index + 2, 2, \"EY\") && \n428                        charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n429                 result.append(\"N\", \"KN\");\n430             } else {\n431                 result.append(\"KN\");\n432             }\n433             index = index + 2;\n434         } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n435             result.append(\"KL\", \"L\");\n436             index += 2;\n437         } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n438             //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n439             result.append('K', 'J');\n440             index += 2;\n441         } else if ((contains(value, index + 1, 2, \"ER\") || \n442                     charAt(value, index + 1) == 'Y') &&\n443                    !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n444                    !contains(value, index - 1, 1, \"E\", \"I\") && \n445                    !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n446             //-- -ger-, -gy- --//\n447             result.append('K', 'J');\n448             index += 2;\n449         } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n450                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n451             //-- Italian \"biaggi\" --//\n452             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n453                 //-- obvious germanic --//\n454                 result.append('K');\n455             } else if (contains(value, index + 1, 4, \"IER\")) {\n456                 result.append('J');\n457             } else {\n458                 result.append('J', 'K');\n459             }\n460             index += 2;\n461         } else if (charAt(value, index + 1) == 'G') {\n462             index += 2;\n463             result.append('K');\n464         } else {\n465             index++;\n466             result.append('K');\n467         }\n468         return index;\n469     }", "bm_classpath": "org.apache.commons.codec.language.DoubleMetaphone"}, {"bug_name": "Codec_4", "report_text": "> new Base64().encode() appends a CRLF, and chunks results into 76 character lines\n> \n> The instance encode() method (e.g. new Base64().encode()) appends a CRLF. Actually it's fully chunking the output into 76 character lines. Commons-Codec-1.3 did not do this. The static Base64.encodeBase64() method behaves the same in both 1.3 and 1.4, so this problem only affects the instance encode() method.\n> ```\n> import org.apache.commons.codec.binary.*;\n> public class B64 {\n>   public static void main(String[] args) throws Exception {\n>     Base64 b64 = new Base64();\n>     String s1 = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n>     String s2 = \"aaaaaaaaaa\";\n>     String s3 = \"a\";\n>     \n>     byte[] b1 = s1.getBytes(\"UTF-8\");\n>     byte[] b2 = s2.getBytes(\"UTF-8\");\n>     byte[] b3 = s3.getBytes(\"UTF-8\");\n>     byte[] result;\n>     result = Base64.encodeBase64(b1);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>     result = b64.encode(b1);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>     result = Base64.encodeBase64(b2);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>     result = b64.encode(b2);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>     result = Base64.encodeBase64(b3);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>     result = b64.encode(b3);\n>     System.out.println(\"[\" + new String(result, \"UTF-8\") + \"]\");\n>   }\n> }\n> ```\n> Here's my output:\n> ```\n> $ java -cp commons-codec-1.3.jar:. B64\n> [YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==]\n> [YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==]\n> [YWFhYWFhYWFhYQ==]\n> [YWFhYWFhYWFhYQ==]\n> [YQ==]\n> [YQ==]\n> $ java -cp commons-codec-1.4.jar:. B64\n> [YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==]\n> [YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh\n> YWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQ==\n> ]\n> [YWFhYWFhYWFhYQ==]\n> [YWFhYWFhYWFhYQ==\n> ]\n> [YQ==]\n> [YQ==\n> ]\n> ```", "test_name": "org.apache.commons.codec.binary.Base64Codec13Test::testEncoder", "test_method": "    public void testEncoder() throws EncoderException {\n        Encoder enc = new Base64();\n        for (int i = 0; i < STRINGS.length; i++) {\n            if (STRINGS[i] != null) {\n                byte[] base64 = utf8(STRINGS[i]);\n                byte[] binary = BYTES[i];\n                boolean b = Arrays.equals(base64, (byte[]) enc.encode(binary));\n                assertTrue(\"Encoder test-\" + i, b);\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Encoder test-1\n\torg.apache.commons.codec.binary.Base64Codec13Test.testEncoder(Base64Codec13Test.java:378)", "buggy_method": "224 public Base64() {\n225         this(false);\n226     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_5", "report_text": "> Base64InputStream causes NullPointerException on some input\n> \n> Certain (malformed?) input to Base64InputStream causes a NullPointerException in Base64.decode.\n> The exception occurs when Base64.decode is entered with the following conditions:\n> * buffer is null\n> * modulus is 3 from a previous entry.\n> * inAvail is -1 because Base64InputStream.read reached EOF on line 150.\n> Under these conditions, Base64.decode reaches line 581 with buffer still null and throws a NullPointerException.\n> Here is some input data that will trigger it:\n> ```\n> H4sIAAAAAAAAAFvzloG1uIhBKiuxLFGvODW5tCizpFIvODM9LzXFPykrNbmE8//eDC2bq/+ZGJij\n> GdiT8/NKUvNKShiYop2iGTiLgQoTS0qLUgsZ6hgYfRh4SjJSE3PS84GmZOSWMAj5gMzVz0nMS9cP\n> LinKzEu3rigoLQJpXvNZ/AcbR8gDJgaGigIGBqbLayAuMUxNKdVLTyxJTc7QS07WSyzKLC7JL8lJ\n> 1StJLErMKynNSdTLyUxOzStO1fOB0AwQwMjEwOrJwJMbn+mSWFkclpiTmeID4joml2SWpYZk5qaW\n> MEj45Bel62flpyTqlwAF9F2A9oBkrMEqnYtSoXyob1hy4z1dShgEIL4oLcnM0Q8N9XQBqubKjYfa\n> DjTV1AfoZn2Im/WTk/XhbtaHu1kf6mZ9T5g2YED8BwKgj8WAbtIDuUkP5CY9mJt22FSkZEXf/QkK\n> oCIGeVRFSYlA/zsBCZjq//9/PvSP1VvMxMDkxcCe6ZuZk5NZ7MPAnemcUZSfl5+Tn15ZwiCF5n2E\n> nDUoDhjVfhrpNABdpI5qWTJYmZ5nsD9Cg0pwSWnSyhOCaYXmAerMoDgsxnAkzG1R+XmpYPXL9Bln\n> 1RhJPQarL+dgYNM1MLUyMKioKAYFOCvIBb8vl8qCOFxA4/jAiRIU7HqgYN8zk/n7jNxWfbAXeXJS\n> E4tLgOnUKbOk2IuBOzcfzqso6M1QmrzKkedPzcYO3QZu129As4xITlZI6QqYFNhz44v9EkFpCGua\n> LmEQdkktS83JL8gF5g4FqBGlIJ+wAI1gKJtZEvTws/j3FluPu4lcr7ra9OfHKXIZNTa4FPd8n33J\n> QXPFLte9AZe5uBaJvGrKVl+rbrTaXDZO6NwU7gnHOVgzzsmnGX2Y5GDqrst8wcTear0Ab1yj6PrD\n> F977vL/5iUMg773My5qLLK8OVAu6Tz7Xcyjy9Uym02Z/+xY7m85nYo/t4E93FXFKOf9/a3X78neS\n> jE5Tu066K3Mdf17m66mbpXN9y34ZZ3ErRobfn+RfzVBIWj0vc82vY7YPvM5eLHHOulV77M6CoB4h\n> xb/FjHWHRR+ldb6QmSP1ROGwGs+nx2quwitN7+mIpsRFhU37JPRoZe2ZjiX/70j7CS1tz51YP/3W\n> /xfnV2i/4rAoYeAN9nA0NTQqBxYMQcGOAG5\n> ```\n> Say this is read from file with a byte[] of size 1024 using Base64InputStream.read(byte[]). In the first iteration, all 1190 bytes get read into buf, then it enters Base64.setInitialBuffer and assigns the byte[1024] to buffer and does a round of decoding. When it then enters Base64.readResults on line 162 in Base64InputStream, it sets buffer to null, modulus has the left-over value 3, and the NPE occurs the next iteration.\n> Base64InputStream could avoid this by returning right away on EOF (-1), but I think the real fix needs to happen in Base64 since it this same situation could be created by direct use. My guess is either more needs to happen in the body of the if on line 542 (set modulus to 0?) or the condition on line 573 is flawed and needs adjusting.", "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec98NPE", "test_method": "    public void testCodec98NPE() throws Exception {\n        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);\n        ByteArrayInputStream data = new ByteArrayInputStream(codec98);\n        Base64InputStream stream = new Base64InputStream(data);\n\n        // This line causes an NPE in commons-codec-1.4.jar:\n        byte[] decodedBytes = Base64TestData.streamToBytes(stream, new byte[1024]); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.codec.binary.Base64.decode(Base64.java:594)\n\torg.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:159)\n\torg.apache.commons.codec.binary.Base64TestData.fill(Base64TestData.java:177)\n\torg.apache.commons.codec.binary.Base64TestData.streamToBytes(Base64TestData.java:148)\n\torg.apache.commons.codec.binary.Base64InputStreamTest.testCodec98NPE(Base64InputStreamTest.java:61)", "buggy_method": "550 void decode(byte[] in, int inPos, int inAvail) {\n551         if (eof) {\n552             return;\n553         }\n554         if (inAvail < 0) {\n555             eof = true;\n556         }\n557         for (int i = 0; i < inAvail; i++) {\n558             if (buffer == null || buffer.length - pos < decodeSize) {\n559                 resizeBuffer();\n560             }\n561             byte b = in[inPos++];\n562             if (b == PAD) {\n563                 // We're done.\n564                 eof = true;\n565                 break;\n566             } else {\n567                 if (b >= 0 && b < DECODE_TABLE.length) {\n568                     int result = DECODE_TABLE[b];\n569                     if (result >= 0) {\n570                         modulus = (++modulus) % 4;\n571                         x = (x << 6) + result;\n572                         if (modulus == 0) {\n573                             buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n574                             buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n575                             buffer[pos++] = (byte) (x & MASK_8BITS);\n576                         }\n577                     }\n578                 }\n579             }\n580         }\n581 \n582         // Two forms of EOF as far as base64 decoder is concerned: actual\n583         // EOF (-1) and first time '=' character is encountered in stream.\n584         // This approach makes the '=' padding characters completely optional.\n585         if (eof && modulus != 0) {\n586             \n587             x = x << 6;\n588             switch (modulus) {\n589                 case 2 :\n590                     x = x << 6;\n591                     buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n592                     break;\n593                 case 3 :\n594                     buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n595                     buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n596                     break;\n597             }\n598         }\n599     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_6", "report_text": "> Base64InputStream#read(byte[]) incorrectly returns 0 at end of any stream which is multiple of 3 bytes long\n> \n> Using new InputStreamReader(new Base64InputStream(in, true)) sometimes fails with \"java.io.IOException: Underlying input stream returned zero bytes\".\n> This is been tracked down that Base64InputStream#read(byte[]) incorrectly returns 0 at end of any stream which is multiple of 3 bytes long.", "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec101", "test_method": "    public void testCodec101() throws Exception {\n        byte[] codec101 = StringUtils.getBytesUtf8(Base64TestData.CODEC_101_MULTIPLE_OF_3);\n        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);\n        Base64InputStream in = new Base64InputStream(bais);\n        byte[] result = new byte[8192];\n        int c = in.read(result);\n        assertTrue(\"Codec101: First read successful [c=\" + c + \"]\", c > 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Codec101: First read successful [c=0]\n\torg.apache.commons.codec.binary.Base64InputStreamTest.testCodec101(Base64InputStreamTest.java:61)", "buggy_method": "138 public int read(byte b[], int offset, int len) throws IOException {\n139         if (b == null) {\n140             throw new NullPointerException();\n141         } else if (offset < 0 || len < 0) {\n142             throw new IndexOutOfBoundsException();\n143         } else if (offset > b.length || offset + len > b.length) {\n144             throw new IndexOutOfBoundsException();\n145         } else if (len == 0) {\n146             return 0;\n147         } else {\n148             /*\n149              Rationale for while-loop on (readLen == 0):\n150              -----\n151              Base64.readResults() usually returns > 0 or EOF (-1).  In the\n152              rare case where it returns 0, we just keep trying.\n153 \n154              This is essentially an undocumented contract for InputStream\n155              implementors that want their code to work properly with\n156              java.io.InputStreamReader, since the latter hates it when\n157              InputStream.read(byte[]) returns a zero.  Unfortunately our\n158              readResults() call must return 0 if a large amount of the data\n159              being decoded was non-base64, so this while-loop enables proper\n160              interop with InputStreamReader for that scenario.\n161              -----\n162              This is a fix for CODEC-101\n163             */\n164                 if (!base64.hasData()) {\n165                     byte[] buf = new byte[doEncode ? 4096 : 8192];\n166                     int c = in.read(buf);\n167                     // A little optimization to avoid System.arraycopy()\n168                     // when possible.\n169                     if (c > 0 && b.length == len) {\n170                         base64.setInitialBuffer(b, offset, len);\n171                     }\n172                     if (doEncode) {\n173                         base64.encode(buf, 0, c);\n174                     } else {\n175                         base64.decode(buf, 0, c);\n176                     }\n177                 }\n178             return base64.readResults(b, offset, len);\n179         }\n180     }", "bm_classpath": "org.apache.commons.codec.binary.Base64InputStream"}, {"bug_name": "Codec_7", "report_text": "> Base64.encodeBase64String() shouldn't chunk\n> \n> Base64.encodeBase64String() shouldn't chunk.\n> Change this:\n> ```\n> public static String encodeBase64String(byte[] binaryData) {\n>     return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n> }\n> ```\n> To this:\n> ```\n> public static String encodeBase64String(byte[] binaryData) {\n>     return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n> }\n> ```\n> This will fix the following tests ggregory added a few minutes ago:\n>  //assertEquals(\"Zg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"f\")));  \n>  //assertEquals(\"Zm8=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fo\")));  \n>  //assertEquals(\"Zm9v\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foo\")));  \n>  //assertEquals(\"Zm9vYg==\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foob\")));  \n>  //assertEquals(\"Zm9vYmE=\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"fooba\")));  \n>  //assertEquals(\"Zm9vYmFy\", Base64.encodeBase64String(StringUtils.getBytesUtf8(\"foobar\")));", "test_name": "org.apache.commons.codec.binary.Base64Test::testByteToStringVariations", "test_method": "    public void testByteToStringVariations() throws DecoderException {\n        Base64 base64 = new Base64(0);\n        byte[] b1 = StringUtils.getBytesUtf8(\"Hello World\");\n        byte[] b2 = new byte[0];\n        byte[] b3 = null;\n        byte[] b4 = Hex.decodeHex(\"2bf7cc2701fe4397b49ebeed5acc7090\".toCharArray());  // for url-safe tests\n\n        assertEquals(\"byteToString static Hello World\", \"SGVsbG8gV29ybGQ=\", Base64.encodeBase64String(b1)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: byteToString static Hello World expected:<SGVsbG8gV29ybGQ=[]> but was:<SGVsbG8gV29ybGQ=[\n\torg.apache.commons.codec.binary.Base64Test.testByteToStringVariations(Base64Test.java:1129)", "buggy_method": "669 public static String encodeBase64String(byte[] binaryData) {\n670         return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n671     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_8", "report_text": "> ArrayIndexOutOfBoundsException when doing multiple reads() on encoding Base64InputStream\n> \n> When encoding a sizable stream byte by byte (so, just calling Base64InputStream.read()), after 10920 successful read()s, this happens: \n> java.lang.ArrayIndexOutOfBoundsException: 2  \n>  at org.apache.commons.codec.binary.Base64.encode(Base64.java:502)  \n>  at org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:157)  \n>  at org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)\n> Based on this, the necessary conditions seem to be that buffer = null and modulus = 2. Then, if a read() is done, a single-byte buffer is used, whose length is doubled by resizeBuffer(), but that still doesn't make it big enough to hold the 4 bytes written to it because modulus was just incremented to 0. \n> Here's some sample code:\n> import org.apache.commons.codec.binary.Base64InputStream;\n> public class TestReads {  \n>  public static void main(String[] args) {  \n>  Base64InputStream b64stream = new Base64InputStream(System.in, true, 0, null);  \n>  int n = 0;  \n>  try \n> {\n>  while (b64stream.read() != -1) n++;\n>  }\n>  catch (Exception x) \n> {\n>  System.out.println(n);\n>  x.printStackTrace();\n>  }\n>  }  \n> }", "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest::testCodec105", "test_method": "    public void testCodec105() throws IOException {\n        Base64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\n        for (int i = 0; i < 5; i++) {\n            in.read();\n        } // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 2\n\torg.apache.commons.codec.binary.Base64.encode(Base64.java:497)\n\torg.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:173)\n\torg.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)\n\torg.apache.commons.codec.binary.Base64InputStreamTest.testCodec105(Base64InputStreamTest.java:58)", "buggy_method": "419 void setInitialBuffer(byte[] out, int outPos, int outAvail) {\n420         if (out != null && out.length == outAvail) {\n421             buffer = out;\n422             pos = outPos;\n423             readPos = outPos;\n424         }\n425     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_9", "report_text": "> Base64.encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) throws IAE for valid maxResultSize if isChunked is false\n> \n> If isChunked is false, Base64.encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) throws IAE for valid maxResultSize.\n> Test case and fix will be applied shortly.", "test_name": "org.apache.commons.codec.binary.Base64Test::testCodec112", "test_method": "    public void testCodec112() { // size calculation assumes always chunked\n        byte[] in = new byte[] {0};\n        byte[] out=Base64.encodeBase64(in);\n        Base64.encodeBase64(in, false, false, out.length); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Input array too big, the output array would be bigger (6) than the specified maxium size of 4\n\torg.apache.commons.codec.binary.Base64.encodeBase64(Base64.java:829)\n\torg.apache.commons.codec.binary.Base64Test.testCodec112(Base64Test.java:343)", "buggy_method": "822 public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n823         if (binaryData == null || binaryData.length == 0) {\n824             return binaryData;\n825         }\n826 \n827         long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n828         if (len > maxResultSize) {\n829             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n830                 len +\n831                 \") than the specified maxium size of \" +\n832                 maxResultSize);\n833         }\n834                 \n835         Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n836         return b64.encode(binaryData);\n837     }", "bm_classpath": "org.apache.commons.codec.binary.Base64"}, {"bug_name": "Codec_10", "report_text": "> Caverphone encodes names starting and ending with \"mb\" incorrectly.\n> \n> Caverphone encode names starting and ending with \"mb\" incorrectly.\n> According to the spec:  \n> \"If the name ends with mb make it m2\".\n> This has been coded as:  \n> \"If the name *starts* with mb make it m2\".", "test_name": "org.apache.commons.codec.language.CaverphoneTest::testEndMb", "test_method": "    public void testEndMb() throws EncoderException {\n        String[][] data = {{\"mb\", \"M111111111\"}, {\"mbmb\", \"MPM1111111\"}};\n        this.checkEncodings(data); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: Source: mbmb expected:<M[PM]1111111> but was:<M[MP]1111111>\n\torg.apache.commons.codec.StringEncoderAbstractTest.checkEncoding(StringEncoderAbstractTest.java:38)\n\torg.apache.commons.codec.StringEncoderAbstractTest.checkEncodings(StringEncoderAbstractTest.java:43)\n\torg.apache.commons.codec.language.CaverphoneTest.testEndMb(CaverphoneTest.java:335)", "buggy_method": "50 public String caverphone(String txt) {\n51         // NOTE: Version 1.0 of Caverphone is easily derivable from this code \n52         // by commenting out the 2.0 lines and adding in the 1.0 lines\n53 \n54         if( txt == null || txt.length() == 0 ) {\n55             return \"1111111111\";\n56         }\n57 \n58         // 1. Convert to lowercase\n59         txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n60 \n61         // 2. Remove anything not A-Z\n62         txt = txt.replaceAll(\"[^a-z]\", \"\");\n63 \n64         // 2.5. Remove final e\n65         txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n66 \n67         // 3. Handle various start options\n68         txt = txt.replaceAll(\"^cough\", \"cou2f\");\n69         txt = txt.replaceAll(\"^rough\", \"rou2f\");\n70         txt = txt.replaceAll(\"^tough\", \"tou2f\");\n71         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n72         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n73         txt = txt.replaceAll(\"^gn\", \"2n\");\n74 \n75         // End \n76         txt = txt.replaceAll(\"^mb\", \"m2\");\n77 \n78         // 4. Handle replacements\n79         txt = txt.replaceAll(\"cq\", \"2q\");\n80         txt = txt.replaceAll(\"ci\", \"si\");\n81         txt = txt.replaceAll(\"ce\", \"se\");\n82         txt = txt.replaceAll(\"cy\", \"sy\");\n83         txt = txt.replaceAll(\"tch\", \"2ch\");\n84         txt = txt.replaceAll(\"c\", \"k\");\n85         txt = txt.replaceAll(\"q\", \"k\");\n86         txt = txt.replaceAll(\"x\", \"k\");\n87         txt = txt.replaceAll(\"v\", \"f\");\n88         txt = txt.replaceAll(\"dg\", \"2g\");\n89         txt = txt.replaceAll(\"tio\", \"sio\");\n90         txt = txt.replaceAll(\"tia\", \"sia\");\n91         txt = txt.replaceAll(\"d\", \"t\");\n92         txt = txt.replaceAll(\"ph\", \"fh\");\n93         txt = txt.replaceAll(\"b\", \"p\");\n94         txt = txt.replaceAll(\"sh\", \"s2\");\n95         txt = txt.replaceAll(\"z\", \"s\");\n96         txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n97         txt = txt.replaceAll(\"[aeiou]\", \"3\");\n98         txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n99         txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n100         txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n101         txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n102         txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n103         txt = txt.replaceAll(\"gh\", \"22\");\n104         txt = txt.replaceAll(\"g\", \"k\");\n105         txt = txt.replaceAll(\"s+\", \"S\");\n106         txt = txt.replaceAll(\"t+\", \"T\");\n107         txt = txt.replaceAll(\"p+\", \"P\");\n108         txt = txt.replaceAll(\"k+\", \"K\");\n109         txt = txt.replaceAll(\"f+\", \"F\");\n110         txt = txt.replaceAll(\"m+\", \"M\");\n111         txt = txt.replaceAll(\"n+\", \"N\");\n112         txt = txt.replaceAll(\"w3\", \"W3\");\n113         //txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n114         txt = txt.replaceAll(\"wh3\", \"Wh3\");\n115         txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n116         //txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n117         txt = txt.replaceAll(\"w\", \"2\");\n118         txt = txt.replaceAll(\"^h\", \"A\");\n119         txt = txt.replaceAll(\"h\", \"2\");\n120         txt = txt.replaceAll(\"r3\", \"R3\");\n121         txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n122         //txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n123         txt = txt.replaceAll(\"r\", \"2\");\n124         txt = txt.replaceAll(\"l3\", \"L3\");\n125         txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n126         //txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n127         txt = txt.replaceAll(\"l\", \"2\");\n128         //txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n129         //txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n130         //txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n131 \n132         // 5. Handle removals\n133         txt = txt.replaceAll(\"2\", \"\");\n134         txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n135         txt = txt.replaceAll(\"3\", \"\");\n136 \n137         // 6. put ten 1s on the end\n138         txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n139 \n140         // 7. take the first six characters as the code\n141         return txt.substring(0, 10);          // 1.0 truncates to 6\n142     }", "bm_classpath": "org.apache.commons.codec.language.Caverphone"}, {"bug_name": "Codec_11", "report_text": "> QuotedPrintableCodec does not support soft line break per the 'quoted-printable' example on Wikipedia\n> \n> Writing a unit test I discovered that the example Wikipedia uses for quoted-printable data does not decode but instead throws an exception.   \n> Their example is here: <http://en.wikipedia.org/wiki/Quoted-printable#Example>\n> test:\n>  String qpdata = \"If you believe that truth=3Dbeauty, then surely=20=\\r\\n\" +  \n>  \"mathematics is the most beautiful branch of philosophy.\";\n>  String expected = \"If you believe that truth=beauty, then surely \" +  \n>  \"mathematics is the most beautiful branch of philosophy.\";\n>  assertEquals( expected, new QuotedPrintableCodec().decode(qpdata) );\n> I suppose I could fix if you like but currently I'm not a registered developer. ", "test_name": "org.apache.commons.codec.net.QuotedPrintableCodecTest::testSkipNotEncodedCRLF", "test_method": "    @Test\n    public void testSkipNotEncodedCRLF() throws Exception {\n        String qpdata = \"CRLF in an\\n encoded text should be=20=\\r\\n\\rskipped in the\\r decoding.\";\n        String expected = \"CRLF in an encoded text should be skipped in the decoding.\";\n\n        QuotedPrintableCodec qpcodec = new QuotedPrintableCodec();\n        assertEquals(expected, qpcodec.decode(qpdata)); // <-- fails here\n    }", "error_message": "org.apache.commons.codec.DecoderException: Invalid URL encoding: not a valid digit (radix 16): 13\n\torg.apache.commons.codec.net.Utils.digit16(Utils.java:44)\n\torg.apache.commons.codec.net.QuotedPrintableCodec.decodeQuotedPrintable(QuotedPrintableCodec.java:229)\n\torg.apache.commons.codec.net.QuotedPrintableCodec.decode(QuotedPrintableCodec.java:275)\n\torg.apache.commons.codec.net.QuotedPrintableCodec.decode(QuotedPrintableCodec.java:324)\n\torg.apache.commons.codec.net.QuotedPrintableCodec.decode(QuotedPrintableCodec.java:344)\n\torg.apache.commons.codec.net.QuotedPrintableCodecTest.testSkipNotEncodedCRLF(QuotedPrintableCodecTest.java:300)", "buggy_method": "167 public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n168         if (bytes == null) {\n169             return null;\n170         }\n171         if (printable == null) {\n172             printable = PRINTABLE_CHARS;\n173         }\n174         ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n175         // encode up to buffer.length - 3, the last three octets will be treated\n176         // separately for simplification of note #3\n177                 // up to this length it is safe to add any byte, encoded or not\n178         for (byte c : bytes) {\n179             int b = c;\n180             if (b < 0) {\n181                 b = 256 + b;\n182             }\n183             if (printable.get(b)) {\n184                 buffer.write(b);\n185             } else {\n186                 // rule #3: whitespace at the end of a line *must* be encoded\n187 \n188                 // rule #5: soft line break\n189                 encodeQuotedPrintable(b, buffer);\n190             }\n191         }\n192 \n193         // rule #3: whitespace at the end of a line *must* be encoded\n194         // if we would do a soft break line after this octet, encode whitespace\n195 \n196         // note #3: '=' *must not* be the ultimate or penultimate character\n197         // simplification: if < 6 bytes left, do a soft line break as we may need\n198         //                 exactly 6 bytes space for the last 2 bytes\n199             // rule #3: trailing whitespace shall be encoded\n200 \n201         return buffer.toByteArray();\n202     }", "bm_classpath": "org.apache.commons.codec.net.QuotedPrintableCodec"}, {"bug_name": "Codec_15", "report_text": "> Bug in HW rule in Soundex\n> \n> The Soundex algorithm says that if two characters that map to the same code are separated by H or W, the second one is not encoded.  \n> However, in the implementation (in Soundex.getMappingCode() line 191), a character that is preceded by two characters that are either H or W, is not encoded, regardless of what the last consonant was.  \n> Source: <http://en.wikipedia.org/wiki/Soundex#American_Soundex>", "test_name": "org.apache.commons.codec.language.SoundexTest::testHWRuleEx1", "test_method": "    @Test\n    public void testHWRuleEx1() {\n        // From\n        // http://www.archives.gov/research_room/genealogy/census/soundex.html:\n        // Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1\n        // for the F). It is not coded A-226.\n        Assert.assertEquals(\"Y330\", this.getStringEncoder().encode(\"yhwdyt\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Y3[3]0> but was:<Y3[0]0>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.codec.language.SoundexTest.testHWRuleEx1(SoundexTest.java:232)", "buggy_method": "183 private char getMappingCode(final String str, final int index) {\n184         // map() throws IllegalArgumentException\n185         final char mappedChar = this.map(str.charAt(index));\n186         // HW rule check\n187         if (index > 1 && mappedChar != '0') {\n188             final char hwChar = str.charAt(index - 1);\n189             if ('H' == hwChar || 'W' == hwChar) {\n190                 final char preHWChar = str.charAt(index - 2);\n191                 final char firstCode = this.map(preHWChar);\n192                 if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n193                     return 0;\n194                 }\n195             }\n196         }\n197         return mappedChar;\n198     }", "bm_classpath": "org.apache.commons.codec.language.Soundex"}, {"bug_name": "Codec_17", "report_text": "> StringUtils.newStringxxx(null) should return null, not NPE\n> \n> Method calls such as StringUtils.newStringIso8859\\_1(null) should return null, not NPE.\n> It looks like this capability was lost with the fix for [~~CODEC-136~~](https://issues.apache.org/jira/browse/CODEC-136 \"Use Charset objects when possible, create Charsets class for required character encodings\"), i.e.  \n> <http://svn.apache.org/viewvc?rev=1306366&view=rev>\n> Several methods were changed from\n> ```\n> return StringUtils.newString(bytes, CharEncoding.xxx);\n> to\n> return new String(bytes, Charsets.xxx);\n> ```\n> The new code should have been:\n> ```\n> return newString(bytes, Charsets.xxx);\n> ```\n> The newString method handles null input.\n> There were no tests for null input so the change in behaviour was missed.", "test_name": "org.apache.commons.codec.binary.StringUtilsTest::testNewStringNullInput_CODEC229", "test_method": "    @Test\n    public void testNewStringNullInput_CODEC229() {\n        Assert.assertNull(StringUtils.newStringIso8859_1(null)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tjava.lang.String.<init>(String.java:515)\n\torg.apache.commons.codec.binary.StringUtils.newStringIso8859_1(StringUtils.java:339)\n\torg.apache.commons.codec.binary.StringUtilsTest.testNewStringNullInput_CODEC229(StringUtilsTest.java:151)", "buggy_method": "338 public static String newStringIso8859_1(final byte[] bytes) {\n339         return new String(bytes, Charsets.ISO_8859_1);\n340     }", "bm_classpath": "org.apache.commons.codec.binary.StringUtils"}, {"bug_name": "Codec_18", "report_text": "> StringUtils.equals(CharSequence cs1, CharSequence cs2) can fail with String Index OBE\n> \n> StringUtils.equals(CharSequence cs1, CharSequence cs2) fails with String Index OBE if the two sequences are different lengths.", "test_name": "org.apache.commons.codec.binary.StringUtilsTest::testEqualsCS1", "test_method": "    @Test\n    public void testEqualsCS1() {\n        Assert.assertFalse(StringUtils.equals(new StringBuilder(\"abc\"), new StringBuilder(\"abcd\"))); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 3\n\tjava.lang.AbstractStringBuilder.charAt(AbstractStringBuilder.java:237)\n\tjava.lang.StringBuilder.charAt(StringBuilder.java:76)\n\torg.apache.commons.codec.binary.CharSequenceUtils.regionMatches(CharSequenceUtils.java:59)\n\torg.apache.commons.codec.binary.StringUtils.equals(StringUtils.java:81)\n\torg.apache.commons.codec.binary.StringUtilsTest.testEqualsCS1(StringUtilsTest.java:228)", "buggy_method": "71 public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n72         if (cs1 == cs2) {\n73             return true;\n74         }\n75         if (cs1 == null || cs2 == null) {\n76             return false;\n77         }\n78         if (cs1 instanceof String && cs2 instanceof String) {\n79             return cs1.equals(cs2);\n80         }\n81         return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n82     }", "bm_classpath": "org.apache.commons.codec.binary.StringUtils"}, {"bug_name": "Collections_25", "report_text": "> IteratorUtils.collatedIterator do not use natural ordering if no comparator was provided\n> \n> In case a null comparator was provided natural ordering should be used, as stated in the javadoc.\n> In fact an exception is thrown the first time the returned iterator is used.", "test_name": "org.apache.commons.collections4.IteratorUtilsTest::testCollatedIterator", "test_method": "    @Test\n    public void testCollatedIterator() {\n        try {\n            IteratorUtils.collatedIterator(null, collectionOdd.iterator(), null);\n            fail(\"expecting NullPointerException\");\n        } catch (NullPointerException npe) {\n            // expected\n        }\n\n        try {\n            IteratorUtils.collatedIterator(null, null, collectionEven.iterator());\n            fail(\"expecting NullPointerException\");\n        } catch (NullPointerException npe) {\n            // expected\n        }\n\n        // natural ordering\n        Iterator<Integer> it = \n                IteratorUtils.collatedIterator(null, collectionOdd.iterator(), collectionEven.iterator());\n\n        List<Integer> result = IteratorUtils.toList(it); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException: You must invoke setComparator() to set a comparator first.\n\torg.apache.commons.collections4.iterators.CollatingIterator.least(CollatingIterator.java:366)\n\torg.apache.commons.collections4.iterators.CollatingIterator.next(CollatingIterator.java:251)\n\torg.apache.commons.collections4.IteratorUtils.toList(IteratorUtils.java:1147)\n\torg.apache.commons.collections4.IteratorUtils.toList(IteratorUtils.java:1122)\n\torg.apache.commons.collections4.IteratorUtilsTest.testCollatedIterator(IteratorUtilsTest.java:943)", "buggy_method": "646 public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n647                                                    final Collection<Iterator<? extends E>> iterators) {\n648         return new CollatingIterator<E>(comparator, iterators);\n649     }", "bm_classpath": "org.apache.commons.collections4.IteratorUtils"}, {"bug_name": "Collections_26", "report_text": "> MultiKey subclassing has deserialization problem since COLLECTIONS-266: either declare protected readResolve() or MultiKey must be final\n> \n> MultiKey from collections 4 provides a transient hashCode and a **private** readResolve to resolve [~~COLLECTIONS-266~~](https://issues.apache.org/jira/browse/COLLECTIONS-266 \"Issue with MultiKey when serialized/deserialized via RMI\"): Issue with MultiKey when serialized/deserialized via RMI.\n> Unfortunately the solution does not work in case of **subclassing**: readResolve in MultiKey should be declared **protected** readResolve() to be called during deserialization of the subclass. Otherwise MultiKey must be final to avoid such subclassing.\n> **Testcase**:\n> **MultiKeySerializationTest.java**\n> ```\n> package de.ivu.test.common.collections4;\n> import static org.junit.Assert.assertEquals;\n> import java.io.ByteArrayInputStream;\n> import java.io.ByteArrayOutputStream;\n> import java.io.IOException;\n> import java.io.ObjectInputStream;\n> import java.io.ObjectOutputStream;\n> import org.apache.commons.collections4.keyvalue.MultiKey;\n> import org.junit.Test;\n> public class MultiKeySerializationTest {\n>     @Test\n>     @SuppressWarnings(\"unchecked\")\n>     public void testReadResolveEqualHashCode()\n>             throws IOException, ClassNotFoundException {\n>         class MultiKey2<A, B>\n>                 extends MultiKey {\n>             private static final long serialVersionUID = 1928896152249821416L;\n>             public MultiKey2(A key1, B key2) {\n>                 super(key1, key2);\n>             }\n>             public A getFirst() {\n>                 return (A) getKey(0);\n>             }\n>             public B getSecond() {\n>                 return (B) getKey(1);\n>             }\n>             \n>             // FIXME: MultiKey should either declare protected readResolve() or must be final.\n>         }\n>         MultiKey2<String, String> one = new MultiKey2<>(\"bla\", \"blub\");\n>         System.out.println(one.hashCode());\n>         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n>         ObjectOutputStream out = new ObjectOutputStream(byteOut);\n>         out.writeObject(one);\n>         out.close();\n>         byte[] serialized = byteOut.toByteArray();\n>         ByteArrayInputStream byteIn = new ByteArrayInputStream(serialized);\n>         ObjectInputStream in = new ObjectInputStream(byteIn);\n>         MultiKey2<String, String> two = (MultiKey2<String, String>) in.readObject();\n>         System.out.println(two.hashCode());\n>         assertEquals(\"hashCode must be equal - please check for protected readResolve in MultiKey\\*\", one.hashCode(),\n>             two.hashCode());\n>     }\n> }\n> ```\n> **Fix:**\n> **MultiKey.java**\n> ```\n> @@ -274,7 +274,7 @@\n>       * only stable for the same process).\n>       * @return the instance with recalculated hash code\n>       */\n> -    private Object readResolve() {\n> +    protected Object readResolve() {\n>          calculateHashCode(keys);\n>          return this;\n>      }\n> ```", "test_name": "org.apache.commons.collections4.keyvalue.MultiKeyTest::testEqualsAfterSerializationOfDerivedClass", "test_method": "    public void testEqualsAfterSerializationOfDerivedClass() throws IOException, ClassNotFoundException\n    {\n        final DerivedMultiKey<?> mk = new DerivedMultiKey<String>(\"A\", \"B\");\n\n        // serialize\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(baos);\n        out.writeObject(mk);\n        out.close();\n\n        // deserialize\n        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        final ObjectInputStream in = new ObjectInputStream(bais);\n        final DerivedMultiKey<?> mk2 = (DerivedMultiKey<?>)in.readObject();\n        in.close();\n\n        assertEquals(mk.hashCode(), mk2.hashCode()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<3> but was:<0>\n\torg.apache.commons.collections4.keyvalue.MultiKeyTest.testEqualsAfterSerializationOfDerivedClass(MultiKeyTest.java:292)", "buggy_method": "277 private Object readResolve() {\n278         calculateHashCode(keys);\n279         return this;\n280     }", "bm_classpath": "org.apache.commons.collections4.keyvalue.MultiKey"}, {"bug_name": "Compress_1", "report_text": "> CPIO reports unexpected EOF\n> \n> When unpacking an CPIO archive (made with the compress classes or even made with OSX cpio comandline tool) an EOF exception is thrown.  \n> Here is the testcode:\n>  final File input = getFile(\"cmdcreated.cpio\");\n>  final InputStream in = new FileInputStream(input);  \n>  CpioArchiveInputStream cin = new CpioArchiveInputStream(in);\n>  CpioArchiveEntry entry = null;\n>  while ((entry = (CpioArchiveEntry) cin.getNextCPIOEntry()) != null) \n> {\n>  File target = new File(dir, entry.getName());\n>  final OutputStream out = new FileOutputStream(target);\n>  IOUtils.copy(in, out);\n>  out.close();\n>  }\n>  cin.close();\n> Stacktrace is here:\n> java.io.EOFException  \n>  at org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.readFully(CpioArchiveInputStream.java:293)  \n>  at org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.getNextCPIOEntry(CpioArchiveInputStream.java:168)  \n>  at org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest.testCpioUnpack(CpioArchiveInputStreamTest.java:26)  \n>  ...\n> This happens with the first read access to the archive. It occured while my try to improve the testcases.", "test_name": "org.apache.commons.compress.archivers.CpioTestCase::testCpioUnarchive", "test_method": "    public void testCpioUnarchive() throws Exception {\n        final File output = new File(dir, \"bla.cpio\");\n        {\n            final File file1 = getFile(\"test1.xml\");\n            final File file2 = getFile(\"test2.xml\");\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"cpio\", out);\n            os.putArchiveEntry(new CpioArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new CpioArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n\n            os.close();\n            out.close();\n        }\n\n        // Unarchive Operation\n        final File input = output;\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"cpio\", is);\n\n\n        Map result = new HashMap();\n        ArchiveEntry entry = null;\n        while ((entry = in.getNextEntry()) != null) {\n            File target = new File(dir, entry.getName());\n            final OutputStream out = new FileOutputStream(target);\n            IOUtils.copy(in, out);\n            out.close();\n            result.put(entry.getName(), target);\n        } // <-- fails here\n    }", "error_message": "java.io.EOFException\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.readFully(CpioArchiveInputStream.java:293)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.getNextCPIOEntry(CpioArchiveInputStream.java:168)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.getNextEntry(CpioArchiveInputStream.java:421)\n\torg.apache.commons.compress.archivers.CpioTestCase.testCpioUnarchive(CpioTestCase.java:82)", "buggy_method": "344 public void close() throws IOException {\n345         if (!this.closed) {\n346             super.close();\n347             this.closed = true;\n348         }\n349     }", "bm_classpath": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"}, {"bug_name": "Compress_2", "report_text": "> Ar doesn't delete correct\n> \n> When working on the Testcases i figured out that a deletion from an Ar Archive is not as successful as it look at first glance.  \n> For example: my bla.ar file contains test1.xml and test2.xml. I delete test2.xml\n> The \"getNextEntry\" Method just delivers test1.xml. Looks correct.\n> But checking the result file at commandline brings the following:\n> $> ar -t /tmp/dir26673/bla.ar  \n> test1.xml  \n> test2.xml\n> vi shows me that there is still the test2.xml entry in the archive,  \n> even when getNextEntry returns null.\n> Deleting test2.xml and adding test.txt afterward brings the following:\n> $> ar -t /tmp/dir24825/bla.ar  \n> test.txt  \n> ar: /tmp/dir24825/bla.ar: Inappropriate file type or format", "test_name": "org.apache.commons.compress.archivers.ArTestCase::testArDelete", "test_method": "    public void testArDelete() throws Exception {\n        final File output = new File(dir, \"bla.ar\");\n\n        final File file1 = getFile(\"test1.xml\");\n        final File file2 = getFile(\"test2.xml\");\n        {\n            // create\n\n            final OutputStream out = new FileOutputStream(output);\n            final ArchiveOutputStream os = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", out);\n            os.putArchiveEntry(new ArArchiveEntry(\"test1.xml\", file1.length()));\n            IOUtils.copy(new FileInputStream(file1), os);\n            os.closeArchiveEntry();\n\n            os.putArchiveEntry(new ArArchiveEntry(\"test2.xml\", file2.length()));\n            IOUtils.copy(new FileInputStream(file2), os);\n            os.closeArchiveEntry();\n            os.close();\n            out.close();\n        }\n\n\n        final File output2 = new File(dir, \"bla2.ar\");\n\n        int copied = 0;\n        int deleted = 0;\n\n        {\n            // remove all but one file\n\n            final InputStream is = new FileInputStream(output);\n            final OutputStream os = new FileOutputStream(output2);\n            final ArchiveOutputStream aos = new ArchiveStreamFactory().createArchiveOutputStream(\"ar\", os);\n            final ArchiveInputStream ais = new ArchiveStreamFactory().createArchiveInputStream(new BufferedInputStream(is));\n            while(true) {\n                final ArArchiveEntry entry = (ArArchiveEntry)ais.getNextEntry();\n                if (entry == null) {\n                    break;\n                }\n\n                if (\"test1.xml\".equals(entry.getName())) {\n                    aos.putArchiveEntry(entry);\n                    IOUtils.copy(ais, aos);\n                    aos.closeArchiveEntry();\n                    copied++;\n                } else {\n                    IOUtils.copy(ais, new ByteArrayOutputStream());\n                    deleted++;\n                }\n\n            }\n            ais.close();\n            aos.close();\n            is.close();\n            os.close();\n        }\n\n        assertEquals(1, deleted); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\torg.apache.commons.compress.archivers.ArTestCase.testArDelete(ArTestCase.java:151)", "buggy_method": "59 public ArArchiveEntry getNextArEntry() throws IOException {\n60                     // hit EOF before previous entry was complete\n61                     // TODO: throw an exception instead?\n62 \n63         if (offset == 0) {\n64             final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n65             final byte[] realized = new byte[expected.length]; \n66             final int read = read(realized);\n67             if (read != expected.length) {\n68                 throw new IOException(\"failed to read header\");\n69             }\n70             for (int i = 0; i < expected.length; i++) {\n71                 if (expected[i] != realized[i]) {\n72                     throw new IOException(\"invalid header \" + new String(realized));\n73                 }\n74             }\n75         }\n76 \n77                 // hit eof\n78 \n79         if (input.available() == 0) {\n80             return null;\n81         }\n82 \n83         if (offset % 2 != 0) {\n84             read();\n85         }\n86         final byte[] name = new byte[16];\n87         final byte[] lastmodified = new byte[12];\n88         final byte[] userid = new byte[6];\n89         final byte[] groupid = new byte[6];\n90         final byte[] filemode = new byte[8];\n91         final byte[] length = new byte[10];\n92 \n93         read(name);\n94         read(lastmodified);\n95         read(userid);\n96         read(groupid);\n97         read(filemode);\n98         read(length);\n99 \n100         {\n101             final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n102             final byte[] realized = new byte[expected.length]; \n103             final int read = read(realized);\n104             if (read != expected.length) {\n105                 throw new IOException(\"failed to read entry header\");\n106             }\n107             for (int i = 0; i < expected.length; i++) {\n108                 if (expected[i] != realized[i]) {\n109                     throw new IOException(\"invalid entry header. not read the content?\");\n110                 }\n111             }\n112         }\n113 \n114         return new ArArchiveEntry(new String(name).trim(),\n115                                           Long.parseLong(new String(length)\n116                                                          .trim()));\n117     }", "bm_classpath": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream"}, {"bug_name": "Compress_3", "report_text": "> Are the public finish() methods ArchiveOutputStream implementations necessary and safe?\n> \n> Some of the ArchiveOutputStream implementations have public finish() methods. These are currently only called from the close() methods.\n> Seems to me that there is no need to allow the finish() methods to be called externally, and the user can corrupt the output if they do.\n> Surely the close() method is all that is needed?", "test_name": "org.apache.commons.compress.archivers.ArchiveOutputStreamTest::testFinish", "test_method": "    public void testFinish() throws Exception {\n        OutputStream out1 = new ByteArrayOutputStream();\n        \n        ArchiveOutputStream aos1 = factory.createArchiveOutputStream(\"zip\", out1);\n        aos1.putArchiveEntry(new ZipArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"jar\", out1);\n        aos1.putArchiveEntry(new JarArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"ar\", out1);\n        aos1.putArchiveEntry(new ArArchiveEntry(\"dummy\", 100));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"cpio\", out1);\n        aos1.putArchiveEntry(new CpioArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        }\n        \n        aos1 = factory.createArchiveOutputStream(\"tar\", out1);\n        aos1.putArchiveEntry(new TarArchiveEntry(\"dummy\"));\n        try {\n            aos1.finish();\n            fail(\"After putArchive should follow closeArchive\");\n        } catch (IOException io) {\n            // Exception expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: After putArchive should follow closeArchive\n\torg.apache.commons.compress.archivers.ArchiveOutputStreamTest.testFinish(ArchiveOutputStreamTest.java:67)", "buggy_method": "111 public void finish() throws IOException {\n112         writeEOFRecord();\n113         writeEOFRecord();\n114     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"}, {"bug_name": "Compress_4", "report_text": "> Are the public finish() methods ArchiveOutputStream implementations necessary and safe?\n> \n> Some of the ArchiveOutputStream implementations have public finish() methods. These are currently only called from the close() methods.\n> Seems to me that there is no need to allow the finish() methods to be called externally, and the user can corrupt the output if they do.\n> Surely the close() method is all that is needed?", "test_name": "org.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest::testJarMarker", "test_method": "    public void testJarMarker() throws IOException {\n        File testArchive = File.createTempFile(\"jar-aostest\", \".jar\");\n        JarArchiveOutputStream out = null;\n        ZipFile zf = null;\n        try {\n\n            out = new JarArchiveOutputStream(new FileOutputStream(testArchive));\n            out.putArchiveEntry(new ZipArchiveEntry(\"foo/\"));\n            out.closeArchiveEntry();\n            out.putArchiveEntry(new ZipArchiveEntry(\"bar/\"));\n            out.closeArchiveEntry();\n            out.finish();\n            out.close();\n            out = null;\n\n            zf = new ZipFile(testArchive);\n            ZipArchiveEntry ze = zf.getEntry(\"foo/\");\n            assertNotNull(ze);\n            ZipExtraField[] fes = ze.getExtraFields();\n            assertEquals(1, fes.length);\n            assertTrue(fes[0] instanceof JarMarker);\n\n            ze = zf.getEntry(\"bar/\");\n            assertNotNull(ze);\n            fes = ze.getExtraFields();\n            assertEquals(0, fes.length);\n        } finally {\n            if (out != null) {\n                try {\n                    out.close();\n                } catch (IOException e) { /* swallow */ }\n            }\n            ZipFile.closeQuietly(zf);\n            if (testArchive.exists()) {\n                testArchive.delete();\n            }\n        } // <-- fails here\n    }", "error_message": "java.io.IOException: central directory is empty, can't expand corrupt archive.\n\torg.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:318)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:181)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:158)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:119)\n\torg.apache.commons.compress.archivers.jar.JarArchiveOutputStreamTest.testJarMarker(JarArchiveOutputStreamTest.java:48)", "buggy_method": "334 public void close() throws IOException {\n335         if (!this.closed) {\n336             this.finish();\n337             out.close();\n338             this.closed = true;\n339         }\n340     }", "bm_classpath": "org.apache.commons.compress.archivers.cpio.CpioArchiveOutputStream"}, {"bug_name": "Compress_5", "report_text": "> ZipArchiveInputStream doesn't report the end of a truncated archive\n> \n> If a Zip archive is truncated, (e.g. because it is the first volume in a multi-volume archive) the ZipArchiveInputStream.read() method will not detect that fact. All calls to read() will return 0 bytes read. They will not return -1 (end of stream), nor will they throw any exception (which would seem like a good idea to me because the archive is truncated).\n> I have tracked this problem to ZipArchiveInputStream.java, line 239. It contains a check\n> if (read == 0 && inf.finished()) {  \n>  return -1;  \n> }\n> For truncated archives the read is always zero but the inf is never finished(). I suggest adding two lines below:\n> if (read == 0 && inf.finished()) {  \n>  return -1;  \n> } else if (read == 0 && lengthOfLastRead == -1) {  \n>  throw new IOException(\"Truncated ZIP file\");  \n> }\n> This solves the problem in my tests.", "test_name": "org.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest::testRead7ZipMultiVolumeArchiveForStream", "test_method": "    public void testRead7ZipMultiVolumeArchiveForStream() throws IOException,\n\t    URISyntaxException {\n\t\n\tURL zip = getClass().getResource(\"/apache-maven-2.2.1.zip.001\");\n\tFileInputStream archive = new FileInputStream(\n\t\tnew File(new URI(zip.toString())));\n\tZipArchiveInputStream zi = null;\n\ttry {\n\t    zi = new ZipArchiveInputStream(archive,null,false);\n\t    \n\t    // these are the entries that are supposed to be processed\n\t    // correctly without any problems\n\t    for (int i = 0; i < ENTRIES.length; i++) {\n\t\tassertEquals(ENTRIES[i], zi.getNextEntry().getName());\n\t    }\n\t    \n\t    // this is the last entry that is truncated\n\t    ArchiveEntry lastEntry = zi.getNextEntry();\n\t    assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n\t    byte [] buffer = new byte [4096];\n\t    \n\t    // before the fix, we'd get 0 bytes on this read and all\n\t    // subsequent reads thus a client application might enter\n\t    // an infinite loop after the fix, we should get an\n\t    // exception\n\t    try {\n                int read = 0;\n\t\twhile ((read = zi.read(buffer)) > 0) { }\n\t\tfail(\"shouldn't be able to read from truncated entry\");\n\t    } catch (IOException e) {\n                assertEquals(\"Truncated ZIP file\", e.getMessage());\n\t    }\n\t    \n\t    // and now we get another entry, which should also yield\n\t    // an exception\n\t    try {\n\t\tzi.getNextEntry();\n\t\tfail(\"shouldn't be able to read another entry from truncated\"\n                     + \" file\");\n\t    } catch (IOException e) {\n\t\t// this is to be expected\n\t    }\n\t} finally {\n\t    if (zi != null) {\n\t\tzi.close();\n\t    }\n\t} // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: shouldn't be able to read from truncated entry\n\torg.apache.commons.compress.archivers.zip.Maven221MultiVolumeTest.testRead7ZipMultiVolumeArchiveForStream(Maven221MultiVolumeTest.java:97)", "buggy_method": "191 public int read(byte[] buffer, int start, int length) throws IOException {\n192         if (closed) {\n193             throw new IOException(\"The stream is closed\");\n194         }\n195         if (inf.finished() || current == null) {\n196             return -1;\n197         }\n198 \n199         // avoid int overflow, check null buffer\n200         if (start <= buffer.length && length >= 0 && start >= 0\n201             && buffer.length - start >= length) {\n202             if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n203                 int csize = (int) current.getSize();\n204                 if (readBytesOfEntry >= csize) {\n205                     return -1;\n206                 }\n207                 if (offsetInBuffer >= lengthOfLastRead) {\n208                     offsetInBuffer = 0;\n209                     if ((lengthOfLastRead = in.read(buf)) == -1) {\n210                         return -1;\n211                     }\n212                     count(lengthOfLastRead);\n213                     bytesReadFromStream += lengthOfLastRead;\n214                 }\n215                 int toRead = length > lengthOfLastRead\n216                     ? lengthOfLastRead - offsetInBuffer\n217                     : length;\n218                 if ((csize - readBytesOfEntry) < toRead) {\n219                     toRead = csize - readBytesOfEntry;\n220                 }\n221                 System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n222                 offsetInBuffer += toRead;\n223                 readBytesOfEntry += toRead;\n224                 crc.update(buffer, start, toRead);\n225                 return toRead;\n226             }\n227             if (inf.needsInput()) {\n228                 fill();\n229                 if (lengthOfLastRead > 0) {\n230                     bytesReadFromStream += lengthOfLastRead;\n231                 }\n232             }\n233             int read = 0;\n234             try {\n235                 read = inf.inflate(buffer, start, length);\n236             } catch (DataFormatException e) {\n237                 throw new ZipException(e.getMessage());\n238             }\n239             if (read == 0 && inf.finished()) {\n240                 return -1;\n241             }\n242             crc.update(buffer, start, read);\n243             return read;\n244         }\n245         throw new ArrayIndexOutOfBoundsException();\n246     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"}, {"bug_name": "Compress_6", "report_text": "> Creating zip files with many entries will ocassionally produce corrupted output\n> \n> Our application produces large numbers of zip files, often with 1000's of similarly named files contained within the zip.   \n> When we switched from the standard JDK zip classes to those in commons compress, we would ocassionally produce a zip file that had corrupted index entries and would fail to unzip successfully using 7-zip, winzip, etc.\n> Debugging the zip creation showed that the the wrong offsets were being returned from the hashmap in ZipOutputStream for the entries that were being corrupted. Further analysis revealed that this occurred when the filenames being added had a hash collision with another entry in the same output zip (which appears to happen quite frequently for us).\n> The issue appears to stem from the fact that ZipArchiveEntry can store the entry name either in its superclass if passed in on the ctor or in its own member attribute if set later via setName(). Not sure whether this functionality is really required? Regardless, the root cause of the bug is that the equals() and hashCode() methods in ZipArchiveEntry do not always use the same filename value in their comparisons. In fact if the filename of the entry is set in the ctor it will always treat two ZipArchiveEntries as equal. This will break the offset hashmap whenever there is a hash collision as it will overwrite the previous entry, believeing it to be equal.\n> Patch to follow.", "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNotEquals", "test_method": "    public void testNotEquals() {\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"bar\");\n        assertFalse(entry1.equals(entry2)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNotEquals(ZipArchiveEntryTest.java:230)", "buggy_method": "62 public ZipArchiveEntry(String name) {\n63         super(name);\n64     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry"}, {"bug_name": "Compress_7", "report_text": "> TarUtils.parseName does not properly handle characters outside the range 0-127\n> \n> if a tarfile contains files with special characters, the names of the tar entries are wrong.\n> example:  \n> correct name: 0302-0601-3\u00b1\u00b1\u00b1F06\u00b1W220\u00b1ZB\u00b1LALALA\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1CAN\u00b1\u00b1DC\u00b1\u00b1\u00b104\u00b1060302\u00b1MOE.model  \n> name resolved by TarUtils.parseName: 0302-0101-3\uffb1\uffb1\uffb1F06\uffb1W220\uffb1ZB\uffb1HECKMODUL\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1ECE\uffb1\uffb1DC\uffb1\uffb1\uffb107\uffb1060302\uffb1DOERN.model\n> please use:   \n> result.append(new String(new byte[] \n> { buffer[i] }\n> ));\n> instead of:   \n> result.append((char) buffer[i]);\n> to solve this encoding problem.", "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripNames", "test_method": "    public void testRoundTripNames(){\n        checkName(\"\");\n        checkName(\"The quick brown fox\\n\");\n        checkName(\"\\177\");\n        // checkName(\"\\0\"); // does not work, because NUL is ignored\n        // COMPRESS-114\n        checkName(\"0302-0601-3F06W220ZBLALALACANDC04060302MOE.model\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<0302-0601-3[\u00b1\u00b1\u00b1F06\u00b1W220\u00b1ZB\u00b1LALALA\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1\u00b1CAN\u00b1\u00b1DC\u00b1\u00b1\u00b104\u00b1060302\u00b1]MOE.model> but was:<0302-0601-3[\uffb1\uffb1\uffb1F06\uffb1W220\uffb1ZB\uffb1LALALA\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1\uffb1CAN\uffb1\uffb1DC\uffb1\uffb1\uffb104\uffb1060302\uffb1]MOE.model>\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.checkName(TarUtilsTest.java:132)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripNames(TarUtilsTest.java:126)", "buggy_method": "93 public static String parseName(byte[] buffer, final int offset, final int length) {\n94         StringBuffer result = new StringBuffer(length);\n95         int          end = offset + length;\n96 \n97         for (int i = offset; i < end; ++i) {\n98             if (buffer[i] == 0) {\n99                 break;\n100             }\n101             result.append((char) buffer[i]);\n102         }\n103 \n104         return result.toString();\n105     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_8", "report_text": "> TarArchiveEntry.parseTarHeader() includes the trailing space/NUL when parsing the octal size\n> \n> TarArchiveEntry.parseTarHeader() includes the trailing space/NUL when parsing the octal size.\n> Although the size field in the header is 12 bytes, the last byte is supposed to be space or NUL - i.e. only 11 octal digits are allowed for the size.", "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctalInvalid", "test_method": "    public void testParseOctalInvalid() throws Exception{\n        byte [] buffer;\n        buffer=new byte[0]; // empty byte array\n        try {\n            TarUtils.parseOctal(buffer,0, buffer.length);\n            fail(\"Expected IllegalArgumentException - should be at least 2 bytes long\");\n        } catch (IllegalArgumentException expected) {\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected IllegalArgumentException - should be at least 2 bytes long\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctalInvalid(TarUtilsTest.java:66)", "buggy_method": "51 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n52         long    result = 0;\n53         boolean stillPadding = true;\n54         int     end = offset + length;\n55         int     start = offset;\n56 \n57         for (int i = start; i < end; i++){\n58             final byte currentByte = buffer[i];\n59             if (currentByte == 0) {\n60                 break;\n61             }\n62 \n63         // Skip leading spaces\n64             if (currentByte == (byte) ' ' || currentByte == '0') {\n65                 if (stillPadding) {\n66                    continue;\n67             }\n68                 if (currentByte == (byte) ' ') {\n69                 break;\n70                 }\n71             }\n72 \n73         // Must have trailing NUL or space\n74         // May have additional NUL or space\n75 \n76             stillPadding = false;\n77             // CheckStyle:MagicNumber OFF\n78             if (currentByte < '0' || currentByte > '7'){\n79                 throw new IllegalArgumentException(\n80                         exceptionMessage(buffer, offset, length, start, currentByte));\n81             }\n82             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n83             // CheckStyle:MagicNumber ON\n84         }\n85 \n86         return result;\n87     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_9", "report_text": "> TarArchiveOutputStream.getBytesWritten() returns invalid value\n> \n> It appears the TarArchiveOutputStream.getBytesWritten()returns zero or invalid value when queried.  \n> In the code sample below, it returns zero, even after an sizeable file was processed.  \n> I've printed it twice, once before closing the output stream, and once after, just for the reference.  \n> It is also demonstrable on multiple processed files.\n> Within the TarArchiveOutputStream.getBytesWritten() implementation, it appears the call for count(numToWrite) is made after the numToWrite is depleted in the process of actual byte writing. When call for count(numToWrite); is moved up, the returned values for TarArchiveOutputStream.getBytesWritten() are getting equal to the sum of the sizes of processed files. This is much closer to expected value (\"Returns the current number of bytes written to this stream.\") but still not correct, for that number should include the tar header sizes as well.\n> At any rate, please find the proposed patch below, merely moving count(numToWrite); up a few lines. This makes TarArchiveOutputStream.getBytesWritten() closer to true value.\n> Test code:\n> ```\n> @Test\n> \tpublic void tartest() throws Exception {\n> \t\t\n> \t\tFileOutputStream myOutputStream = new FileOutputStream(\"C:/temp/tartest.tar\");\n> \t\t\n> \t\tArchiveOutputStream sTarOut = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.TAR, myOutputStream);\n> \t\t\n> \t\tFile sSource = new File(\"C:/share/od\\_l.txt\");\n> \t\tTarArchiveEntry sEntry = new TarArchiveEntry(sSource);\n> \t\tsTarOut.putArchiveEntry(sEntry);\n> \t\t\n> \t\tFileInputStream sInput = new FileInputStream(sSource);\n> \t\tbyte[] cpRead = new byte[8192];\n> \t\t\n> \t\tint iRead = 0;\n> \t\twhile ((iRead = sInput.read(cpRead)) > 0) {\n> \t\t\tsTarOut.write(cpRead, 0, iRead);\n> \t\t}\n> \t\t\n> \t\tsLog.info(\"Processed: \"+sTarOut.getBytesWritten()+\" bytes. File Len: \"+sSource.length());\n> \t\t\n> \t\tsInput.close();\n> \t\tsTarOut.closeArchiveEntry();\n> \t\tsTarOut.close();\n> \t\tsLog.info(\"Processed: \"+sTarOut.getBytesWritten()+\" bytes. File Len: \"+sSource.length());\n> \t\t\n> \t\treturn;\n> \t\t\t\n> \t}\n> ```\n> Test Output:\n> ```\n> Oct 21, 2011 9:09:28 AM com.cronsult.jndmpd.test.Backup tartest\n> INFO: Processed: 0 bytes. File Len: 186974208\n> Oct 21, 2011 9:09:28 AM com.cronsult.jndmpd.test.Backup tartest\n> INFO: Processed: 0 bytes. File Len: 186974208\n> ```\n> Proposed Patch:\n> ```\n> Index: src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\n> ===================================================================\n> --- src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\t(revision 1187150)\n> +++ src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java\t(working copy)\n> @@ -276,6 +276,8 @@\n>              // eliminate some of the buffer copying.\n>              //\n>          }\n> +        \n> +        count(numToWrite);\n>  \n>          if (assemLen > 0) {\n>              if ((assemLen + numToWrite) >= recordBuf.length) {\n> @@ -325,7 +327,7 @@\n>              wOffset += num;\n>          }\n>          \n> -        count(numToWrite);\n> +        \n>      }\n>  \n>      /**\n> ```", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testCount", "test_method": "    public void testCount() throws Exception {\n        File f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\n        f.deleteOnExit();\n        FileOutputStream fos = new FileOutputStream(f);\n\n        ArchiveOutputStream tarOut = new ArchiveStreamFactory()\n            .createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\n\n        File file1 = getFile(\"test1.xml\");\n        TarArchiveEntry sEntry = new TarArchiveEntry(file1);\n        tarOut.putArchiveEntry(sEntry);\n\n        FileInputStream in = new FileInputStream(file1);\n        byte[] buf = new byte[8192];\n\n        int read = 0;\n        while ((read = in.read(buf)) > 0) {\n            tarOut.write(buf, 0, read);\n        }\n\n        in.close();\n        tarOut.closeArchiveEntry();\n        tarOut.close();\n\n        assertEquals(f.length(), tarOut.getBytesWritten()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<10240> but was:<76>\n\torg.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testCount(TarArchiveOutputStreamTest.java:55)", "buggy_method": "266 @Override\n267     public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n268         if ((currBytes + numToWrite) > currSize) {\n269             throw new IOException(\"request to write '\" + numToWrite\n270                                   + \"' bytes exceeds size in header of '\"\n271                                   + currSize + \"' bytes for entry '\"\n272                                   + currName + \"'\");\n273 \n274             //\n275             // We have to deal with assembly!!!\n276             // The programmer can be writing little 32 byte chunks for all\n277             // we know, and we must assemble complete records for writing.\n278             // REVIEW Maybe this should be in TarBuffer? Could that help to\n279             // eliminate some of the buffer copying.\n280             //\n281         }\n282 \n283         if (assemLen > 0) {\n284             if ((assemLen + numToWrite) >= recordBuf.length) {\n285                 int aLen = recordBuf.length - assemLen;\n286 \n287                 System.arraycopy(assemBuf, 0, recordBuf, 0,\n288                                  assemLen);\n289                 System.arraycopy(wBuf, wOffset, recordBuf,\n290                                  assemLen, aLen);\n291                 buffer.writeRecord(recordBuf);\n292 \n293                 currBytes += recordBuf.length;\n294                 wOffset += aLen;\n295                 numToWrite -= aLen;\n296                 assemLen = 0;\n297             } else {\n298                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n299                                  numToWrite);\n300 \n301                 wOffset += numToWrite;\n302                 assemLen += numToWrite;\n303                 numToWrite = 0;\n304             }\n305         }\n306 \n307         //\n308         // When we get here we have EITHER:\n309         // o An empty \"assemble\" buffer.\n310         // o No bytes to write (numToWrite == 0)\n311         //\n312         while (numToWrite > 0) {\n313             if (numToWrite < recordBuf.length) {\n314                 System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n315                                  numToWrite);\n316 \n317                 assemLen += numToWrite;\n318 \n319                 break;\n320             }\n321 \n322             buffer.writeRecord(wBuf, wOffset);\n323 \n324             int num = recordBuf.length;\n325 \n326             currBytes += num;\n327             numToWrite -= num;\n328             wOffset += num;\n329         }\n330         count(numToWrite);\n331     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"}, {"bug_name": "Compress_10", "report_text": "> Cannot Read Winzip Archives With Unicode Extra Fields\n> \n> I have a zip file created with WinZip containing Unicode extra fields. Upon attempting to extract it with org.apache.commons.compress.archivers.zip.ZipFile, ZipFile.getInputStream() returns null for ZipArchiveEntries previously retrieved with ZipFile.getEntry() or even ZipFile.getEntries(). See UTF8ZipFilesTest.patch in the attachments for a test case exposing the bug. The original test case stopped short of trying to read the entries, that's why this wasn't flagged up before. \n> The problem lies in the fact that inside ZipFile.java entries are stored in a HashMap. However, at one point after populating the HashMap, the unicode extra fields are read, which leads to a change of the ZipArchiveEntry name, and therefore a change of its hash code. Because of this, subsequent gets on the HashMap fail to retrieve the original values.\n> ZipFile.patch contains an (admittedly simple-minded) fix for this problem by reconstructing the entries HashMap after the Unicode extra fields have been parsed. The purpose of this patch is mainly to show that the problem is indeed what I think, rather than providing a well-designed solution.\n> The patches have been tested against revision 1210416.", "test_name": "org.apache.commons.compress.archivers.zip.UTF8ZipFilesTest::testReadWinZipArchive", "test_method": "    public void testReadWinZipArchive() throws IOException, URISyntaxException {\n        URL zip = getClass().getResource(\"/utf8-winzip-test.zip\");\n        File archive = new File(new URI(zip.toString()));\n        ZipFile zf = null;\n        try {\n            zf = new ZipFile(archive, null, true);\n            assertCanRead(zf, ASCII_TXT);\n            assertCanRead(zf, EURO_FOR_DOLLAR_TXT);\n            assertCanRead(zf, OIL_BARREL_TXT);\n        } finally {\n            ZipFile.closeQuietly(zf);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: InputStream is null\n\torg.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.assertCanRead(UTF8ZipFilesTest.java:144)\n\torg.apache.commons.compress.archivers.zip.UTF8ZipFilesTest.testReadWinZipArchive(UTF8ZipFilesTest.java:133)", "buggy_method": "801 private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n802                                             entriesWithoutUTF8Flag)\n803         throws IOException {\n804         // changing the name of a ZipArchiveEntry is going to change\n805         // the hashcode - see COMPRESS-164\n806         // Map needs to be reconstructed in order to keep central\n807         // directory order\n808         for (ZipArchiveEntry ze : entries.keySet()) {\n809             OffsetEntry offsetEntry = entries.get(ze);\n810             long offset = offsetEntry.headerOffset;\n811             archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n812             byte[] b = new byte[SHORT];\n813             archive.readFully(b);\n814             int fileNameLen = ZipShort.getValue(b);\n815             archive.readFully(b);\n816             int extraFieldLen = ZipShort.getValue(b);\n817             int lenToSkip = fileNameLen;\n818             while (lenToSkip > 0) {\n819                 int skipped = archive.skipBytes(lenToSkip);\n820                 if (skipped <= 0) {\n821                     throw new RuntimeException(\"failed to skip file name in\"\n822                                                + \" local file header\");\n823                 }\n824                 lenToSkip -= skipped;\n825             }\n826             byte[] localExtraData = new byte[extraFieldLen];\n827             archive.readFully(localExtraData);\n828             ze.setExtra(localExtraData);\n829             offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n830                 + SHORT + SHORT + fileNameLen + extraFieldLen;\n831 \n832             if (entriesWithoutUTF8Flag.containsKey(ze)) {\n833                 String orig = ze.getName();\n834                 NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n835                 ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n836                                                          nc.comment);\n837                 if (!orig.equals(ze.getName())) {\n838                     nameMap.remove(orig);\n839                     nameMap.put(ze.getName(), ze);\n840                 }\n841             }\n842         }\n843     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipFile"}, {"bug_name": "Compress_11", "report_text": "> createArchiveInputStream detects text files less than 100 bytes as tar archives\n> \n> The fix for [~~COMPRESS-117~~](https://issues.apache.org/jira/browse/COMPRESS-117 \"Certain tar files not recognised by ArchiveStreamFactory\") which modified ArchiveStreamFactory().createArchiveInputStream(inputstream) results in short text files (empirically seems to be those <= 100 bytes) being detected as tar archives which obviously is not desirable if one wants to know whether or not the files are archives.  \n> I'm not an expert on compressed archives but perhaps the heuristic that if a stream is interpretable as a tar file without an exception being thrown should only be applied on archives greater than 100 bytes?", "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::shortTextFilesAreNoTARs", "test_method": "    @Test\n    public void shortTextFilesAreNoTARs() throws Exception {\n        try {\n            new ArchiveStreamFactory()\n                .createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: created an input stream for a non-archive\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs(ArchiveStreamFactoryTest.java:36)", "buggy_method": "197 public ArchiveInputStream createArchiveInputStream(final InputStream in)\n198             throws ArchiveException {\n199         if (in == null) {\n200             throw new IllegalArgumentException(\"Stream must not be null.\");\n201         }\n202 \n203         if (!in.markSupported()) {\n204             throw new IllegalArgumentException(\"Mark is not supported.\");\n205         }\n206 \n207         final byte[] signature = new byte[12];\n208         in.mark(signature.length);\n209         try {\n210             int signatureLength = in.read(signature);\n211             in.reset();\n212             if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n213                 return new ZipArchiveInputStream(in);\n214             } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n215                 return new JarArchiveInputStream(in);\n216             } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n217                 return new ArArchiveInputStream(in);\n218             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n219                 return new CpioArchiveInputStream(in);\n220             }\n221 \n222             // Dump needs a bigger buffer to check the signature;\n223             final byte[] dumpsig = new byte[32];\n224             in.mark(dumpsig.length);\n225             signatureLength = in.read(dumpsig);\n226             in.reset();\n227             if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n228                 return new DumpArchiveInputStream(in);\n229             }\n230 \n231             // Tar needs an even bigger buffer to check the signature; read the first block\n232             final byte[] tarheader = new byte[512];\n233             in.mark(tarheader.length);\n234             signatureLength = in.read(tarheader);\n235             in.reset();\n236             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n237                 return new TarArchiveInputStream(in);\n238             }\n239             // COMPRESS-117 - improve auto-recognition\n240             try {\n241                 TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n242                 tais.getNextEntry();\n243                 return new TarArchiveInputStream(in);\n244             } catch (Exception e) { // NOPMD\n245                 // can generate IllegalArgumentException as well as IOException\n246                 // autodetection, simply not a TAR\n247                 // ignored\n248             }\n249         } catch (IOException e) {\n250             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n251         }\n252 \n253         throw new ArchiveException(\"No Archiver found for the stream signature\");\n254     }", "bm_classpath": "org.apache.commons.compress.archivers.ArchiveStreamFactory"}, {"bug_name": "Compress_12", "report_text": "> TarArchiveInputStream throws IllegalArgumentException instead of IOException\n> \n> TarArchiveInputStream is throwing IllegalArgumentException instead of IOException on corrupt files, in direct contradiction to the Javadoc. Here is a stack-trace:\n> ```\n> java.lang.IllegalArgumentException: Invalid byte -1 at offset 7 in '<some bytes>' len=8\n> \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:86)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:790)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:308)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:198)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextEntry(TarArchiveInputStream.java:380)\n> \tat de.schlichtherle.truezip.fs.archive.tar.TarInputShop.<init>(TarInputShop.java:91)\n> \tat de.schlichtherle.truezip.fs.archive.tar.TarDriver.newTarInputShop(TarDriver.java:159)\n> \tat de.schlichtherle.truezip.fs.archive.tar.TarGZipDriver.newTarInputShop(TarGZipDriver.java:82)\n> \tat de.schlichtherle.truezip.fs.archive.tar.TarDriver.newInputShop(TarDriver.java:151)\n> \tat de.schlichtherle.truezip.fs.archive.tar.TarDriver.newInputShop(TarDriver.java:47)\n> \tat de.schlichtherle.truezip.fs.archive.FsDefaultArchiveController.mount(FsDefaultArchiveController.java:170)\n> \tat de.schlichtherle.truezip.fs.archive.FsFileSystemArchiveController$ResetFileSystem.autoMount(FsFileSystemArchiveController.java:98)\n> \tat de.schlichtherle.truezip.fs.archive.FsFileSystemArchiveController.autoMount(FsFileSystemArchiveController.java:47)\n> \tat de.schlichtherle.truezip.fs.archive.FsArchiveController.autoMount(FsArchiveController.java:129)\n> \tat de.schlichtherle.truezip.fs.archive.FsArchiveController.getEntry(FsArchiveController.java:160)\n> \tat de.schlichtherle.truezip.fs.archive.FsContextController.getEntry(FsContextController.java:117)\n> \tat de.schlichtherle.truezip.fs.FsDecoratingController.getEntry(FsDecoratingController.java:76)\n> \tat de.schlichtherle.truezip.fs.FsDecoratingController.getEntry(FsDecoratingController.java:76)\n> \tat de.schlichtherle.truezip.fs.FsConcurrentController.getEntry(FsConcurrentController.java:164)\n> \tat de.schlichtherle.truezip.fs.FsSyncController.getEntry(FsSyncController.java:108)\n> \tat de.schlichtherle.truezip.fs.FsFederatingController.getEntry(FsFederatingController.java:156)\n> \tat de.schlichtherle.truezip.nio.file.TFileSystem.newDirectoryStream(TFileSystem.java:348)\n> \tat de.schlichtherle.truezip.nio.file.TPath.newDirectoryStream(TPath.java:963)\n> \tat de.schlichtherle.truezip.nio.file.TFileSystemProvider.newDirectoryStream(TFileSystemProvider.java:344)\n> \tat java.nio.file.Files.newDirectoryStream(Files.java:400)\n> \tat com.googlecode.boostmavenproject.GetSourcesMojo.convertToJar(GetSourcesMojo.java:248)\n> \tat com.googlecode.boostmavenproject.GetSourcesMojo.download(GetSourcesMojo.java:221)\n> \tat com.googlecode.boostmavenproject.GetSourcesMojo.execute(GetSourcesMojo.java:111)\n> \tat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)\n> \t... 20 more\n> ```\n> Expected behavior: TarArchiveInputStream should wrap the IllegalArgumentException in an IOException.", "test_name": "org.apache.commons.compress.archivers.TarTestCase::testCOMPRESS178", "test_method": "    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid byte 0 at offset 2 in '00{NUL}0765{NUL}' len=8\n\torg.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:99)\n\torg.apache.commons.compress.archivers.tar.TarUtils.parseOctalOrBinary(TarUtils.java:130)\n\torg.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:815)\n\torg.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:314)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:198)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextEntry(TarArchiveInputStream.java:395)\n\torg.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178(TarTestCase.java:309)", "buggy_method": "172 public TarArchiveEntry getNextTarEntry() throws IOException {\n173         if (hasHitEOF) {\n174             return null;\n175         }\n176 \n177         if (currEntry != null) {\n178             long numToSkip = entrySize - entryOffset;\n179 \n180             while (numToSkip > 0) {\n181                 long skipped = skip(numToSkip);\n182                 if (skipped <= 0) {\n183                     throw new RuntimeException(\"failed to skip current tar entry\");\n184                 }\n185                 numToSkip -= skipped;\n186             }\n187 \n188             readBuf = null;\n189         }\n190 \n191         byte[] headerBuf = getRecord();\n192 \n193         if (hasHitEOF) {\n194             currEntry = null;\n195             return null;\n196         }\n197 \n198         currEntry = new TarArchiveEntry(headerBuf);\n199         entryOffset = 0;\n200         entrySize = currEntry.getSize();\n201 \n202         if (currEntry.isGNULongNameEntry()) {\n203             // read in the name\n204             StringBuffer longName = new StringBuffer();\n205             byte[] buf = new byte[SMALL_BUFFER_SIZE];\n206             int length = 0;\n207             while ((length = read(buf)) >= 0) {\n208                 longName.append(new String(buf, 0, length));\n209             }\n210             getNextEntry();\n211             if (currEntry == null) {\n212                 // Bugzilla: 40334\n213                 // Malformed tar file - long entry name not followed by entry\n214                 return null;\n215             }\n216             // remove trailing null terminator\n217             if (longName.length() > 0\n218                 && longName.charAt(longName.length() - 1) == 0) {\n219                 longName.deleteCharAt(longName.length() - 1);\n220             }\n221             currEntry.setName(longName.toString());\n222         }\n223 \n224         if (currEntry.isPaxHeader()){ // Process Pax headers\n225             paxHeaders();\n226         }\n227 \n228         if (currEntry.isGNUSparse()){ // Process sparse files\n229             readGNUSparse();\n230         }\n231 \n232         // If the size of the next element in the archive has changed\n233         // due to a new size being reported in the posix header\n234         // information, we update entrySize here so that it contains\n235         // the correct value.\n236         entrySize = currEntry.getSize();\n237         return currEntry;\n238     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"}, {"bug_name": "Compress_13", "report_text": "> ArchiveInputStream#getNextEntry(): Problems with WinZip directories with Umlauts\n> \n> There is a problem when handling a WinZip-created zip with Umlauts in directories.\n> I'm accessing a zip file created with WinZip containing a directory with an umlaut (\"\u00e4\") with ArchiveInputStream. When creating the zip file the unicode-flag of winzip had been active.\n> The following problem occurs when accessing the entries of the zip:  \n> the ArchiveEntry for a directory containing an umlaut is not marked as a directory and the file names for the directory and all files contained in that directory contain backslashes instead of slashes (i.e. completely different to all other files in directories with no umlaut in their path).\n> There is no difference when letting the ArchiveStreamFactory decide which ArchiveInputStream to create or when using the ZipArchiveInputStream constructor with the correct encoding (I've tried different encodings CP437, CP850, ISO-8859-15, but still the problem persisted).\n> This problem does not occur when using the very same zip file but compressed by 7zip or the built-in Windows 7 zip functionality.", "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::winzipBackSlashWorkaround", "test_method": "    @Test\n    public void winzipBackSlashWorkaround() throws Exception {\n        URL zip = getClass().getResource(\"/test-winzip.zip\");\n        ZipArchiveInputStream in = null;\n        try {\n            in = new ZipArchiveInputStream(new FileInputStream(new File(new URI(zip.toString()))));\n            ZipArchiveEntry zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            assertEquals(\"\\u00e4/\", zae.getName());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<\u00e4[/]> but was:<\u00e4[\\]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.winzipBackSlashWorkaround(ZipArchiveInputStreamTest.java:43)", "buggy_method": "511 protected void setName(String name) {\n512         this.name = name;\n513     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry"}, {"bug_name": "Compress_14", "report_text": "> Tar files created by AIX native tar, and which contain symlinks, cannot be read by TarArchiveInputStream\n> \n> A simple tar file created on AIX using the native (/usr/bin/tar tar utility) **and** which contains a symbolic link, cannot be loaded by TarArchiveInputStream:\n> ```\n> java.io.IOException: Error detected parsing the header\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:201)\n> \tat Extractor.extract(Extractor.java:13)\n> \tat Extractor.main(Extractor.java:28)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n> \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n> \tat java.lang.reflect.Method.invoke(Method.java:597)\n> \tat org.apache.tools.ant.taskdefs.ExecuteJava.run(ExecuteJava.java:217)\n> \tat org.apache.tools.ant.taskdefs.ExecuteJava.execute(ExecuteJava.java:152)\n> \tat org.apache.tools.ant.taskdefs.Java.run(Java.java:771)\n> \tat org.apache.tools.ant.taskdefs.Java.executeJava(Java.java:221)\n> \tat org.apache.tools.ant.taskdefs.Java.executeJava(Java.java:135)\n> \tat org.apache.tools.ant.taskdefs.Java.execute(Java.java:108)\n> \tat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n> \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n> \tat java.lang.reflect.Method.invoke(Method.java:597)\n> \tat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n> \tat org.apache.tools.ant.Task.perform(Task.java:348)\n> \tat org.apache.tools.ant.Target.execute(Target.java:390)\n> \tat org.apache.tools.ant.Target.performTasks(Target.java:411)\n> \tat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n> \tat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\n> \tat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n> \tat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\n> \tat org.apache.tools.ant.Main.runBuild(Main.java:809)\n> \tat org.apache.tools.ant.Main.startAnt(Main.java:217)\n> \tat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\n> \tat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\n> Caused by: java.lang.IllegalArgumentException: Invalid byte 0 at offset 0 in '{NUL}1722000726 ' len=12\n> \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:99)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:819)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:314)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:199)\n> \t... 29 more\n> ```\n> Tested with 1.2 and the 1.4 nightly build from Feb 23 (Implementation-Build: trunk@r1292625; 2012-02-23 03:20:30+0000)", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::workaroundForBrokenTimeHeader", "test_method": "    @Test\n    public void workaroundForBrokenTimeHeader() throws Exception {\n        URL tar = getClass().getResource(\"/simple-aix-native-tar.tar\");\n        TarArchiveInputStream in = null;\n        try {\n            in = new TarArchiveInputStream(new FileInputStream(new File(new URI(tar.toString()))));\n            TarArchiveEntry tae = in.getNextTarEntry();\n            tae = in.getNextTarEntry();\n            assertEquals(\"sample/link-to-txt-file.lnk\", tae.getName());\n            assertEquals(new Date(0), tae.getLastModifiedDate());\n            assertTrue(tae.isSymbolicLink());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        } // <-- fails here\n    }", "error_message": "java.io.IOException: Error detected parsing the header\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:201)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.workaroundForBrokenTimeHeader(TarArchiveInputStreamTest.java:57)", "buggy_method": "56 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n57         long    result = 0;\n58         int     end = offset + length;\n59         int     start = offset;\n60 \n61         if (length < 2){\n62             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n63         }\n64 \n65         boolean allNUL = true;\n66         for (int i = start; i < end; i++){\n67             if (buffer[i] != 0){\n68                 allNUL = false;\n69                 break;\n70             }\n71         }\n72         if (allNUL) {\n73             return 0L;\n74         }\n75 \n76         // Skip leading spaces\n77         while (start < end){\n78             if (buffer[start] == ' '){\n79                 start++;\n80             } else {\n81                 break;\n82             }\n83         }\n84 \n85         // Must have trailing NUL or space\n86         byte trailer;\n87         trailer = buffer[end-1];\n88         if (trailer == 0 || trailer == ' '){\n89             end--;\n90         } else {\n91             throw new IllegalArgumentException(\n92                     exceptionMessage(buffer, offset, length, end-1, trailer));\n93         }\n94         // May have additional NUL or space\n95         trailer = buffer[end-1];\n96         if (trailer == 0 || trailer == ' '){\n97             end--;\n98         }\n99 \n100         for ( ;start < end; start++) {\n101             final byte currentByte = buffer[start];\n102             // CheckStyle:MagicNumber OFF\n103             if (currentByte < '0' || currentByte > '7'){\n104                 throw new IllegalArgumentException(\n105                         exceptionMessage(buffer, offset, length, start, currentByte));\n106             }\n107             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n108             // CheckStyle:MagicNumber ON\n109         }\n110 \n111         return result;\n112     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_15", "report_text": "> ZipArchiveInputStream and ZipFile don't produce equals ZipArchiveEntry instances\n> \n> I'm trying to use a ZipArchiveEntry coming from ZipArchiveInputStream that I stored somwhere for later with a ZipFile and it does not work.\n> The reason is that it can't find the ZipArchiveEntry in the ZipFile entries map. It is exactly the same zip file but both entries are not equals so the Map#get fail.\n> As far as I can see the main difference is that comment is null in ZipArchiveInputStream while it's en empty string in ZipFile. I looked at ZipArchiveInputStream and it looks like the comment (whatever it is) is simply not parsed while I can find some code related to the comment at the end of ZIipFile#readCentralDirectoryEntry.\n> Note that java.util.zip does not have this issue. Did not checked what they do but the zip entries are equals.", "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveEntryTest::testNullCommentEqualsEmptyComment", "test_method": "    public void testNullCommentEqualsEmptyComment() {\n        ZipArchiveEntry entry1 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry2 = new ZipArchiveEntry(\"foo\");\n        ZipArchiveEntry entry3 = new ZipArchiveEntry(\"foo\");\n        entry1.setComment(null);\n        entry2.setComment(\"\");\n        entry3.setComment(\"bar\");\n        assertEquals(entry1, entry2); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<foo> but was:<foo>\n\torg.apache.commons.compress.archivers.zip.ZipArchiveEntryTest.testNullCommentEqualsEmptyComment(ZipArchiveEntryTest.java:250)", "buggy_method": "648 @Override\n649     public boolean equals(Object obj) {\n650         if (this == obj) {\n651             return true;\n652         }\n653         if (obj == null || getClass() != obj.getClass()) {\n654             return false;\n655         }\n656         ZipArchiveEntry other = (ZipArchiveEntry) obj;\n657         String myName = getName();\n658         String otherName = other.getName();\n659         if (myName == null) {\n660             if (otherName != null) {\n661                 return false;\n662             }\n663         } else if (!myName.equals(otherName)) {\n664             return false;\n665         }\n666         String myComment = getComment();\n667         String otherComment = other.getComment();\n668         if (myComment == null) {\n669             if (otherComment != null) {\n670                 return false;\n671             }\n672         } else if (!myComment.equals(otherComment)) {\n673             return false;\n674         }\n675         return getTime() == other.getTime()\n676             && getInternalAttributes() == other.getInternalAttributes()\n677             && getPlatform() == other.getPlatform()\n678             && getExternalAttributes() == other.getExternalAttributes()\n679             && getMethod() == other.getMethod()\n680             && getSize() == other.getSize()\n681             && getCrc() == other.getCrc()\n682             && getCompressedSize() == other.getCompressedSize()\n683             && Arrays.equals(getCentralDirectoryExtra(),\n684                              other.getCentralDirectoryExtra())\n685             && Arrays.equals(getLocalFileDataExtra(),\n686                              other.getLocalFileDataExtra())\n687             && gpb.equals(other.gpb);\n688     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry"}, {"bug_name": "Compress_16", "report_text": "> Too relaxed tar detection in ArchiveStreamFactory\n> \n> The relaxed tar detection logic added in [~~COMPRESS-117~~](https://issues.apache.org/jira/browse/COMPRESS-117 \"Certain tar files not recognised by ArchiveStreamFactory\") unfortunately matches also some non-tar files like a [test AIFF file](https://svn.apache.org/repos/asf/tika/trunk/tika-parsers/src/test/resources/test-documents/testAIFF.aif) that Apache Tika uses. It would be good to improve the detection heuristics to still match files like the one in [~~COMPRESS-117~~](https://issues.apache.org/jira/browse/COMPRESS-117 \"Certain tar files not recognised by ArchiveStreamFactory\") but avoid false positives like the AIFF file in Tika.", "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::aiffFilesAreNoTARs", "test_method": "    @Test\n    public void aiffFilesAreNoTARs() throws Exception {\n        InputStream is = null;\n        try {\n            is = new BufferedInputStream(new FileInputStream(\"src/test/resources/testAIFF.aif\"));\n            new ArchiveStreamFactory().createArchiveInputStream(is);\n            fail(\"created an input stream for a non-archive\");\n        } catch (ArchiveException ae) {\n            assertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: created an input stream for a non-archive\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.ArchiveStreamFactoryTest.aiffFilesAreNoTARs(ArchiveStreamFactoryTest.java:56)", "buggy_method": "197 public ArchiveInputStream createArchiveInputStream(final InputStream in)\n198             throws ArchiveException {\n199         if (in == null) {\n200             throw new IllegalArgumentException(\"Stream must not be null.\");\n201         }\n202 \n203         if (!in.markSupported()) {\n204             throw new IllegalArgumentException(\"Mark is not supported.\");\n205         }\n206 \n207         final byte[] signature = new byte[12];\n208         in.mark(signature.length);\n209         try {\n210             int signatureLength = in.read(signature);\n211             in.reset();\n212             if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n213                 return new ZipArchiveInputStream(in);\n214             } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n215                 return new JarArchiveInputStream(in);\n216             } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n217                 return new ArArchiveInputStream(in);\n218             } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n219                 return new CpioArchiveInputStream(in);\n220             }\n221 \n222             // Dump needs a bigger buffer to check the signature;\n223             final byte[] dumpsig = new byte[32];\n224             in.mark(dumpsig.length);\n225             signatureLength = in.read(dumpsig);\n226             in.reset();\n227             if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n228                 return new DumpArchiveInputStream(in);\n229             }\n230 \n231             // Tar needs an even bigger buffer to check the signature; read the first block\n232             final byte[] tarheader = new byte[512];\n233             in.mark(tarheader.length);\n234             signatureLength = in.read(tarheader);\n235             in.reset();\n236             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n237                 return new TarArchiveInputStream(in);\n238             }\n239             // COMPRESS-117 - improve auto-recognition\n240             if (signatureLength >= 512) {\n241                 try {\n242                     TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n243                     // COMPRESS-191 - verify the header checksum\n244                     tais.getNextEntry();\n245                         return new TarArchiveInputStream(in);\n246                 } catch (Exception e) { // NOPMD\n247                     // can generate IllegalArgumentException as well\n248                     // as IOException\n249                     // autodetection, simply not a TAR\n250                     // ignored\n251                 }\n252             }\n253         } catch (IOException e) {\n254             throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n255         }\n256 \n257         throw new ArchiveException(\"No Archiver found for the stream signature\");\n258     }", "bm_classpath": "org.apache.commons.compress.archivers.ArchiveStreamFactory"}, {"bug_name": "Compress_17", "report_text": "> Tar file for Android backup cannot be read\n> \n> Attached tar file was generated by some kind of backup tool on Android. Normal tar utilities seem to handle it fine, but Commons Compress doesn't.\n> ```\n> java.lang.IllegalArgumentException: Invalid byte 0 at offset 5 in '01750{NUL}{NUL}{NUL}' len=8\n>     at org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:99)\n>     at org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:788)\n>     at org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:308)\n> ```", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::testCompress197", "test_method": "    @Test\n    public void testCompress197() throws Exception {\n        TarArchiveInputStream tar = getTestStream(\"/COMPRESS-197.tar\");\n        try {\n            TarArchiveEntry entry = tar.getNextTarEntry();\n            while (entry != null) {\n                entry = tar.getNextTarEntry();\n            }\n        } catch (IOException e) {\n            fail(\"COMPRESS-197: \" + e.getMessage());\n        } finally {\n            tar.close();\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: COMPRESS-197: Error detected parsing the header\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.testCompress197(TarArchiveInputStreamTest.java:134)", "buggy_method": "102 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n103         long    result = 0;\n104         int     end = offset + length;\n105         int     start = offset;\n106 \n107         if (length < 2){\n108             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n109         }\n110 \n111         if (buffer[start] == 0) {\n112             return 0L;\n113         }\n114 \n115         // Skip leading spaces\n116         while (start < end){\n117             if (buffer[start] == ' '){\n118                 start++;\n119             } else {\n120                 break;\n121             }\n122         }\n123 \n124         // Must have trailing NUL or space\n125         byte trailer;\n126         trailer = buffer[end-1];\n127         if (trailer == 0 || trailer == ' '){\n128             end--;\n129         } else {\n130             throw new IllegalArgumentException(\n131                     exceptionMessage(buffer, offset, length, end-1, trailer));\n132         }\n133         // May have additional NULs or spaces\n134         trailer = buffer[end - 1];\n135         if (trailer == 0 || trailer == ' '){\n136             end--;\n137         }\n138 \n139         for ( ;start < end; start++) {\n140             final byte currentByte = buffer[start];\n141             // CheckStyle:MagicNumber OFF\n142             if (currentByte < '0' || currentByte > '7'){\n143                 throw new IllegalArgumentException(\n144                         exceptionMessage(buffer, offset, length, start, currentByte));\n145             }\n146             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n147             // CheckStyle:MagicNumber ON\n148         }\n149 \n150         return result;\n151     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_18", "report_text": "> Long directory names can not be stored in a tar archive because of error when writing PAX headers\n> \n> Trying to add a directory to the TAR Archive that has a name longer than 100 bytes generates an exception with a stack trace similar to the following:\n> ```\n> java.io.IOException: request to write '114' bytes exceeds size in header of '0' bytes for entry './PaxHeaders.X/layers/openstreetmap__osm.disy.net/.tiles/1.0.0/openstreetmap__osm.disy.net/default/'\n>             at org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.write(TarArchiveOutputStream.java:385)\n>             at java.io.OutputStream.write(Unknown Source)\n>             at org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.writePaxHeaders(TarArchiveOutputStream.java:485)\n>             at org.apache.commons.compress.archivers.tar.TarArchiveOutputStream.putArchiveEntry(TarArchiveOutputStream.java:312)\n>             at net.disy.lib.io.tar.TarUtilities.addFile(TarUtilities.java:116)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:158)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.addDirectory(TarUtilities.java:162)\n>             at net.disy.lib.io.tar.TarUtilities.tar(TarUtilities.java:77)\n>             at net.disy.lib.io.tar.TarUtilities.tar(TarUtilities.java:42)\n>             at net.disy.gisterm.tilecacheset.export.TileCacheSetExporter.tarTreeStructure(TileCacheSetExporter.java:262)\n>             at net.disy.gisterm.tilecacheset.export.TileCacheSetExporter.export(TileCacheSetExporter.java:111)\n>             at net.disy.gisterm.tilecacheset.desktop.controller.ExportController$1.run(ExportController.java:81)\n>             ... 2 more\n> ```\n> Informal source code investigation points to the problem being that for directory entries the code assumes that the length is 0 in putArchiveEntry (see TarArchiveOutputStream:321 ) but when writing the data, it actually writes some data (the filename) and the length written (filename size) is larger than the length expected (0).", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest::testWriteNonAsciiDirectoryNamePosixMode", "test_method": "    public void testWriteNonAsciiDirectoryNamePosixMode() throws Exception {\n        String n = \"f\\u00f6\\u00f6/\";\n        TarArchiveEntry t = new TarArchiveEntry(n);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setAddPaxHeadersForNonAsciiNames(true);\n        tos.putArchiveEntry(t); // <-- fails here\n    }", "error_message": "java.io.IOException: request to write '15' bytes exceeds size in header of '0' bytes for entry './PaxHeaders.X/fvv/'\n\torg.apache.commons.compress.archivers.tar.TarArchiveOutputStream.write(TarArchiveOutputStream.java:387)\n\tjava.io.OutputStream.write(OutputStream.java:75)\n\torg.apache.commons.compress.archivers.tar.TarArchiveOutputStream.writePaxHeaders(TarArchiveOutputStream.java:489)\n\torg.apache.commons.compress.archivers.tar.TarArchiveOutputStream.putArchiveEntry(TarArchiveOutputStream.java:314)\n\torg.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testWriteNonAsciiDirectoryNamePosixMode(TarArchiveOutputStreamTest.java:418)", "buggy_method": "454 void writePaxHeaders(String entryName,\n455                          Map<String, String> headers) throws IOException {\n456         String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n457             // TarEntry's constructor would think this is a directory\n458             // and not allow any data to be written\n459         if (name.length() >= TarConstants.NAMELEN) {\n460             name = name.substring(0, TarConstants.NAMELEN - 1);\n461         }\n462         TarArchiveEntry pex = new TarArchiveEntry(name,\n463                                                   TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n464 \n465         StringWriter w = new StringWriter();\n466         for (Map.Entry<String, String> h : headers.entrySet()) {\n467             String key = h.getKey();\n468             String value = h.getValue();\n469             int len = key.length() + value.length()\n470                 + 3 /* blank, equals and newline */\n471                 + 2 /* guess 9 < actual length < 100 */;\n472             String line = len + \" \" + key + \"=\" + value + \"\\n\";\n473             int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n474             while (len != actualLength) {\n475                 // Adjust for cases where length < 10 or > 100\n476                 // or where UTF-8 encoding isn't a single octet\n477                 // per character.\n478                 // Must be in loop as size may go from 99 to 100 in\n479                 // first pass so we'd need a second.\n480                 len = actualLength;\n481                 line = len + \" \" + key + \"=\" + value + \"\\n\";\n482                 actualLength = line.getBytes(CharsetNames.UTF_8).length;\n483             }\n484             w.write(line);\n485         }\n486         byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n487         pex.setSize(data.length);\n488         putArchiveEntry(pex);\n489         write(data);\n490         closeArchiveEntry();\n491     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream"}, {"bug_name": "Compress_19", "report_text": "> ZipException on reading valid zip64 file\n> \n> ZipFile zip = new ZipFile(new File(\"ordertest-64.zip\")); throws ZipException \"central directory zip64 extended information extra field's length doesn't match central directory data. Expected length 16 but is 28\".\n> The archive was created by using DotNetZip-WinFormsTool uzing zip64 flag (forces always to make zip64 archives).\n> Zip file is tested from the console: $zip -T ordertest-64.zip\n> Output:  \n> test of ordertest-64.zip OK\n> I can open the archive with FileRoller without problem on my machine, browse and extract it.", "test_name": "org.apache.commons.compress.archivers.zip.ZipFileTest::testExcessDataInZip64ExtraField", "test_method": "    public void testExcessDataInZip64ExtraField() throws Exception {\n        File archive = getFile(\"COMPRESS-228.zip\");\n        zf = new ZipFile(archive); // <-- fails here\n    }", "error_message": "java.util.zip.ZipException: central directory zip64 extended information extra field's length doesn't match central directory data.  Expected length 16 but is 28\n\torg.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField.reparseCentralDirectoryData(Zip64ExtendedInformationExtraField.java:260)\n\torg.apache.commons.compress.archivers.zip.ZipFile.setSizesAndOffsetFromZip64Extra(ZipFile.java:619)\n\torg.apache.commons.compress.archivers.zip.ZipFile.readCentralDirectoryEntry(ZipFile.java:584)\n\torg.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:499)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:217)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:193)\n\torg.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:154)\n\torg.apache.commons.compress.archivers.zip.ZipFileTest.testExcessDataInZip64ExtraField(ZipFileTest.java:234)", "buggy_method": "249 public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n250                                             boolean hasCompressedSize,\n251                                             boolean hasRelativeHeaderOffset,\n252                                             boolean hasDiskStart)\n253         throws ZipException {\n254         if (rawCentralDirectoryData != null) {\n255             int expectedLength = (hasUncompressedSize ? DWORD : 0)\n256                 + (hasCompressedSize ? DWORD : 0)\n257                 + (hasRelativeHeaderOffset ? DWORD : 0)\n258                 + (hasDiskStart ? WORD : 0);\n259             if (rawCentralDirectoryData.length != expectedLength) {\n260                 throw new ZipException(\"central directory zip64 extended\"\n261                                        + \" information extra field's length\"\n262                                        + \" doesn't match central directory\"\n263                                        + \" data.  Expected length \"\n264                                        + expectedLength + \" but is \"\n265                                        + rawCentralDirectoryData.length);\n266             }\n267             int offset = 0;\n268             if (hasUncompressedSize) {\n269                 size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n270                 offset += DWORD;\n271             }\n272             if (hasCompressedSize) {\n273                 compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n274                                                          offset);\n275                 offset += DWORD;\n276             }\n277             if (hasRelativeHeaderOffset) {\n278                 relativeHeaderOffset =\n279                     new ZipEightByteInteger(rawCentralDirectoryData, offset);\n280                 offset += DWORD;\n281             }\n282             if (hasDiskStart) {\n283                 diskStart = new ZipLong(rawCentralDirectoryData, offset);\n284                 offset += WORD;\n285             }\n286         }\n287     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField"}, {"bug_name": "Compress_20", "report_text": "> IllegalArgumentException reading CPIO generated by Redline RPM\n> \n> <http://redline-rpm.org/> creates CPIO archives with a non-zero file mode on the trailer. This causes an IllegalArgumentException when reading the file. I've attached a patch and test archive to fix this.", "test_name": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest::testCpioUnarchiveCreatedByRedlineRpm", "test_method": "    public void testCpioUnarchiveCreatedByRedlineRpm() throws Exception {\n        CpioArchiveInputStream in =\n            new CpioArchiveInputStream(new FileInputStream(getFile(\"redline.cpio\")));\n        CpioArchiveEntry entry= null;\n\n        int count = 0;\n        while ((entry = (CpioArchiveEntry) in.getNextEntry()) != null) {\n            count++;\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Unknown mode. Full: 1a4 Masked: 0\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveEntry.setMode(CpioArchiveEntry.java:766)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.readNewEntry(CpioArchiveInputStream.java:332)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.getNextCPIOEntry(CpioArchiveInputStream.java:204)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStream.getNextEntry(CpioArchiveInputStream.java:450)\n\torg.apache.commons.compress.archivers.cpio.CpioArchiveInputStreamTest.testCpioUnarchiveCreatedByRedlineRpm(CpioArchiveInputStreamTest.java:55)", "buggy_method": "320 private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n321             throws IOException {\n322         CpioArchiveEntry ret;\n323         if (hasCrc) {\n324             ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n325         } else {\n326             ret = new CpioArchiveEntry(FORMAT_NEW);\n327         }\n328 \n329         ret.setInode(readAsciiLong(8, 16));\n330         long mode = readAsciiLong(8, 16);\n331         if (mode != 0){\n332             ret.setMode(mode);\n333         }\n334         ret.setUID(readAsciiLong(8, 16));\n335         ret.setGID(readAsciiLong(8, 16));\n336         ret.setNumberOfLinks(readAsciiLong(8, 16));\n337         ret.setTime(readAsciiLong(8, 16));\n338         ret.setSize(readAsciiLong(8, 16));\n339         ret.setDeviceMaj(readAsciiLong(8, 16));\n340         ret.setDeviceMin(readAsciiLong(8, 16));\n341         ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n342         ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n343         long namesize = readAsciiLong(8, 16);\n344         ret.setChksum(readAsciiLong(8, 16));\n345         String name = readCString((int) namesize);\n346         ret.setName(name);\n347         if (mode == 0 && !name.equals(CPIO_TRAILER)){\n348             throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n349         }\n350         skip(ret.getHeaderPadCount());\n351 \n352         return ret;\n353     }", "bm_classpath": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream"}, {"bug_name": "Compress_21", "report_text": "> Writing 7z empty entries produces incorrect or corrupt archive\n> \n> I couldn't find an exact rule that causes this incorrect behavior, but I tried to reduce it to some simple scenarios to reproduce it:\n> Input: A folder with certain files -> tried to archive it.  \n> If the folder contains more than 7 files the incorrect behavior appears.\n> Scenario 1: 7 empty files  \n> Result: The created archive contains a single folder entry with the name of the archive (no matter which was the name of the file)\n> Scenario 2: 7 files, some empty, some with content  \n> Result: The created archive contains a folder entry with the name of the archive and a number of file entries also with the name of the archive. The number of the entries is equal to the number of non empty files.\n> Scenario 3: 8 empty files  \n> Result: 7zip Manager cannot open archive and stops working.\n> Scenario 4.1: 8 files: some empty, some with content, last file (alphabetically) with content  \n> Result: same behavior as described for Scenario 2.\n> Scenario 4.2: 8 files, some empty, some with content, last file empy  \n> Result: archive is corrupt, the following message is received: \"Cannot open file 'archivename.7z' as archive\" (7Zip Manager does not crash).", "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest::testSevenEmptyFiles", "test_method": "    public void testSevenEmptyFiles() throws Exception {\n        testCompress252(7, 0); // <-- fails here\n    }", "error_message": "java.io.IOException: Unknown property 128\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.readFilesInfo(SevenZFile.java:714)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.readHeader(SevenZFile.java:241)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.readHeaders(SevenZFile.java:197)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:94)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:116)\n\torg.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.verifyCompress252(SevenZOutputFileTest.java:226)\n\torg.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testCompress252(SevenZOutputFileTest.java:221)\n\torg.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testSevenEmptyFiles(SevenZOutputFileTest.java:183)", "buggy_method": "634 private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n635         int cache = 0;\n636         int shift = 7;\n637         for (int i = 0; i < length; i++) {\n638             cache |= ((bits.get(i) ? 1 : 0) << shift);\n639             --shift;\n640             if (shift == 0) {\n641                 header.write(cache);\n642                 shift = 7;\n643                 cache = 0;\n644             }\n645         }\n646         if (length > 0 && shift > 0) {\n647             header.write(cache);\n648         }\n649     }", "bm_classpath": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile"}, {"bug_name": "Compress_22", "report_text": "> BZip2CompressorInputStream reads fewer bytes from truncated file than CPython's bz2 implementation\n> \n> Jython includes support for decompressing bz2 files using commons compress and shares regression tests with CPython. The CPython test [test\\_read\\_truncated](https://bitbucket.org/jython/jython/src/b2890af7a5e817e30f6ca2325f6dcdb14a59f32b/lib-python/2.7/test/test_bz2.py?at=default#cl-331) in test\\_bz2.py passes under CPython but fails under Jython.\n> The BZip2CompressorInputStream is able to read 769 bytes from the truncated data rather than the 770 bytes that the CPython bz2 implementation can read.", "test_name": "org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test::testPartialReadTruncatedData", "test_method": "    @Test\n    public void testPartialReadTruncatedData() throws IOException {\n        //with BZ2File(self.filename) as f:\n        //    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n        //    self.assertRaises(EOFError, f.read, 1)\n\n        final int length = TEXT.length();\n        ByteBuffer buffer = ByteBuffer.allocate(length);\n        bz2Channel.read(buffer); // <-- fails here\n    }", "error_message": "java.io.IOException: unexpected end of stream\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.bsR(BZip2CompressorInputStream.java:384)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.bsGetUByte(BZip2CompressorInputStream.java:419)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.initBlock(BZip2CompressorInputStream.java:276)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.setupNoRandPartA(BZip2CompressorInputStream.java:878)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.setupNoRandPartB(BZip2CompressorInputStream.java:928)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.read0(BZip2CompressorInputStream.java:222)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream.read(BZip2CompressorInputStream.java:174)\n\tjava.nio.channels.Channels$ReadableByteChannelImpl.read(Channels.java:385)\n\torg.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test.testPartialReadTruncatedData(PythonTruncatedBzip2Test.java:92)", "buggy_method": "129 public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n130         this.in = in;\n131         this.decompressConcatenated = decompressConcatenated;\n132 \n133         init(true);\n134         initBlock();\n135         setupBlock();\n136     }", "bm_classpath": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream"}, {"bug_name": "Compress_23", "report_text": "> 7z: 16 MB dictionary is too big\n> \n> I created an archiv with 7zip 9.20 containing the compress-1.7-src directory. Also tried it with 1.6 version and directory. I \n> downloaded the zip file and reziped it as 7z. The standard setting where used:  \n> Compression level: normal  \n> Compression method: lzma2  \n> Dictionary size: 16 MB  \n> Word size: 32  \n> Solid Block size: 2 GB\n> I get an exception if I try to open the file with the simple line of code:  \n> SevenZFile input = new SevenZFile(new File(arcName));\n> Maybe it is a bug in the tukaani library, but I do not know how to report it to them.  \n> The exception thrown:\n> org.tukaani.xz.UnsupportedOptionsException: LZMA dictionary is too big for this implementation  \n>  at org.tukaani.xz.LZMAInputStream.initialize(Unknown Source)  \n>  at org.tukaani.xz.LZMAInputStream.<init>(Unknown Source)  \n>  at org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder.decode(Coders.java:117)  \n>  at org.apache.commons.compress.archivers.sevenz.Coders.addDecoder(Coders.java:48)  \n>  at org.apache.commons.compress.archivers.sevenz.SevenZFile.readEncodedHeader(SevenZFile.java:278)  \n>  at org.apache.commons.compress.archivers.sevenz.SevenZFile.readHeaders(SevenZFile.java:190)  \n>  at org.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:94)  \n>  at org.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:116)  \n>  at compress.SevenZipError.main(SevenZipError.java:28)", "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest::testCompressedHeaderWithNonDefaultDictionarySize", "test_method": "    public void testCompressedHeaderWithNonDefaultDictionarySize() throws Exception {\n        SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-256.7z\")); // <-- fails here\n    }", "error_message": "org.tukaani.xz.UnsupportedOptionsException: LZMA dictionary is too big for this implementation\n\torg.tukaani.xz.LZMAInputStream.initialize(Unknown Source)\n\torg.tukaani.xz.LZMAInputStream.<init>(Unknown Source)\n\torg.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder.decode(Coders.java:117)\n\torg.apache.commons.compress.archivers.sevenz.Coders.addDecoder(Coders.java:48)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.readEncodedHeader(SevenZFile.java:278)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.readHeaders(SevenZFile.java:190)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:94)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.<init>(SevenZFile.java:116)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFileTest.testCompressedHeaderWithNonDefaultDictionarySize(SevenZFileTest.java:79)", "buggy_method": "106 @Override\n107         InputStream decode(final InputStream in, final Coder coder,\n108                 byte[] password) throws IOException {\n109             byte propsByte = coder.properties[0];\n110             long dictSize = coder.properties[1];\n111             for (int i = 1; i < 4; i++) {\n112                 dictSize |= (coder.properties[i + 1] << (8 * i));\n113             }\n114             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n115                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n116             }\n117             return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n118         }", "bm_classpath": "org.apache.commons.compress.archivers.sevenz.Coders$LZMADecoder"}, {"bug_name": "Compress_24", "report_text": "> TarArchiveInputStream fails to read entry with big user-id value\n> \n> Caused by: java.lang.IllegalArgumentException: Invalid byte 52 at offset 7 in '62410554' len=8  \n>  at org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:130)  \n>  at org.apache.commons.compress.archivers.tar.TarUtils.parseOctalOrBinary(TarUtils.java:175)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:953)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:940)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:324)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:247)  \n>  ... 5 more", "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal", "test_method": "    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid byte 55 at offset 11 in '777777777777' len=12\n\torg.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:132)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal(TarUtilsTest.java:53)", "buggy_method": "102 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n103         long    result = 0;\n104         int     end = offset + length;\n105         int     start = offset;\n106 \n107         if (length < 2){\n108             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n109         }\n110 \n111         if (buffer[start] == 0) {\n112             return 0L;\n113         }\n114 \n115         // Skip leading spaces\n116         while (start < end){\n117             if (buffer[start] == ' '){\n118                 start++;\n119             } else {\n120                 break;\n121             }\n122         }\n123 \n124         // Trim all trailing NULs and spaces.\n125         // The ustar and POSIX tar specs require a trailing NUL or\n126         // space but some implementations use the extra digit for big\n127         // sizes/uids/gids ...\n128         byte trailer = buffer[end - 1];\n129         if (trailer == 0 || trailer == ' '){\n130             end--;\n131         } else {\n132             throw new IllegalArgumentException(\n133                     exceptionMessage(buffer, offset, length, end-1, trailer));\n134         }\n135         trailer = buffer[end - 1];\n136         while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n137             end--;\n138             trailer = buffer[end - 1];\n139         }\n140 \n141         for ( ;start < end; start++) {\n142             final byte currentByte = buffer[start];\n143             // CheckStyle:MagicNumber OFF\n144             if (currentByte < '0' || currentByte > '7'){\n145                 throw new IllegalArgumentException(\n146                         exceptionMessage(buffer, offset, length, start, currentByte));\n147             }\n148             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n149             // CheckStyle:MagicNumber ON\n150         }\n151 \n152         return result;\n153     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_25", "report_text": "> ZIP reads correctly with commons-compress 1.6, gives NUL bytes in 1.7\n> \n> When running the code below, commons-compress 1.6 writes:\n>  Content of test.txt:  \n>  data\n> By comparison, commons-compress 1.7 writes\n>  Content of test.txt:  \n> @@@@^@\n> package com.example.jrn;  \n> import org.apache.commons.compress.archivers.zip.ZipArchiveEntry;  \n> import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;  \n> import java.io.ByteArrayInputStream;  \n> import java.io.IOException;  \n> import java.lang.System;  \n> /\\*\\*\n> * Hello world!  \n>  \\*  \n>  \\*/  \n> public class App {  \n>  public static void main(String[] args) {  \n>  byte[] zip = \n> {\n>  (byte)0x50, (byte)0x4b, (byte)0x03, (byte)0x04, (byte)0x0a, (byte)0x00,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x03, (byte)0x7b,\n>  (byte)0xd1, (byte)0x42, (byte)0x82, (byte)0xc5, (byte)0xc1, (byte)0xe6,\n>  (byte)0x05, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x05, (byte)0x00,\n>  (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x1c, (byte)0x00,\n>  (byte)0x74, (byte)0x65, (byte)0x73, (byte)0x74, (byte)0x2e, (byte)0x74,\n>  (byte)0x78, (byte)0x74, (byte)0x55, (byte)0x54, (byte)0x09, (byte)0x00,\n>  (byte)0x03, (byte)0x56, (byte)0x62, (byte)0xbf, (byte)0x51, (byte)0x2a,\n>  (byte)0x63, (byte)0xbf, (byte)0x51, (byte)0x75, (byte)0x78, (byte)0x0b,\n>  (byte)0x00, (byte)0x01, (byte)0x04, (byte)0x01, (byte)0xff, (byte)0x01,\n>  (byte)0x00, (byte)0x04, (byte)0x88, (byte)0x13, (byte)0x00, (byte)0x00,\n>  (byte)0x64, (byte)0x61, (byte)0x74, (byte)0x61, (byte)0x0a, (byte)0x50,\n>  (byte)0x4b, (byte)0x01, (byte)0x02, (byte)0x1e, (byte)0x03, (byte)0x0a,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x03,\n>  (byte)0x7b, (byte)0xd1, (byte)0x42, (byte)0x82, (byte)0xc5, (byte)0xc1,\n>  (byte)0xe6, (byte)0x05, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x05,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x08, (byte)0x00, (byte)0x18,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x01,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0xa0, (byte)0x81, (byte)0x00,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x74, (byte)0x65, (byte)0x73,\n>  (byte)0x74, (byte)0x2e, (byte)0x74, (byte)0x78, (byte)0x74, (byte)0x55,\n>  (byte)0x54, (byte)0x05, (byte)0x00, (byte)0x03, (byte)0x56, (byte)0x62,\n>  (byte)0xbf, (byte)0x51, (byte)0x75, (byte)0x78, (byte)0x0b, (byte)0x00,\n>  (byte)0x01, (byte)0x04, (byte)0x01, (byte)0xff, (byte)0x01, (byte)0x00,\n>  (byte)0x04, (byte)0x88, (byte)0x13, (byte)0x00, (byte)0x00, (byte)0x50,\n>  (byte)0x4b, (byte)0x05, (byte)0x06, (byte)0x00, (byte)0x00, (byte)0x00,\n>  (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x01, (byte)0x00, (byte)0x4e,\n>  (byte)0x00, (byte)0x00, (byte)0x00, (byte)0x47, (byte)0x00, (byte)0x00,\n>  (byte)0x00, (byte)0x00, (byte)00\n>  }\n> ;\n>  ByteArrayInputStream bin = new ByteArrayInputStream(zip);  \n>  try {  \n>  ZipArchiveInputStream in = new ZipArchiveInputStream(bin);  \n>  try {  \n>  while (true) {  \n>  ZipArchiveEntry entry = in.getNextZipEntry();  \n>  if (entry == null) \n> {\n>  break;\n>  }\n>  byte[] buf = new byte[(int) entry.getSize()];  \n>  in.read(buf);  \n>  System.out.println(\"Content of \" + entry.getName() + \":\");  \n>  System.out.write(buf);  \n>  }  \n>  } finally \n> {\n>  in.close();\n>  }\n>  } catch (IOException e) \n> {\n>  System.err.println(\"IOException: \" + e);\n>  }\n>  }  \n> }", "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::testReadingOfFirstStoredEntry", "test_method": "    @Test\n    public void testReadingOfFirstStoredEntry() throws Exception {\n        ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\n        \n        try {\n            ZipArchiveEntry ze = in.getNextZipEntry();\n            assertEquals(5, ze.getSize());\n            assertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\n                              IOUtils.toByteArray(in));\n        } finally {\n            in.close();\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<100> but was:<0>\n\torg.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\n\torg.junit.Assert.internalArrayEquals(Assert.java:473)\n\torg.junit.Assert.assertArrayEquals(Assert.java:294)\n\torg.junit.Assert.assertArrayEquals(Assert.java:305)\n\torg.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry(ZipArchiveInputStreamTest.java:166)", "buggy_method": "174 public ZipArchiveInputStream(InputStream inputStream,\n175                                  String encoding,\n176                                  boolean useUnicodeExtraFields,\n177                                  boolean allowStoredEntriesWithDataDescriptor) {\n178         zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n179         this.useUnicodeExtraFields = useUnicodeExtraFields;\n180         in = new PushbackInputStream(inputStream, buf.capacity());\n181         this.allowStoredEntriesWithDataDescriptor =\n182             allowStoredEntriesWithDataDescriptor;\n183         // haven't read anything so far\n184     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"}, {"bug_name": "Compress_26", "report_text": "> IOUtils.skip does not work as advertised\n> \n> I am trying to feed a TarInputStream from a CipherInputStream.  \n> It does not work, because IOUtils.skip() does not adhere to the contract it claims in javadoc:\n> \" \\* <p>This method will only skip less than the requested number of\n> * bytes if the end of the input stream has been reached.</p>\"\n> However it does:\n>  long skipped = input.skip(numToSkip);  \n>  if (skipped == 0) \n> {\n>  break;\n>  }\n> And the input stream javadoc says:\n> \" \\* This may result from any of a number of conditions; reaching end of file\n> * before <code>n</code> bytes have been skipped is only one possibility.\"\n> In the case of CipherInputStream, it stops at the end of each byte buffer.\n> If you check the IOUtils from colleagues at commons-io, they have considered this case in IOUtils.skip() where they use a read to skip through the stream.  \n> An optimized version could combine trying to skip, then read then trying to skip again.", "test_name": "org.apache.commons.compress.utils.IOUtilsTest::skipUsingRead", "test_method": "    @Test\n    public void skipUsingRead() throws Exception {\n        skip(new StreamWrapper() {\n                public InputStream wrap(InputStream toWrap) {\n                    return new FilterInputStream(toWrap) {\n                        public long skip(long s) {\n                            return 0;\n                        }\n                    };\n                }\n            }); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<10> but was:<0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.compress.utils.IOUtilsTest.skip(IOUtilsTest.java:80)\n\torg.apache.commons.compress.utils.IOUtilsTest.skipUsingRead(IOUtilsTest.java:45)", "buggy_method": "94 public static long skip(InputStream input, long numToSkip) throws IOException {\n95         long available = numToSkip;\n96         while (numToSkip > 0) {\n97             long skipped = input.skip(numToSkip);\n98             if (skipped == 0) {\n99                 break;\n100             }\n101             numToSkip -= skipped;\n102         }\n103             \n104         return available - numToSkip;\n105     }", "bm_classpath": "org.apache.commons.compress.utils.IOUtils"}, {"bug_name": "Compress_27", "report_text": "> Incorrect handling of NUL username and group Tar.gz entries\n> \n> With version 1.8 of commons-compress it's no longer possible to decompress files from an archive if the archive contains entries having null (or being empty?) set as username and/or usergroup. With version 1.7 this still worked now I get this exception:\n> ```\n> java.io.IOException: Error detected parsing the header\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:249)\n> \tat TestBed.AppTest.extractNoFileOwner(AppTest.java:30)\n> Caused by: java.lang.IllegalArgumentException: Invalid byte 32 at offset 7 in ' {NUL}' len=8\n> \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:134)\n> \tat org.apache.commons.compress.archivers.tar.TarUtils.parseOctalOrBinary(TarUtils.java:173)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:953)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.parseTarHeader(TarArchiveEntry.java:940)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveEntry.<init>(TarArchiveEntry.java:324)\n> \tat org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:247)\n> \t... 27 more\n> ```\n> This exception leads to my suspision that the regression was introduced with the fix for this ticket [~~COMPRESS-262~~](https://issues.apache.org/jira/browse/COMPRESS-262 \"TarArchiveInputStream fails to read entry with big user-id value\"), which has a nearly identical exception provided.\n> Some test code you can run to verify it:\n> ```\n> package TestBed;\n> import java.io.File;\n> import java.io.FileInputStream;\n> import java.io.FileNotFoundException;\n> import java.io.IOException;\n> import org.apache.commons.compress.archivers.tar.TarArchiveEntry;\n> import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n> import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;\n> import org.junit.Test;\n> /**\n>  * Unit test for simple App.\n>  */\n> public class AppTest\n> {\n>     @Test\n>     public void extractNoFileOwner()\n>     {\n>         TarArchiveInputStream tarInputStream = null;\n>         try\n>         {\n>             tarInputStream =\n>                 new TarArchiveInputStream( new GzipCompressorInputStream( new FileInputStream( new File(\n>                     \"/home/pknobel/redis-dist-2.8.3\\_1-linux.tar.gz\" ) ) ) );\n>             TarArchiveEntry entry;\n>             while ( ( entry = tarInputStream.getNextTarEntry() ) != null )\n>             {\n>                 System.out.println( entry.getName() );\n>                 System.out.println(entry.getUserName()+\"/\"+entry.getGroupName());\n>             }\n>         }\n>         catch ( FileNotFoundException e )\n>         {\n>             e.printStackTrace();\n>         }\n>         catch ( IOException e )\n>         {\n>             e.printStackTrace();\n>         }\n>     }\n> }\n> ```\n> With 1.7 the TestCase outputed this:\n> ```\n> redis-dist-2.8.3_1/bin/\n> /\n> redis-dist-2.8.3_1/bin/redis-server\n> jenkins/jenkins\n> redis-dist-2.8.3_1/bin/redis-cli\n> jenkins/jenkins\n> ```\n> With 1.8 it's failing once it reaches the null valued entry, which is the first. The archive is created using maven assembly plugin, and I tried the same with maven ant task. Both generating an archive with not set username and groups for at least some entries.\n> You can download the archive from <http://heli0s.darktech.org/redis/2.8.3_1/redis-dist-2.8.3_1-linux.tar.gz>\n> If you run a tar -tvzf on the file you see this report:\n> ```\n> drwxr-xr-x 0/0               0 2014-04-18 09:43 redis-dist-2.8.3_1-SNAPSHOT/bin/\n> -rwxr-xr-x pknobel/pknobel 3824588 2014-01-02 14:58 redis-dist-2.8.3_1-SNAPSHOT/bin/redis-cli\n> -rwxr-xr-x pknobel/pknobel 5217234 2014-01-02 14:58 redis-dist-2.8.3_1-SNAPSHOT/bin/redis-server\n> ```\n> The user 0/0 probably indicates that it's not set although it's the root user id. A correctly root user file would show up as root/root", "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest::testParseOctal", "test_method": "    public void testParseOctal() throws Exception{\n        long value; \n        byte [] buffer;\n        final long MAX_OCTAL  = 077777777777L; // Allowed 11 digits\n        final long MAX_OCTAL_OVERFLOW  = 0777777777777L; // in fact 12 for some implementations\n        final String maxOctal = \"777777777777\"; // Maximum valid octal\n        buffer = maxOctal.getBytes(CharsetNames.UTF_8);\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        buffer[buffer.length - 1] = ' ';\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        buffer[buffer.length-1]=0;\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        buffer=new byte[]{0,0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        buffer=new byte[]{0,' '};\n        value = TarUtils.parseOctal(buffer,0, buffer.length);\n        buffer=new byte[]{' ',0};\n        value = TarUtils.parseOctal(buffer,0, buffer.length); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid byte 32 at offset 1 in ' {NUL}' len=2\n\torg.apache.commons.compress.archivers.tar.TarUtils.parseOctal(TarUtils.java:134)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testParseOctal(TarUtilsTest.java:68)", "buggy_method": "102 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n103         long    result = 0;\n104         int     end = offset + length;\n105         int     start = offset;\n106 \n107         if (length < 2){\n108             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n109         }\n110 \n111         if (buffer[start] == 0) {\n112             return 0L;\n113         }\n114 \n115         // Skip leading spaces\n116         while (start < end){\n117             if (buffer[start] == ' '){\n118                 start++;\n119             } else {\n120                 break;\n121             }\n122         }\n123 \n124         // Trim all trailing NULs and spaces.\n125         // The ustar and POSIX tar specs require a trailing NUL or\n126         // space but some implementations use the extra digit for big\n127         // sizes/uids/gids ...\n128         byte trailer = buffer[end - 1];\n129         while (start < end && (trailer == 0 || trailer == ' ')) {\n130             end--;\n131             trailer = buffer[end - 1];\n132         }\n133         if (start == end) {\n134             throw new IllegalArgumentException(\n135                     exceptionMessage(buffer, offset, length, start, trailer));\n136         }\n137 \n138         for ( ;start < end; start++) {\n139             final byte currentByte = buffer[start];\n140             // CheckStyle:MagicNumber OFF\n141             if (currentByte < '0' || currentByte > '7'){\n142                 throw new IllegalArgumentException(\n143                         exceptionMessage(buffer, offset, length, start, currentByte));\n144             }\n145             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n146             // CheckStyle:MagicNumber ON\n147         }\n148 \n149         return result;\n150     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_28", "report_text": "> TarArchiveInputStream silently finished when unexpected EOF occured\n> \n> I just found the following test case didn't raise an IOException as it used to be for a **tar trimmed on purpose** \n> @Test  \n>  public void testCorruptedBzip2() throws IOException {  \n>  String archivePath = PathUtil.join(testdataDir, \"test.tar.bz2\");  \n>  TarArchiveInputStream input = null;  \n>  input = new TarArchiveInputStream(new BZip2CompressorInputStream(  \n>  GoogleFile.SYSTEM.newInputStream(archivePath), true));  \n>  ArchiveEntry nextMatchedEntry = input.getNextEntry();  \n>  while (nextMatchedEntry != null) \n> {\n>  logger.infofmt(\"Extracting %s\", nextMatchedEntry.getName());\n>  String outputPath = PathUtil.join(\"/tmp/\", nextMatchedEntry.getName());\n>  OutputStream out = new FileOutputStream(outputPath);\n>  ByteStreams.copy(input, out);\n>  out.close();\n>  nextMatchedEntry = input.getNextEntry();\n>  }\n>  }", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldThrowAnExceptionOnTruncatedEntries", "test_method": "public void shouldThrowAnExceptionOnTruncatedEntries() throws Exception {\n        File dir = mkdir(\"COMPRESS-279\");\n        TarArchiveInputStream is = getTestStream(\"/COMPRESS-279.tar\");\n        FileOutputStream out = null;\n        try {\n            TarArchiveEntry entry = is.getNextTarEntry();\n            int count = 0;\n            while (entry != null) {\n                out = new FileOutputStream(new File(dir, String.valueOf(count)));\n                IOUtils.copy(is, out);\n                out.close();\n                out = null;\n                count++;\n                entry = is.getNextTarEntry();\n            }\n        } finally {\n            is.close();\n            if (out != null) {\n                out.close();\n            }\n        }\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: java.io.IOException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "568 @Override\n569     public int read(byte[] buf, int offset, int numToRead) throws IOException {\n570     \tint totalRead = 0;\n571 \n572         if (hasHitEOF || entryOffset >= entrySize) {\n573             return -1;\n574         }\n575 \n576         if (currEntry == null) {\n577             throw new IllegalStateException(\"No current tar entry\");\n578         }\n579 \n580         numToRead = Math.min(numToRead, available());\n581         \n582         totalRead = is.read(buf, offset, numToRead);\n583         count(totalRead);\n584         \n585         if (totalRead == -1) {\n586             hasHitEOF = true;\n587         } else {\n588             entryOffset += totalRead;\n589         }\n590 \n591         return totalRead;\n592     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"}, {"bug_name": "Compress_29", "report_text": "> ArchiveStreamFactory fails to pass on the encoding when creating some streams\n> \n> ArchiveStreamFactory fails to pass on the encoding when creating the following streams (in some or all cases):\n> * ArjArchiveInputStream\n> * CpioArchiveInputStream\n> * DumpArchiveInputStream\n> * JarArchiveInputStream\n> * JarArchiveOutputStream", "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest::testEncodingInputStream", "test_method": "    @Test\n    public void testEncodingInputStream() throws Exception {\n        int failed = 0;\n        for(int i = 1; i <= TESTS.length; i++) {\n            TestData test = TESTS[i-1];\n            ArchiveInputStream ais = getInputStreamFor(test.type, test.testFile, test.fac);\n            final String field = getField(ais,test.fieldName);\n            if (!eq(test.expectedEncoding,field)) {\n                System.out.println(\"Failed test \" + i + \". expected: \" + test.expectedEncoding + \" actual: \" + field + \" type: \" + test.type);\n                failed++;\n            }\n        }\n        if (failed > 0) {\n            fail(\"Tests failed: \" + failed);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Tests failed: 20\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.ArchiveStreamFactoryTest.testEncodingInputStream(ArchiveStreamFactoryTest.java:319)", "buggy_method": "269 public ArchiveOutputStream createArchiveOutputStream(\n270             final String archiverName, final OutputStream out)\n271             throws ArchiveException {\n272         if (archiverName == null) {\n273             throw new IllegalArgumentException(\"Archivername must not be null.\");\n274         }\n275         if (out == null) {\n276             throw new IllegalArgumentException(\"OutputStream must not be null.\");\n277         }\n278 \n279         if (AR.equalsIgnoreCase(archiverName)) {\n280             return new ArArchiveOutputStream(out);\n281         }\n282         if (ZIP.equalsIgnoreCase(archiverName)) {\n283             ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n284             if (entryEncoding != null) {\n285                 zip.setEncoding(entryEncoding);\n286             }\n287             return zip;\n288         }\n289         if (TAR.equalsIgnoreCase(archiverName)) {\n290             if (entryEncoding != null) {\n291                 return new TarArchiveOutputStream(out, entryEncoding);\n292             } else {\n293                 return new TarArchiveOutputStream(out);\n294             }\n295         }\n296         if (JAR.equalsIgnoreCase(archiverName)) {\n297                 return new JarArchiveOutputStream(out);\n298         }\n299         if (CPIO.equalsIgnoreCase(archiverName)) {\n300             if (entryEncoding != null) {\n301                 return new CpioArchiveOutputStream(out, entryEncoding);\n302             } else {\n303                 return new CpioArchiveOutputStream(out);\n304             }\n305         }\n306         if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n307             throw new StreamingNotSupportedException(SEVEN_Z);\n308         }\n309         throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n310     }", "bm_classpath": "org.apache.commons.compress.archivers.ArchiveStreamFactory"}, {"bug_name": "Compress_30", "report_text": "> BZip2CompressorInputStream return value wrong when told to read to a full buffer.\n> \n> BZip2CompressorInputStream.read(buffer, offset, length) returns -1 when given an offset equal to the length of the buffer.\n> This indicates, not that the buffer was full, but that the stream was finished.\n> It seems like a pretty stupid thing to do - but I'm getting this when trying to use Kryo serialization (which is probably a bug on their part, too), so it does occur and has negative affects.\n> Here's a JUnit test that shows the problem specifically:\n> ```\n> \t@Test\n> \tpublic void testApacheCommonsBZipUncompression () throws Exception {\n> \t\t// Create a big random piece of data\n> \t\tbyte[] rawData = new byte[1048576];\n> \t\tfor (int i=0; i<rawData.length; ++i) {\n> \t\t\trawData[i] = (byte) Math.floor(Math.random()*256);\n> \t\t}\n> \t\t// Compress it\n> \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n> \t\tBZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n> \t\tbzipOut.write(rawData);\n> \t\tbzipOut.flush();\n> \t\tbzipOut.close();\n> \t\tbaos.flush();\n> \t\tbaos.close();\n> \t\t// Try to read it back in\n> \t\tByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n> \t\tBZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n> \t\tbyte[] buffer = new byte[1024];\n> \t\t// Works fine\n> \t\tAssert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n> \t\t// Fails, returns -1 (indicating the stream is complete rather than that the buffer \n> \t\t// was full)\n> \t\tAssert.assertEquals(0, bzipIn.read(buffer, 1024, 0));\n> \t\t// But if you change the above expected value to -1, the following line still works\n> \t\tAssert.assertEquals(1024, bzipIn.read(buffer, 0, 1024));\n> \t\tbzipIn.close();\n> \t}\n> ```", "test_name": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest::readOfLength0ShouldReturn0", "test_method": "    @Test\n    public void readOfLength0ShouldReturn0() throws Exception {\n        // Create a big random piece of data\n        byte[] rawData = new byte[1048576];\n        for (int i=0; i < rawData.length; ++i) {\n            rawData[i] = (byte) Math.floor(Math.random()*256);\n        }\n\n        // Compress it\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        BZip2CompressorOutputStream bzipOut = new BZip2CompressorOutputStream(baos);\n        bzipOut.write(rawData);\n        bzipOut.flush();\n        bzipOut.close();\n        baos.flush();\n        baos.close();\n\n        // Try to read it back in\n        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n        BZip2CompressorInputStream bzipIn = new BZip2CompressorInputStream(bais);\n        byte[] buffer = new byte[1024];\n        Assert.assertEquals(0, bzipIn.read(buffer, 1024, 0)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<-1>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStreamTest.readOfLength0ShouldReturn0(BZip2CompressorInputStreamTest.java:67)", "buggy_method": "152 @Override\n153     public int read(final byte[] dest, final int offs, final int len)\n154         throws IOException {\n155         if (offs < 0) {\n156             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n157         }\n158         if (len < 0) {\n159             throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n160         }\n161         if (offs + len > dest.length) {\n162             throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n163                                                 + len + \") > dest.length(\" + dest.length + \").\");\n164         }\n165         if (this.in == null) {\n166             throw new IOException(\"stream closed\");\n167         }\n168 \n169         final int hi = offs + len;\n170         int destOffs = offs;\n171         int b;\n172         while (destOffs < hi && ((b = read0()) >= 0)) {\n173             dest[destOffs++] = (byte) b;\n174             count(1);\n175         }\n176 \n177         int c = (destOffs == offs) ? -1 : (destOffs - offs);\n178         return c;\n179     }", "bm_classpath": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream"}, {"bug_name": "Compress_31", "report_text": "> Illegal argument exception when extracting .tgz file\n> \n> When attempting to unpack a .tgz file, I am receiving the illegal argument exception: java.lang.IllegalArgumentException: Invalid byte 0 at offset 5 in '05412\n> {NUL}11' len=8. This is causing a java.io.IOException: Error detected parsing the header error.   \n>   \n> This is being thrown when the function TarArchiveInputStream.getNextTarEntry() is called.   \n>   \n> Here is the code I am using.   \n> ```\n>             TarArchiveInputStream tarIn = new TarArchiveInputStream(\n>                     new GZIPInputStream(\n>                             new BufferedInputStream(\n>                                     new FileInputStream(\n>                                             tempDirPath + fileName))));\n>             TarArchiveEntry entry = tarIn.getNextTarEntry();\n>             while (entry != null) {\n>                 File path = new File(tempDirPath, entry.getName());\n>                 if (entry.isDirectory()) {\n>                     path.mkdirs();\n>                 } else {          \n>                     path.createNewFile();\n>                     byte[] read = new byte[2048];\n>                     BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(path));\n>                     int len;\n>                     while ((len = tarIn.read(read)) != -1) {\n>                         bout.write(read, 0, len);\n>                         System.out.print(new String(read, \"UTF-8\"));\n>                     }\n>                     bout.close();\n>                     read = null;\n>                 }\n>                 entry = tarIn.getNextTarEntry();\n>             }\n>             tarIn.close();\n> ```\n>   \n>   \n> Here is the full stack trace:   \n>   \n> [2015-02-12T23:17:31.944+0000] [glassfish 4.0] [SEVERE] [] [] [tid: \\_ThreadID=123 \\_ThreadName=Thread-4] [timeMillis: 1423783051944] [levelValue: 1000] [[  \n>  java.io.IOException: Error detected parsing the header  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:257)  \n>  at org.unavco.ws.tilt.ExtractTiltFile.extractFile(ExtractTiltFile.java:125)  \n>  at org.unavco.ws.tilt.ExtractTiltFile.run(ExtractTiltFile.java:59)  \n>  at org.unavco.ws.cache.ProcessDataFile.getFileData(ProcessDataFile.java:100)  \n>  at org.unavco.ws.cache.ProcessDataFile.getResultSet(ProcessDataFile.java:81)  \n>  at org.unavco.ws.tilt.TiltDsClient.write(TiltDsClient.java:47)  \n>  at org.glassfish.jersey.message.internal.StreamingOutputProvider.writeTo(StreamingOutputProvider.java:76)  \n>  at org.glassfish.jersey.message.internal.StreamingOutputProvider.writeTo(StreamingOutputProvider.java:58)  \n>  at org.glassfish.jersey.message.internal.WriterInterceptorExecutor$TerminalWriterInterceptor.aroundWriteTo(WriterInterceptorExecutor.java:194)  \n>  at org.glassfish.jersey.message.internal.WriterInterceptorExecutor.proceed(WriterInterceptorExecutor.java:139)  \n>  at org.glassfish.jersey.server.internal.JsonWithPaddingInterceptor.aroundWriteTo(JsonWithPaddingInterceptor.java:103)  \n>  at org.glassfish.jersey.message.internal.WriterInterceptorExecutor.proceed(WriterInterceptorExecutor.java:139)  \n>  at org.glassfish.jersey.server.internal.MappableExceptionWrapperInterceptor.aroundWriteTo(MappableExceptionWrapperInterceptor.java:88)  \n>  at org.glassfish.jersey.message.internal.WriterInterceptorExecutor.proceed(WriterInterceptorExecutor.java:139)  \n>  at org.glassfish.jersey.message.internal.MessageBodyFactory.writeTo(MessageBodyFactory.java:1005)  \n>  at org.glassfish.jersey.server.ServerRuntime$Responder.writeResponse(ServerRuntime.java:471)  \n>  at org.glassfish.jersey.server.ServerRuntime$Responder.processResponse(ServerRuntime.java:333)  \n>  at org.glassfish.jersey.server.ServerRuntime$Responder.process(ServerRuntime.java:323)  \n>  at org.glassfish.jersey.server.ServerRuntime$1.run(ServerRuntime.java:227)  \n>  at org.glassfish.jersey.internal.Errors$1.call(Errors.java:271)  \n>  at org.glassfish.jersey.internal.Errors$1.call(Errors.java:267)  \n>  at org.glassfish.jersey.internal.Errors.process(Errors.java:315)  \n>  at org.glassfish.jersey.internal.Errors.process(Errors.java:297)  \n>  at org.glassfish.jersey.internal.Errors.process(Errors.java:267)  \n>  at org.glassfish.jersey.process.internal.RequestScope.runInScope(RequestScope.java:317)  \n>  at org.glassfish.jersey.server.ServerRuntime.process(ServerRuntime.java:198)  \n>  at org.glassfish.jersey.server.ApplicationHandler.handle(ApplicationHandler.java:946)  \n>  at org.glassfish.jersey.servlet.WebComponent.service(WebComponent.java:323)  \n>  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:372)  \n>  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:335)  \n>  at org.glassfish.jersey.servlet.ServletContainer.service(ServletContainer.java:218)  \n>  at org.apache.catalina.core.StandardWrapper.service(StandardWrapper.java:1682)  \n>  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:344)  \n>  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:214)  \n>  at com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source)  \n>  at com.thetransactioncompany.cors.CORSFilter.doFilter(Unknown Source)  \n>  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:256)  \n>  at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:214)  \n>  at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:316)  \n>  at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:160)  \n>  at org.apache.catalina.core.StandardPipeline.doInvoke(StandardPipeline.java:734)  \n>  at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:673)  \n>  at com.sun.enterprise.web.WebPipeline.invoke(WebPipeline.java:99)  \n>  at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:174)  \n>  at org.apache.catalina.connector.CoyoteAdapter.doService(CoyoteAdapter.java:357)  \n>  at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:260)  \n>  at com.sun.enterprise.v3.services.impl.ContainerMapper.service(ContainerMapper.java:188)  \n>  at org.glassfish.grizzly.http.server.HttpHandler.runService(HttpHandler.java:191)  \n>  at org.glassfish.grizzly.http.server.HttpHandler.doHandle(HttpHandler.java:168)  \n>  at org.glassfish.grizzly.http.server.HttpServerFilter.handleRead(HttpServerFilter.java:189)  \n>  at org.glassfish.grizzly.filterchain.ExecutorResolver$9.execute(ExecutorResolver.java:119)  \n>  at org.glassfish.grizzly.filterchain.DefaultFilterChain.executeFilter(DefaultFilterChain.java:288)  \n>  at org.glassfish.grizzly.filterchain.DefaultFilterChain.executeChainPart(DefaultFilterChain.java:206)  \n>  at org.glassfish.grizzly.filterchain.DefaultFilterChain.execute(DefaultFilterChain.java:136)  \n>  at org.glassfish.grizzly.filterchain.DefaultFilterChain.process(DefaultFilterChain.java:114)  \n>  at org.glassfish.grizzly.ProcessorExecutor.execute(ProcessorExecutor.java:77)  \n>  at org.glassfish.grizzly.nio.transport.TCPNIOTransport.fireIOEvent(TCPNIOTransport.java:838)  \n>  at org.glassfish.grizzly.strategies.AbstractIOStrategy.fireIOEvent(AbstractIOStrategy.java:113)  \n>  at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy.run0(WorkerThreadIOStrategy.java:115)  \n>  at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy.access$100(WorkerThreadIOStrategy.java:55)  \n>  at org.glassfish.grizzly.strategies.WorkerThreadIOStrategy$WorkerThreadRunnable.run(WorkerThreadIOStrategy.java:135)  ", "test_name": "org.apache.commons.compress.archivers.TarTestCase::testCOMPRESS178", "test_method": "    @Test\n    public void testCOMPRESS178() throws Exception {\n        final File input = getFile(\"COMPRESS-178.tar\");\n        final InputStream is = new FileInputStream(input);\n        final ArchiveInputStream in = new ArchiveStreamFactory().createArchiveInputStream(\"tar\", is);\n        try {\n            in.getNextEntry();\n            fail(\"Expected IOException\");\n        } catch (IOException e) {\n            Throwable t = e.getCause();\n            assertTrue(\"Expected cause = IllegalArgumentException\", t instanceof IllegalArgumentException);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected IOException\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.TarTestCase.testCOMPRESS178(TarTestCase.java:325)", "buggy_method": "101 public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n102         long    result = 0;\n103         int     end = offset + length;\n104         int     start = offset;\n105 \n106         if (length < 2){\n107             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n108         }\n109 \n110         if (buffer[start] == 0) {\n111             return 0L;\n112         }\n113 \n114         // Skip leading spaces\n115         while (start < end){\n116             if (buffer[start] == ' '){\n117                 start++;\n118             } else {\n119                 break;\n120             }\n121         }\n122 \n123         // Trim all trailing NULs and spaces.\n124         // The ustar and POSIX tar specs require a trailing NUL or\n125         // space but some implementations use the extra digit for big\n126         // sizes/uids/gids ...\n127         byte trailer = buffer[end - 1];\n128         while (start < end && (trailer == 0 || trailer == ' ')) {\n129             end--;\n130             trailer = buffer[end - 1];\n131         }\n132 \n133         for ( ;start < end; start++) {\n134             final byte currentByte = buffer[start];\n135             if (currentByte == 0) {\n136                 break;\n137             }\n138             // CheckStyle:MagicNumber OFF\n139             if (currentByte < '0' || currentByte > '7'){\n140                 throw new IllegalArgumentException(\n141                         exceptionMessage(buffer, offset, length, start, currentByte));\n142             }\n143             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n144             // CheckStyle:MagicNumber ON\n145         }\n146 \n147         return result;\n148     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_32", "report_text": "> TarArchiveInputStream rejects uid or gid >= 0x80000000\n> \n> A POSIX-format archive that came from sysdiagnose produces NumberFormatException[1] when I try to read it with TarArchiveInputStream.\n> The relevant part of the .tar file looks like this:\n>  18 uid=429496729\n> That's the uid of 'nobody' on Mac OS (on Mac OS, uid\\_t is 'unsigned int').\n> POSIX doesn't say anything about the width of the uid extended header[2], so I assume the tar file is okay. GNU tar doesn't have trouble with it.\n> The relevant code, in applyPaxHeadersToCurrentEntry:\n>  } else if (\"gid\".equals(key))\n> {\n>  currEntry.setGroupId(Integer.parseInt(val));\n> ...\n>  }\n>  else if (\"uid\".equals(key)){  \n>  currEntry.setUserId(Integer.parseInt(val));\n> uid\\_t and gid\\_t are typically unsigned 32-bit integers, so these should presumably use Long.parseLong to handle integers with the top bit set (and TarArchiveEntry would need some modifications to handle large uid and gid, too).\n> [1] java.lang.NumberFormatException: For input string: \"4294967294\"  \n>  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)  \n>  at java.lang.Integer.parseInt(Integer.java:495)  \n>  at java.lang.Integer.parseInt(Integer.java:527)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveInputStream.applyPaxHeadersToCurrentEntry(TarArchiveInputStream.java:488)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveInputStream.paxHeaders(TarArchiveInputStream.java:415)  \n>  at org.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:295)\n> [2] <http://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03>  \n> uid  \n> The user ID of the file owner, expressed as a decimal number using digits from the ISO/IEC 646:1991 standard. This record shall override the uid field in the following header block(s). When used in write or copy mode, pax shall include a uid extended header record for each file whose owner ID is greater than 2097151 (octal 7777777).", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::shouldReadBigGid", "test_method": "    @Test\n    public void shouldReadBigGid() throws Exception {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        TarArchiveOutputStream tos = new TarArchiveOutputStream(bos);\n        tos.setBigNumberMode(TarArchiveOutputStream.BIGNUMBER_POSIX);\n        TarArchiveEntry t = new TarArchiveEntry(\"name\");\n        t.setGroupId(4294967294l);\n        t.setSize(1);\n        tos.putArchiveEntry(t);\n        tos.write(30);\n        tos.closeArchiveEntry();\n        tos.close();\n        byte[] data = bos.toByteArray();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        TarArchiveInputStream tis =\n            new TarArchiveInputStream(bis);\n        t = tis.getNextTarEntry(); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: For input string: \"4294967294\"\n\tjava.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tjava.lang.Integer.parseInt(Integer.java:583)\n\tjava.lang.Integer.parseInt(Integer.java:615)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.applyPaxHeadersToCurrentEntry(TarArchiveInputStream.java:501)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.paxHeaders(TarArchiveInputStream.java:431)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:311)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.shouldReadBigGid(TarArchiveInputStreamTest.java:254)", "buggy_method": "481 private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n482         /*\n483          * The following headers are defined for Pax.\n484          * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n485          * mtime\n486          * comment\n487          * gid, gname\n488          * linkpath\n489          * size\n490          * uid,uname\n491          * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n492          */\n493         for (Entry<String, String> ent : headers.entrySet()){\n494             String key = ent.getKey();\n495             String val = ent.getValue();\n496             if (\"path\".equals(key)){\n497                 currEntry.setName(val);\n498             } else if (\"linkpath\".equals(key)){\n499                 currEntry.setLinkName(val);\n500             } else if (\"gid\".equals(key)){\n501                 currEntry.setGroupId(Integer.parseInt(val));\n502             } else if (\"gname\".equals(key)){\n503                 currEntry.setGroupName(val);\n504             } else if (\"uid\".equals(key)){\n505                 currEntry.setUserId(Integer.parseInt(val));\n506             } else if (\"uname\".equals(key)){\n507                 currEntry.setUserName(val);\n508             } else if (\"size\".equals(key)){\n509                 currEntry.setSize(Long.parseLong(val));\n510             } else if (\"mtime\".equals(key)){\n511                 currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n512             } else if (\"SCHILY.devminor\".equals(key)){\n513                 currEntry.setDevMinor(Integer.parseInt(val));\n514             } else if (\"SCHILY.devmajor\".equals(key)){\n515                 currEntry.setDevMajor(Integer.parseInt(val));\n516             }\n517         }\n518     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"}, {"bug_name": "Compress_33", "report_text": "> CompressorStreamFactory doesn't handle deflate streams with a zlib header\n> \n> If you take a zlib / deflate compressed file, with the zlib header (eg the test file bla.tar.deflatez) and pass it to CompressorStreamFactory.createCompressorInputStream, it won't be detected and you'll get a CompressorException(\"No Compressor found for the stream signature.\")\n> While detecting header-less zlib files is probably too tricky to manage, those with the header ought to be possible to spot and handle", "test_name": "org.apache.commons.compress.compressors.DetectCompressorTestCase::testDetection", "test_method": "    @Test\n    public void testDetection() throws Exception {\n        CompressorInputStream bzip2 = getStreamFor(\"bla.txt.bz2\"); \n\n        CompressorInputStream gzip = getStreamFor(\"bla.tgz\");\n        \n        CompressorInputStream pack200 = getStreamFor(\"bla.pack\");\n\n        CompressorInputStream xz = getStreamFor(\"bla.tar.xz\");\n\n        CompressorInputStream zlib = getStreamFor(\"bla.tar.deflatez\"); // <-- fails here\n    }", "error_message": "org.apache.commons.compress.compressors.CompressorException: No Compressor found for the stream signature.\n\torg.apache.commons.compress.compressors.CompressorStreamFactory.createCompressorInputStream(CompressorStreamFactory.java:255)\n\torg.apache.commons.compress.compressors.DetectCompressorTestCase.getStreamFor(DetectCompressorTestCase.java:165)\n\torg.apache.commons.compress.compressors.DetectCompressorTestCase.testDetection(DetectCompressorTestCase.java:108)", "buggy_method": "204 public CompressorInputStream createCompressorInputStream(final InputStream in)\n205             throws CompressorException {\n206         if (in == null) {\n207             throw new IllegalArgumentException(\"Stream must not be null.\");\n208         }\n209 \n210         if (!in.markSupported()) {\n211             throw new IllegalArgumentException(\"Mark is not supported.\");\n212         }\n213 \n214         final byte[] signature = new byte[12];\n215         in.mark(signature.length);\n216         try {\n217             int signatureLength = IOUtils.readFully(in, signature);\n218             in.reset();\n219 \n220             if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n221                 return new BZip2CompressorInputStream(in, decompressConcatenated);\n222             }\n223 \n224             if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n225                 return new GzipCompressorInputStream(in, decompressConcatenated);\n226             }\n227 \n228             if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n229                 return new Pack200CompressorInputStream(in);\n230             }\n231 \n232             if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n233                 return new FramedSnappyCompressorInputStream(in);\n234             }\n235 \n236             if (ZCompressorInputStream.matches(signature, signatureLength)) {\n237                 return new ZCompressorInputStream(in);\n238             }\n239 \n240 \n241             if (XZUtils.matches(signature, signatureLength) &&\n242                 XZUtils.isXZCompressionAvailable()) {\n243                 return new XZCompressorInputStream(in, decompressConcatenated);\n244             }\n245 \n246             if (LZMAUtils.matches(signature, signatureLength) &&\n247                 LZMAUtils.isLZMACompressionAvailable()) {\n248                 return new LZMACompressorInputStream(in);\n249             }\n250 \n251         } catch (IOException e) {\n252             throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n253         }\n254 \n255         throw new CompressorException(\"No Compressor found for the stream signature.\");\n256     }", "bm_classpath": "org.apache.commons.compress.compressors.CompressorStreamFactory"}, {"bug_name": "Compress_34", "report_text": "> Exception in X7875_NewUnix.parseFromLocalFileData when parsing 0-sized \"ux\" local entry\n> \n> When trying to detect content type of a zip file with Tika 1.10 (which uses Commons Compress 1.9 internally) in manner like this:\n> ```\n>         byte[] content = ... // whole zip file.\n>         String name = \"TR\\_01.ZIP\";\n>         Tika tika = new Tika();\n>         return tika.detect(content, name);\n> ```\n> it throws an exception:\n> ```\n> java.lang.ArrayIndexOutOfBoundsException: 13\n> \tat org.apache.commons.compress.archivers.zip.X7875_NewUnix.parseFromLocalFileData(X7875_NewUnix.java:199)\n> \tat org.apache.commons.compress.archivers.zip.X7875_NewUnix.parseFromCentralDirectoryData(X7875_NewUnix.java:220)\n> \tat org.apache.commons.compress.archivers.zip.ExtraFieldUtils.parse(ExtraFieldUtils.java:174)\n> \tat org.apache.commons.compress.archivers.zip.ZipArchiveEntry.setCentralDirectoryExtra(ZipArchiveEntry.java:476)\n> \tat org.apache.commons.compress.archivers.zip.ZipFile.readCentralDirectoryEntry(ZipFile.java:575)\n> \tat org.apache.commons.compress.archivers.zip.ZipFile.populateFromCentralDirectory(ZipFile.java:492)\n> \tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:216)\n> \tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:192)\n> \tat org.apache.commons.compress.archivers.zip.ZipFile.<init>(ZipFile.java:153)\n> \tat org.apache.tika.parser.pkg.ZipContainerDetector.detectZipFormat(ZipContainerDetector.java:141)\n> \tat org.apache.tika.parser.pkg.ZipContainerDetector.detect(ZipContainerDetector.java:88)\n> \tat org.apache.tika.detect.CompositeDetector.detect(CompositeDetector.java:77)\n> \tat org.apache.tika.Tika.detect(Tika.java:155)\n> \tat org.apache.tika.Tika.detect(Tika.java:183)\n> \tat org.apache.tika.Tika.detect(Tika.java:223)\n> ```\n> The zip file does contain two .jpg images and is not a \"special\" (JAR, Openoffice, ... ) zip file.\n> Unfortunately, the contents of the zip file is confidential and so I cannot attach it to this ticket as it is, although I can provide the parameters supplied to  \n> org.apache.commons.compress.archivers.zip.X7875\\_NewUnix.parseFromLocalFileData(X7875\\_NewUnix.java:199) as caught by the debugger:\n> ```\n> data = {byte[13]@2103}\n>  0 = 85\n>  1 = 84\n>  2 = 5\n>  3 = 0\n>  4 = 7\n>  5 = -112\n>  6 = -108\n>  7 = 51\n>  8 = 85\n>  9 = 117\n>  10 = 120\n>  11 = 0\n>  12 = 0\n> offset = 13\n> length = 0\n> ```\n> This data comes from the local zip entry for the first file, it seems the method tries to read more bytes than is actually available in the buffer.\n> It seems that first 9 bytes of the buffer are 'UT' extended field with timestamp, followed by 0-sized 'ux' field (bytes 9-12) that is supposed to contain UID/GID - according to infozip's doc the 0-size is common for global dictionary, but the local dictionary should contain complete data. In this case for some reason it does contain 0-sized data.\n> Note that 7zip and unzip can unzip the file without even a warning, so Commons Compress should be also able to handle that file correctly without choking on that exception.", "test_name": "org.apache.commons.compress.archivers.zip.X7875_NewUnixTest::testParseReparse", "test_method": "    @Test\n    public void testParseReparse() throws ZipException {\n\n        // Version=1, Len=0, Len=0.\n        final byte[] ZERO_LEN = {1, 0, 0};\n\n        // Version=1, Len=1, zero, Len=1, zero.\n        final byte[] ZERO_UID_GID = {1, 1, 0, 1, 0};\n\n        // Version=1, Len=1, one, Len=1, one\n        final byte[] ONE_UID_GID = {1, 1, 1, 1, 1};\n\n        // Version=1, Len=2, one thousand, Len=2, one thousand\n        final byte[] ONE_THOUSAND_UID_GID = {1, 2, -24, 3, 2, -24, 3};\n\n        // (2^32 - 2).   I guess they avoid (2^32 - 1) since it's identical to -1 in\n        // two's complement, and -1 often has a special meaning.\n        final byte[] UNIX_MAX_UID_GID = {1, 4, -2, -1, -1, -1, 4, -2, -1, -1, -1};\n\n        // Version=1, Len=5, 2^32, Len=5, 2^32 + 1\n        // Esoteric test:  can we handle 40 bit numbers?\n        final byte[] LENGTH_5 = {1, 5, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 1};\n\n        // Version=1, Len=8, 2^63 - 2, Len=8, 2^63 - 1\n        // Esoteric test:  can we handle 64 bit numbers?\n        final byte[] LENGTH_8 = {1, 8, -2, -1, -1, -1, -1, -1, -1, 127, 8, -1, -1, -1, -1, -1, -1, -1, 127};\n\n        final long TWO_TO_32 = 0x100000000L;\n        final long MAX = TWO_TO_32 - 2;\n\n        parseReparse(0, 0, ZERO_LEN, 0, 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<5>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.compress.archivers.zip.X7875_NewUnixTest.parseReparse(X7875_NewUnixTest.java:236)\n\torg.apache.commons.compress.archivers.zip.X7875_NewUnixTest.testParseReparse(X7875_NewUnixTest.java:168)", "buggy_method": "145 public ZipShort getCentralDirectoryLength() {\n146         return getLocalFileDataLength();\n147     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.X7875_NewUnix"}, {"bug_name": "Compress_35", "report_text": "> TAR checksum fails when checksum is right aligned\n> \n> The linked TAR has a checksum with zero padding on the left instead of the expected NULL-SPACE terminator on the right. As a result the last two digits of the stored checksum are lost and the otherwise valid checksum is treated as invalid.\n> Given that the code already checks for digits being in range before adding them to the stored sum, is it necessary to only look at the first 6 octal digits instead of the whole field?", "test_name": "org.apache.commons.compress.DetectArchiverTestCase::testCOMPRESS335", "test_method": "    @Test\n    public void testCOMPRESS335() throws Exception {\n        final ArchiveInputStream tar = getStreamFor(\"COMPRESS-335.tar\"); // <-- fails here\n    }", "error_message": "org.apache.commons.compress.archivers.ArchiveException: No Archiver found for the stream signature\n\torg.apache.commons.compress.archivers.ArchiveStreamFactory.createArchiveInputStream(ArchiveStreamFactory.java:397)\n\torg.apache.commons.compress.DetectArchiverTestCase.getStreamFor(DetectArchiverTestCase.java:101)\n\torg.apache.commons.compress.DetectArchiverTestCase.testCOMPRESS335(DetectArchiverTestCase.java:60)", "buggy_method": "593 public static boolean verifyCheckSum(byte[] header) {\n594         long storedSum = 0;\n595         long unsignedSum = 0;\n596         long signedSum = 0;\n597 \n598         int digits = 0;\n599         for (int i = 0; i < header.length; i++) {\n600             byte b = header[i];\n601             if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n602                 if ('0' <= b && b <= '7' && digits++ < 6) {\n603                     storedSum = storedSum * 8 + b - '0';\n604                 } else if (digits > 0) {\n605                     digits = 6;\n606                 }\n607                 b = ' ';\n608             }\n609             unsignedSum += 0xff & b;\n610             signedSum += b;\n611         }\n612         return storedSum == unsignedSum || storedSum == signedSum;\n613     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_36", "report_text": "> Calling SevenZFile.read() on empty SevenZArchiveEntry throws IllegalStateException\n> \n> I'm pretty sure [~~COMPRESS-340~~](https://issues.apache.org/jira/browse/COMPRESS-340 \"Provide an efficient way to skip over 7zip entries without decompressing them\") breaks reading empty archive entries. When calling getNextEntry() and that entry has no content, the code jumps into the first block at line 830 (SevenZFile.class), clearing the deferredBlockStreams. When calling entry.read(...) afterwards an IllegalStateException (\"No current 7z entry (call getNextEntry() first).\") is thrown. IMHO, there should be another check for entry.getSize() == 0.\n> This worked correctly up until 1.10.", "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZFileTest::readEntriesOfSize0", "test_method": "    @Test\n    public void readEntriesOfSize0() throws IOException {\n        final SevenZFile sevenZFile = new SevenZFile(getFile(\"COMPRESS-348.7z\"));\n        try {\n            int entries = 0;\n            SevenZArchiveEntry entry = sevenZFile.getNextEntry();\n            while (entry != null) {\n                entries++;\n                int b = sevenZFile.read();\n                if (\"2.txt\".equals(entry.getName()) || \"5.txt\".equals(entry.getName())) {\n                    assertEquals(-1, b);\n                } else {\n                    assertNotEquals(-1, b);\n                }\n                entry = sevenZFile.getNextEntry();\n            }\n            assertEquals(5, entries);\n        } finally {\n            sevenZFile.close();\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: No current 7z entry (call getNextEntry() first).\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.getCurrentStream(SevenZFile.java:903)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFile.read(SevenZFile.java:898)\n\torg.apache.commons.compress.archivers.sevenz.SevenZFileTest.readEntriesOfSize0(SevenZFileTest.java:274)", "buggy_method": "901 private InputStream getCurrentStream() throws IOException {\n902         if (deferredBlockStreams.isEmpty()) {\n903             throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n904         }\n905         \n906         while (deferredBlockStreams.size() > 1) {\n907             // In solid compression mode we need to decompress all leading folder'\n908             // streams to get access to an entry. We defer this until really needed\n909             // so that entire blocks can be skipped without wasting time for decompression.\n910             final InputStream stream = deferredBlockStreams.remove(0);\n911             IOUtils.skip(stream, Long.MAX_VALUE);\n912             stream.close();\n913         }\n914 \n915         return deferredBlockStreams.get(0);\n916     }", "bm_classpath": "org.apache.commons.compress.archivers.sevenz.SevenZFile"}, {"bug_name": "Compress_37", "report_text": "> Parsing PAX headers fails with NegativeArraySizeException\n> \n> The TarArchiveInputStream.parsePaxHeaders method fails with a NegativeArraySizeException when there is an empty line at the end of the headers.\n> The inner loop starts reading the length, but it gets a newline (10) and ends up subtracting '0' (48) from it; the result is a negative length that blows up an attempt to allocate the rest array.\n> I would say that a check to see if ch is less the '0' and break the loop if it is.\n> I used npm pack aws-sdk@2.2.16 to generate a tarball with this issue.", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::survivesBlankLinesInPaxHeader", "test_method": "    @Test\n    public void survivesBlankLinesInPaxHeader() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-355.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        } // <-- fails here\n    }", "error_message": "java.lang.NegativeArraySizeException\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.parsePaxHeaders(TarArchiveInputStream.java:474)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.paxHeaders(TarArchiveInputStream.java:444)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:319)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesBlankLinesInPaxHeader(TarArchiveInputStreamTest.java:308)", "buggy_method": "452 Map<String, String> parsePaxHeaders(final InputStream i)\n453         throws IOException {\n454         final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);\n455         // Format is \"length keyword=value\\n\";\n456         while(true){ // get length\n457             int ch;\n458             int len = 0;\n459             int read = 0;\n460             while((ch = i.read()) != -1) {\n461                 read++;\n462                 if (ch == ' '){\n463                     // Get keyword\n464                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();\n465                     while((ch = i.read()) != -1) {\n466                         read++;\n467                         if (ch == '='){ // end of keyword\n468                             final String keyword = coll.toString(CharsetNames.UTF_8);\n469                             // Get rest of entry\n470                             final int restLen = len - read;\n471                             if (restLen == 1) { // only NL\n472                                 headers.remove(keyword);\n473                             } else {\n474                                 final byte[] rest = new byte[restLen];\n475                                 final int got = IOUtils.readFully(i, rest);\n476                                 if (got != restLen) {\n477                                     throw new IOException(\"Failed to read \"\n478                                                           + \"Paxheader. Expected \"\n479                                                           + restLen\n480                                                           + \" bytes, read \"\n481                                                           + got);\n482                                 }\n483                                 // Drop trailing NL\n484                                 final String value = new String(rest, 0,\n485                                                           restLen - 1, CharsetNames.UTF_8);\n486                                 headers.put(keyword, value);\n487                             }\n488                             break;\n489                         }\n490                         coll.write((byte) ch);\n491                     }\n492                     break; // Processed single header\n493                 }\n494                 len *= 10;\n495                 len += ch - '0';\n496             }\n497             if (ch == -1){ // EOF\n498                 break;\n499             }\n500         }\n501         return headers;\n502     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream"}, {"bug_name": "Compress_38", "report_text": "> PAX header entry name ending with / causes problems\n> \n> There seems to be a problem when a PAX header entry (link flag is 'x') has a name ending with \"/\". The TarArchiveEntry.isDirectory() check ends up returning true because of the trailing slash which means no content can be read from the entry. PAX header parsing effectively finds nothing and the stream is not advanced; this leaves the stream in a bad state as the next entry's header is actually read from the header contents.\n> If the name is modified to remove the trailing slash when the link flag indicates a PAX header everything seems to work fine. That would be one potential fix in parseTarHeader. Changing isDirectory to return false if isPaxHeader is true (before the trailing \"/\" check) would probably also fix the issue (though I can't verify that in the debugger like I can with changing the name).\n> So far I have only seen this when using Docker to save images that contain a yum database. For example:\n> ```\n> docker pull centos:latest && docker save centos:latest | tar x --include \"*/layer.tar\"\n> ```\n> Will produce at least one \"layer.tar\" that exhibits this issue. If I come across a smaller TAR for testing I will attach it.", "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest::survivesPaxHeaderWithNameEndingInSlash", "test_method": "    @Test\n    public void survivesPaxHeaderWithNameEndingInSlash() throws Exception {\n        final TarArchiveInputStream is = getTestStream(\"/COMPRESS-356.tar\");\n        try {\n            final TarArchiveEntry entry = is.getNextTarEntry();\n            assertEquals(\"package/package.json\", entry.getName());\n            assertNull(is.getNextTarEntry());\n        } finally {\n            is.close();\n        } // <-- fails here\n    }", "error_message": "java.io.IOException: Error detected parsing the header\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:286)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextEntry(TarArchiveInputStream.java:600)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.paxHeaders(TarArchiveInputStream.java:445)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStream.getNextTarEntry(TarArchiveInputStream.java:319)\n\torg.apache.commons.compress.archivers.tar.TarArchiveInputStreamTest.survivesPaxHeaderWithNameEndingInSlash(TarArchiveInputStreamTest.java:323)", "buggy_method": "849 @Override\n850     public boolean isDirectory() {\n851         if (file != null) {\n852             return file.isDirectory();\n853         }\n854 \n855         if (linkFlag == LF_DIR) {\n856             return true;\n857         }\n858 \n859         if (getName().endsWith(\"/\")) {\n860             return true;\n861         }\n862 \n863         return false;\n864     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarArchiveEntry"}, {"bug_name": "Compress_39", "report_text": "> Defective .zip-archive produces problematic error message\n> \n> A truncated .zip-File produces an java.io.EOFException conatining a hughe amount of byte[]-data in the error-message - leading to beeps and crippeling workload in an potential console-logger.", "test_name": "org.apache.commons.compress.ArchiveUtilsTest::sanitizeShortensString", "test_method": "    @Test\n    public void sanitizeShortensString() {\n        String input = \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\";\n        String expected = \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901234567890123456789012345678901234567890123456789\"\n            + \"012345678901...\";\n        assertEquals(expected, ArchiveUtils.sanitize(input)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...23456789012345678901[...]> but was:<...23456789012345678901[234567890123456789012345678901234567890123456789]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.compress.ArchiveUtilsTest.sanitizeShortensString(ArchiveUtilsTest.java:82)", "buggy_method": "272 public static String sanitize(String s) {\n273         final char[] chars = s.toCharArray();\n274         final int len = chars.length;\n275         final StringBuilder sb = new StringBuilder();\n276         for (int i = 0; i < len; i++) {\n277             final char c = chars[i];\n278             if (!Character.isISOControl(c)) {\n279                 Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n280                 if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n281                     sb.append(c);\n282                     continue;\n283                 }\n284             }\n285             sb.append('?');\n286         }\n287         return sb.toString();\n288     }", "bm_classpath": "org.apache.commons.compress.utils.ArchiveUtils"}, {"bug_name": "Compress_40", "report_text": "> Overflow in BitInputStream\n> \n> in Class BitInputStream.java(\\src\\main\\java\\org\\apache\\commons\\compress\\utils),  \n> funcion:\n>  public long readBits(final int count) throws IOException {  \n>  if (count < 0 || count > MAXIMUM\\_CACHE\\_SIZE) \n> {\n>  throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM\\_CACHE\\_SIZE);\n>  }\n>  while (bitsCachedSize < count) {  \n>  final long nextByte = in.read();  \n>  if (nextByte < 0) \n> {\n>  return nextByte;\n>  }\n>  if (byteOrder == ByteOrder.LITTLE\\_ENDIAN) \n> {\n>  bitsCached |= (nextByte << bitsCachedSize);\n>  }\n>  else \n> {\n>  bitsCached <<= 8;\n>  bitsCached |= nextByte;\n>  }\n>  bitsCachedSize += 8;  \n>  }\n>  final long bitsOut;  \n>  if (byteOrder == ByteOrder.LITTLE\\_ENDIAN) \n> {\n>  bitsOut = (bitsCached & MASKS[count]);\n>  bitsCached >>>= count;\n>  }\n>  else \n> {\n>  bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n>  }\n>  bitsCachedSize -= count;  \n>  return bitsOut;  \n>  }\n> I think here \"bitsCached |= (nextByte << bitsCachedSize);\" will overflow in some cases. for example, below is a test case:\n> public static void test() {\n>  ByteArrayInputStream in = new ByteArrayInputStream(new byte[]\n> {87, 45, 66, 15,\n>  90, 29, 88, 61, 33, 74}\n> );  \n>  BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE\\_ENDIAN);  \n>  try \n> {\n>  long ret = bin.readBits(5);\n>  ret = bin.readBits(63);\n>  ret = bin.readBits(12);\n>  }\n>  catch (Exception e) \n> {\n>  e.printStackTrace();\n>  }\n> }\n> overflow occur in \"bin.readBits(63);\" , so ,result in wrong result from \"bin.readBits(12);\" ", "test_name": "org.apache.commons.compress.utils.BitInputStreamTest::littleEndianWithOverflow", "test_method": "    @Test\n    public void littleEndianWithOverflow() throws Exception {\n        ByteArrayInputStream in = new ByteArrayInputStream(new byte[] {\n                87, // 01010111\n                45, // 00101101\n                66, // 01000010\n                15, // 00001111\n                90, // 01011010\n                29, // 00011101\n                88, // 01011000\n                61, // 00111101\n                33, // 00100001\n                74  // 01001010\n            });\n        BitInputStream bin = new BitInputStream(in, ByteOrder.LITTLE_ENDIAN);\n        assertEquals(1186, // 01001010-0010\n                     bin.readBits(12)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1186> but was:<1184>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.compress.utils.BitInputStreamTest.littleEndianWithOverflow(BitInputStreamTest.java:143)", "buggy_method": "81 public long readBits(final int count) throws IOException {\n82         if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n83             throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n84         }\n85         while (bitsCachedSize < count) {\n86             final long nextByte = in.read();\n87             if (nextByte < 0) {\n88                 return nextByte;\n89             }\n90             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n91                 bitsCached |= (nextByte << bitsCachedSize);\n92             } else {\n93                 bitsCached <<= 8;\n94                 bitsCached |= nextByte;\n95             }\n96             bitsCachedSize += 8;\n97         }\n98             // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n99         \n100         final long bitsOut;\n101             if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n102                 bitsOut = (bitsCached & MASKS[count]);\n103                 bitsCached >>>= count;\n104             } else {\n105                 bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n106             }\n107             bitsCachedSize -= count;\n108         return bitsOut;\n109     }", "bm_classpath": "org.apache.commons.compress.utils.BitInputStream"}, {"bug_name": "Compress_41", "report_text": "> ZipArchiveInputStream.getNextZipEntry() should differentiate between \"invalid entry encountered\" and \"no more entries\"\n> \n> ZipArchiveInputStream.getNextZipEntry() currently returns null if an invalid entry is encountered. Thus, it's not possible to differentiate between \"no more entries\" and \"invalid entry encountered\" conditions.\n> Instead, it should throw an exception if an invalid entry is encountered.\n> I've created a test case and fix. I will submit a pull request shortly.", "test_name": "org.apache.commons.compress.archivers.ZipTestCase::testListAllFilesWithNestedArchive", "test_method": "    @Test\n    public void testListAllFilesWithNestedArchive() throws Exception {\n        final File input = getFile(\"OSX_ArchiveWithNestedArchive.zip\");\n\n        final List<String> results = new ArrayList<>();\n        final List<ZipException> expectedExceptions = new ArrayList<>();\n\n        final InputStream is = new FileInputStream(input);\n        ArchiveInputStream in = null;\n        try {\n            in = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", is);\n\n            ZipArchiveEntry entry = null;\n            while ((entry = (ZipArchiveEntry) in.getNextEntry()) != null) {\n                results.add(entry.getName());\n\n                final ArchiveInputStream nestedIn = new ArchiveStreamFactory().createArchiveInputStream(\"zip\", in);\n                try {\n                    ZipArchiveEntry nestedEntry = null;\n                    while ((nestedEntry = (ZipArchiveEntry) nestedIn.getNextEntry()) != null) {\n                        results.add(nestedEntry.getName());\n                    }\n                } catch (ZipException ex) {\n                    // expected since you cannot create a final ArchiveInputStream from test3.xml\n                    expectedExceptions.add(ex);\n                }\n                // nested stream must not be closed here\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n        is.close();\n\n        assertEquals(1, expectedExceptions.size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.compress.archivers.ZipTestCase.testListAllFilesWithNestedArchive(ZipTestCase.java:281)", "buggy_method": "219 public ZipArchiveEntry getNextZipEntry() throws IOException {\n220         boolean firstEntry = true;\n221         if (closed || hitCentralDirectory) {\n222             return null;\n223         }\n224         if (current != null) {\n225             closeEntry();\n226             firstEntry = false;\n227         }\n228 \n229         try {\n230             if (firstEntry) {\n231                 // split archives have a special signature before the\n232                 // first local file header - look for it and fail with\n233                 // the appropriate error message if this is a split\n234                 // archive.\n235                 readFirstLocalFileHeader(LFH_BUF);\n236             } else {\n237                 readFully(LFH_BUF);\n238             }\n239         } catch (final EOFException e) {\n240             return null;\n241         }\n242 \n243         final ZipLong sig = new ZipLong(LFH_BUF);\n244         if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\n245             hitCentralDirectory = true;\n246             skipRemainderOfArchive();\n247         }\n248         if (!sig.equals(ZipLong.LFH_SIG)) {\n249             return null;\n250         }\n251 \n252         int off = WORD;\n253         current = new CurrentEntry();\n254 \n255         final int versionMadeBy = ZipShort.getValue(LFH_BUF, off);\n256         off += SHORT;\n257         current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n258 \n259         final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\n260         final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n261         final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n262         current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n263         current.entry.setGeneralPurposeBit(gpFlag);\n264 \n265         off += SHORT;\n266 \n267         current.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\n268         off += SHORT;\n269 \n270         final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\n271         current.entry.setTime(time);\n272         off += WORD;\n273 \n274         ZipLong size = null, cSize = null;\n275         if (!current.hasDataDescriptor) {\n276             current.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\n277             off += WORD;\n278 \n279             cSize = new ZipLong(LFH_BUF, off);\n280             off += WORD;\n281 \n282             size = new ZipLong(LFH_BUF, off);\n283             off += WORD;\n284         } else {\n285             off += 3 * WORD;\n286         }\n287 \n288         final int fileNameLen = ZipShort.getValue(LFH_BUF, off);\n289 \n290         off += SHORT;\n291 \n292         final int extraLen = ZipShort.getValue(LFH_BUF, off);\n293         off += SHORT;\n294 \n295         final byte[] fileName = new byte[fileNameLen];\n296         readFully(fileName);\n297         current.entry.setName(entryEncoding.decode(fileName), fileName);\n298 \n299         final byte[] extraData = new byte[extraLen];\n300         readFully(extraData);\n301         current.entry.setExtra(extraData);\n302 \n303         if (!hasUTF8Flag && useUnicodeExtraFields) {\n304             ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n305         }\n306 \n307         processZip64Extra(size, cSize);\n308 \n309         if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n310             if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n311                 current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n312             } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n313                 current.in = new ExplodingInputStream(\n314                         current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n315                         current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n316                         new BoundedInputStream(in, current.entry.getCompressedSize()));\n317             } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n318                 current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n319             }\n320         }\n321         \n322         entriesRead++;\n323         return current.entry;\n324     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"}, {"bug_name": "Compress_43", "report_text": "> [Zip] Local `Version Needed To Extract` does not match Central Directory\n> \n> Hi,\n> This is followup on an issue reported on Plexus Archiver - <https://github.com/codehaus-plexus/plexus-archiver/issues/57>\n> Plexus Archiver uses ZipArchiveOutputStream to create zip archives. It constructs the ZipArchiveOutputStream using BufferedOutputStream. As a result the output do not provide random access and additional data descriptor records are added. Unfortunately this leads to different values being set for version needed to extract field in the local file header and in the central directory. It looks like that the root cause is the way the local header version needed to extract field value is calculated:\n> ```\n>         if (phased &&  !isZip64Required(entry.entry, zip64Mode)){\n>             putShort(INITIAL_VERSION, buf, LFH_VERSION_NEEDED_OFFSET);\n>         } else {\n>             putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze)), buf, LFH_VERSION_NEEDED_OFFSET);\n>         }\n> ```\n> As you can see the need for data descriptors is not taken into account. On other hand when the central directory is created the following is used to determine the minimum required version\n> ```\n>     private int versionNeededToExtract(final int zipMethod, final boolean zip64) {\n>         if (zip64) {\n>             return ZIP64_MIN_VERSION;\n>         }\n>         // requires version 2 as we are going to store length info\n>         // in the data descriptor\n>         return (isDeflatedToOutputStream(zipMethod)) ?\n>                 DATA_DESCRIPTOR_MIN_VERSION :\n>                 INITIAL_VERSION;\n>     }\n> ```\n> As a side note: I'm not a zip expert by any means so I could be wrong, but my understanding is that if Deflate compression is used then the minimum required version should be 2.0 regardless if data descriptors are used or not.", "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest::doesntWriteDataDescriptorWhenAddingRawEntries", "test_method": "    @Test\n    public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n        ByteArrayOutputStream init = new ByteArrayOutputStream();\n        try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n            zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n            zos.write(\"foo\".getBytes(\"UTF-8\"));\n            zos.closeArchiveEntry();\n        }\n\n        File f = new File(dir, \"test.zip\");\n        try (FileOutputStream fos = new FileOutputStream(f)) {\n            fos.write(init.toByteArray());\n        }\n\n        ByteArrayOutputStream o = new ByteArrayOutputStream();\n        ZipArchiveEntry zae;\n        try (ZipFile zf = new ZipFile(f);\n             ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n            zae = zf.getEntry(\"test1.txt\");\n            zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n        }\n\n        byte[] data = o.toByteArray();\n        byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n        // still 2.0 because of Deflate\n        byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n        // no DD but EFS flag\n        assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\n\torg.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\n\torg.junit.Assert.internalArrayEquals(Assert.java:473)\n\torg.junit.Assert.assertArrayEquals(Assert.java:294)\n\torg.junit.Assert.assertArrayEquals(Assert.java:305)\n\torg.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries(DataDescriptorTest.java:162)", "buggy_method": "1024 private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n1025         final boolean encodable = zipEncoding.canEncode(ze.getName());\n1026         final ByteBuffer name = getName(ze);\n1027 \n1028         if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n1029             addUnicodeExtraFields(ze, encodable, name);\n1030         }\n1031 \n1032         final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n1033         final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n1034         metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n1035         entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n1036         writeCounted(localHeader);\n1037         entry.dataStart = streamCompressor.getTotalBytesWritten();\n1038     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream"}, {"bug_name": "Compress_44", "report_text": "> NullPointerException defect in ChecksumCalculatingInputStream#getValue()\n> \n> NullPointerException defect in ChecksumCalculatingInputStream#getValue() detected as stated in pull request 33: <https://github.com/apache/commons-compress/pull/33>\n> Furthermore the following test describes the problem:\n> ```\n>     @Test(expected = NullPointerException.class) //I assume this behaviour to be a bug or at least a defect.\n>     public void testGetValueThrowsNullPointerException() {\n>         ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n>         checksumCalculatingInputStream.getValue();\n>     }\n> ```", "test_name": "org.apache.commons.compress.utils.ChecksumCalculatingInputStreamTest::testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne", "test_method": "public void testClassInstantiationWithParameterBeingNullThrowsNullPointerExceptionOne() {\n\n        ChecksumCalculatingInputStream checksumCalculatingInputStream = new ChecksumCalculatingInputStream(null,null);\n\n\n    }\n\n\n    @Test(expected = NullPointerException.class)", "error_message": "junit.framework.AssertionFailedError: Expected exception: java.lang.NullPointerException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "33 public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n34 \n35 \n36 \n37         this.checksum = checksum;\n38         this.in = in;\n39     }", "bm_classpath": "org.apache.commons.compress.utils.ChecksumCalculatingInputStream"}, {"bug_name": "Compress_45", "report_text": "> TarUtils.formatLongOctalOrBinaryBytes never uses result of formatLongBinary\n> \n> if the length < 9, formatLongBinary is executed, then overwritten by the results of formatBigIntegerBinary. \n> If the results are not ignored, a unit test would fail.\n> Also, do the binary hacks need to support negative numbers? ", "test_name": "org.apache.commons.compress.archivers.tar.TarUtilsTest::testRoundTripOctalOrBinary8", "test_method": "    @Test\n    public void testRoundTripOctalOrBinary8() {\n        testRoundTripOctalOrBinary(8); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Value -72057594037927935 is too large for 8 byte field.\n\torg.apache.commons.compress.archivers.tar.TarUtils.formatBigIntegerBinary(TarUtils.java:523)\n\torg.apache.commons.compress.archivers.tar.TarUtils.formatLongOctalOrBinaryBytes(TarUtils.java:488)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.checkRoundTripOctalOrBinary(TarUtilsTest.java:141)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripOctalOrBinary(TarUtilsTest.java:163)\n\torg.apache.commons.compress.archivers.tar.TarUtilsTest.testRoundTripOctalOrBinary8(TarUtilsTest.java:148)", "buggy_method": "474 public static int formatLongOctalOrBinaryBytes(\n475         final long value, final byte[] buf, final int offset, final int length) {\n476 \n477         // Check whether we are dealing with UID/GID or SIZE field\n478         final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n479 \n480         final boolean negative = value < 0;\n481         if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n482             return formatLongOctalBytes(value, buf, offset, length);\n483         }\n484 \n485         if (length < 9) {\n486             formatLongBinary(value, buf, offset, length, negative);\n487         }\n488         formatBigIntegerBinary(value, buf, offset, length, negative);\n489 \n490         buf[offset] = (byte) (negative ? 0xff : 0x80);\n491         return offset + length;\n492     }", "bm_classpath": "org.apache.commons.compress.archivers.tar.TarUtils"}, {"bug_name": "Compress_46", "report_text": "> Tests failing under jdk 9 : one reflection issue, one change to ZipEntry related issue\n> \n> X5455\\_ExtendedTimestampTest is failing under JDK 9 , due to what appears to be a bogus value returned from getTime(). It seems like the test failure might be due to the changes introduced for this:   \n> <https://bugs.openjdk.java.net/browse/JDK-8073497>\n> Tests were run using intelliJ TestRunner, using the openjdk9 build from the tip of the jdk9 tree (not dev). I believe that this is at most one commit away from what will be the RC (which was delayed at the last minute due to two issues, one of which was javadoc related, and the other hotspot. ", "test_name": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest::testGettersSetters", "test_method": "    @Test\n    public void testGettersSetters() {\n        // X5455 is concerned with time, so let's\n        // get a timestamp to play with (Jan 1st, 2000).\n        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n        cal.set(Calendar.YEAR, 2000);\n        cal.set(Calendar.MONTH, Calendar.JANUARY);\n        cal.set(Calendar.DATE, 1);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        final long timeMillis = cal.getTimeInMillis();\n        final ZipLong time = new ZipLong(timeMillis / 1000);\n\n        // set too big\n        try {\n            // Java time is 1000 x larger (milliseconds).\n            xf.setModifyJavaTime(new Date(1000L * (MAX_TIME_SECONDS.getValue() + 1L)));\n            fail(\"Time too big for 32 bits!\");\n        } catch (final IllegalArgumentException iae) {\n            // All is good.\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Time too big for 32 bits!\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.compress.archivers.zip.X5455_ExtendedTimestampTest.testGettersSetters(X5455_ExtendedTimestampTest.java:218)", "buggy_method": "528 private static ZipLong unixTimeToZipLong(long l) {\n529         final long TWO_TO_32 = 0x100000000L;\n530         if (l >= TWO_TO_32) {\n531             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n532         }\n533         return new ZipLong(l);\n534     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp"}, {"bug_name": "Compress_47", "report_text": "> ZipArchiveInputStream#getNextZipEntry should verify compressed size is known for bzip2, implode etc.\n> \n> ```\n> \r\n>         if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\r\n>             if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\r\n>                 current.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n>             } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\r\n>                 current.in = new ExplodingInputStream(\r\n>                         current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\r\n>                         current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\r\n>                         new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n>             } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\r\n>                 current.in = new BZip2CompressorInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\r\n>             }\r\n>         }\r\n> ```\n> never sets current.in if the compressed size is unknown which probably leads to a NullPointerException in read later. We should fail early with a useful error message instead.", "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest::properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown", "test_method": "    @Test\n    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\n        // we never read any data\n        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {\n            ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\n            e.setMethod(ZipMethod.DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.BZIP2.getCode());\n            assertFalse(zis.canReadEntryData(e));\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertFalse(Assert.java:64)\n\torg.junit.Assert.assertFalse(Assert.java:74)\n\torg.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown(ZipArchiveInputStreamTest.java:339)", "buggy_method": "410 @Override\n411     public boolean canReadEntryData(final ArchiveEntry ae) {\n412         if (ae instanceof ZipArchiveEntry) {\n413             final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n414             return ZipUtil.canHandleEntryData(ze)\n415                 && supportsDataDescriptorFor(ze);\n416         }\n417         return false;\n418     }", "bm_classpath": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream"}, {"bug_name": "Csv_1", "report_text": "> ExtendedBufferReader does not handle EOL consistently\n> \n> ExtendedBufferReader checks for '\\n' (LF) in the read() methods, incrementing linecount when found.\n> However, the readLine() method calls BufferedReader.readLine() which treats CR, LF and CRLF equally (and drops them).\n> If the code is to be flexible in what it accepts, the class should also allow for CR alone as a line terminator.\n> It should work if the code increments the line counter for CR, and for LF if the previous character was not CR.", "test_name": "org.apache.commons.csv.CSVParserTest::testGetLineNumberWithCR", "test_method": "    @Test\n    public void testGetLineNumberWithCR() throws Exception {\n        CSVParser parser = new CSVParser(\"a\\rb\\rc\", CSVFormat.DEFAULT.withLineSeparator(\"\\r\"));\n        \n        assertEquals(1, parser.getLineNumber()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.csv.CSVParserTest.testGetLineNumberWithCR(CSVParserTest.java:510)", "buggy_method": "55 @Override\n56     public int read() throws IOException {\n57         int current = super.read();\n58         if (current == '\\n') {\n59             lineCounter++;\n60         }\n61         lastChar = current;\n62         return lastChar;\n63     }", "bm_classpath": "org.apache.commons.csv.ExtendedBufferedReader"}, {"bug_name": "Csv_2", "report_text": "> CSVRecord does not verify that the length of the header mapping matches the number of values\n> \n> CSVRecord does not verify that the size of the header mapping matches the number of values. The following test will produce a ArrayOutOfBoundsException:\n> ```\n> @Test\n> public void testInvalidHeaderTooLong() throws Exception {\n>    final CSVParser parser = new CSVParser(\"a,b\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n>    final CSVRecord record = parser.iterator().next();\n>    record.get(\"C\");\n> }\n> ```", "test_name": "org.apache.commons.csv.CSVRecordTest::testGetStringInconsistentRecord", "test_method": "    @Test(expected = IllegalArgumentException.class)\n    public void testGetStringInconsistentRecord() {\n        header.put(\"fourth\", Integer.valueOf(4));\n        recordWithHeader.get(\"fourth\"); // <-- fails here\n    }", "error_message": "java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<java.lang.ArrayIndexOutOfBoundsException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)", "buggy_method": "79 public String get(final String name) {\n80         if (mapping == null) {\n81             throw new IllegalStateException(\n82                     \"No header mapping was specified, the record values can't be accessed by name\");\n83         }\n84         final Integer index = mapping.get(name);\n85             return index != null ? values[index.intValue()] : null;\n86     }", "bm_classpath": "org.apache.commons.csv.CSVRecord"}, {"bug_name": "Csv_3", "report_text": "> Unescape handling needs rethinking\n> \n> The current escape parsing converts <esc><char> to plain <char> if the <char> is not one of the special characters to be escaped.\n> This can affect unicode escapes if the <esc> character is backslash.\n> One way round this is to specifically check for <char> == 'u', but it seems wrong to only do this for 'u'.\n> Another solution would be to leave <esc><char> as is unless the <char> is one of the special characters.\n> There are several possible ways to treat unrecognised escapes:\n> * treat it as if the escape char had not been present (current behaviour)\n> * leave the escape char as is\n> * throw an exception", "test_name": "org.apache.commons.csv.CSVLexerTest::testEscapedMySqlNullValue", "test_method": "    @Test\n    public void testEscapedMySqlNullValue() throws Exception {\n        // MySQL uses \\N to symbolize null values. We have to restore this\n        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)\n\torg.junit.Assert.assertThat(Assert.java:865)\n\torg.junit.Assert.assertThat(Assert.java:832)\n\torg.apache.commons.csv.CSVLexerTest.testEscapedMySqlNullValue(CSVLexerTest.java:335)", "buggy_method": "87 int readEscape() throws IOException {\n88         // the escape char has just been read (normally a backslash)\n89         final int c = in.read();\n90         switch (c) {\n91         case 'r':\n92             return CR;\n93         case 'n':\n94             return LF;\n95         case 't':\n96             return TAB;\n97         case 'b':\n98             return BACKSPACE;\n99         case 'f':\n100             return FF;\n101         case CR:\n102         case LF:\n103         case FF: // TODO is this correct?\n104         case TAB: // TODO is this correct? Do tabs need to be escaped?\n105         case BACKSPACE: // TODO is this correct?\n106             return c;\n107         case END_OF_STREAM:\n108             throw new IOException(\"EOF whilst processing escape sequence\");\n109         default:\n110             // Now check for meta-characters\n111                 return c;\n112             // indicate unexpected char - available from in.getLastChar()\n113         }\n114     }", "bm_classpath": "org.apache.commons.csv.Lexer"}, {"bug_name": "Csv_4", "report_text": "> CSVParser: getHeaderMap throws NPE\n> \n> title nearly says it all ![](/jira/images/icons/emoticons/smile.png) \n> Given a CSVParser parser, the following line throws an NPE:\n> ```\n> Map<String, Integer> header = parser.getHeaderMap();\n> ```\n> Stacktrace: \n> ```\n> Caused by: java.lang.NullPointerException\n> at java.util.HashMap.<init>(HashMap.java:318)\n> at java.util.LinkedHashMap.<init>(LinkedHashMap.java:212)\n> at org.apache.commons.csv.CSVParser.getHeaderMap(CSVParser.java:288)\n> ```\n> happens if the format doesn't have a headerMap.\n> to fix, check if the parser's headerMap is null before trying to create the returned map:\n> ```\n> public Map<String, Integer> getHeaderMap() {\n>     return this.headerMap != null ?\n>        new LinkedHashMap<String, Integer>(this.headerMap)\n>        : null;\n> }\n> ```", "test_name": "org.apache.commons.csv.CSVParserTest::testNoHeaderMap", "test_method": "    @Test\n    public void testNoHeaderMap() throws Exception {\n        final CSVParser parser = CSVParser.parse(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT);\n        Assert.assertNull(parser.getHeaderMap()); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tjava.util.HashMap.putMapEntries(HashMap.java:501)\n\tjava.util.LinkedHashMap.<init>(LinkedHashMap.java:384)\n\torg.apache.commons.csv.CSVParser.getHeaderMap(CSVParser.java:288)\n\torg.apache.commons.csv.CSVParserTest.testNoHeaderMap(CSVParserTest.java:670)", "buggy_method": "287 public Map<String, Integer> getHeaderMap() {\n288         return new LinkedHashMap<String, Integer>(this.headerMap);\n289     }", "bm_classpath": "org.apache.commons.csv.CSVParser"}, {"bug_name": "Csv_5", "report_text": "> CSVFormat.format allways append null\n> \n> When I now call  \n> CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\",\"H2\").format(\"A\",\"B\")  \n> I get the output A;Bnull\n> The expected output would be \n> A;B", "test_name": "org.apache.commons.csv.CSVFormatTest::testNullRecordSeparatorCsv106", "test_method": "    @Test\n    public void testNullRecordSeparatorCsv106() {\n        final CSVFormat format = CSVFormat.newFormat(';').withSkipHeaderRecord(true).withHeader(\"H1\", \"H2\");\n        final String formatStr = format.format(\"A\", \"B\");\n        assertFalse(formatStr.endsWith(\"null\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertFalse(Assert.java:64)\n\torg.junit.Assert.assertFalse(Assert.java:74)\n\torg.apache.commons.csv.CSVFormatTest.testNullRecordSeparatorCsv106(CSVFormatTest.java:237)", "buggy_method": "323 public void println() throws IOException {\n324         final String recordSeparator = format.getRecordSeparator();\n325             out.append(recordSeparator);\n326         newRecord = true;\n327     }", "bm_classpath": "org.apache.commons.csv.CSVPrinter"}, {"bug_name": "Csv_6", "report_text": "> CSVRecord.toMap() fails if row length shorter than header length\n> \n> Similar to [~~CSV-96~~](https://issues.apache.org/jira/browse/CSV-96 \"CSVRecord does not verify that the length of the header mapping matches the number of values\"), if .toMap() is called on a record that has fewer fields than we have header columns we'll get an ArrayOutOfBoundsException.\n> ```\n> @Test\n> public void testToMapWhenHeaderTooLong() throws Exception {\n>    final CSVParser parser = new CSVParser(\"a,b\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n>    final CSVRecord record = parser.iterator().next();\n>    record.toMap();\n> }\n> ```", "test_name": "org.apache.commons.csv.CSVRecordTest::testToMapWithShortRecord", "test_method": "    @Test\n    public void testToMapWithShortRecord() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n       final CSVRecord shortRec = parser.iterator().next();\n       shortRec.toMap(); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 2\n\torg.apache.commons.csv.CSVRecord.putIn(CSVRecord.java:182)\n\torg.apache.commons.csv.CSVRecord.toMap(CSVRecord.java:212)\n\torg.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord(CSVRecordTest.java:167)", "buggy_method": "179 <M extends Map<String, String>> M putIn(final M map) {\n180         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n181             final int col = entry.getValue().intValue();\n182                 map.put(entry.getKey(), values[col]);\n183         }\n184         return map;\n185     }", "bm_classpath": "org.apache.commons.csv.CSVRecord"}, {"bug_name": "Csv_7", "report_text": "> HeaderMap is inconsistent when it is parsed from an input with duplicate columns names\n> \n> Given a parser format for csv files with a header line:\n> ```\n> CSVFormat myFormat = CSVFormat.RFC4180.withDelimiter(\",\").withQuoteChar('\"').withQuotePolicy(Quote.MINIMAL)\n> \t\t\t\t.withIgnoreSurroundingSpaces(true).withHeader().withSkipHeaderRecord(true);\n> ```\n> And given a file with duplicate header names:\n> Col1,Col2,Col2,Col3,Col4  \n> 1,2,3,4,5  \n> 4,5,6,7,8 \n> The HeaderMap returned by the parser misses an entry because of the Column name being used as a key, leading to wrong behavior when we rely on it.\n> If this is not supposed to happen in the file regarding the CSV format, at least this should raise an error. If not we should come up with a more clever way to store and access the headers.", "test_name": "org.apache.commons.csv.CSVParserTest::testDuplicateHeaderEntries", "test_method": "public void testDuplicateHeaderEntries() throws Exception {\n        CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[]{}));\n    }\n\n    @Test", "error_message": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalStateException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "348 private Map<String, Integer> initializeHeader() throws IOException {\n349         Map<String, Integer> hdrMap = null;\n350         final String[] formatHeader = this.format.getHeader();\n351         if (formatHeader != null) {\n352             hdrMap = new LinkedHashMap<String, Integer>();\n353 \n354             String[] header = null;\n355             if (formatHeader.length == 0) {\n356                 // read the header from the first line of the file\n357                 final CSVRecord nextRecord = this.nextRecord();\n358                 if (nextRecord != null) {\n359                     header = nextRecord.values();\n360                 }\n361             } else {\n362                 if (this.format.getSkipHeaderRecord()) {\n363                     this.nextRecord();\n364                 }\n365                 header = formatHeader;\n366             }\n367 \n368             // build the name to index mappings\n369             if (header != null) {\n370                 for (int i = 0; i < header.length; i++) {\n371                     hdrMap.put(header[i], Integer.valueOf(i));\n372                 }\n373             }\n374         }\n375         return hdrMap;\n376     }", "bm_classpath": "org.apache.commons.csv.CSVParser"}, {"bug_name": "Csv_8", "report_text": "> CSVFormat constructor should reject a header array with duplicate entries\n> \n> CSVFormat currently accepts whatever header String[] is provided.  \n> It cannot be used if there are duplicate entries so these should be rejected.", "test_name": "org.apache.commons.csv.CSVFormatTest::testDuplicateHeaderElements", "test_method": "    @Test(expected = IllegalArgumentException.class)\n    public void testDuplicateHeaderElements() {\n        CSVFormat.DEFAULT.withHeader(\"A\", \"A\").validate(); // <-- fails here\n    }", "error_message": "java.lang.Exception: Unexpected exception, expected<java.lang.IllegalArgumentException> but was<java.lang.IllegalStateException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "296 private CSVFormat(final char delimiter, final Character quoteChar,\n297             final Quote quotePolicy, final Character commentStart,\n298             final Character escape, final boolean ignoreSurroundingSpaces,\n299             final boolean ignoreEmptyLines, final String recordSeparator,\n300             final String nullString, final String[] header, final boolean skipHeaderRecord) {\n301         if (isLineBreak(delimiter)) {\n302             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n303         }\n304         this.delimiter = delimiter;\n305         this.quoteChar = quoteChar;\n306         this.quotePolicy = quotePolicy;\n307         this.commentStart = commentStart;\n308         this.escape = escape;\n309         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n310         this.ignoreEmptyLines = ignoreEmptyLines;\n311         this.recordSeparator = recordSeparator;\n312         this.nullString = nullString;\n313         if (header == null) {\n314         \tthis.header = null;\n315         } else {\n316             this.header = header.clone();        \t\n317         }\n318         this.skipHeaderRecord = skipHeaderRecord;\n319     }", "bm_classpath": "org.apache.commons.csv.CSVFormat"}, {"bug_name": "Csv_9", "report_text": "> CSVRecord.toMap() throws NPE on formats with no headers.\n> \n> The method toMap() on CSVRecord throws a NullPointerExcpetion when called on records derived using a format with no headers.\n> The method documentation states a null map should be returned instead.", "test_name": "org.apache.commons.csv.CSVRecordTest::testToMapWithNoHeader", "test_method": "    @Test\n    public void testToMapWithNoHeader() throws Exception {\n       final CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.newFormat(','));\n       final CSVRecord shortRec = parser.iterator().next();\n       Map<String, String> map = shortRec.toMap(); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.csv.CSVRecord.putIn(CSVRecord.java:180)\n\torg.apache.commons.csv.CSVRecord.toMap(CSVRecord.java:214)\n\torg.apache.commons.csv.CSVRecordTest.testToMapWithNoHeader(CSVRecordTest.java:175)", "buggy_method": "179 <M extends Map<String, String>> M putIn(final M map) {\n180         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n181             final int col = entry.getValue().intValue();\n182             if (col < values.length) {\n183                 map.put(entry.getKey(), values[col]);\n184             }\n185         }\n186         return map;\n187     }", "bm_classpath": "org.apache.commons.csv.CSVRecord"}, {"bug_name": "Csv_10", "report_text": "> CSVFormat#withHeader doesn't work with CSVPrinter\n> \n> In the current version [CSVFormat#withHeader](https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVFormat.html#withHeader(java.lang.String...)) is only used by CSVParser. It would be nice if CSVPrinter also supported it. Ideally, the following line of code\n> ```\n> CSVPrinter csvPrinter\n>   = CSVFormat.TDF\n>     .withHeader(\"x\")\n>     .print(Files.newBufferedWriter(Paths.get(\"data.csv\")));\n> csvPrinter.printRecord(42);\n> csvPrinter.close();\n> ```\n> should produce\n> ```\n> x\n> 42\n> ```\n> If you're alright with the idea of automatically inserting headers, I can attach a patch.", "test_name": "org.apache.commons.csv.CSVPrinterTest::testHeader", "test_method": "    @Test\n    public void testHeader() throws IOException {\n        final StringWriter sw = new StringWriter();\n        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n                .withHeader(\"C1\", \"C2\", \"C3\"));\n        printer.printRecord(\"a\", \"b\", \"c\");\n        printer.printRecord(\"x\", \"y\", \"z\");\n        assertEquals(\"C1,C2,C3\\r\\na,b,c\\r\\nx,y,z\\r\\n\", sw.toString()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[C1,C2,C3\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.csv.CSVPrinterTest.testHeader(CSVPrinterTest.java:495)", "buggy_method": "61 public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n62         Assertions.notNull(out, \"out\");\n63         Assertions.notNull(format, \"format\");\n64 \n65         this.out = out;\n66         this.format = format;\n67         this.format.validate();\n68         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n69         // It seems a pain to have to track whether the header has already been printed or not.\n70     }", "bm_classpath": "org.apache.commons.csv.CSVPrinter"}, {"bug_name": "Csv_11", "report_text": "> NullPointerException when empty header string and and null string of \"\"\n> \n> When setting the format to have a nullString of \"\" and having an empty header value, a nullPointerException is thrown.", "test_name": "org.apache.commons.csv.CSVParserTest::testHeaderMissingWithNull", "test_method": "    @Test\n    public void testHeaderMissingWithNull() throws Exception {\n        final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n        CSVFormat.DEFAULT.withHeader().withNullString(\"\").withIgnoreEmptyHeaders(true).parse(in).iterator(); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.csv.CSVParser.initializeHeader(CSVParser.java:384)\n\torg.apache.commons.csv.CSVParser.<init>(CSVParser.java:250)\n\torg.apache.commons.csv.CSVFormat.parse(CSVFormat.java:611)\n\torg.apache.commons.csv.CSVParserTest.testHeaderMissingWithNull(CSVParserTest.java:670)", "buggy_method": "359 private Map<String, Integer> initializeHeader() throws IOException {\n360         Map<String, Integer> hdrMap = null;\n361         final String[] formatHeader = this.format.getHeader();\n362         if (formatHeader != null) {\n363             hdrMap = new LinkedHashMap<String, Integer>();\n364 \n365             String[] headerRecord = null;\n366             if (formatHeader.length == 0) {\n367                 // read the header from the first line of the file\n368                 final CSVRecord nextRecord = this.nextRecord();\n369                 if (nextRecord != null) {\n370                     headerRecord = nextRecord.values();\n371                 }\n372             } else {\n373                 if (this.format.getSkipHeaderRecord()) {\n374                     this.nextRecord();\n375                 }\n376                 headerRecord = formatHeader;\n377             }\n378 \n379             // build the name to index mappings\n380             if (headerRecord != null) {\n381                 for (int i = 0; i < headerRecord.length; i++) {\n382                     final String header = headerRecord[i];\n383                     final boolean containsHeader = hdrMap.containsKey(header);\n384                     final boolean emptyHeader = header.trim().isEmpty();\n385                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n386                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n387                                 \"\\\" in \" + Arrays.toString(headerRecord));\n388                     }\n389                     hdrMap.put(header, Integer.valueOf(i));\n390                 }\n391             }\n392         }\n393         return hdrMap;\n394     }", "bm_classpath": "org.apache.commons.csv.CSVParser"}, {"bug_name": "Csv_14", "report_text": "> Negative numeric values in the first column are always quoted in minimal mode\n> \n> Negative Numeric values are always quoted in minimal mode if (and only if) they are in the first column.\n> i.e.  \n> long,lat,data  \n> \"-92.222\",43.333,3\n> Looking at the code, this is by design but seem to be for an unknown reason.\n> From v1.2 CSVPrinter line 230:\n> // TODO where did this rule come from?  \n> if (newRecord && (c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {  \n>  quote = true;  \n> } else ...\n> I propose this rule to either be remove or at a minimum be changed to:  \n> // TODO where did this rule come from?  \n> if (newRecord && (c !='-' && c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || (c > 'z'))) {  \n>  quote = true;  \n> } else ...", "test_name": "org.apache.commons.csv.CSVPrinterTest::testEscapeNull1", "test_method": "    @Test\n    public void testEscapeNull1() throws IOException {\n        StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape(null))) {\n            printer.print(\"\\\\\");\n        }\n        assertEquals(\"\\\\\", sw.toString()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[\\]> but was:<[\"\\\"]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.csv.CSVPrinterTest.testEscapeNull1(CSVPrinterTest.java:346)", "buggy_method": "1001 private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n1002             final Appendable out, final boolean newRecord) throws IOException {\n1003         boolean quote = false;\n1004         int start = offset;\n1005         int pos = offset;\n1006         final int end = offset + len;\n1007 \n1008         final char delimChar = getDelimiter();\n1009         final char quoteChar = getQuoteCharacter().charValue();\n1010 \n1011         QuoteMode quoteModePolicy = getQuoteMode();\n1012         if (quoteModePolicy == null) {\n1013             quoteModePolicy = QuoteMode.MINIMAL;\n1014         }\n1015         switch (quoteModePolicy) {\n1016         case ALL:\n1017             quote = true;\n1018             break;\n1019         case NON_NUMERIC:\n1020             quote = !(object instanceof Number);\n1021             break;\n1022         case NONE:\n1023             // Use the existing escaping code\n1024             printAndEscape(value, offset, len, out);\n1025             return;\n1026         case MINIMAL:\n1027             if (len <= 0) {\n1028                 // always quote an empty token that is the first\n1029                 // on the line, as it may be the only thing on the\n1030                 // line. If it were not quoted in that case,\n1031                 // an empty line has no tokens.\n1032                 if (newRecord) {\n1033                     quote = true;\n1034                 }\n1035             } else {\n1036                 char c = value.charAt(pos);\n1037 \n1038                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n1039                 if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n1040                     quote = true;\n1041                 } else if (c <= COMMENT) {\n1042                     // Some other chars at the start of a value caused the parser to fail, so for now\n1043                     // encapsulate if we start in anything less than '#'. We are being conservative\n1044                     // by including the default comment char too.\n1045                     quote = true;\n1046                 } else {\n1047                     while (pos < end) {\n1048                         c = value.charAt(pos);\n1049                         if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n1050                             quote = true;\n1051                             break;\n1052                         }\n1053                         pos++;\n1054                     }\n1055 \n1056                     if (!quote) {\n1057                         pos = end - 1;\n1058                         c = value.charAt(pos);\n1059                         // Some other chars at the end caused the parser to fail, so for now\n1060                         // encapsulate if we end in anything less than ' '\n1061                         if (c <= SP) {\n1062                             quote = true;\n1063                         }\n1064                     }\n1065                 }\n1066             }\n1067 \n1068             if (!quote) {\n1069                 // no encapsulation needed - write out the original value\n1070                 out.append(value, start, end);\n1071                 return;\n1072             }\n1073             break;\n1074         default:\n1075             throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n1076         }\n1077 \n1078         if (!quote) {\n1079             // no encapsulation needed - write out the original value\n1080             out.append(value, start, end);\n1081             return;\n1082         }\n1083 \n1084         // we hit something that needed encapsulation\n1085         out.append(quoteChar);\n1086 \n1087         // Pick up where we left off: pos should be positioned on the first character that caused\n1088         // the need for encapsulation.\n1089         while (pos < end) {\n1090             final char c = value.charAt(pos);\n1091             if (c == quoteChar) {\n1092                 // write out the chunk up until this point\n1093 \n1094                 // add 1 to the length to write out the encapsulator also\n1095                 out.append(value, start, pos + 1);\n1096                 // put the next starting position on the encapsulator so we will\n1097                 // write it out again with the next string (effectively doubling it)\n1098                 start = pos;\n1099             }\n1100             pos++;\n1101         }\n1102 \n1103         // write the last segment\n1104         out.append(value, start, pos);\n1105         out.append(quoteChar);\n1106     }", "bm_classpath": "org.apache.commons.csv.CSVFormat"}, {"bug_name": "Csv_15", "report_text": "> The behavior of quote char using is not similar as Excel does when the first string contains CJK char(s)\n> \n> When using CSVFormat.EXCEL to print a CSV file, the behavior of quote char using is not similar as Microsoft Excel does when the first string contains Chinese, Japanese or Korean (CJK) char(s).\n> e.g.  \n> There are 3 data members in a record, with Japanese chars: \"\u3042\", \"\u3044\", \"\u3046\":  \n>  Microsoft Excel outputs:  \n>  \u3042,\u3044,\u3046  \n>  Apache Common CSV outputs:  \n>  \"\u3042\",\u3044,\u3046", "test_name": "org.apache.commons.csv.CSVPrinterTest::testDontQuoteEuroFirstChar", "test_method": "    @Test\n    public void testDontQuoteEuroFirstChar() throws IOException {\n        final StringWriter sw = new StringWriter();\n        try (final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.RFC4180)) {\n            printer.printRecord(EURO_CH, \"Deux\");\n            assertEquals(EURO_CH + \",Deux\" + recordSeparator, sw.toString());\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[\u20ac],Deux\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.csv.CSVPrinterTest.testDontQuoteEuroFirstChar(CSVPrinterTest.java:1040)", "buggy_method": "1151 private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n1152             final Appendable out, final boolean newRecord) throws IOException {\n1153         boolean quote = false;\n1154         int start = offset;\n1155         int pos = offset;\n1156         final int end = offset + len;\n1157 \n1158         final char delimChar = getDelimiter();\n1159         final char quoteChar = getQuoteCharacter().charValue();\n1160 \n1161         QuoteMode quoteModePolicy = getQuoteMode();\n1162         if (quoteModePolicy == null) {\n1163             quoteModePolicy = QuoteMode.MINIMAL;\n1164         }\n1165         switch (quoteModePolicy) {\n1166         case ALL:\n1167         case ALL_NON_NULL:\n1168             quote = true;\n1169             break;\n1170         case NON_NUMERIC:\n1171             quote = !(object instanceof Number);\n1172             break;\n1173         case NONE:\n1174             // Use the existing escaping code\n1175             printAndEscape(value, offset, len, out);\n1176             return;\n1177         case MINIMAL:\n1178             if (len <= 0) {\n1179                 // always quote an empty token that is the first\n1180                 // on the line, as it may be the only thing on the\n1181                 // line. If it were not quoted in that case,\n1182                 // an empty line has no tokens.\n1183                 if (newRecord) {\n1184                     quote = true;\n1185                 }\n1186             } else {\n1187                 char c = value.charAt(pos);\n1188 \n1189                 if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n1190                     quote = true;\n1191                 } else if (c <= COMMENT) {\n1192                     // Some other chars at the start of a value caused the parser to fail, so for now\n1193                     // encapsulate if we start in anything less than '#'. We are being conservative\n1194                     // by including the default comment char too.\n1195                     quote = true;\n1196                 } else {\n1197                     while (pos < end) {\n1198                         c = value.charAt(pos);\n1199                         if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n1200                             quote = true;\n1201                             break;\n1202                         }\n1203                         pos++;\n1204                     }\n1205 \n1206                     if (!quote) {\n1207                         pos = end - 1;\n1208                         c = value.charAt(pos);\n1209                         // Some other chars at the end caused the parser to fail, so for now\n1210                         // encapsulate if we end in anything less than ' '\n1211                         if (c <= SP) {\n1212                             quote = true;\n1213                         }\n1214                     }\n1215                 }\n1216             }\n1217 \n1218             if (!quote) {\n1219                 // no encapsulation needed - write out the original value\n1220                 out.append(value, start, end);\n1221                 return;\n1222             }\n1223             break;\n1224         default:\n1225             throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy);\n1226         }\n1227 \n1228         if (!quote) {\n1229             // no encapsulation needed - write out the original value\n1230             out.append(value, start, end);\n1231             return;\n1232         }\n1233 \n1234         // we hit something that needed encapsulation\n1235         out.append(quoteChar);\n1236 \n1237         // Pick up where we left off: pos should be positioned on the first character that caused\n1238         // the need for encapsulation.\n1239         while (pos < end) {\n1240             final char c = value.charAt(pos);\n1241             if (c == quoteChar) {\n1242                 // write out the chunk up until this point\n1243 \n1244                 // add 1 to the length to write out the encapsulator also\n1245                 out.append(value, start, pos + 1);\n1246                 // put the next starting position on the encapsulator so we will\n1247                 // write it out again with the next string (effectively doubling it)\n1248                 start = pos;\n1249             }\n1250             pos++;\n1251         }\n1252 \n1253         // write the last segment\n1254         out.append(value, start, pos);\n1255         out.append(quoteChar);\n1256     }", "bm_classpath": "org.apache.commons.csv.CSVFormat"}, {"bug_name": "Csv_16", "report_text": "> Some multi-iterator parsing peek sequences incorrectly consume elements\n> \n> Repeated calls to CSVParser Iterable return new Iterators that each reference the same underlying parser lexer. Within the scope of a\u00a0single Iterator, row peeking with Iterator.hasNext() works as intended. When row peeking with Iterator.hasNext()\u00a0under circumstances that create a new Iterator, an element is consumed by the iterator which cannot be\u00a0accessed by subsequent, newly created Iterators and Iterator.next()s. Effectively, the record Iterator and the lexer get out of sequence. See snippet below.\n> The \"right thing\" is keeping the Iterator in sequence with the lexer, and since this is reading from a buffer, there seem to me to be only two resolutions:\n> 1. One lexer, one Iterator.\n> 2. New Iterators, but peeking with hasNext doesn't advance the lexer.\n> \u00a0\n> If there's a consensus on one of these, I can put up a PR.\n> \u00a0\n> ```\n> \r\n> \u00a0 @Test\r\n> \r\n> \u00a0 public void newIteratorSameLexer() throws Exception {\r\n> \r\n> \r\n> \r\n> \u00a0 \u00a0 String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\r\n> \r\n> \r\n> \r\n> \u00a0 \u00a0 System.out.println(\"Enhanced for loop, no peeking:\");\r\n> \r\n> \u00a0 \u00a0 CSVParser parser =\r\n> \r\n> \u00a0 \u00a0 \u00a0 \u00a0 new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n> \r\n> \u00a0 \u00a0 int recordNumber = 0;\r\n> \r\n> \u00a0 \u00a0 for (CSVRecord record : parser) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 recordNumber++;\r\n> \r\n> \u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n> \r\n> \u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 \u00a0 break;\r\n> \r\n> \u00a0 \u00a0 \u00a0 }\r\n> \r\n> \u00a0 \u00a0 }\r\n> \r\n> \u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but the lexer isn't reset so we can pick up\r\n> \r\n> \u00a0 \u00a0 // where we left off.\r\n> \r\n> \u00a0 \u00a0 for (CSVRecord record : parser) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 recordNumber++;\r\n> \r\n> \u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n> \r\n> \u00a0 \u00a0 }\r\n> \r\n> \u00a0 \u00a0 // Enhanced for loop, no peeking:\r\n> \r\n> \u00a0 \u00a0 // 1 -> 1\r\n> \r\n> \u00a0 \u00a0 // 2 -> 2\r\n> \r\n> \u00a0 \u00a0 // 3 -> 3\r\n> \r\n> \u00a0 \u00a0 // 4 -> 4\r\n> \r\n> \u00a0 \u00a0 // 5 -> 5\r\n> \r\n> \r\n> \r\n> \r\n> \r\n> \u00a0 \u00a0 System.out.println(\"\\nEnhanced for loop, with peek:\");\r\n> \r\n> \u00a0 \u00a0 parser = new CSVParser(new BufferedReader(new StringReader(fiveRows)), CSVFormat.DEFAULT);\r\n> \r\n> \u00a0 \u00a0 recordNumber = 0;\r\n> \r\n> \u00a0 \u00a0 for (CSVRecord record : parser) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 recordNumber++;\r\n> \r\n> \u00a0 \u00a0 \u00a0 System.out.println(recordNumber + \" -> \" + record.get(0));\r\n> \r\n> \u00a0 \u00a0 \u00a0 if (recordNumber >= 2) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 \u00a0 break;\r\n> \r\n> \u00a0 \u00a0 \u00a0 }\r\n> \r\n> \u00a0 \u00a0 }\r\n> \r\n> \u00a0 \u00a0 // CSVParser.iterator() returns a new iterator, but we call hasNext before next, so we queue\r\n> \r\n> \u00a0 \u00a0 // one element for consumption. This element is discarded by the new iterator, even though the\r\n> \r\n> \u00a0 \u00a0 // lexer has advanced a row, so we've consumed an element with the peek!\r\n> \r\n> \u00a0 \u00a0 System.out.println(\"hasNext(): \" + parser.iterator().hasNext());\r\n> \r\n> \u00a0 \u00a0 for (CSVRecord record : parser) {\r\n> \r\n> \u00a0 \u00a0 \u00a0 recordNumber++;\r", "test_name": "org.apache.commons.csv.CSVParserTest::testIteratorSequenceBreaking", "test_method": "    @Test\n    public void testIteratorSequenceBreaking() throws IOException {\n        final String fiveRows = \"1\\n2\\n3\\n4\\n5\\n\";\n\n        // Iterator hasNext() shouldn't break sequence\n        CSVParser parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        int recordNumber = 0;\n        Iterator<CSVRecord> iter = parser.iterator();\n        recordNumber = 0;\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        iter.hasNext();\n        while (iter.hasNext()) {\n            CSVRecord record = iter.next();\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n\n        // Consecutive enhanced for loops shouldn't break sequence\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        }\n\n        // Consecutive enhanced for loops with hasNext() peeking shouldn't break sequence\n        parser = CSVFormat.DEFAULT.parse(new StringReader(fiveRows));\n        recordNumber = 0;\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n            if (recordNumber >= 2) {\n                break;\n            }\n        }\n        parser.iterator().hasNext();\n        for (CSVRecord record : parser) {\n            recordNumber++;\n            assertEquals(String.valueOf(recordNumber), record.get(0));\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[3]> but was:<[4]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.csv.CSVParserTest.testIteratorSequenceBreaking(CSVParserTest.java:1053)", "buggy_method": "349 @SuppressWarnings(\"resource\")\n350     public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n351             throws IOException {\n352         Assertions.notNull(reader, \"reader\");\n353         Assertions.notNull(format, \"format\");\n354 \n355         this.format = format;\n356         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n357         this.headerMap = this.initializeHeader();\n358         this.characterOffset = characterOffset;\n359         this.recordNumber = recordNumber - 1;\n360     }", "bm_classpath": "org.apache.commons.csv.CSVParser"}, {"bug_name": "Gson_1", "report_text": "> Fails to serialize/deserialize a class where a super-class has a type parameter\n> \n> ```\n> Unfortunately, shortly after the Gson 1.2 release, I found a bug in the\n> TypeVariable support.  Basically, the following class can not be serialized\n> or deserialized using Gson:\n> public class Foo<T> {\n>   private final T someField;\n>   public Foo(T value) {\n>     this.someField = value;\n>   }\n>   public boolean equals(Object o) {\n>     if (!(o instanceof Foo)) {\n>       return false;\n>     } else {\n>         return someField.equals(((Foo)o).someField);\n>     }\n>   }\n> }\n> public class Bar extends Foo<Integer> {\n>   public Bar(Integer i) {\n>     super(i);\n>   }\n> }\n> Gson gson = new Gson();\n> Bar bar1 = new Bar(1);\n> String json = gson.toJson(bar1);   // Fails\n> Bar bar2 = gson.fromJson(\"{\\\"someField\\\":1\", Bar.class);    // Fails\n> assertEquals(bar1, bar2);\n> ```\n> Original issue reported on code.google.com by `joel.leitch@gmail.com` on 29 Aug 2008 at 11:53\n> * Merged into: [#168](https://github.com/google/gson/issues/168)", "test_name": "com.google.gson.functional.TypeVariableTest::testSingle", "test_method": "  public void testSingle() throws Exception {\n    Gson gson = new Gson();\n    Bar bar1 = new Bar(\"someString\", 1);\n    ArrayList<Integer> arrayList = new ArrayList<Integer>();\n    arrayList.add(1);\n    arrayList.add(2);\n    bar1.map.put(\"key1\", arrayList);\n    bar1.map.put(\"key2\", new ArrayList<Integer>());\n    String json = gson.toJson(bar1); // <-- fails here\n    }", "error_message": "java.lang.UnsupportedOperationException: Expecting parameterized type, got class com.google.gson.functional.TypeVariableTest$Bar.\n\tcom.google.gson.TypeInfoFactory.getActualType(TypeInfoFactory.java:97)\n\tcom.google.gson.TypeInfoFactory.getTypeInfoForField(TypeInfoFactory.java:54)\n\tcom.google.gson.ObjectNavigator.navigateClassFields(ObjectNavigator.java:156)\n\tcom.google.gson.ObjectNavigator.accept(ObjectNavigator.java:131)\n\tcom.google.gson.JsonSerializationContextDefault.serialize(JsonSerializationContextDefault.java:56)\n\tcom.google.gson.Gson.toJsonTree(Gson.java:231)\n\tcom.google.gson.Gson.toJson(Gson.java:271)\n\tcom.google.gson.Gson.toJson(Gson.java:251)\n\tcom.google.gson.functional.TypeVariableTest.testSingle(TypeVariableTest.java:41)", "buggy_method": "58 private static Type getActualType(\n59       Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n60     if (typeToEvaluate instanceof Class<?>) {\n61       return typeToEvaluate;\n62     } else if (typeToEvaluate instanceof ParameterizedType) {\n63       ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n64       Type owner = castedType.getOwnerType();\n65       Type[] actualTypeParameters =\n66           extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n67       Type rawType = castedType.getRawType();\n68       return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n69     } else if (typeToEvaluate instanceof GenericArrayType) {\n70       GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n71       Type componentType = castedType.getGenericComponentType();\n72       Type actualType = getActualType(componentType, parentType, rawParentClass);\n73       if (componentType.equals(actualType)) {\n74         return castedType;\n75       }\n76       return actualType instanceof Class<?> ?\n77           TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n78           : new GenericArrayTypeImpl(actualType);\n79     } else if (typeToEvaluate instanceof TypeVariable<?>) {\n80       if (parentType instanceof ParameterizedType) {\n81         // The class definition has the actual types used for the type variables.\n82         // Find the matching actual type for the Type Variable used for the field.\n83         // For example, class Foo<A> { A a; }\n84         // new Foo<Integer>(); defines the actual type of A to be Integer.\n85         // So, to find the type of the field a, we will have to look at the class'\n86         // actual type arguments.\n87         TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n88         TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n89         ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n90         int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n91         Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n92         return actualTypeArguments[indexOfActualTypeArgument];\n93 \n94 \n95       }\n96 \n97       throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n98           + \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n99           + \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n100     } else if (typeToEvaluate instanceof WildcardType) {\n101       WildcardType castedType = (WildcardType) typeToEvaluate;\n102       return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n103     } else {\n104       throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n105           + \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n106     }\n107   }", "bm_classpath": "com.google.gson.TypeInfoFactory"}, {"bug_name": "Gson_2", "report_text": "> Fix type hierarchy adapters to do a runtime check.\n> \n> Otherwise if we have a type hierarchy adapter for Vehicle, and we  \n> attempt to decode a JSON string as a Car, we get the right exception  \n> if the JSON string is actually decoded as a Truck.", "test_name": "com.google.gson.functional.DefaultTypeAdaptersTest::testJsonElementTypeMismatch", "test_method": "  public void testJsonElementTypeMismatch() {\n    try {\n      gson.fromJson(\"\\\"abc\\\"\", JsonObject.class);\n      fail();\n    } catch (JsonSyntaxException expected) {\n      assertEquals(\"Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive\",\n          expected.getMessage());\n    } // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: Cannot cast com.google.gson.JsonPrimitive to com.google.gson.JsonObject\n\tjava.lang.Class.cast(Class.java:3369)\n\tcom.google.gson.Gson.fromJson(Gson.java:701)\n\tcom.google.gson.functional.DefaultTypeAdaptersTest.testJsonElementTypeMismatch(DefaultTypeAdaptersTest.java:623)", "buggy_method": "824 public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\n825       final Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\n826     return new TypeAdapterFactory() {\n827       @SuppressWarnings(\"unchecked\")\n828       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n829         final Class<? super T2> requestedType = typeToken.getRawType();\n830         if (!clazz.isAssignableFrom(requestedType)) {\n831           return null;\n832         }\n833         return (TypeAdapter<T2>) typeAdapter;\n834 \n835       }\n836       @Override public String toString() {\n837         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n838       }\n839     };\n840   }", "bm_classpath": "com.google.gson.internal.bind.TypeAdapters"}, {"bug_name": "Gson_3", "report_text": "> Error desirialization of ConcurrentNavigableMap\n> \n> ```\n> What steps will reproduce the problem?\n> 1. Create POJO with filled ConcurrentNavigableMap field\n> 2. Sirialize to json string\n> 3. Desirialize from json string\n> What is the expected output? What do you see instead?\n> Original state is expected. IllegalArgumentException is thrown\n> What version of the product are you using? On what operating system?\n> Gson 2.3.1, java 8, windows 7\n> Please provide any additional information below.\n> Gson works only with class type field such as ConcurrentSkipListMap.\n> Good programming style is using interface type such as ConcurrentNavigableMap. \n> See attach for log and unit-test\n> ```\n> Original issue reported on code.google.com by `dkhomya...@gmail.com` on 29 Jan 2015 at 8:34\n> Attachments:\n> * [gsonErrLog.TXT](https://storage.googleapis.com/google-code-attachments/google-gson/issue-624/comment-0/gsonErrLog.TXT)\n> * [JsonUtilsTest.java](https://storage.googleapis.com/google-code-attachments/google-gson/issue-624/comment-0/JsonUtilsTest.java)", "test_name": "com.google.gson.functional.MapTest::testConcurrentMap", "test_method": "  public void testConcurrentMap() throws Exception {\n    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();\n    ConcurrentMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: java.util.LinkedHashMap cannot be cast to java.util.concurrent.ConcurrentMap\n\tcom.google.gson.functional.MapTest.testConcurrentMap(MapTest.java:188)", "buggy_method": "127 @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n128   private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n129       final Type type, Class<? super T> rawType) {\n130     if (Collection.class.isAssignableFrom(rawType)) {\n131       if (SortedSet.class.isAssignableFrom(rawType)) {\n132         return new ObjectConstructor<T>() {\n133           @Override public T construct() {\n134             return (T) new TreeSet<Object>();\n135           }\n136         };\n137       } else if (EnumSet.class.isAssignableFrom(rawType)) {\n138         return new ObjectConstructor<T>() {\n139           @SuppressWarnings(\"rawtypes\")\n140           @Override public T construct() {\n141             if (type instanceof ParameterizedType) {\n142               Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n143               if (elementType instanceof Class) {\n144                 return (T) EnumSet.noneOf((Class)elementType);\n145               } else {\n146                 throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n147               }\n148             } else {\n149               throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n150             }\n151           }\n152         };\n153       } else if (Set.class.isAssignableFrom(rawType)) {\n154         return new ObjectConstructor<T>() {\n155           @Override public T construct() {\n156             return (T) new LinkedHashSet<Object>();\n157           }\n158         };\n159       } else if (Queue.class.isAssignableFrom(rawType)) {\n160         return new ObjectConstructor<T>() {\n161           @Override public T construct() {\n162             return (T) new LinkedList<Object>();\n163           }\n164         };\n165       } else {\n166         return new ObjectConstructor<T>() {\n167           @Override public T construct() {\n168             return (T) new ArrayList<Object>();\n169           }\n170         };\n171       }\n172     }\n173 \n174     if (Map.class.isAssignableFrom(rawType)) {\n175       if (SortedMap.class.isAssignableFrom(rawType)) {\n176         return new ObjectConstructor<T>() {\n177           @Override public T construct() {\n178             return (T) new TreeMap<Object, Object>();\n179           }\n180         };\n181       } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n182           TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n183         return new ObjectConstructor<T>() {\n184           @Override public T construct() {\n185             return (T) new LinkedHashMap<Object, Object>();\n186           }\n187         };\n188       } else {\n189         return new ObjectConstructor<T>() {\n190           @Override public T construct() {\n191             return (T) new LinkedTreeMap<String, Object>();\n192           }\n193         };\n194       }\n195     }\n196 \n197     return null;\n198   }", "bm_classpath": "com.google.gson.internal.ConstructorConstructor"}, {"bug_name": "Gson_4", "report_text": "> Update reader and writer for RFC 7159.\n> \n> This allows for top-level value types without the requirement of leniency.", "test_name": "com.google.gson.stream.JsonReaderTest::testTopLevelValueTypeWithSkipValue", "test_method": "  public void testTopLevelValueTypeWithSkipValue() throws IOException {\n    JsonReader reader = new JsonReader(reader(\"true\"));\n    reader.skipValue(); // <-- fails here\n    }", "error_message": "com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $\n\tcom.google.gson.stream.JsonReader.syntaxError(JsonReader.java:1572)\n\tcom.google.gson.stream.JsonReader.checkLenient(JsonReader.java:1422)\n\tcom.google.gson.stream.JsonReader.doPeek(JsonReader.java:586)\n\tcom.google.gson.stream.JsonReader.skipValue(JsonReader.java:1236)\n\tcom.google.gson.stream.JsonReaderTest.testTopLevelValueTypeWithSkipValue(JsonReaderTest.java:1251)", "buggy_method": "465 int doPeek() throws IOException {\n466     int peekStack = stack[stackSize - 1];\n467     if (peekStack == JsonScope.EMPTY_ARRAY) {\n468       stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n469     } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n470       // Look for a comma before the next element.\n471       int c = nextNonWhitespace(true);\n472       switch (c) {\n473       case ']':\n474         return peeked = PEEKED_END_ARRAY;\n475       case ';':\n476         checkLenient(); // fall-through\n477       case ',':\n478         break;\n479       default:\n480         throw syntaxError(\"Unterminated array\");\n481       }\n482     } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n483       stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n484       // Look for a comma before the next element.\n485       if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n486         int c = nextNonWhitespace(true);\n487         switch (c) {\n488         case '}':\n489           return peeked = PEEKED_END_OBJECT;\n490         case ';':\n491           checkLenient(); // fall-through\n492         case ',':\n493           break;\n494         default:\n495           throw syntaxError(\"Unterminated object\");\n496         }\n497       }\n498       int c = nextNonWhitespace(true);\n499       switch (c) {\n500       case '\"':\n501         return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n502       case '\\'':\n503         checkLenient();\n504         return peeked = PEEKED_SINGLE_QUOTED_NAME;\n505       case '}':\n506         if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n507           return peeked = PEEKED_END_OBJECT;\n508         } else {\n509           throw syntaxError(\"Expected name\");\n510         }\n511       default:\n512         checkLenient();\n513         pos--; // Don't consume the first character in an unquoted string.\n514         if (isLiteral((char) c)) {\n515           return peeked = PEEKED_UNQUOTED_NAME;\n516         } else {\n517           throw syntaxError(\"Expected name\");\n518         }\n519       }\n520     } else if (peekStack == JsonScope.DANGLING_NAME) {\n521       stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n522       // Look for a colon before the value.\n523       int c = nextNonWhitespace(true);\n524       switch (c) {\n525       case ':':\n526         break;\n527       case '=':\n528         checkLenient();\n529         if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n530           pos++;\n531         }\n532         break;\n533       default:\n534         throw syntaxError(\"Expected ':'\");\n535       }\n536     } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n537       if (lenient) {\n538         consumeNonExecutePrefix();\n539       }\n540       stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n541     } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n542       int c = nextNonWhitespace(false);\n543       if (c == -1) {\n544         return peeked = PEEKED_EOF;\n545       } else {\n546         checkLenient();\n547         pos--;\n548       }\n549     } else if (peekStack == JsonScope.CLOSED) {\n550       throw new IllegalStateException(\"JsonReader is closed\");\n551     }\n552 \n553     int c = nextNonWhitespace(true);\n554     switch (c) {\n555     case ']':\n556       if (peekStack == JsonScope.EMPTY_ARRAY) {\n557         return peeked = PEEKED_END_ARRAY;\n558       }\n559       // fall-through to handle \",]\"\n560     case ';':\n561     case ',':\n562       // In lenient mode, a 0-length literal in an array means 'null'.\n563       if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n564         checkLenient();\n565         pos--;\n566         return peeked = PEEKED_NULL;\n567       } else {\n568         throw syntaxError(\"Unexpected value\");\n569       }\n570     case '\\'':\n571       checkLenient();\n572       return peeked = PEEKED_SINGLE_QUOTED;\n573     case '\"':\n574       if (stackSize == 1) {\n575         checkLenient();\n576       }\n577       return peeked = PEEKED_DOUBLE_QUOTED;\n578     case '[':\n579       return peeked = PEEKED_BEGIN_ARRAY;\n580     case '{':\n581       return peeked = PEEKED_BEGIN_OBJECT;\n582     default:\n583       pos--; // Don't consume the first character in a literal value.\n584     }\n585     if (stackSize == 1) {\n586       checkLenient();\n587     }\n588 \n589     int result = peekKeyword();\n590     if (result != PEEKED_NONE) {\n591       return result;\n592     }\n593 \n594     result = peekNumber();\n595     if (result != PEEKED_NONE) {\n596       return result;\n597     }\n598 \n599     if (!isLiteral(buffer[pos])) {\n600       throw syntaxError(\"Expected value\");\n601     }\n602 \n603     checkLenient();\n604     return peeked = PEEKED_UNQUOTED;\n605   }", "bm_classpath": "com.google.gson.stream.JsonReader"}, {"bug_name": "Gson_5", "report_text": "> ISO8601 is not fully implemented\n> \n> Hi guys,\n> I'm working on a project where I have to parse `2016-01-11T11:06:14.000-02` to java.util.Date which is a valid date according to [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) on page 12.\n> But I got an Exception trying to archive it\n> ```\n> Caused by: com.google.gson.JsonSyntaxException: 2016-01-11T11:06:14.000-02\n>         at com.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:107)\n>         at com.google.gson.DefaultDateTypeAdapter.deserialize(DefaultDateTypeAdapter.java:84)\n>         at com.google.gson.DefaultDateTypeAdapter.deserialize(DefaultDateTypeAdapter.java:38)\n>         at com.google.gson.TreeTypeAdapter.read(TreeTypeAdapter.java:58)\n>         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:117)\n>         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:217)\n>         at com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper.read(TypeAdapterRuntimeTypeWrapper.java:40)\n>         at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:82)\n>         at com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter.read(CollectionTypeAdapterFactory.java:61)\n>         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:117)\n>         at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:217)\n>         at com.google.gson.Gson.fromJson(Gson.java:861)\n>         at com.google.gson.Gson.fromJson(Gson.java:926)\n>         at com.google.gson.Gson.fromJson(Gson.java:899)\n>         at ...\n> Caused by: java.text.ParseException: Failed to parse date [\"2016-01-11T11:06:14.000-02']: Mismatching time zone indicator: GMT-02 given, resolves to GMT-02:00\n>         at com.google.gson.internal.bind.util.ISO8601Utils.parse(ISO8601Utils.java:270)\n>         at com.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:105)\n>         ... 31 more\n> Caused by: java.lang.IndexOutOfBoundsException: Mismatching time zone indicator: GMT-02 given, resolves to GMT-02:00\n>         at com.google.gson.internal.bind.util.ISO8601Utils.parse(ISO8601Utils.java:236)\n>         ... 32 more\n> ```\n> I'm able to fix this if it sounds reasonable.", "test_name": "com.google.gson.DefaultDateTypeAdapterTest::testDateDeserializationISO8601", "test_method": "  public void testDateDeserializationISO8601() throws Exception {\n  \tDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\n    assertParsed(\"1970-01-01T01:00:00+01\", adapter); // <-- fails here\n    }", "error_message": "com.google.gson.JsonSyntaxException: 1970-01-01T01:00:00+01\n\tcom.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:107)\n\tcom.google.gson.DefaultDateTypeAdapter.deserialize(DefaultDateTypeAdapter.java:84)\n\tcom.google.gson.DefaultDateTypeAdapterTest.assertParsed(DefaultDateTypeAdapterTest.java:168)\n\tcom.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601(DefaultDateTypeAdapterTest.java:133)", "buggy_method": "123 public static Date parse(String date, ParsePosition pos) throws ParseException {\n124         Exception fail = null;\n125         try {\n126             int offset = pos.getIndex();\n127 \n128             // extract year\n129             int year = parseInt(date, offset, offset += 4);\n130             if (checkOffset(date, offset, '-')) {\n131                 offset += 1;\n132             }\n133 \n134             // extract month\n135             int month = parseInt(date, offset, offset += 2);\n136             if (checkOffset(date, offset, '-')) {\n137                 offset += 1;\n138             }\n139 \n140             // extract day\n141             int day = parseInt(date, offset, offset += 2);\n142             // default time value\n143             int hour = 0;\n144             int minutes = 0;\n145             int seconds = 0;\n146             int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n147 \n148             // if the value has no time component (and no time zone), we are done\n149             boolean hasT = checkOffset(date, offset, 'T');\n150             \n151             if (!hasT && (date.length() <= offset)) {\n152                 Calendar calendar = new GregorianCalendar(year, month - 1, day);\n153 \n154                 pos.setIndex(offset);\n155                 return calendar.getTime();\n156             }\n157 \n158             if (hasT) {\n159 \n160                 // extract hours, minutes, seconds and milliseconds\n161                 hour = parseInt(date, offset += 1, offset += 2);\n162                 if (checkOffset(date, offset, ':')) {\n163                     offset += 1;\n164                 }\n165 \n166                 minutes = parseInt(date, offset, offset += 2);\n167                 if (checkOffset(date, offset, ':')) {\n168                     offset += 1;\n169                 }\n170                 // second and milliseconds can be optional\n171                 if (date.length() > offset) {\n172                     char c = date.charAt(offset);\n173                     if (c != 'Z' && c != '+' && c != '-') {\n174                         seconds = parseInt(date, offset, offset += 2);\n175                         if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n176                         // milliseconds can be optional in the format\n177                         if (checkOffset(date, offset, '.')) {\n178                             offset += 1;\n179                             int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\n180                             int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\n181                             int fraction = parseInt(date, offset, parseEndOffset);\n182                             // compensate for \"missing\" digits\n183                             switch (parseEndOffset - offset) { // number of digits parsed\n184                             case 2:\n185                                 milliseconds = fraction * 10;\n186                                 break;\n187                             case 1:\n188                                 milliseconds = fraction * 100;\n189                                 break;\n190                             default:\n191                                 milliseconds = fraction;\n192                             }\n193                             offset = endOffset;\n194                         }\n195                     }\n196                 }\n197             }\n198 \n199             // extract timezone\n200             if (date.length() <= offset) {\n201                 throw new IllegalArgumentException(\"No time zone indicator\");\n202             }\n203 \n204             TimeZone timezone = null;\n205             char timezoneIndicator = date.charAt(offset);\n206 \n207             if (timezoneIndicator == 'Z') {\n208                 timezone = TIMEZONE_UTC;\n209                 offset += 1;\n210             } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n211                 String timezoneOffset = date.substring(offset);\n212 \n213                 // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n214 \n215                 offset += timezoneOffset.length();\n216                 // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n217                 if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n218                     timezone = TIMEZONE_UTC;\n219                 } else {\n220                     // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n221                     //    not sure why, but that's the way it looks. Further, Javadocs for\n222                     //    `java.util.TimeZone` specifically instruct use of GMT as base for\n223                     //    custom timezones... odd.\n224                     String timezoneId = \"GMT\" + timezoneOffset;\n225 //                    String timezoneId = \"UTC\" + timezoneOffset;\n226 \n227                     timezone = TimeZone.getTimeZone(timezoneId);\n228 \n229                     String act = timezone.getID();\n230                     if (!act.equals(timezoneId)) {\n231                         /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n232                          *    one without. If so, don't sweat.\n233                          *   Yes, very inefficient. Hopefully not hit often.\n234                          *   If it becomes a perf problem, add 'loose' comparison instead.\n235                          */\n236                         String cleaned = act.replace(\":\", \"\");\n237                         if (!cleaned.equals(timezoneId)) {\n238                             throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n239                                     +timezone.getID());\n240                         }\n241                     }\n242                 }\n243             } else {\n244                 throw new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n245             }\n246 \n247             Calendar calendar = new GregorianCalendar(timezone);\n248             calendar.setLenient(false);\n249             calendar.set(Calendar.YEAR, year);\n250             calendar.set(Calendar.MONTH, month - 1);\n251             calendar.set(Calendar.DAY_OF_MONTH, day);\n252             calendar.set(Calendar.HOUR_OF_DAY, hour);\n253             calendar.set(Calendar.MINUTE, minutes);\n254             calendar.set(Calendar.SECOND, seconds);\n255             calendar.set(Calendar.MILLISECOND, milliseconds);\n256 \n257             pos.setIndex(offset);\n258             return calendar.getTime();\n259             // If we get a ParseException it'll already have the right message/offset.\n260             // Other exception types can convert here.\n261         } catch (IndexOutOfBoundsException e) {\n262             fail = e;\n263         } catch (NumberFormatException e) {\n264             fail = e;\n265         } catch (IllegalArgumentException e) {\n266             fail = e;\n267         }\n268         String input = (date == null) ? null : ('\"' + date + \"'\");\n269         String msg = fail.getMessage();\n270         if (msg == null || msg.isEmpty()) {\n271             msg = \"(\"+fail.getClass().getName()+\")\";\n272         }\n273         ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n274         ex.initCause(fail);\n275         throw ex;\n276     }", "bm_classpath": "com.google.gson.internal.bind.util.ISO8601Utils"}, {"bug_name": "Gson_6", "report_text": "> Fixed a regression in Gson 2.6 where Gson caused NPE if the TypeAdapt\u2026\n> \n> \u2026erFactory.create() returned null.", "test_name": "com.google.gson.regression.JsonAdapterNullSafeTest::testNullSafeBugDeserialize", "test_method": "  public void testNullSafeBugDeserialize() throws Exception {\n    Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter(JsonAdapterAnnotationTypeAdapterFactory.java:67)\n\tcom.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.create(JsonAdapterAnnotationTypeAdapterFactory.java:47)\n\tcom.google.gson.Gson.getDelegateAdapter(Gson.java:498)\n\tcom.google.gson.regression.JsonAdapterNullSafeTest$Device$JsonAdapterFactory.create(JsonAdapterNullSafeTest.java:58)\n\tcom.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter(JsonAdapterAnnotationTypeAdapterFactory.java:60)\n\tcom.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.create(JsonAdapterAnnotationTypeAdapterFactory.java:47)\n\tcom.google.gson.Gson.getAdapter(Gson.java:416)\n\tcom.google.gson.Gson.fromJson(Gson.java:878)\n\tcom.google.gson.Gson.fromJson(Gson.java:844)\n\tcom.google.gson.Gson.fromJson(Gson.java:793)\n\tcom.google.gson.Gson.fromJson(Gson.java:765)\n\tcom.google.gson.regression.JsonAdapterNullSafeTest.testNullSafeBugDeserialize(JsonAdapterNullSafeTest.java:35)", "buggy_method": "50 @SuppressWarnings(\"unchecked\") // Casts guarded by conditionals.\n51   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n52       TypeToken<?> fieldType, JsonAdapter annotation) {\n53     Class<?> value = annotation.value();\n54     TypeAdapter<?> typeAdapter;\n55     if (TypeAdapter.class.isAssignableFrom(value)) {\n56       Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n57       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n58     } else if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n59       Class<TypeAdapterFactory> typeAdapterFactory = (Class<TypeAdapterFactory>) value;\n60       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterFactory))\n61           .construct()\n62           .create(gson, fieldType);\n63     } else {\n64       throw new IllegalArgumentException(\n65           \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n66     }\n67       typeAdapter = typeAdapter.nullSafe();\n68     return typeAdapter;\n69   }", "bm_classpath": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory"}, {"bug_name": "Gson_7", "report_text": "> JsonReader.nextInt() doesent work if p == PEEKED_UNQUOTED\n> \n> ```\n> What steps will reproduce the problem?\n> This unit test describes the problem:\n>     @Test public void test() {\n>         Map<Integer, Integer> expected = new HashMap<Integer, Integer>() {{ put(0, 1); }};\n>         Map<Integer, Integer> actual = new Gson().fromJson(\"{0:1}\", new TypeToken<Map<Integer, Integer>>() {}.getType());\n>         assertEquals(expected, actual);\n>     }\n> What version of the product are you using? On what operating system?\n> 2.3 (version 2.1 works OK)\n> ```\n> Original issue reported on code.google.com by `feathoro...@gmail.com` on 28 Oct 2014 at 4:32", "test_name": "com.google.gson.functional.MapTest::testMapDeserializationWithUnquotedLongKeys", "test_method": "  public void testMapDeserializationWithUnquotedLongKeys() {\n    long longKey = 9876543210L;\n    String json = String.format(\"{%d:\\\"456\\\"}\", longKey);\n    Type typeOfMap = new TypeToken<Map<Long, String>>() {}.getType();\n    Map<Long, String> map = gson.fromJson(json, typeOfMap); // <-- fails here\n    }", "error_message": "com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a long but was STRING at line 1 column 2 path $.\n\tcom.google.gson.Gson.fromJson(Gson.java:892)\n\tcom.google.gson.Gson.fromJson(Gson.java:845)\n\tcom.google.gson.Gson.fromJson(Gson.java:794)\n\tcom.google.gson.functional.MapTest.testMapDeserializationWithUnquotedLongKeys(MapTest.java:192)", "buggy_method": "939 public long nextLong() throws IOException {\n940     int p = peeked;\n941     if (p == PEEKED_NONE) {\n942       p = doPeek();\n943     }\n944 \n945     if (p == PEEKED_LONG) {\n946       peeked = PEEKED_NONE;\n947       pathIndices[stackSize - 1]++;\n948       return peekedLong;\n949     }\n950 \n951     if (p == PEEKED_NUMBER) {\n952       peekedString = new String(buffer, pos, peekedNumberLength);\n953       pos += peekedNumberLength;\n954     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n955         peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n956       try {\n957         long result = Long.parseLong(peekedString);\n958         peeked = PEEKED_NONE;\n959         pathIndices[stackSize - 1]++;\n960         return result;\n961       } catch (NumberFormatException ignored) {\n962         // Fall back to parse as a double below.\n963       }\n964     } else {\n965       throw new IllegalStateException(\"Expected a long but was \" + peek()\n966           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n967     }\n968 \n969     peeked = PEEKED_BUFFERED;\n970     double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n971     long result = (long) asDouble;\n972     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n973       throw new NumberFormatException(\"Expected a long but was \" + peekedString\n974           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n975     }\n976     peekedString = null;\n977     peeked = PEEKED_NONE;\n978     pathIndices[stackSize - 1]++;\n979     return result;\n980   }", "bm_classpath": "com.google.gson.stream.JsonReader"}, {"bug_name": "Gson_8", "report_text": "> JNI Error in Android\n> \n> I am getting a 'JNI DETECTED AN ERROR IN APPLICATION\" while using gson 2.5.jar in Android. Can anyone tell me how to solve this? Appreciate it.  \n> I am using a sub-class of Parse Object using Parse SDK.  \n> Here is the stack trace:\n> ```\n> 03-28 14:01:15.445: E/art(28683): JNI DETECTED ERROR IN APPLICATION: can't make objects of type java.util.concurrent.locks.Lock: 0x70dd7858\n> 03-28 14:01:15.445: E/art(28683):     in call to AllocObject\n> 03-28 14:01:15.445: E/art(28683):     from java.lang.Object sun.misc.Unsafe.allocateInstance(java.lang.Class)\n> 03-28 14:01:15.445: E/art(28683): \"main\" prio=5 tid=1 Runnable\n> 03-28 14:01:15.445: E/art(28683):   | group=\"main\" sCount=0 dsCount=0 obj=0x7617aef8 self=0x7fa917c400\n> 03-28 14:01:15.445: E/art(28683):   | sysTid=28683 nice=0 cgrp=default sched=0/0 handle=0x7face5d2c0\n> 03-28 14:01:15.445: E/art(28683):   | state=R schedstat=( 657346072 17671229 611 ) utm=52 stm=13 core=1 HZ=100\n> 03-28 14:01:15.445: E/art(28683):   | stack=0x7fe28ac000-0x7fe28ae000 stackSize=8MB\n> 03-28 14:01:15.445: E/art(28683):   | held mutexes= \"mutator lock\"(shared held)\n> 03-28 14:01:15.445: E/art(28683):   at sun.misc.Unsafe.allocateInstance(Native method)\n> 03-28 14:01:15.445: E/art(28683):   at java.lang.reflect.Method.invoke!(Native method)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.UnsafeAllocator$1.newInstance(UnsafeAllocator.java:48)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.ConstructorConstructor$14.construct(ConstructorConstructor.java:223)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:207)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:117)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:217)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:117)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:217)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.Gson.fromJson(Gson.java:861)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.Gson.fromJson(Gson.java:826)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.Gson.fromJson(Gson.java:775)\n> 03-28 14:01:15.445: E/art(28683):   at com.google.gson.Gson.fromJson(Gson.java:747)\n> 03-28 14:01:15.445: E/art(28683):   at b5.project.medibro.FeedItemDetails.onCreate(FeedItemDetails.java:47)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.Activity.performCreate(Activity.java:6583)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1114)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2531)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2666)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.ActivityThread.-wrap11(ActivityThread.java:-1)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1493)\n> 03-28 14:01:15.445: E/art(28683):   at android.os.Handler.dispatchMessage(Handler.java:111)\n> 03-28 14:01:15.445: E/art(28683):   at android.os.Looper.loop(Looper.java:207)\n> 03-28 14:01:15.445: E/art(28683):   at android.app.ActivityThread.main(ActivityThread.java:5769)\n> 03-28 14:01:15.445: E/art(28683):   at java.lang.reflect.Method.invoke!(Native method)\n> 03-28 14:01:15.445: E/art(28683):   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:789)\n> 03-28 14:01:15.445: E/art(28683):   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:679)\n> ```\n> The error is occurring at the last line of this code:\n> ```\n>         gson=new Gson();\n>         String jsonObj=getIntent().getStringExtra(\"feedItem\");\n>         item = gson.fromJson(jsonObj, FeedItem.class);\n> ```\n> I have logged the json string which I am getting. The formatted json string is\n> ```\n> {\n>    \"feedItemChannel\":\"mdldsrgXN1\",\n>    \"estimatedData\":{\n>       \"feedTopic\":\"Testing\",\n>       \"feedComments\":2,\n>       \"createdBy\":\"KXTQtpfBSW\",\n>       \"feedQuestion\":\"Test Question \",\n>       \"feedDesc\":\"Test \"\n>    },\n>    \"hashedObjects\":{\n>    },\n>    \"isDeleted\":false,\n>    \"isDeletingEventually\":0,\n>    \"mutex\":{\n>    },\n>    \"operationSetQueue\":[\n>       {\n>       }\n>    ],\n>    \"saveEvent\":{\n>       \"callbacks\":[\n>       ]\n>    },\n>    \"state\":{\n>       \"className\":\"FeedItem\",\n>       \"createdAt\":1458798818385,\n>       \"isComplete\":true,\n>       \"objectId\":\"mdldsrgXN1\",\n>       \"serverData\":{\n>          \"feedTopic\":\"TestTopic\",\n>          \"createdBy\":\"KXTQtpfBSW\",\n>          \"feedComments\":2,\n>          \"feedQuestion\":\"Test Question \",\n>          \"feedDesc\":\"Test \"\n>       },\n>       \"updatedAt\":1458803553636\n>    },\n>    \"taskQueue\":{\n>       \"lock\":{\n>          \"sync\":{\n>             \"state\":0\n>          }\n>       }\n>    }\n> }\n> ```", "test_name": "com.google.gson.internal.UnsafeAllocatorInstantiationTest::testInterfaceInstantiation", "test_method": "  public void testInterfaceInstantiation() {\n    UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n    try {\n      unsafeAllocator.newInstance(Interface.class);\n      fail();\n    } catch (Exception e) {\n      assertEquals(e.getClass(), UnsupportedOperationException.class);\n    } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<class java.lang.reflect.InvocationTargetException> but was:<class java.lang.UnsupportedOperationException>\n\tcom.google.gson.internal.UnsafeAllocatorInstantiationTest.testInterfaceInstantiation(UnsafeAllocatorInstantiationTest.java:45)", "buggy_method": "33 public static UnsafeAllocator create() {\n34     // try JVM\n35     // public class Unsafe {\n36     //   public Object allocateInstance(Class<?> type);\n37     // }\n38     try {\n39       Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n40       Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n41       f.setAccessible(true);\n42       final Object unsafe = f.get(null);\n43       final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n44       return new UnsafeAllocator() {\n45         @Override\n46         @SuppressWarnings(\"unchecked\")\n47         public <T> T newInstance(Class<T> c) throws Exception {\n48           return (T) allocateInstance.invoke(unsafe, c);\n49         }\n50       };\n51     } catch (Exception ignored) {\n52     }\n53 \n54     // try dalvikvm, post-gingerbread\n55     // public class ObjectStreamClass {\n56     //   private static native int getConstructorId(Class<?> c);\n57     //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n58     // }\n59     try {\n60       Method getConstructorId = ObjectStreamClass.class\n61           .getDeclaredMethod(\"getConstructorId\", Class.class);\n62       getConstructorId.setAccessible(true);\n63       final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n64       final Method newInstance = ObjectStreamClass.class\n65           .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n66       newInstance.setAccessible(true);\n67       return new UnsafeAllocator() {\n68         @Override\n69         @SuppressWarnings(\"unchecked\")\n70         public <T> T newInstance(Class<T> c) throws Exception {\n71           return (T) newInstance.invoke(null, c, constructorId);\n72         }\n73       };\n74     } catch (Exception ignored) {\n75     }\n76 \n77     // try dalvikvm, pre-gingerbread\n78     // public class ObjectInputStream {\n79     //   private static native Object newInstance(\n80     //     Class<?> instantiationClass, Class<?> constructorClass);\n81     // }\n82     try {\n83       final Method newInstance = ObjectInputStream.class\n84           .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n85       newInstance.setAccessible(true);\n86       return new UnsafeAllocator() {\n87         @Override\n88         @SuppressWarnings(\"unchecked\")\n89         public <T> T newInstance(Class<T> c) throws Exception {\n90           return (T) newInstance.invoke(null, c, Object.class);\n91         }\n92       };\n93     } catch (Exception ignored) {\n94     }\n95 \n96     // give up\n97     return new UnsafeAllocator() {\n98       @Override\n99       public <T> T newInstance(Class<T> c) {\n100         throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n101       }\n102     };\n103   }", "bm_classpath": "com.google.gson.internal.UnsafeAllocator"}, {"bug_name": "Gson_10", "report_text": "> JsonAdapter annotation ignored for primitive fields\n> \n> `ReflectiveTypeAdapterFactory` correctly detects the `@JsonAdapter` annotation and registers the custom adapter ([source](https://github.com/google/gson/blob/6f6af8050799bec5321d2c06cd3230daadbb6535/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java#L133)), but its `write` method wraps that type adapter in a `TypeAdapterRuntimeTypeWrapper` ([source](https://github.com/google/gson/blob/6f6af8050799bec5321d2c06cd3230daadbb6535/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java#L111)), which overrides the adapter with the default Gson adapter ([source](https://github.com/google/gson/blob/6f6af8050799bec5321d2c06cd3230daadbb6535/gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java#L65)).\n> Here's a test that demonstrates the behavior:\n> ```\n> diff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest\n> index 4c745ec..8cae980 100644\n> --- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n> +++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n> @@ -220,4 +220,43 @@ public final class JsonAdapterAnnotationOnFieldsTest extends TestCase {\n>        this.part = part;\n>      }\n>    }\n> +\n> + public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n> + Gson gson = new Gson();\n> + String json = gson.toJson(new GadgetWithPrimitivePart(42));\n> + assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json);\n> + GadgetWithPrimitivePart gadget = gson.fromJson(json, GadgetWithPrimitivePart.class);\n> + assertEquals(42, gadget.part);\n> + }\n> +\n> + private static final class GadgetWithPrimitivePart {\n> + @JsonAdapter(LongToStringTypeAdapterFactory.class)\n> + final long part;\n> +\n> + private GadgetWithPrimitivePart(long part) {\n> + this.part = part;\n> + }\n> + }\n> +\n> + private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {\n> + static final TypeAdapter<Long> ADAPTER = new TypeAdapter<Long>() {\n> + @Override public void write(JsonWriter out, Long value) throws IOException {\n> + out.value(value.toString());\n> + }\n> + @SuppressWarnings(\"unchecked\")\n> + @Override public Long read(JsonReader in) throws IOException {\n> + return in.nextLong();\n> + }\n> + };\n> + @Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\n> + Class<?> cls = type.getRawType();\n> + if (Long.class.isAssignableFrom(cls)) {\n> + return (TypeAdapter<T>) ADAPTER;\n> + } else if (long.class.isAssignableFrom(cls)) {\n> + return (TypeAdapter<T>) ADAPTER;\n> + }\n> + throw new IllegalStateException(\"Non-long field of type \" + type\n> + + \" annotated with @JsonAdapter(LongToStringTypeAdapterFactory.class)\");\n> + }\n> + }\n>  }\n> ```\n> And here's the result of running it:\n> ```\n> [snip]\n> Running com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest\n> Tests run: 8, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.016 sec <<< FAILURE!\n> [snip]\n> Results :\n> Failed tests:   testPrimitiveFieldAnnotationTakesPrecedenceOverDefault(com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest): expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}>\n> Tests run: 990, Failures: 1, Errors: 0, Skipped: 0\n> ```\n> Is this the intended behavior? If so, `JsonAdapter`'s documentation is a bit misleading.\n> If it's not, I unfortunately do not have a suggested fix. I was actually a bit surprised to see that a new `TypeAdapterRuntimeTypeWrapper` object is constructed for each field that is serialized, on every serialization.\n> In case you would like to incorporate my test into Gson, I hereby assign copyright of that test to Google.\n> Thanks!", "test_name": "com.google.gson.functional.JsonAdapterAnnotationOnFieldsTest::testPrimitiveFieldAnnotationTakesPrecedenceOverDefault", "test_method": "  public void testPrimitiveFieldAnnotationTakesPrecedenceOverDefault() {\n    Gson gson = new Gson();\n    String json = gson.toJson(new GadgetWithPrimitivePart(42));\n    assertEquals(\"{\\\"part\\\":\\\"42\\\"}\", json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"part\":[\"42\"]}> but was:<{\"part\":[42]}>\n\tcom.google.gson.functional.JsonAdapterAnnotationOnFieldsTest.testPrimitiveFieldAnnotationTakesPrecedenceOverDefault(JsonAdapterAnnotationOnFieldsTest.java:236)", "buggy_method": "103 private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n104       final Gson context, final Field field, final String name,\n105       final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n106     final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n107     // special casing primitives here saves ~5% on Android...\n108     JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n109     TypeAdapter<?> mapped = null;\n110     if (annotation != null) {\n111       mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n112     }\n113     final boolean jsonAdapterPresent = mapped != null;\n114     if (mapped == null) mapped = context.getAdapter(fieldType);\n115 \n116     final TypeAdapter<?> typeAdapter = mapped;\n117     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n118       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n119       @Override void write(JsonWriter writer, Object value)\n120           throws IOException, IllegalAccessException {\n121         Object fieldValue = field.get(value);\n122         TypeAdapter t =\n123           new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n124         t.write(writer, fieldValue);\n125       }\n126       @Override void read(JsonReader reader, Object value)\n127           throws IOException, IllegalAccessException {\n128         Object fieldValue = typeAdapter.read(reader);\n129         if (fieldValue != null || !isPrimitive) {\n130           field.set(value, fieldValue);\n131         }\n132       }\n133       @Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n134         if (!serialized) return false;\n135         Object fieldValue = field.get(value);\n136         return fieldValue != value; // avoid recursion for example for Throwable.cause\n137       }\n138     };\n139   }", "bm_classpath": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory"}, {"bug_name": "Gson_11", "report_text": "> Allow deserialization of a Number represented as a String\n> \n> This works:\n> ```\n> gson.fromJson(\"\\\"15\\\"\", int.class)\n> ```\n> This doesn't:\n> ```\n> gson.fromJson(\"\\\"15\\\"\", Number.class)\n> ```\n> This PR makes it so the second case works too.", "test_name": "com.google.gson.functional.PrimitiveTest::testNumberAsStringDeserialization", "test_method": "  public void testNumberAsStringDeserialization() {\n    Number value = gson.fromJson(\"\\\"18\\\"\", Number.class); // <-- fails here\n    }", "error_message": "com.google.gson.JsonSyntaxException: Expecting number, got: STRING\n\tcom.google.gson.internal.bind.TypeAdapters$15.read(TypeAdapters.java:373)\n\tcom.google.gson.internal.bind.TypeAdapters$15.read(TypeAdapters.java:362)\n\tcom.google.gson.Gson.fromJson(Gson.java:887)\n\tcom.google.gson.Gson.fromJson(Gson.java:852)\n\tcom.google.gson.Gson.fromJson(Gson.java:801)\n\tcom.google.gson.Gson.fromJson(Gson.java:773)\n\tcom.google.gson.functional.PrimitiveTest.testNumberAsStringDeserialization(PrimitiveTest.java:162)", "buggy_method": "363 @Override\n364     public Number read(JsonReader in) throws IOException {\n365       JsonToken jsonToken = in.peek();\n366       switch (jsonToken) {\n367       case NULL:\n368         in.nextNull();\n369         return null;\n370       case NUMBER:\n371         return new LazilyParsedNumber(in.nextString());\n372       default:\n373         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n374       }\n375     }", "bm_classpath": "com.google.gson.internal.bind.TypeAdapters$1"}, {"bug_name": "Gson_12", "report_text": "> Bug when skipping a value while using the JsonTreeReader\n> \n> When using a `JsonReader` to read a JSON object, `skipValue()` skips the structure successfully.\n> ```\n> @Test\n> public void testSkipValue\\_JsonReader() throws IOException {\n>   try (JsonReader in = new JsonReader(new StringReader(\"{}\"))) {\n>     in.skipValue();\n>   }\n> }\n> ```\n> But when using a `JsonTreeReader` to read a JSON object, `skipValue()` throws a `ArrayIndexOutOfBoundsException`.\n> ```\n> @Test\n> public void testSkipValue\\_JsonTreeReader() throws IOException {\n>   try (JsonTreeReader in = new JsonTreeReader(new JsonObject())) {\n>     in.skipValue();\n>   }\n> }\n> ```\n> Stacktrace\n> ```\n> java.lang.ArrayIndexOutOfBoundsException: -1\n> \tat com.google.gson.internal.bind.JsonTreeReader.skipValue(JsonTreeReader.java:262)\n> ```\n> The method `popStack()` is being called on line 261 with a `stackSize` of `1` and afterwards the `stackSize` is `0` and the call on line 262 must result in an `ArrayIndexOutOfBoundsException`.", "test_name": "com.google.gson.internal.bind.JsonTreeReaderTest::testSkipValue_filledJsonObject", "test_method": "  public void testSkipValue_filledJsonObject() throws IOException {\n    JsonObject jsonObject = new JsonObject();\n    JsonArray jsonArray = new JsonArray();\n    jsonArray.add('c');\n    jsonArray.add(\"text\");\n    jsonObject.add(\"a\", jsonArray);\n    jsonObject.addProperty(\"b\", true);\n    jsonObject.addProperty(\"i\", 1);\n    jsonObject.add(\"n\", JsonNull.INSTANCE);\n    JsonObject jsonObject2 = new JsonObject();\n    jsonObject2.addProperty(\"n\", 2L);\n    jsonObject.add(\"o\", jsonObject2);\n    jsonObject.addProperty(\"s\", \"text\");\n    JsonTreeReader in = new JsonTreeReader(jsonObject);\n    in.skipValue(); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: -1\n\tcom.google.gson.internal.bind.JsonTreeReader.skipValue(JsonTreeReader.java:262)\n\tcom.google.gson.internal.bind.JsonTreeReaderTest.testSkipValue_filledJsonObject(JsonTreeReaderTest.java:47)", "buggy_method": "256 @Override public void skipValue() throws IOException {\n257     if (peek() == JsonToken.NAME) {\n258       nextName();\n259       pathNames[stackSize - 2] = \"null\";\n260     } else {\n261       popStack();\n262         pathNames[stackSize - 1] = \"null\";\n263     }\n264       pathIndices[stackSize - 1]++;\n265   }", "bm_classpath": "com.google.gson.internal.bind.JsonTreeReader"}, {"bug_name": "Gson_13", "report_text": "> Negative zero\n> \n> Hi,\n> I have been cross testing various json parsers looking for those that expose the lexical of json numbers and not only their bound java.lang.Number. Because of the lazy parsing done by gson with `LazilyParsedNumber`, that keeps the lexical, all my roundtrip tests pass apart one: the lexical `-0` that is treated as it were `0`\n> I read some threads about negative zero:  \n> <https://www.ietf.org/mail-archive/web/json/current/msg03668.html>  \n> <https://www.ietf.org/mail-archive/web/json/current/msg01520.html>  \n> <https://www.ietf.org/mail-archive/web/json/current/msg01523.html>  \n> <https://www.ietf.org/mail-archive/web/json/current/msg01525.html>\n> I created this issue thinking that `-0` is a float, the same as `-0.0`, since a signed zero makes sense only in floating point numbers and also because in Java only Double/Float preserve sign of zero. This would have the implication that `-0` could not be validated by jsonschema `type` `integer` , and that a jsonschema implementation would have the need to know if a `-0` is present in json data, but probably this is not the case.\n> After I started to (re)consider that `-0` could be an integer, only that seems that in no programming language there is an integer that preserves sign for zero.\n> In any case, differentiating between `0` and `-0` at lexical level would allow a client of gson to be able to refuse the value `-0`.\n> Gson could easily support differentiating between `0` and `-0`: in code `-0` is [treated as an integer (PEEKED\\_LONG) in JsonReader](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/stream/JsonReader.java#L731) so its value is stored in a Java `long` that cannot represent negative zero. I noted that `-0.0` roundtrips correctly because is treated as a PEEKED\\_NUMBER that is kept as a Java String. So the case of `-0` could be trapped and treated as `-0.0`, as a PEEKED\\_NUMBER, in this way the `toString()` method of `LazilyParsedNumber` will return `-0` and gson will be able to roundtrip any valid number value found in source, only clients using `Number.toString()` will notice any difference.\n> My proposal is to change [this code](https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/stream/JsonReader.java#L731) from\n> ```\n>       if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n> ```\n> to\n> ```\n>       if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value!=0 || false==negative) && (value != Long.MIN_VALUE || negative)) {\n> ```\n> Thanks,  \n> Michele", "test_name": "com.google.gson.stream.JsonReaderTest::testNegativeZero", "test_method": "  public void testNegativeZero() throws Exception {\n\t  \tJsonReader reader = new JsonReader(reader(\"[-0]\"));\n\t    reader.setLenient(false);\n\t    reader.beginArray();\n\t    assertEquals(\"-0\", reader.nextString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[-]0> but was:<[]0>\n\tcom.google.gson.stream.JsonReaderTest.testNegativeZero(JsonReaderTest.java:573)", "buggy_method": "641 private int peekNumber() throws IOException {\n642     // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n643     char[] buffer = this.buffer;\n644     int p = pos;\n645     int l = limit;\n646 \n647     long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n648     boolean negative = false;\n649     boolean fitsInLong = true;\n650     int last = NUMBER_CHAR_NONE;\n651 \n652     int i = 0;\n653 \n654     charactersOfNumber:\n655     for (; true; i++) {\n656       if (p + i == l) {\n657         if (i == buffer.length) {\n658           // Though this looks like a well-formed number, it's too long to continue reading. Give up\n659           // and let the application handle this as an unquoted literal.\n660           return PEEKED_NONE;\n661         }\n662         if (!fillBuffer(i + 1)) {\n663           break;\n664         }\n665         p = pos;\n666         l = limit;\n667       }\n668 \n669       char c = buffer[p + i];\n670       switch (c) {\n671       case '-':\n672         if (last == NUMBER_CHAR_NONE) {\n673           negative = true;\n674           last = NUMBER_CHAR_SIGN;\n675           continue;\n676         } else if (last == NUMBER_CHAR_EXP_E) {\n677           last = NUMBER_CHAR_EXP_SIGN;\n678           continue;\n679         }\n680         return PEEKED_NONE;\n681 \n682       case '+':\n683         if (last == NUMBER_CHAR_EXP_E) {\n684           last = NUMBER_CHAR_EXP_SIGN;\n685           continue;\n686         }\n687         return PEEKED_NONE;\n688 \n689       case 'e':\n690       case 'E':\n691         if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n692           last = NUMBER_CHAR_EXP_E;\n693           continue;\n694         }\n695         return PEEKED_NONE;\n696 \n697       case '.':\n698         if (last == NUMBER_CHAR_DIGIT) {\n699           last = NUMBER_CHAR_DECIMAL;\n700           continue;\n701         }\n702         return PEEKED_NONE;\n703 \n704       default:\n705         if (c < '0' || c > '9') {\n706           if (!isLiteral(c)) {\n707             break charactersOfNumber;\n708           }\n709           return PEEKED_NONE;\n710         }\n711         if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n712           value = -(c - '0');\n713           last = NUMBER_CHAR_DIGIT;\n714         } else if (last == NUMBER_CHAR_DIGIT) {\n715           if (value == 0) {\n716             return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n717           }\n718           long newValue = value * 10 - (c - '0');\n719           fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n720               || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n721           value = newValue;\n722         } else if (last == NUMBER_CHAR_DECIMAL) {\n723           last = NUMBER_CHAR_FRACTION_DIGIT;\n724         } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n725           last = NUMBER_CHAR_EXP_DIGIT;\n726         }\n727       }\n728     }\n729 \n730     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n731     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n732       peekedLong = negative ? value : -value;\n733       pos += i;\n734       return peeked = PEEKED_LONG;\n735     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n736         || last == NUMBER_CHAR_EXP_DIGIT) {\n737       peekedNumberLength = i;\n738       return peeked = PEEKED_NUMBER;\n739     } else {\n740       return PEEKED_NONE;\n741     }\n742   }", "bm_classpath": "com.google.gson.stream.JsonReader"}, {"bug_name": "Gson_14", "report_text": "> $Gson$Types.resolve() shall collapse chains of super/extends type bounds to avoid StackOverflowError\n> \n> While resolving recursive generic types, $Gson$Types.resolve() sometimes starts to generate chains of type bounds like \"super ? extends ? .... ? extends A\" , causing infinite recursion and thus StackOverflowError's like  \n> `java.lang.StackOverflowError at com.google.gson.internal.$Gson$Types.resolveTypeVariable($Gson$Types.java:407) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:330) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:384) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:379) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:384) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:379) at com.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:384) ...`   \n> This can be reproduced on the following simple ccde:\n> ```\n>   private static class Foo1<A> {\n>     Foo2<? extends A> foo2;\n>   }\n>   private static class Foo2<B> {\n>     Foo1<? super B> foo1;\n>   }\n>   public void testRecursiveResolveSimple() {\n>     new Gson().getAdapter(Foo1.class);\n>   }\n> ```\n> This is the root cause of StackOverflowError's described in Issue [#440](https://github.com/google/gson/issues/440) and Issue [#603](https://github.com/google/gson/issues/603).\n> In order to fix them, such chains need to be collapsed using the following rules:\n> * supertypeOf(supertypeOf(X)) == supertypeOf(X)\n> * subtypeOf(subtypeOf(X)) == subtypeOf(X)\n> * supertypeOf(subtypeOf(X)) == subtypeOf(Object.class)\n> * subtypeOf(supertypeOf(X)) == subtypeOf(Object.class)", "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest::testDoubleSupertype", "test_method": "  public void testDoubleSupertype() {\n    assertEquals($Gson$Types.supertypeOf(Number.class),\n            $Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<? super java.lang.Number> but was:<? super ? super java.lang.Number>\n\tcom.google.gson.internal.bind.RecursiveTypesResolveTest.testDoubleSupertype(RecursiveTypesResolveTest.java:71)", "buggy_method": "77 public static WildcardType subtypeOf(Type bound) {\n78     Type[] upperBounds;\n79       upperBounds = new Type[] { bound };\n80     return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n81   }", "bm_classpath": "com.google.gson.internal.$Gson$Types"}, {"bug_name": "Gson_15", "report_text": "> JsonWriter#value(java.lang.Number) can be lenient, but JsonWriter#value(double) can't,\n> \n> In lenient mode, JsonWriter#value(java.lang.Number) can write pseudo-numeric values like `NaN`, `Infinity`, `-Infinity`:\n> ```\n>     if (!lenient\n>         && (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n>       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n>     }\n> ```\n> But JsonWriter#value(double) behaves in different way:\n> ```\n>     if (Double.isNaN(value) || Double.isInfinite(value)) {\n>       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n>     }\n> ```\n> So, while working with streaming, it's impossible to write semi-numeric value without boxing a double (e. g. `out.value((Number) Double.valueOf(Double.NaN))`).\n> I think, this should be possible, because boxing gives worse performance.", "test_name": "com.google.gson.stream.JsonWriterTest::testNonFiniteDoublesWhenLenient", "test_method": "  public void testNonFiniteDoublesWhenLenient() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setLenient(true);\n    jsonWriter.beginArray();\n    jsonWriter.value(Double.NaN); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Numeric values must be finite, but was NaN\n\tcom.google.gson.stream.JsonWriter.value(JsonWriter.java:496)\n\tcom.google.gson.stream.JsonWriterTest.testNonFiniteDoublesWhenLenient(JsonWriterTest.java:222)", "buggy_method": "493 public JsonWriter value(double value) throws IOException {\n494     writeDeferredName();\n495     if (Double.isNaN(value) || Double.isInfinite(value)) {\n496       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n497     }\n498     beforeValue();\n499     out.append(Double.toString(value));\n500     return this;\n501   }", "bm_classpath": "com.google.gson.stream.JsonWriter"}, {"bug_name": "Gson_16", "report_text": "> Fix StackOverflowError on resolving types with TypeVariable recursion\n> \n> Sample failing code:  \n> private static class TestType {  \n> TestType<? super X> superType;  \n> }  \n> ...  \n> new Gson().getAdapter(TestType.class);", "test_name": "com.google.gson.internal.bind.RecursiveTypesResolveTest::testRecursiveTypeVariablesResolve12", "test_method": "public void testRecursiveTypeVariablesResolve12() throws Exception {\n    TypeAdapter<TestType2> adapter = new Gson().getAdapter(TestType2.class);\n    assertNotNull(adapter);\n  }", "error_message": "java.lang.StackOverflowError\n\tjava.lang.String.lastIndexOf(String.java:1611)\n\tsun.reflect.misc.ReflectUtil.isNonPublicProxyClass(ReflectUtil.java:287)\n\tsun.reflect.misc.ReflectUtil.checkPackageAccess(ReflectUtil.java:165)\n\tsun.reflect.generics.reflectiveObjects.TypeVariableImpl.getGenericDeclaration(TypeVariableImpl.java:164)\n\tsun.reflect.generics.reflectiveObjects.TypeVariableImpl.equals(TypeVariableImpl.java:189)\n\tcom.google.gson.internal.$Gson$Types.indexOf($Gson$Types.java:429)\n\tcom.google.gson.internal.$Gson$Types.resolveTypeVariable($Gson$Types.java:420)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:343)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)\n\tcom.google.gson.internal.$Gson$Types.resolve($Gson$Types.java:392)", "buggy_method": "336 private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n337                               Collection<TypeVariable> visitedTypeVariables) {\n338     // this implementation is made a little more complicated in an attempt to avoid object-creation\n339     while (true) {\n340       if (toResolve instanceof TypeVariable) {\n341         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n342           // cannot reduce due to infinite recursion\n343         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n344         if (toResolve == typeVariable) {\n345           return toResolve;\n346         }\n347 \n348       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n349         Class<?> original = (Class<?>) toResolve;\n350         Type componentType = original.getComponentType();\n351         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n352         return componentType == newComponentType\n353             ? original\n354             : arrayOf(newComponentType);\n355 \n356       } else if (toResolve instanceof GenericArrayType) {\n357         GenericArrayType original = (GenericArrayType) toResolve;\n358         Type componentType = original.getGenericComponentType();\n359         Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n360         return componentType == newComponentType\n361             ? original\n362             : arrayOf(newComponentType);\n363 \n364       } else if (toResolve instanceof ParameterizedType) {\n365         ParameterizedType original = (ParameterizedType) toResolve;\n366         Type ownerType = original.getOwnerType();\n367         Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n368         boolean changed = newOwnerType != ownerType;\n369 \n370         Type[] args = original.getActualTypeArguments();\n371         for (int t = 0, length = args.length; t < length; t++) {\n372           Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n373           if (resolvedTypeArgument != args[t]) {\n374             if (!changed) {\n375               args = args.clone();\n376               changed = true;\n377             }\n378             args[t] = resolvedTypeArgument;\n379           }\n380         }\n381 \n382         return changed\n383             ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n384             : original;\n385 \n386       } else if (toResolve instanceof WildcardType) {\n387         WildcardType original = (WildcardType) toResolve;\n388         Type[] originalLowerBound = original.getLowerBounds();\n389         Type[] originalUpperBound = original.getUpperBounds();\n390 \n391         if (originalLowerBound.length == 1) {\n392           Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n393           if (lowerBound != originalLowerBound[0]) {\n394             return supertypeOf(lowerBound);\n395           }\n396         } else if (originalUpperBound.length == 1) {\n397           Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n398           if (upperBound != originalUpperBound[0]) {\n399             return subtypeOf(upperBound);\n400           }\n401         }\n402         return original;\n403 \n404       } else {\n405         return toResolve;\n406       }\n407     }\n408   }", "bm_classpath": "com.google.gson.internal.$Gson$Types"}, {"bug_name": "Gson_17", "report_text": "> Fixed DefaultDateTypeAdapter nullability issue and JSON primitives contract\n> \n> Regression in:\n> * [b8f616c](https://github.com/google/gson/commit/b8f616c939c652b8540c95fa2b377b8c628ef3ff) - Migrate DefaultDateTypeAdapter to streaming adapter ([#1070](https://github.com/google/gson/pull/1070))\n> Bug reports:\n> * [#1096](https://github.com/google/gson/issues/1096) - 2.8.1 can't serialize and deserialize date null (2.8.0 works fine)\n> * [#1098](https://github.com/google/gson/issues/1098) - Gson 2.8.1 DefaultDateTypeAdapter is not null safe.\n> * [#1095](https://github.com/google/gson/issues/1095) - serialize date sometimes TreeTypeAdapter, sometimes DefaultDateTypeAdapter?", "test_name": "com.google.gson.DefaultDateTypeAdapterTest::testUnexpectedToken", "test_method": "  public void testUnexpectedToken() throws Exception {\n    try {\n      DefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter(Date.class);\n      adapter.fromJson(\"{}\");\n      fail(\"Unexpected token should fail.\");\n    } catch (IllegalStateException expected) { } // <-- fails here\n    }", "error_message": "com.google.gson.JsonParseException: The date should be a string value\n\tcom.google.gson.DefaultDateTypeAdapter.read(DefaultDateTypeAdapter.java:100)\n\tcom.google.gson.DefaultDateTypeAdapter.read(DefaultDateTypeAdapter.java:40)\n\tcom.google.gson.TypeAdapter.fromJson(TypeAdapter.java:260)\n\tcom.google.gson.TypeAdapter.fromJson(TypeAdapter.java:273)\n\tcom.google.gson.DefaultDateTypeAdapterTest.testUnexpectedToken(DefaultDateTypeAdapterTest.java:173)", "buggy_method": "97 @Override\n98   public Date read(JsonReader in) throws IOException {\n99     if (in.peek() != JsonToken.STRING) {\n100       throw new JsonParseException(\"The date should be a string value\");\n101     }\n102     Date date = deserializeToDate(in.nextString());\n103     if (dateType == Date.class) {\n104       return date;\n105     } else if (dateType == Timestamp.class) {\n106       return new Timestamp(date.getTime());\n107     } else if (dateType == java.sql.Date.class) {\n108       return new java.sql.Date(date.getTime());\n109     } else {\n110       // This must never happen: dateType is guarded in the primary constructor\n111       throw new AssertionError();\n112     }\n113   }", "bm_classpath": "com.google.gson.DefaultDateTypeAdapter"}, {"bug_name": "Gson_18", "report_text": "> Gson deserializes wildcards to LinkedHashMap\n> \n> This issue is a successor to [#1101](https://github.com/google/gson/issues/1101).\n> Models:\n> ```\n> // ? extends causes the issue\n> class BigClass { Map<String, ? extends List<SmallClass>> inBig; }\n> class SmallClass { String inSmall; }\n> ```\n> Json:\n> ```\n> {\n>   \"inBig\": {\n>     \"key\": [\n>       { \"inSmall\": \"hello\" }\n>     ]\n>   }\n> }\n> ```\n> Gson call:\n> ```\n> SmallClass small = new Gson().fromJson(json, BigClass.class).inBig.get(\"inSmall\").get(0);\n> ```\n> This call will fail with a `ClassCastException` exception \u2013  \n> `com.google.gson.internal.LinkedTreeMap cannot be cast to Entry`. If we remove `? extends` then everything works fine.", "test_name": "com.google.gson.functional.CollectionTest::testIssue1107", "test_method": "  public void testIssue1107() {\n    String json = \"{\\n\" +\n            \"  \\\"inBig\\\": {\\n\" +\n            \"    \\\"key\\\": [\\n\" +\n            \"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n            \"    ]\\n\" +\n            \"  }\\n\" +\n            \"}\";\n    BigClass bigClass = new Gson().fromJson(json, BigClass.class);\n    SmallClass small = bigClass.inBig.get(\"key\").get(0); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.google.gson.functional.CollectionTest$SmallClass\n\tcom.google.gson.functional.CollectionTest.testIssue1107(CollectionTest.java:410)", "buggy_method": "277 static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n278       // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\n279     checkArgument(supertype.isAssignableFrom(contextRawType));\n280     return resolve(context, contextRawType,\n281         $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n282   }", "bm_classpath": "com.google.gson.internal.$Gson$Types"}, {"bug_name": "JacksonCore_1", "report_text": "> NullPointerException thrown when NaN read as BigDecimal\n> \n> (moved from <https://github.com/FasterXML/jackson/issues/4> reported by [@jroper](https://github.com/jroper))\n> ---\n> If `JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS` is turned on, then when NaN is encountered, it will be reported as being a float number token. Subsequently invoking getDecimalNumber throws an NPE:\n> ```\n> NullPointerException: null (TextBuffer.java:394)\n> com.fasterxml.jackson.core.util.TextBuffer.contentsAsDecimal(TextBuffer.java:394)\n> com.fasterxml.jackson.core.base.ParserBase._parseSlowFloatValue(ParserBase.java:799)\n> com.fasterxml.jackson.core.base.ParserBase._parseNumericValue(ParserBase.java:781)\n>  com.fasterxml.jackson.core.base.ParserBase.getDecimalValue(ParserBase.java:711)\n> ```\n> By the way, the expected behaviour here I would say would be to throw NumberFormatException, this is what is thrown by the BigDecimal constructor when you pass in Double.NaN or any of the infinity double values.\n> I'm not sure, but maybe this NPE is also an issue for integers too, and the expected behaviour for them would also be to throw NumberFormatException.", "test_name": "com.fasterxml.jackson.core.json.TestParserNonStandard::testAllowNaN", "test_method": "    public void testAllowNaN() throws Exception {\n        _testAllowNaN(false); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([can not be represented as BigDecimal]): got one with message \"null\"\n\tcom.fasterxml.jackson.test.BaseTest.verifyException(BaseTest.java:355)\n\tcom.fasterxml.jackson.core.json.TestParserNonStandard._testAllowNaN(TestParserNonStandard.java:394)\n\tcom.fasterxml.jackson.core.json.TestParserNonStandard.testAllowNaN(TestParserNonStandard.java:63)", "buggy_method": "302 public static BigDecimal parseBigDecimal(char[] buffer, int offset, int len)\n303             throws NumberFormatException\n304     {\n305             return new BigDecimal(buffer, offset, len);\n306     }", "bm_classpath": "com.fasterxml.jackson.core.io.NumberInput"}, {"bug_name": "JacksonCore_2", "report_text": "> Parser parsers numbers eagerly; does not report error with missing space\n> \n> (note: moved from [FasterXML/jackson-databind#260](https://github.com/FasterXML/jackson-databind/issues/260))\n> ---\n> If you give input like:\n> ```\n> 123true\n> ```\n> it will first successfully parse integer 123, and then boolean `true`. This should instead result in a parse exception.", "test_name": "com.fasterxml.jackson.core.json.TestParserErrorHandling::testMangledNumbersBytes", "test_method": "    public void testMangledNumbersBytes() throws Exception {\n        _testMangledNumbers(true); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should have gotten an exception; instead got token: VALUE_NUMBER_INT\n\tcom.fasterxml.jackson.core.json.TestParserErrorHandling._testMangledNumbers(TestParserErrorHandling.java:93)\n\tcom.fasterxml.jackson.core.json.TestParserErrorHandling.testMangledNumbersBytes(TestParserErrorHandling.java:22)", "buggy_method": "846 protected JsonToken _parseNumber(int ch) throws IOException\n847     {\n848         /* Although we will always be complete with respect to textual\n849          * representation (that is, all characters will be parsed),\n850          * actual conversion to a number is deferred. Thus, need to\n851          * note that no representations are valid yet\n852          */\n853         boolean negative = (ch == INT_MINUS);\n854         int ptr = _inputPtr;\n855         int startPtr = ptr-1; // to include sign/digit already read\n856         final int inputLen = _inputEnd;\n857 \n858         dummy_loop:\n859         do { // dummy loop, to be able to break out\n860             if (negative) { // need to read the next digit\n861                 if (ptr >= _inputEnd) {\n862                     break dummy_loop;\n863                 }\n864                 ch = _inputBuffer[ptr++];\n865                 // First check: must have a digit to follow minus sign\n866                 if (ch > INT_9 || ch < INT_0) {\n867                     _inputPtr = ptr;\n868                     return _handleInvalidNumberStart(ch, true);\n869                 }\n870                 /* (note: has been checked for non-negative already, in\n871                  * the dispatching code that determined it should be\n872                  * a numeric value)\n873                  */\n874             }\n875             // One special case, leading zero(es):\n876             if (ch == INT_0) {\n877                 break dummy_loop;\n878             }\n879             \n880             /* First, let's see if the whole number is contained within\n881              * the input buffer unsplit. This should be the common case;\n882              * and to simplify processing, we will just reparse contents\n883              * in the alternative case (number split on buffer boundary)\n884              */\n885             \n886             int intLen = 1; // already got one\n887             \n888             // First let's get the obligatory integer part:\n889             \n890             int_loop:\n891             while (true) {\n892                 if (ptr >= _inputEnd) {\n893                     break dummy_loop;\n894                 }\n895                 ch = (int) _inputBuffer[ptr++];\n896                 if (ch < INT_0 || ch > INT_9) {\n897                     break int_loop;\n898                 }\n899                 ++intLen;\n900             }\n901 \n902             int fractLen = 0;\n903             \n904             // And then see if we get other parts\n905             if (ch == '.') { // yes, fraction\n906                 fract_loop:\n907                 while (true) {\n908                     if (ptr >= inputLen) {\n909                         break dummy_loop;\n910                     }\n911                     ch = (int) _inputBuffer[ptr++];\n912                     if (ch < INT_0 || ch > INT_9) {\n913                         break fract_loop;\n914                     }\n915                     ++fractLen;\n916                 }\n917                 // must be followed by sequence of ints, one minimum\n918                 if (fractLen == 0) {\n919                     reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n920                 }\n921             }\n922 \n923             int expLen = 0;\n924             if (ch == 'e' || ch == 'E') { // and/or exponent\n925                 if (ptr >= inputLen) {\n926                     break dummy_loop;\n927                 }\n928                 // Sign indicator?\n929                 ch = (int) _inputBuffer[ptr++];\n930                 if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n931                     if (ptr >= inputLen) {\n932                         break dummy_loop;\n933                     }\n934                     ch = (int) _inputBuffer[ptr++];\n935                 }\n936                 while (ch <= INT_9 && ch >= INT_0) {\n937                     ++expLen;\n938                     if (ptr >= inputLen) {\n939                         break dummy_loop;\n940                     }\n941                     ch = (int) _inputBuffer[ptr++];\n942                 }\n943                 // must be followed by sequence of ints, one minimum\n944                 if (expLen == 0) {\n945                     reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n946                 }\n947             }\n948             // Got it all: let's add to text buffer for parsing, access\n949             --ptr; // need to push back following separator\n950             _inputPtr = ptr;\n951             // As per #105, need separating space between root values; check here\n952             int len = ptr-startPtr;\n953             _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n954             return reset(negative, intLen, fractLen, expLen);\n955         } while (false);\n956 \n957         _inputPtr = negative ? (startPtr+1) : startPtr;\n958         return _parseNumber2(negative);\n959     }", "bm_classpath": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser"}, {"bug_name": "JacksonCore_3", "report_text": "> _currInputRowStart isn't initialized in UTF8StreamJsonParser() constructor. The column position will be wrong.\n> \n> The UTF8StreamJson Parser constructor allows to specify the start position. But it doesn't set the \"\\_currInputRowStart\" as the same value. It is still 0. So when raise the exception, the column calculation (ParserBase.getCurrentLocation() )will be wrong.\n> int col = \\_inputPtr - \\_currInputRowStart + 1; // 1-based\n> public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,  \n> ObjectCodec codec, BytesToNameCanonicalizer sym,  \n> byte[] inputBuffer, int start, int end,  \n> boolean bufferRecyclable)", "test_name": "com.fasterxml.jackson.core.json.TestLocation::testOffsetWithInputOffset", "test_method": "    public void testOffsetWithInputOffset() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        JsonLocation loc;\n        JsonParser p;\n        // 3 spaces before, 2 after, just for padding\n        byte[] b = \"   { }  \".getBytes(\"UTF-8\");\n\n        // and then peel them off\n        p = f.createParser(b, 3, b.length-5);\n\n        loc = p.getTokenLocation();\n        assertEquals(0L, loc.getByteOffset()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<3>\n\tcom.fasterxml.jackson.core.json.TestLocation.testOffsetWithInputOffset(TestLocation.java:68)", "buggy_method": "113 public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\n114             ObjectCodec codec, BytesToNameCanonicalizer sym,\n115             byte[] inputBuffer, int start, int end,\n116             boolean bufferRecyclable)\n117     {\n118         super(ctxt, features);\n119         _inputStream = in;\n120         _objectCodec = codec;\n121         _symbols = sym;\n122         _inputBuffer = inputBuffer;\n123         _inputPtr = start;\n124         _inputEnd = end;\n125         // If we have offset, need to omit that from byte offset, so:\n126         _bufferRecyclable = bufferRecyclable;\n127     }", "bm_classpath": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser"}, {"bug_name": "JacksonCore_4", "report_text": "> What is the maximum key length allowed?\n> \n> I noticed that even in Jackson 2.4, if a JSON key is longer than 262144 bytes, ArrayIndexOutOfBoundsException is thrown from TextBuffer. Below is the stack trace:\n> ```\n> java.lang.ArrayIndexOutOfBoundsException\n>     at java.lang.System.arraycopy(Native Method)\n>     at com.fasterxml.jackson.core.util.TextBuffer.expandCurrentSegment(TextBuffer.java:604)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2034)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.findName(UTF8StreamJsonParser.java:1928)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseLongFieldName(UTF8StreamJsonParser.java:1534)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumFieldName(UTF8StreamJsonParser.java:1502)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseFieldName(UTF8StreamJsonParser.java:1437)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:668)\n>     ... <below are our code> ...\n> ```\n> Looking at TextBuffer.expandCurrentSegment(TextBuffer.java:604), once the length of \\_currentSegment is increased to MAX\\_SEGMENT\\_LEN + 1 (262145) bytes, the newLen will stay at MAX\\_SEGMENT\\_LEN, which is smaller than len. Therefore System.arraycopy() will fail.\n> I understand it is rare to have key larger than 262144 bytes, but it would be nice if\n> * Jackson explicitly throw exception stating that key is too long.\n> * Document that the maximum key length is 262144 bytes.\n> OR\n> * Update TextBuffer to support super long key.\n> Thanks!", "test_name": "com.fasterxml.jackson.core.util.TestTextBuffer::testExpand", "test_method": "      public void testExpand()\n      {\n          TextBuffer tb = new TextBuffer(new BufferRecycler());\n          char[] buf = tb.getCurrentSegment();\n\n          while (buf.length < 500 * 1000) {\n              char[] old = buf;\n              buf = tb.expandCurrentSegment();\n              if (old.length >= buf.length) {\n                  fail(\"Expected buffer of \"+old.length+\" to expand, did not, length now \"+buf.length);\n              }\n          } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected buffer of 262145 to expand, did not, length now 262144\n\tcom.fasterxml.jackson.core.util.TestTextBuffer.testExpand(TestTextBuffer.java:76)", "buggy_method": "580 public char[] expandCurrentSegment()\n581     {\n582         final char[] curr = _currentSegment;\n583         // Let's grow by 50% by default\n584         final int len = curr.length;\n585         // but above intended maximum, slow to increase by 25%\n586         int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n587         return (_currentSegment = Arrays.copyOf(curr, newLen));\n588     }", "bm_classpath": "com.fasterxml.jackson.core.util.TextBuffer"}, {"bug_name": "JacksonCore_5", "report_text": "> An exception is thrown for a valid JsonPointer expression\n> \n> Json-Patch project leader has noted me that there is a bug on JsonPointer implementation and I have decided to investigate.\n> Basically if you do something like `JsonPointer.compile(\"/1e0\");` it throws a NumberFormatExpcetion which is not true. This is because this piece of code:\n> ```\n> private final static int \\_parseInt(String str)\n>     {\n>         final int len = str.length();\n>         if (len == 0) {\n>             return -1;\n>         }\n>         for (int i = 0; i < len; ++i) {\n>             char c = str.charAt(i++);\n>             if (c > '9' || c < '0') {\n>                 return -1;\n>             }\n>         }\n>         // for now, we'll assume 32-bit indexes are fine\n>         return NumberInput.parseInt(str);\n>     }\n> ```\n> When they found a number it interprets the segment as integer but in reality it should be the whole expression. For this reason I think that the condition should be changed to the inverse condition (if it doesn't found any char then it is a number.\n> If you want I can send you a PR as well.\n> Alex.", "test_name": "com.fasterxml.jackson.core.TestJsonPointer::testWonkyNumber173", "test_method": "    public void testWonkyNumber173() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/1e0\"); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: For input string: \"1e0\"\n\tjava.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tjava.lang.Integer.parseInt(Integer.java:580)\n\tjava.lang.Integer.parseInt(Integer.java:615)\n\tcom.fasterxml.jackson.core.io.NumberInput.parseInt(NumberInput.java:91)\n\tcom.fasterxml.jackson.core.JsonPointer._parseIndex(JsonPointer.java:204)\n\tcom.fasterxml.jackson.core.JsonPointer.<init>(JsonPointer.java:70)\n\tcom.fasterxml.jackson.core.JsonPointer._parseTail(JsonPointer.java:225)\n\tcom.fasterxml.jackson.core.JsonPointer.compile(JsonPointer.java:98)\n\tcom.fasterxml.jackson.core.TestJsonPointer.testWonkyNumber173(TestJsonPointer.java:41)", "buggy_method": "185 private final static int _parseIndex(String str) {\n186         final int len = str.length();\n187         // [Issue#133]: beware of super long indexes; assume we never\n188         // have arrays over 2 billion entries so ints are fine.\n189         if (len == 0 || len > 10) {\n190             return -1;\n191         }\n192         for (int i = 0; i < len; ++i) {\n193             char c = str.charAt(i++);\n194             if (c > '9' || c < '0') {\n195                 return -1;\n196             }\n197         }\n198         if (len == 10) {\n199             long l = NumberInput.parseLong(str);\n200             if (l > Integer.MAX_VALUE) {\n201                 return -1;\n202             }\n203         }\n204         return NumberInput.parseInt(str);\n205     }", "bm_classpath": "com.fasterxml.jackson.core.JsonPointer"}, {"bug_name": "JacksonCore_6", "report_text": "> JsonPointer should not consider \"00\" to be valid index\n> \n> Although `00` can be parsed as `0` in some cases, it is not a valid JSON number; and is also not legal numeric index for JSON Pointer. As such, `JsonPointer` class should ensure it can only match property name \"00\" and not array index.", "test_name": "com.fasterxml.jackson.core.TestJsonPointer::testIZeroIndex", "test_method": "    public void testIZeroIndex() throws Exception\n    {\n        JsonPointer ptr = JsonPointer.compile(\"/0\");\n        ptr = JsonPointer.compile(\"/00\");\n        assertEquals(-1, ptr.getMatchingIndex()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-1> but was:<0>\n\tcom.fasterxml.jackson.core.TestJsonPointer.testIZeroIndex(TestJsonPointer.java:51)", "buggy_method": "185 private final static int _parseIndex(String str) {\n186         final int len = str.length();\n187         // [core#133]: beware of super long indexes; assume we never\n188         // have arrays over 2 billion entries so ints are fine.\n189         if (len == 0 || len > 10) {\n190             return -1;\n191         }\n192         // [core#176]: no leading zeroes allowed\n193         for (int i = 0; i < len; ++i) {\n194             char c = str.charAt(i);\n195             if (c > '9' || c < '0') {\n196                 return -1;\n197             }\n198         }\n199         if (len == 10) {\n200             long l = NumberInput.parseLong(str);\n201             if (l > Integer.MAX_VALUE) {\n202                 return -1;\n203             }\n204         }\n205         return NumberInput.parseInt(str);\n206     }", "bm_classpath": "com.fasterxml.jackson.core.JsonPointer"}, {"bug_name": "JacksonCore_7", "report_text": "> Add a check so JsonGenerator.writeString() won't work if writeFieldName() expected.\n> \n> Looks like calling `writeString()` (and perhaps other scalar write methods) results in writing invalid output, instead of throwing an exception. It should instead fail; in future we may want to consider allowing this as an alias, but at any rate it should not produce invalid output.", "test_name": "com.fasterxml.jackson.core.json.GeneratorFailTest::testFailOnWritingStringNotFieldNameBytes", "test_method": "    public void testFailOnWritingStringNotFieldNameBytes() throws Exception {\n        _testFailOnWritingStringNotFieldName(F, false); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should not have let com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeString() be used in place of 'writeFieldName()': output = {:\"a\"\n\tcom.fasterxml.jackson.core.json.GeneratorFailTest._testFailOnWritingStringNotFieldName(GeneratorFailTest.java:79)\n\tcom.fasterxml.jackson.core.json.GeneratorFailTest.testFailOnWritingStringNotFieldNameBytes(GeneratorFailTest.java:27)", "buggy_method": "166 public int writeValue() {\n167         // Most likely, object:\n168         if (_type == TYPE_OBJECT) {\n169             _gotName = false;\n170             ++_index;\n171             return STATUS_OK_AFTER_COLON;\n172         }\n173 \n174         // Ok, array?\n175         if (_type == TYPE_ARRAY) {\n176             int ix = _index;\n177             ++_index;\n178             return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n179         }\n180         \n181         // Nope, root context\n182         // No commas within root context, but need space\n183         ++_index;\n184         return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n185     }", "bm_classpath": "com.fasterxml.jackson.core.json.JsonWriteContext"}, {"bug_name": "JacksonCore_8", "report_text": "> Inconsistent TextBuffer#getTextBuffer behavior\n> \n> Hi, I'm using 2.4.2. While I'm working on CBORParser, I noticed that CBORParser#getTextCharacters() returns sometimes `null` sometimes `[]` (empty array) when it's parsing empty string `\"\"`.\n> While debugging, I noticed that TextBuffer#getTextBuffer behaves inconsistently.\n> ```\n> TextBuffer buffer = new TextBuffer(new BufferRecycler());\n> buffer.resetWithEmpty();\n> buffer.getTextBuffer(); // returns null\n> buffer.contentsAsString(); // returns empty string \"\"\n> buffer.getTextBuffer(); // returns empty array []\n> ```\n> I think getTextBuffer should return the same value. Not sure which (`null` or `[]`) is expected though.", "test_name": "com.fasterxml.jackson.core.util.TestTextBuffer::testEmpty", "test_method": "    public void testEmpty() {\n        TextBuffer tb = new TextBuffer(new BufferRecycler());\n        tb.resetWithEmpty();\n\n        assertTrue(tb.getTextBuffer().length == 0); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.fasterxml.jackson.core.util.TestTextBuffer.testEmpty(TestTextBuffer.java:83)", "buggy_method": "298 public char[] getTextBuffer()\n299     {\n300         // Are we just using shared input buffer?\n301         if (_inputStart >= 0) return _inputBuffer;\n302         if (_resultArray != null)  return _resultArray;\n303         if (_resultString != null) {\n304             return (_resultArray = _resultString.toCharArray());\n305         }\n306         // Nope; but does it fit in just one segment?\n307         if (!_hasSegments)  return _currentSegment;\n308         // Nope, need to have/create a non-segmented array and return it\n309         return contentsAsArray();\n310     }", "bm_classpath": "com.fasterxml.jackson.core.util.TextBuffer"}, {"bug_name": "JacksonCore_9", "report_text": "> JsonParser.getValueAsString() should return field name for JsonToken.FIELD_NAME, not null\n> \n> (note: offshoot of [FasterXML/jackson-databind#745](https://github.com/FasterXML/jackson-databind/issues/745))\n> Although Javadocs do not specify expected behavior for `JsonParser.getValueAsString()`, when current token is `JsonToken.FIELD_NAME`, it makes more sense to return name as-is, instead of null.  \n> This will simplify handling of code that requires a String representation; and code that does need to know the difference can use token type if that is relevant.\n> While this can be seen as a fix it is still a minor API change, so it needs to go in 2.6.0, not a 2.5.x patch release.", "test_name": "com.fasterxml.jackson.core.json.TestJsonParser::testGetValueAsTextBytes", "test_method": "    public void testGetValueAsTextBytes() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        _testGetValueAsText(f, true, false); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<a> but was:<null>\n\tcom.fasterxml.jackson.core.json.TestJsonParser._testGetValueAsText(TestJsonParser.java:546)\n\tcom.fasterxml.jackson.core.json.TestJsonParser.testGetValueAsTextBytes(TestJsonParser.java:518)", "buggy_method": "395 @Override\n396     public String getValueAsString(String defaultValue) throws IOException {\n397         if (_currToken == JsonToken.VALUE_STRING) {\n398             return getText();\n399         }\n400         if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n401             return defaultValue;\n402         }\n403         return getText();\n404     }", "bm_classpath": "com.fasterxml.jackson.core.base.ParserMinimalBase"}, {"bug_name": "JacksonCore_10", "report_text": "> ArrayIndexOutOfBoundsException in com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer\n> \n> The following code demonstrates a bug in jackson-core, version 2.6.0, in the hash table implementation of `com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer`. From a quick glance, it looks to me as if the \"primary hash information area\" `_hashArea` has a spillover area that is not accounted for properly in the `String` array `_names`.\n> ```\n> import com.fasterxml.jackson.core.JsonFactory;\n> import com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import org.testng.annotations.Test;\n> import java.lang.reflect.Field;\n> import java.lang.reflect.Method;\n> import java.nio.charset.StandardCharsets;\n> import java.util.Map;\n> /\\*\\*\n>  \\* Simple test case for demonstrating bug in class {@link ByteQuadsCanonicalizer}.\n>  \\*\n>  \\* <p>In some cases, it is possible to work around this bug by disabling the\n>  \\* {@link JsonFactory.Feature#CANONICALIZE\\_FIELD\\_NAMES} feature. In that case\n>  \\* {@link com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper#constructParser(int, com.fasterxml.jackson.core.ObjectCodec, ByteQuadsCanonicalizer, com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer, int)}\n>  \\* creates a {@link com.fasterxml.jackson.core.json.ReaderBasedJsonParser} instead of a\n>  \\* {@link com.fasterxml.jackson.core.json.UTF8StreamJsonParser}.\n>  \\*/\n> public class UTF8ByteStreamTest {\n>     private static final int SEED = -523743345;\n>     private static void injectReproducibleSeed(ObjectMapper objectMapper) throws Exception {\n>         JsonFactory jsonFactory = objectMapper.getFactory();\n>         // As a workaround, uncomment the following line.\n>         // jsonFactory.disable(JsonFactory.Feature.CANONICALIZE\\_FIELD\\_NAMES);\n>         Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"\\_byteSymbolCanonicalizer\");\n>         byteSymbolCanonicalizerField.setAccessible(true);\n>         Method factoryMethod = ByteQuadsCanonicalizer.class.getDeclaredMethod(\"createRoot\", int.class);\n>         factoryMethod.setAccessible(true);\n>         byteSymbolCanonicalizerField.set(jsonFactory, factoryMethod.invoke(null, SEED));\n>     }\n>     @Test\n>     public void testRead() throws Exception {\n>         ObjectMapper objectMapper = new ObjectMapper();\n>         injectReproducibleSeed(objectMapper);\n>         StringBuilder stringBuilder = new StringBuilder();\n>         stringBuilder.append(\"{\\n\");\n>         stringBuilder.append(\" \\\"expectedGCperPosition\\\": null\");\n>         for (int i = 0; i < 60; ++i) {\n>             stringBuilder.append(\",\\n \\\"\").append(i + 1).append(\"\\\": null\");\n>         }\n>         stringBuilder.append(\"\\n}\");\n>         objectMapper.readValue(stringBuilder.toString().getBytes(StandardCharsets.UTF\\_8), Map.class);\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.core.sym.TestByteBasedSymbols::testIssue207", "test_method": "    public void testIssue207() throws Exception\n    {\n        ByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\n        Field byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\n        byteSymbolCanonicalizerField.setAccessible(true);\n        JsonFactory jsonF = new JsonFactory();\n        byteSymbolCanonicalizerField.set(jsonF, nc);\n\n        StringBuilder stringBuilder = new StringBuilder();\n        stringBuilder.append(\"{\\n\");\n        stringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\n        for (int i = 0; i < 60; ++i) {\n            stringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n        }\n        stringBuilder.append(\"\\n}\");\n\n        JsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\n        while (p.nextToken() != null) { } // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 256\n\tcom.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseEscapedName(UTF8StreamJsonParser.java:1980)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.slowParseName(UTF8StreamJsonParser.java:1867)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1651)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:740)\n\tcom.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207(TestByteBasedSymbols.java:119)", "buggy_method": "887 private int _findOffsetForAdd(int hash)\n888     {\n889         // first, check the primary:\n890         int offset = _calcOffset(hash);\n891         final int[] hashArea = _hashArea;\n892         if (hashArea[offset+3] == 0) {\n893 //System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n894             return offset;\n895         }\n896         // then secondary\n897         int offset2 = _secondaryStart + ((offset >> 3) << 2);\n898         if (hashArea[offset2+3] == 0) {\n899 //System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n900             return offset2;\n901         }\n902         // if not, tertiary?\n903 \n904         offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n905         final int bucketSize = (1 << _tertiaryShift);\n906         for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n907             if (hashArea[offset2+3] == 0) {\n908 //System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n909                 return offset2;\n910             }\n911         }\n912 \n913         // and if even tertiary full, append at the end of spill area\n914         offset = _spilloverEnd;\n915         _spilloverEnd += 4;\n916 \n917 //System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n918         \n919         // one caveat: in the unlikely event if spill-over filling up,\n920         // check if that could be considered a DoS attack; handle appropriately\n921         // (NOTE: approximate for now; we could verify details if that becomes necessary)\n922         /* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n923          *   since \"long names\" area follows. Instead, need to calculate from hash size.\n924          */\n925         if (_spilloverEnd >= hashArea.length) {\n926             if (_failOnDoS) {\n927                 _reportTooManyCollisions();\n928             }\n929             // and if we didn't fail, we'll simply force rehash for next add\n930             // (which, in turn, may double up or nuke contents, depending on size etc)\n931             _needRehash = true;\n932         }\n933         return offset;\n934     }", "bm_classpath": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer"}, {"bug_name": "JacksonCore_11", "report_text": "> ArrayIndexOutOfBoundsException: 128 when repeatedly serializing to a byte array\n> \n> ```\n> java.lang.ArrayIndexOutOfBoundsException: 128\n>     at com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.findName(UTF8StreamJsonParser.java:2224)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseLongName(UTF8StreamJsonParser.java:1831)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumName2(UTF8StreamJsonParser.java:1786)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseMediumName(UTF8StreamJsonParser.java:1743)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1678)\n>     at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextFieldName(UTF8StreamJsonParser.java:1007)\n>     at com.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBindStringMap(MapDeserializer.java:471)\n>     at com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:341)\n>     at com.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:26)\n>     at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3702)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2824)\n>     at com.kryptnostic.services.v1.SmokeTests.spamAddIndexPair(SmokeTests.java:605)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:497)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n>     at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n>     at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n>     at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> ```\n> Repro:\n> ```\n> @Test\n> public void spamTest() {\n>         ObjectMapper mapper = new ObjectMapper();\n>         Map<ObjectUserKey, ServerIndexPair> ssip = Maps.newConcurrentMap();\n>         for ( int i = 0; i < 10000; ++i ) {\n>             byte[] indexPairBytes = new byte[ 2080 ];\n>             new Random().nextBytes( indexPairBytes );\n>             ServerIndexPair sip = new ServerIndexPair( indexPairBytes );\n>             byte[] s = mapper.writeValueAsBytes( ImmutableMap.of( UUID\n>                     .randomUUID().toString(), sip ) );\n>             Map<String, ServerIndexPair> metadata = mapper.readValue( s,\n>                     new TypeReference<Map<String, ServerIndexPair>>() {} );\n>             for ( Entry<String, ServerIndexPair> metadataEntry : metadata.entrySet() ) {\n>                 ServerIndexPair indexPair = metadataEntry.getValue();\n>                 ssip.put( new ObjectUserKey( metadataEntry.getKey(), user ),\n>                         indexPair );\n>             }\n>             logger.error( \"Iteration: {}\", i );\n>         }\n> }\n> ```\n> ```\n> public class ServerIndexPair {\n>     public static final String INDEX_PAIR_FIELD = \"indexPair\";\n>     private final byte[]       indexPair;\n>     @JsonCreator\n>     public ServerIndexPair( @JsonProperty( INDEX_PAIR_FIELD ) byte[] indexPair ) {\n>         Preconditions.checkState( indexPair.length == 2080, \"Index pair must be 2080 bytes long.\" );\n>         this.indexPair = indexPair;\n>     }\n>     @JsonProperty( INDEX_PAIR_FIELD )\n>     public byte[] getIndexPair() {\n>         return indexPair;\n>     }\n> }\n> ```\n> ```\n> public class ObjectUserKey {\n>     public static final String SEPARATOR = \":\";\n>     private final String       objectId;\n>     private final UUID         userKey;\n>     @JsonCreator\n>     public ObjectUserKey(\n>             @JsonProperty( Names.ID_FIELD ) String objectId,\n>             @JsonProperty( Names.USER_FIELD ) UUID userKey ) {\n>         super();\n>         this.objectId = objectId;\n>         this.userKey = userKey;\n>     }\n>     @JsonProperty( Names.ID_FIELD )\n>     public String getObjectId() {\n>         return objectId;\n>     }\n>     @JsonProperty( Names.USER_FIELD )\n>     public UUID getUserKey() {", "test_name": "com.fasterxml.jackson.core.sym.SymbolsViaParserTest::testSymbolTableExpansionBytes", "test_method": "    public void testSymbolTableExpansionBytes() throws Exception {\n        _testSymbolTableExpansion(true); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 512\n\tcom.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:824)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.findName(UTF8StreamJsonParser.java:2185)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1691)\n\tcom.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:740)\n\tcom.fasterxml.jackson.core.sym.SymbolsViaParserTest._testSymbolTableExpansion(SymbolsViaParserTest.java:87)\n\tcom.fasterxml.jackson.core.sym.SymbolsViaParserTest.testSymbolTableExpansionBytes(SymbolsViaParserTest.java:32)", "buggy_method": "874 private void _verifySharing()\n875     {\n876         if (_hashShared) {\n877             _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n878             _names = Arrays.copyOf(_names, _names.length);\n879             _hashShared = false;\n880             // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n881             //    we rehash as needed, as need-rehash flag is not copied from parent\n882         }\n883         if (_needRehash) {\n884             rehash();\n885         }\n886     }", "bm_classpath": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer"}, {"bug_name": "JacksonCore_12", "report_text": "> JsonParser.getTokenLocation() doesn't update after field names.\n> \n> There's a unit test to repro the issue below. Basically, when you're on a FIELD\\_NAME token, if you call getTokenLocation() and then nextToken() and then getTokenLocation() again, you'll get the same location for both calls to getTokenLocation(), even though you've advanced to a new token.\n> The issue seems to be the \\_nextToken logic in ReaderBasedJsonParser and UTF8StreamJsonParser. When calling nextToken() on a FIELD\\_NAME, it calls \\_nextAfterName(), which updates \\_currToken but doesn't update \\_tokenInputRow and \\_tokenInputCol for the new token's location.\n> I started to try to fix it, but the \\_nextToken logic is spread across so much code that it looked like it'd be a pretty major surgery. Not something I'm willing to do at this point. :-)\n> ```\n> public void testTokenLocationAfterFieldName() throws Exception\n> {\n>     _testTokenLocationAfterFieldName(false);\n>     _testTokenLocationAfterFieldName(true);\n> }\n> private void _testTokenLocationAfterFieldName(Boolean useStream) throws Exception\n> {\n>     final String DOC = \"{\\\"name\\\":123}\";\n>     JsonFactory jf = new JsonFactory();\n>     JsonParser jp = useStream ?\n>             jf.createJsonParser(new ByteArrayInputStream(DOC.getBytes(\"UTF-8\")))\n>             : jf.createJsonParser(new StringReader(DOC));\n>     assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n>     assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n>     assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n>     assertEquals(1, jp.getTokenLocation().getLineNr());\n>     assertEquals(9, jp.getTokenLocation().getColumnNr());\n>     jp.close();\n> }\n> ```", "test_name": "com.fasterxml.jackson.core.json.LocationInObjectTest::testOffsetWithObjectFieldsUsingReader", "test_method": "    public void testOffsetWithObjectFieldsUsingReader() throws Exception\n    {\n        final JsonFactory f = new JsonFactory();\n        char[] c = \"{\\\"f1\\\":\\\"v1\\\",\\\"f2\\\":{\\\"f3\\\":\\\"v3\\\"},\\\"f4\\\":[true,false],\\\"f5\\\":5}\".toCharArray();\n        //            1      6      11    16 17    22      28    33 34 39      46    51\n        JsonParser p = f.createParser(c);\n\n\n        assertEquals(6L, p.getTokenLocation().getCharOffset()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<6> but was:<1>\n\tcom.fasterxml.jackson.core.json.LocationInObjectTest.testOffsetWithObjectFieldsUsingReader(LocationInObjectTest.java:66)", "buggy_method": "573 @Override\n574     public final JsonToken nextToken() throws IOException\n575     {\n576         /* First: field names are special -- we will always tokenize\n577          * (part of) value along with field name to simplify\n578          * state handling. If so, can and need to use secondary token:\n579          */\n580         if (_currToken == JsonToken.FIELD_NAME) {\n581             return _nextAfterName();\n582         }\n583         // But if we didn't already have a name, and (partially?) decode number,\n584         // need to ensure no numeric information is leaked\n585         _numTypesValid = NR_UNKNOWN;\n586         if (_tokenIncomplete) {\n587             _skipString(); // only strings can be partial\n588         }\n589         int i = _skipWSOrEnd();\n590         if (i < 0) { // end-of-input\n591             /* 19-Feb-2009, tatu: Should actually close/release things\n592              *    like input source, symbol table and recyclable buffers now.\n593              */\n594             close();\n595             return (_currToken = null);\n596         }\n597         // clear any data retained so far\n598         _binaryValue = null;\n599 \n600         // Closing scope?\n601         if (i == INT_RBRACKET) {\n602             _updateLocation();\n603             if (!_parsingContext.inArray()) {\n604                 _reportMismatchedEndMarker(i, '}');\n605             }\n606             _parsingContext = _parsingContext.getParent();\n607             return (_currToken = JsonToken.END_ARRAY);\n608         }\n609         if (i == INT_RCURLY) {\n610             _updateLocation();\n611             if (!_parsingContext.inObject()) {\n612                 _reportMismatchedEndMarker(i, ']');\n613             }\n614             _parsingContext = _parsingContext.getParent();\n615             return (_currToken = JsonToken.END_OBJECT);\n616         }\n617 \n618         // Nope: do we then expect a comma?\n619         if (_parsingContext.expectComma()) {\n620             i = _skipComma(i);\n621         }\n622         _updateLocation();\n623 \n624         /* And should we now have a name? Always true for Object contexts, since\n625          * the intermediate 'expect-value' state is never retained.\n626          */\n627         boolean inObject = _parsingContext.inObject();\n628         if (inObject) {\n629             // First, field name itself:\n630             String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n631             _parsingContext.setCurrentName(name);\n632             _currToken = JsonToken.FIELD_NAME;\n633             i = _skipColon();\n634         }\n635 \n636         // Ok: we must have a value... what is it?\n637 \n638         JsonToken t;\n639 \n640         switch (i) {\n641         case '\"':\n642             _tokenIncomplete = true;\n643             t = JsonToken.VALUE_STRING;\n644             break;\n645         case '[':\n646             if (!inObject) {\n647                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n648             }\n649             t = JsonToken.START_ARRAY;\n650             break;\n651         case '{':\n652             if (!inObject) {\n653                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n654             }\n655             t = JsonToken.START_OBJECT;\n656             break;\n657         case ']':\n658         case '}':\n659             // Error: neither is valid at this point; valid closers have\n660             // been handled earlier\n661             _reportUnexpectedChar(i, \"expected a value\");\n662         case 't':\n663             _matchTrue();\n664             t = JsonToken.VALUE_TRUE;\n665             break;\n666         case 'f':\n667             _matchFalse();\n668             t = JsonToken.VALUE_FALSE;\n669             break;\n670         case 'n':\n671             _matchNull();\n672             t = JsonToken.VALUE_NULL;\n673             break;\n674 \n675         case '-':\n676             /* Should we have separate handling for plus? Although\n677              * it is not allowed per se, it may be erroneously used,\n678              * and could be indicate by a more specific error message.\n679              */\n680             t = _parseNegNumber();\n681             break;\n682         case '0':\n683         case '1':\n684         case '2':\n685         case '3':\n686         case '4':\n687         case '5':\n688         case '6':\n689         case '7':\n690         case '8':\n691         case '9':\n692             t = _parsePosNumber(i);\n693             break;\n694         default:\n695             t = _handleOddValue(i);\n696             break;\n697         }\n698 \n699         if (inObject) {\n700             _nextToken = t;\n701             return _currToken;\n702         }\n703         _currToken = t;\n704         return t;\n705     }", "bm_classpath": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser"}, {"bug_name": "JacksonCore_14", "report_text": "> Relax ownership checks for buffers not to require increase in size\n> \n> Checks in `IOContext` expect buffer to either be the same or grow. But it should actually be completely legal to return another buffer with similar size, given that most allocation strategies will eventually converge into maximum allowed block size.", "test_name": "com.fasterxml.jackson.core.io.TestIOContext::testAllocations", "test_method": "    public void testAllocations() throws Exception\n    {\n        IOContext ctxt = new IOContext(new BufferRecycler(), \"N/A\", true);\n\n        /* I/O Read buffer */\n\n        // First succeeds:\n        // second fails\n        try {\n            ctxt.allocReadIOBuffer();\n        } catch (IllegalStateException e) {\n            verifyException(e, \"second time\");\n        }\n        // Also: can't succeed with different buffer\n        try {\n            ctxt.releaseReadIOBuffer(new byte[1]);\n        } catch (IllegalArgumentException e) {\n            verifyException(e, \"smaller than original\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([smaller than original]): got one with message \"Trying to release buffer not owned by the context\"\n\tcom.fasterxml.jackson.core.BaseTest.verifyException(BaseTest.java:390)\n\tcom.fasterxml.jackson.core.io.TestIOContext.testAllocations(TestIOContext.java:27)", "buggy_method": "272 protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n273         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n274         if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n275     }", "bm_classpath": "com.fasterxml.jackson.core.io.IOContext"}, {"bug_name": "JacksonCore_15", "report_text": "> Make use of _allowMultipleMatches in FilteringParserDelegate\n> \n> Currently, it looks like that the \\_allowMultipleMatches attribute in FilteringGeneratorDelegate is not utilised (i.e. no value is assigned to this variable). Re. the documentation this attribute offers some useful functionality. So it would be nice, if it could be implemented properly. See <https://groups.google.com/d/msg/jackson-user/VzZ94G9hvrs/JGFozl6lCQAJ>", "test_name": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testNotAllowMultipleMatches", "test_method": "    @SuppressWarnings(\"resource\")\n    public void testNotAllowMultipleMatches() throws Exception\n    {\n    \tString jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'value':4,'b':true}\");\n        JsonParser p0 = JSON_F.createParser(jsonString);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   false, // includePath\n                   false // multipleMatches -false\n                );\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(aposToQuotes(\"3\"), result); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<3[]> but was:<3[ 4]>\n\tcom.fasterxml.jackson.core.filter.BasicParserFilteringTest.testNotAllowMultipleMatches(BasicParserFilteringTest.java:118)", "buggy_method": "221 @Override\n222     public JsonToken nextToken() throws IOException\n223     {\n224     \t//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n225     \t// check for no buffered context _exposedContext - null\n226     \t//If all the conditions matches then check for scalar / non-scalar property\n227     \t\t//if not scalar and ended successfully, then return null\n228     \t\t//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n229     \t\t// then return null \n230         // Anything buffered?\n231         TokenFilterContext ctxt = _exposedContext;\n232 \n233         if (ctxt != null) {\n234             while (true) {\n235                 JsonToken t = ctxt.nextTokenToRead();\n236                 if (t != null) {\n237                     _currToken = t;\n238                     return t;\n239                 }\n240                 // all done with buffered stuff?\n241                 if (ctxt == _headContext) {\n242                     _exposedContext = null;\n243                     if (ctxt.inArray()) {\n244                         t = delegate.getCurrentToken();\n245 // Is this guaranteed to work without further checks?\n246 //                        if (t != JsonToken.START_ARRAY) {\n247                         _currToken = t;\n248                         return t;\n249                     }\n250 \n251                     // Almost! Most likely still have the current token;\n252                     // with the sole exception of \n253                     /*\n254                     t = delegate.getCurrentToken();\n255                     if (t != JsonToken.FIELD_NAME) {\n256                         _currToken = t;\n257                         return t;\n258                     }\n259                     */\n260                     break;\n261                 }\n262                 // If not, traverse down the context chain\n263                 ctxt = _headContext.findChildOf(ctxt);\n264                 _exposedContext = ctxt;\n265                 if (ctxt == null) { // should never occur\n266                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n267                 }\n268             }\n269         }\n270 \n271         // If not, need to read more. If we got any:\n272         JsonToken t = delegate.nextToken();\n273         if (t == null) {\n274             // no strict need to close, since we have no state here\n275             return (_currToken = t);\n276         }\n277 \n278         // otherwise... to include or not?\n279         TokenFilter f;\n280         \n281         switch (t.id()) {\n282         case ID_START_ARRAY:\n283             f = _itemFilter;\n284             if (f == TokenFilter.INCLUDE_ALL) {\n285                 _headContext = _headContext.createChildArrayContext(f, true);\n286                 return (_currToken = t);\n287             }\n288             if (f == null) { // does this occur?\n289                 delegate.skipChildren();\n290                 break;\n291             }\n292             // Otherwise still iffy, need to check\n293             f = _headContext.checkValue(f);\n294             if (f == null) {\n295                 delegate.skipChildren();\n296                 break;\n297             }\n298             if (f != TokenFilter.INCLUDE_ALL) {\n299                 f = f.filterStartArray();\n300             }\n301             _itemFilter = f;\n302             if (f == TokenFilter.INCLUDE_ALL) {\n303                 _headContext = _headContext.createChildArrayContext(f, true);\n304                 return (_currToken = t);\n305             }\n306             _headContext = _headContext.createChildArrayContext(f, false);\n307             \n308             // Also: only need buffering if parent path to be included\n309             if (_includePath) {\n310                 t = _nextTokenWithBuffering(_headContext);\n311                 if (t != null) {\n312                     _currToken = t;\n313                     return t;\n314                 }\n315             }\n316             break;\n317 \n318         case ID_START_OBJECT:\n319             f = _itemFilter;\n320             if (f == TokenFilter.INCLUDE_ALL) {\n321                 _headContext = _headContext.createChildObjectContext(f, true);\n322                 return (_currToken = t);\n323             }\n324             if (f == null) { // does this occur?\n325                 delegate.skipChildren();\n326                 break;\n327             }\n328             // Otherwise still iffy, need to check\n329             f = _headContext.checkValue(f);\n330             if (f == null) {\n331                 delegate.skipChildren();\n332                 break;\n333             }\n334             if (f != TokenFilter.INCLUDE_ALL) {\n335                 f = f.filterStartObject();\n336             }\n337             _itemFilter = f;\n338             if (f == TokenFilter.INCLUDE_ALL) {\n339                 _headContext = _headContext.createChildObjectContext(f, true);\n340                 return (_currToken = t);\n341             }\n342             _headContext = _headContext.createChildObjectContext(f, false);\n343             // Also: only need buffering if parent path to be included\n344             if (_includePath) {\n345                 t = _nextTokenWithBuffering(_headContext);\n346                 if (t != null) {\n347                     _currToken = t;\n348                     return t;\n349                 }\n350             }\n351             // note: inclusion of surrounding Object handled separately via\n352             // FIELD_NAME\n353             break;\n354 \n355         case ID_END_ARRAY:\n356         case ID_END_OBJECT:\n357             {\n358                 boolean returnEnd = _headContext.isStartHandled();\n359                 f = _headContext.getFilter();\n360                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n361                     f.filterFinishArray();\n362                 }\n363                 _headContext = _headContext.getParent();\n364                 _itemFilter = _headContext.getFilter();\n365                 if (returnEnd) {\n366                     return (_currToken = t);\n367                 }\n368             }\n369             break;\n370 \n371         case ID_FIELD_NAME:\n372             {\n373                 final String name = delegate.getCurrentName();\n374                 // note: this will also set 'needToHandleName'\n375                 f = _headContext.setFieldName(name);\n376                 if (f == TokenFilter.INCLUDE_ALL) {\n377                     _itemFilter = f;\n378                     if (!_includePath) {\n379                         // Minor twist here: if parent NOT included, may need to induce output of\n380                         // surrounding START_OBJECT/END_OBJECT\n381                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n382                             t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n383                             _exposedContext = _headContext;\n384                         }\n385                     }\n386                     return (_currToken = t);\n387                 }\n388                 if (f == null) {\n389                     delegate.nextToken();\n390                     delegate.skipChildren();\n391                     break;\n392                 }\n393                 f = f.includeProperty(name);\n394                 if (f == null) {\n395                     delegate.nextToken();\n396                     delegate.skipChildren();\n397                     break;\n398                 }\n399                 _itemFilter = f;\n400                 if (f == TokenFilter.INCLUDE_ALL) {\n401                     if (_includePath) {\n402                         return (_currToken = t);\n403                     }\n404                 }\n405                 if (_includePath) {\n406                     t = _nextTokenWithBuffering(_headContext);\n407                     if (t != null) {\n408                         _currToken = t;\n409                         return t;\n410                     }\n411                 }\n412                 break;\n413             }\n414 \n415         default: // scalar value\n416             f = _itemFilter;\n417             if (f == TokenFilter.INCLUDE_ALL) {\n418                 return (_currToken = t);\n419             }\n420             if (f != null) {\n421                 f = _headContext.checkValue(f);\n422                 if ((f == TokenFilter.INCLUDE_ALL)\n423                         || ((f != null) && f.includeValue(delegate))) {\n424                     return (_currToken = t);\n425                 }\n426             }\n427             // Otherwise not included (leaves must be explicitly included)\n428             break;\n429         }\n430 \n431         // We get here if token was not yet found; offlined handling\n432         return _nextToken2();\n433     }", "bm_classpath": "com.fasterxml.jackson.core.filter.FilteringParserDelegate"}, {"bug_name": "JacksonCore_16", "report_text": "> JsonParserSequence skips a token on a switched Parser.\n> \n> Having 2 parsers concatenated with `JsonParserSequence.createFlattened(parser1, parser2)`.\n> If the second parser is on a token that is not null and should not be skipped, the JsonParserSequence will still skip it. JsonParserSequence's [nextToken()](https://github.com/FasterXML/jackson-core/blob/master/src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java#L102) calls nextToken() on the new delegate which may cause that we miss a token.\n> For more details : [forum question](http://jackson-users.ning.com/forum/topics/jsonparsersequence-behaviour-seems-misleading)\n> I'll open a PR for this.  \n> Thanks.", "test_name": "com.fasterxml.jackson.core.json.ParserSequenceTest::testInitialized", "test_method": "    public void testInitialized() throws Exception\n    {\n        JsonParser p1 = JSON_FACTORY.createParser(\"1 2\");\n        JsonParser p2 = JSON_FACTORY.createParser(\"3 false\");\n        // consume '1', move to '2'\n\n        JsonParserSequence seq = JsonParserSequence.createFlattened(p1, p2);\n        assertEquals(2, seq.getIntValue()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2> but was:<3>\n\tcom.fasterxml.jackson.core.json.ParserSequenceTest.testInitialized(ParserSequenceTest.java:60)", "buggy_method": "42 protected JsonParserSequence(JsonParser[] parsers)\n43     {\n44         super(parsers[0]);\n45         _parsers = parsers;\n46         _nextParser = 1;\n47     }", "bm_classpath": "com.fasterxml.jackson.core.util.JsonParserSequence"}, {"bug_name": "JacksonCore_17", "report_text": "> JsonGenerationException: Split surrogate on writeRaw() input thrown for input of a certain size\n> \n> In short, I am seeing the following exception while processing text that includes valid multi-byte Unicode characters, and adding or removing characters before the \"problematic\" characters can affect whether the exception is thrown.\n> `$ java -classpath .:../../jackson-core/target/jackson-core-2.8.2-SNAPSHOT.jar BadMsg com.fasterxml.jackson.core.JsonGenerationException: Split surrogate on writeRaw() input (last character) at com.fasterxml.jackson.core.JsonGenerator._reportError(JsonGenerator.java:1887) at com.fasterxml.jackson.core.json.UTF8JsonGenerator._outputRawMultiByteChar(UTF8JsonGenerator.java:1916) at com.fasterxml.jackson.core.json.UTF8JsonGenerator._writeSegmentedRaw(UTF8JsonGenerator.java:697) at com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:611) at com.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:560) at com.fasterxml.jackson.core.base.GeneratorBase.writeRawValue(GeneratorBase.java:306) at BadMsg.main(BadMsg.java:17)` \n> The simplest way to demonstrate this is code, so I will attach a sample program with a document that causes the error. Sorry for the ugly redacted text, but you can imagine some real words and other interesting strings in place of all the x's. Note that if I delete or add enough of the 'x' characters (doesn't matter where in the JSON they appear, as long as it's before the character that causes the exception) the exception will not be thrown. I believe the problem is in buffering the data that is passed to the lower level functions, but I have not debugged to that level.", "test_name": "com.fasterxml.jackson.core.json.RawValueWithSurrogatesTest::testRawWithSurrogatesString", "test_method": "    public void testRawWithSurrogatesString() throws Exception {\r\n        _testRawWithSurrogatesString(false); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.core.JsonGenerationException: Split surrogate on writeRaw() input (last character)\n\tcom.fasterxml.jackson.core.JsonGenerator._reportError(JsonGenerator.java:1723)\n\tcom.fasterxml.jackson.core.json.UTF8JsonGenerator._outputRawMultiByteChar(UTF8JsonGenerator.java:1887)\n\tcom.fasterxml.jackson.core.json.UTF8JsonGenerator._writeSegmentedRaw(UTF8JsonGenerator.java:658)\n\tcom.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:573)\n\tcom.fasterxml.jackson.core.json.UTF8JsonGenerator.writeRaw(UTF8JsonGenerator.java:536)\n\tcom.fasterxml.jackson.core.base.GeneratorBase.writeRawValue(GeneratorBase.java:299)\n\tcom.fasterxml.jackson.core.json.RawValueWithSurrogatesTest._testRawWithSurrogatesString(RawValueWithSurrogatesTest.java:82)\n\tcom.fasterxml.jackson.core.json.RawValueWithSurrogatesTest.testRawWithSurrogatesString(RawValueWithSurrogatesTest.java:54)", "buggy_method": "522 @Override\n523     public void writeRaw(String text, int offset, int len) throws IOException\n524     {\n525         final char[] buf = _charBuffer;\n526 \n527         // minor optimization: see if we can just get and copy\n528 \n529         // If not, need segmented approach. For speed, let's also use input buffer\n530         // size that is guaranteed to fit in output buffer; each char can expand to\n531         // at most 3 bytes, so at most 1/3 of buffer size.\n532 \n533         while (len > 0) {\n534             int len2 = Math.min(buf.length, len);\n535             text.getChars(offset, offset+len2, buf, 0);\n536             writeRaw(buf, 0, len2);\n537             // If this is NOT the last segment and if the last character looks like\n538             // split surrogate second half, drop it\n539             offset += len2;\n540             len -= len2;\n541         }\n542     }", "bm_classpath": "com.fasterxml.jackson.core.json.UTF8JsonGenerator"}, {"bug_name": "JacksonCore_18", "report_text": "> OutOfMemoryError when writing BigDecimal\n> \n> (note: moved from [FasterXML/jackson-databind#1316](https://github.com/FasterXML/jackson-databind/issues/1316) reported by [@gmethvin](https://github.com/gmethvin))\n> When I've enabled the `WRITE_BIGDECIMAL_AS_PLAIN` setting on Jackson 2.7.5, Jackson will attempt to write out the whole number, no matter how large the exponent.\n> For example, the following code:\n> ```\n> ObjectMapper mapper = new ObjectMapper().enable(JsonGenerator.Feature.WRITE\\_BIGDECIMAL\\_AS\\_PLAIN);\n> mapper.writeValueAsString(new java.math.BigDecimal(\"9.223372E+1010671858\"));\n> ```\n> triggers the exception:\n> ```\n> java.lang.OutOfMemoryError: Java heap space\n>   at java.lang.AbstractStringBuilder.<init>(AbstractStringBuilder.java:68)\n>   at java.lang.StringBuilder.<init>(StringBuilder.java:101)\n>   at java.math.BigDecimal.toPlainString(BigDecimal.java:2964)\n>   at com.fasterxml.jackson.core.json.WriterBasedJsonGenerator.writeNumber(WriterBasedJsonGenerator.java:690)\n>   at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:45)\n>   at com.fasterxml.jackson.databind.ser.std.NumberSerializer.serialize(NumberSerializer.java:19)\n>   at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:130)\n>   at com.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3612)\n>   at com.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2980)\n>   ... 23 elided\n> ```\n> I know technically Jackson is doing what you're telling it to do (so if you don't feel this is an issue feel free to close it). But it would be nice if `WRITE_BIGDECIMAL_AS_PLAIN` set a reasonable length on the number, so as not to leave users open to denial of service vulnerabilities.\n> (Actually, I think this might technically be an issue in jackson-core; let me know if I should resubmit.)", "test_name": "com.fasterxml.jackson.core.json.TestJsonGeneratorFeatures::testTooBigBigDecimal", "test_method": "    public void testTooBigBigDecimal() throws Exception\n    {\n        JsonFactory f = new JsonFactory();\n        f.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n\n        // 24-Aug-2016, tatu: Initial check limits scale to [-9999,+9999]\n        BigDecimal BIG = new BigDecimal(\"1E+9999\");\n        BigDecimal TOO_BIG = new BigDecimal(\"1E+10000\");\n        BigDecimal SMALL = new BigDecimal(\"1E-9999\");\n        BigDecimal TOO_SMALL = new BigDecimal(\"1E-10000\");\n\n        for (boolean useBytes : new boolean[] { false, true } ) {\n            for (boolean asString : new boolean[] { false, true } ) {\n                JsonGenerator g;\n                \n                if (useBytes) {\n                    g = f.createGenerator(new ByteArrayOutputStream());\n                } else {\n                    g = f.createGenerator(new StringWriter());\n                }\n                if (asString) {\n                    g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                }\n\n                // first, ok cases:\n                g.writeStartArray();\n                g.writeNumber(BIG);\n                g.writeNumber(SMALL);\n                g.writeEndArray();\n                g.close();\n\n                // then invalid\n                for (BigDecimal input : new BigDecimal[] { TOO_BIG, TOO_SMALL }) {\n                    if (useBytes) {\n                        g = f.createGenerator(new ByteArrayOutputStream());\n                    } else {\n                        g = f.createGenerator(new StringWriter());\n                    }\n                    if (asString) {\n                        g.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS);\n                    }\n                    try {\n                        g.writeNumber(input);\n                        fail(\"Should not have written without exception: \"+input);\n                    } catch (JsonGenerationException e) {\n                        verifyException(e, \"Attempt to write plain `java.math.BigDecimal`\");\n                        verifyException(e, \"illegal scale\");\n                    }\n                    g.close();\n                }\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should not have written without exception: 1E+10000\n\tcom.fasterxml.jackson.core.json.TestJsonGeneratorFeatures.testTooBigBigDecimal(TestJsonGeneratorFeatures.java:154)", "buggy_method": "433 protected String _asString(BigDecimal value) throws IOException {\n434             // 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n435         return value.toString();\n436     }", "bm_classpath": "com.fasterxml.jackson.core.base.GeneratorBase"}, {"bug_name": "JacksonCore_19", "report_text": "> ArrayIndexOutOfBoundsException: 200 on floating point number with exactly 200-length decimal part\n> \n> Very similar issue to [#160](https://github.com/FasterXML/jackson-core/issues/160) and [#157](https://github.com/FasterXML/jackson-core/issues/157)  \n> With `jackson-core 2.8.1` when attempting to parse fractional number that has exactly 200 numbers in the decimal part and some random fractional part then java.lang.ArrayIndexOutOfBoundsException: 200 is thrown.\n> ```\n> public class Test {\n>     public static void main(String[] args) throws IOException {\n>         StringBuilder input = new StringBuilder();\n>         for (int i = 1; i < 201; i++) {\n>             input.append(1);\n>         }\n>         input.append(\".0\");\n>         JsonFactory factory = new JsonFactory();\n>         JsonParser parser =\n>                 factory.createParser(new ByteArrayInputStream(input.toString().getBytes(Charset.forName(\"UTF-8\"))));\n>         parser.nextToken();\n>     }\n> }\n> ```\n> Produces:  \n> `Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 200 at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseFloat(UTF8StreamJsonParser.java:1576) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseNumber2(UTF8StreamJsonParser.java:1509) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parsePosNumber(UTF8StreamJsonParser.java:1410) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser._nextTokenNotInObject(UTF8StreamJsonParser.java:876) at com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:772)`", "test_name": "com.fasterxml.jackson.core.json.TestNumericValues::testLongerFloatingPoint", "test_method": "    public void testLongerFloatingPoint() throws Exception\n    {\n        StringBuilder input = new StringBuilder();\n        for (int i = 1; i < 201; i++) {\n            input.append(1);\n        }\n        input.append(\".0\");\n        final String DOC = input.toString();\n\n        // test out with both Reader and ByteArrayInputStream\n        JsonParser p;\n\n        p = FACTORY.createParser(new StringReader(DOC));\n        _testLongerFloat(p, DOC); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 200\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._parseNumber2(ReaderBasedJsonParser.java:1418)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._parseFloat(ReaderBasedJsonParser.java:1266)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._parsePosNumber(ReaderBasedJsonParser.java:1241)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:705)\n\tcom.fasterxml.jackson.core.json.TestNumericValues._testLongerFloat(TestNumericValues.java:580)\n\tcom.fasterxml.jackson.core.json.TestNumericValues.testLongerFloatingPoint(TestNumericValues.java:570)", "buggy_method": "1374 private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n1375     {\n1376         _inputPtr = neg ? (startPtr+1) : startPtr;\n1377         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n1378         int outPtr = 0;\n1379 \n1380         // Need to prepend sign?\n1381         if (neg) {\n1382             outBuf[outPtr++] = '-';\n1383         }\n1384 \n1385         // This is the place to do leading-zero check(s) too:\n1386         int intLen = 0;\n1387         char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n1388         if (c == '0') {\n1389             c = _verifyNoLeadingZeroes();\n1390         }\n1391         boolean eof = false;\n1392 \n1393         // Ok, first the obligatory integer part:\n1394         int_loop:\n1395         while (c >= '0' && c <= '9') {\n1396             ++intLen;\n1397             if (outPtr >= outBuf.length) {\n1398                 outBuf = _textBuffer.finishCurrentSegment();\n1399                 outPtr = 0;\n1400             }\n1401             outBuf[outPtr++] = c;\n1402             if (_inputPtr >= _inputEnd && !loadMore()) {\n1403                 // EOF is legal for main level int values\n1404                 c = CHAR_NULL;\n1405                 eof = true;\n1406                 break int_loop;\n1407             }\n1408             c = _inputBuffer[_inputPtr++];\n1409         }\n1410         // Also, integer part is not optional\n1411         if (intLen == 0) {\n1412             return _handleInvalidNumberStart(c, neg);\n1413         }\n1414 \n1415         int fractLen = 0;\n1416         // And then see if we get other parts\n1417         if (c == '.') { // yes, fraction\n1418             outBuf[outPtr++] = c;\n1419 \n1420             fract_loop:\n1421             while (true) {\n1422                 if (_inputPtr >= _inputEnd && !loadMore()) {\n1423                     eof = true;\n1424                     break fract_loop;\n1425                 }\n1426                 c = _inputBuffer[_inputPtr++];\n1427                 if (c < INT_0 || c > INT_9) {\n1428                     break fract_loop;\n1429                 }\n1430                 ++fractLen;\n1431                 if (outPtr >= outBuf.length) {\n1432                     outBuf = _textBuffer.finishCurrentSegment();\n1433                     outPtr = 0;\n1434                 }\n1435                 outBuf[outPtr++] = c;\n1436             }\n1437             // must be followed by sequence of ints, one minimum\n1438             if (fractLen == 0) {\n1439                 reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n1440             }\n1441         }\n1442 \n1443         int expLen = 0;\n1444         if (c == 'e' || c == 'E') { // exponent?\n1445             if (outPtr >= outBuf.length) {\n1446                 outBuf = _textBuffer.finishCurrentSegment();\n1447                 outPtr = 0;\n1448             }\n1449             outBuf[outPtr++] = c;\n1450             // Not optional, can require that we get one more char\n1451             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n1452                 : getNextChar(\"expected a digit for number exponent\");\n1453             // Sign indicator?\n1454             if (c == '-' || c == '+') {\n1455                 if (outPtr >= outBuf.length) {\n1456                     outBuf = _textBuffer.finishCurrentSegment();\n1457                     outPtr = 0;\n1458                 }\n1459                 outBuf[outPtr++] = c;\n1460                 // Likewise, non optional:\n1461                 c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n1462                     : getNextChar(\"expected a digit for number exponent\");\n1463             }\n1464 \n1465             exp_loop:\n1466             while (c <= INT_9 && c >= INT_0) {\n1467                 ++expLen;\n1468                 if (outPtr >= outBuf.length) {\n1469                     outBuf = _textBuffer.finishCurrentSegment();\n1470                     outPtr = 0;\n1471                 }\n1472                 outBuf[outPtr++] = c;\n1473                 if (_inputPtr >= _inputEnd && !loadMore()) {\n1474                     eof = true;\n1475                     break exp_loop;\n1476                 }\n1477                 c = _inputBuffer[_inputPtr++];\n1478             }\n1479             // must be followed by sequence of ints, one minimum\n1480             if (expLen == 0) {\n1481                 reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n1482             }\n1483         }\n1484 \n1485         // Ok; unless we hit end-of-input, need to push last char read back\n1486         if (!eof) {\n1487             --_inputPtr;\n1488             if (_parsingContext.inRoot()) {\n1489                 _verifyRootSpace(c);\n1490             }\n1491         }\n1492         _textBuffer.setCurrentLength(outPtr);\n1493         // And there we have it!\n1494         return reset(neg, intLen, fractLen, expLen);\n1495     }", "bm_classpath": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser"}, {"bug_name": "JacksonCore_20", "report_text": "> Add support for writing byte[] via JsonGenerator.writeEmbeddedObject()\n> \n> (note: should be safe for patch, that is, 2.8.3)\n> Default implementation of 2.8-added `writeEmbeddedObject()` throws exception (unsupported operation) for all values, since JSON does not have any native object types.  \n> This is different from handling of `writeObject()`, which tries to either delegate to `ObjectCodec` (if one registered), or even encode \"simple\" values.\n> However: since support for binary data is already handled in some cases using `VALUE_EMBEDDED_OBJECT`, it would actually make sense to handle case of `byte[]` (and, if feasible, perhaps `ByteBuffer` for extra points), and also ensure `null` can be written.\n> This is likely necessary to support [FasterXML/jackson-databind#1361](https://github.com/FasterXML/jackson-databind/issues/1361) and should in general make system more robust.", "test_name": "com.fasterxml.jackson.core.base64.Base64GenerationTest::testBinaryAsEmbeddedObject", "test_method": "    public void testBinaryAsEmbeddedObject() throws Exception\n    {\n        JsonGenerator g;\n\n        StringWriter sw = new StringWriter();\n        g = JSON_F.createGenerator(sw);\n        g.writeEmbeddedObject(WIKIPEDIA_BASE64_AS_BYTES); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.core.JsonGenerationException: No native support for writing embedded objects\n\tcom.fasterxml.jackson.core.JsonGenerator.writeEmbeddedObject(JsonGenerator.java:1330)\n\tcom.fasterxml.jackson.core.base64.Base64GenerationTest.testBinaryAsEmbeddedObject(Base64GenerationTest.java:100)", "buggy_method": "1328 public void writeEmbeddedObject(Object object) throws IOException {\n1329         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n1330         throw new JsonGenerationException(\"No native support for writing embedded objects\",\n1331                 this);\n1332     }", "bm_classpath": "com.fasterxml.jackson.core.JsonGenerator"}, {"bug_name": "JacksonCore_21", "report_text": "> FilteringParserDelegate seems to miss last closing END_OBJECT\n> \n> (note: adding a failing test for this case)\n> Looks like with settings like:\n> ```\n>         JsonParser p = new FilteringParserDelegate(p0,\n>                new NameMatchFilter(\"value\"),\n>                    true, // includePath\n>                    false // multipleMatches\n>                 );\n> ```\n> and input\n> ```\n> {\n>   \"a\":123,\n>   \"array\":[1,2],\n>   \"ob\": {\n>     \"value0\":2,\n>     \"value\":3,\n>     \"value2\":4\n>   },\n>   \"b\":true\n> }\n> ```\n> output will be like:\n> ```\n> {\"ob\":{\"value\":3}\n> ```\n> (note the missing trailing `}` for closing `END_OBJECT`)", "test_name": "com.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test::testTokensSingleMatchWithPath", "test_method": "    @SuppressWarnings(\"resource\")\n    public void testTokensSingleMatchWithPath() throws Exception\n    {\n        JsonParser p0 = JSON_F.createParser(SIMPLE);\n        JsonParser p = new FilteringParserDelegate(p0,\n               new NameMatchFilter(\"value\"),\n                   true, // includePath\n                   false // multipleMatches\n                );\n\n        \n// {'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\n//      String result = readAndWrite(JSON_F, p);\n//      assertEquals(aposToQuotes(\"{'ob':{'value':3}}\"), result);\n\n\n//        assertEquals(\"ob\", p.getText());\n\n\n\n\n\n        assertToken(JsonToken.END_OBJECT, p.nextToken()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected token END_OBJECT, current token null\n\tcom.fasterxml.jackson.core.BaseTest.assertToken(BaseTest.java:448)\n\tcom.fasterxml.jackson.core.filter.TokenVerifyingParserFiltering330Test.testTokensSingleMatchWithPath(TokenVerifyingParserFiltering330Test.java:111)", "buggy_method": "226 @Override\n227     public JsonToken nextToken() throws IOException\n228     {\n229         // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n230         //    conditionals; and it seems odd to return `null` but NOT considering input\n231         //    as closed... would love a rewrite to simplify/clear up logic here.\n232         \n233         // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n234         // check for no buffered context _exposedContext - null\n235         // If all the conditions matches then check for scalar / non-scalar property\n236         if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n237             //if not scalar and ended successfully, and !includePath, then return null\n238                 if (_currToken.isStructEnd()) {\n239                     if (_headContext.isStartHandled()) {\n240                         return (_currToken = null);\n241                     }\n242                 } else if (_currToken.isScalarValue()) {\n243                     //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n244                     // then return null \n245                     if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n246                         return (_currToken = null);\n247                     }\n248             }\n249         }\n250         // Anything buffered?\n251         TokenFilterContext ctxt = _exposedContext;\n252 \n253         if (ctxt != null) {\n254             while (true) {\n255                 JsonToken t = ctxt.nextTokenToRead();\n256                 if (t != null) {\n257                     _currToken = t;\n258                     return t;\n259                 }\n260                 // all done with buffered stuff?\n261                 if (ctxt == _headContext) {\n262                     _exposedContext = null;\n263                     if (ctxt.inArray()) {\n264                         t = delegate.getCurrentToken();\n265 // Is this guaranteed to work without further checks?\n266 //                        if (t != JsonToken.START_ARRAY) {\n267                         _currToken = t;\n268                         return t;\n269                     }\n270 \n271                     // Almost! Most likely still have the current token;\n272                     // with the sole exception of \n273                     /*\n274                     t = delegate.getCurrentToken();\n275                     if (t != JsonToken.FIELD_NAME) {\n276                         _currToken = t;\n277                         return t;\n278                     }\n279                     */\n280                     break;\n281                 }\n282                 // If not, traverse down the context chain\n283                 ctxt = _headContext.findChildOf(ctxt);\n284                 _exposedContext = ctxt;\n285                 if (ctxt == null) { // should never occur\n286                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n287                 }\n288             }\n289         }\n290 \n291         // If not, need to read more. If we got any:\n292         JsonToken t = delegate.nextToken();\n293         if (t == null) {\n294             // no strict need to close, since we have no state here\n295             _currToken = t;\n296             return t;\n297         }\n298 \n299         // otherwise... to include or not?\n300         TokenFilter f;\n301         \n302         switch (t.id()) {\n303         case ID_START_ARRAY:\n304             f = _itemFilter;\n305             if (f == TokenFilter.INCLUDE_ALL) {\n306                 _headContext = _headContext.createChildArrayContext(f, true);\n307                 return (_currToken = t);\n308             }\n309             if (f == null) { // does this occur?\n310                 delegate.skipChildren();\n311                 break;\n312             }\n313             // Otherwise still iffy, need to check\n314             f = _headContext.checkValue(f);\n315             if (f == null) {\n316                 delegate.skipChildren();\n317                 break;\n318             }\n319             if (f != TokenFilter.INCLUDE_ALL) {\n320                 f = f.filterStartArray();\n321             }\n322             _itemFilter = f;\n323             if (f == TokenFilter.INCLUDE_ALL) {\n324                 _headContext = _headContext.createChildArrayContext(f, true);\n325                 return (_currToken = t);\n326             }\n327             _headContext = _headContext.createChildArrayContext(f, false);\n328             \n329             // Also: only need buffering if parent path to be included\n330             if (_includePath) {\n331                 t = _nextTokenWithBuffering(_headContext);\n332                 if (t != null) {\n333                     _currToken = t;\n334                     return t;\n335                 }\n336             }\n337             break;\n338 \n339         case ID_START_OBJECT:\n340             f = _itemFilter;\n341             if (f == TokenFilter.INCLUDE_ALL) {\n342                 _headContext = _headContext.createChildObjectContext(f, true);\n343                 return (_currToken = t);\n344             }\n345             if (f == null) { // does this occur?\n346                 delegate.skipChildren();\n347                 break;\n348             }\n349             // Otherwise still iffy, need to check\n350             f = _headContext.checkValue(f);\n351             if (f == null) {\n352                 delegate.skipChildren();\n353                 break;\n354             }\n355             if (f != TokenFilter.INCLUDE_ALL) {\n356                 f = f.filterStartObject();\n357             }\n358             _itemFilter = f;\n359             if (f == TokenFilter.INCLUDE_ALL) {\n360                 _headContext = _headContext.createChildObjectContext(f, true);\n361                 return (_currToken = t);\n362             }\n363             _headContext = _headContext.createChildObjectContext(f, false);\n364             // Also: only need buffering if parent path to be included\n365             if (_includePath) {\n366                 t = _nextTokenWithBuffering(_headContext);\n367                 if (t != null) {\n368                     _currToken = t;\n369                     return t;\n370                 }\n371             }\n372             // note: inclusion of surrounding Object handled separately via\n373             // FIELD_NAME\n374             break;\n375 \n376         case ID_END_ARRAY:\n377         case ID_END_OBJECT:\n378             {\n379                 boolean returnEnd = _headContext.isStartHandled();\n380                 f = _headContext.getFilter();\n381                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n382                     f.filterFinishArray();\n383                 }\n384                 _headContext = _headContext.getParent();\n385                 _itemFilter = _headContext.getFilter();\n386                 if (returnEnd) {\n387                     return (_currToken = t);\n388                 }\n389             }\n390             break;\n391 \n392         case ID_FIELD_NAME:\n393             {\n394                 final String name = delegate.getCurrentName();\n395                 // note: this will also set 'needToHandleName'\n396                 f = _headContext.setFieldName(name);\n397                 if (f == TokenFilter.INCLUDE_ALL) {\n398                     _itemFilter = f;\n399                     if (!_includePath) {\n400                         // Minor twist here: if parent NOT included, may need to induce output of\n401                         // surrounding START_OBJECT/END_OBJECT\n402                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n403                             t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n404                             _exposedContext = _headContext;\n405                         }\n406                     }\n407                     return (_currToken = t);\n408                 }\n409                 if (f == null) {\n410                     delegate.nextToken();\n411                     delegate.skipChildren();\n412                     break;\n413                 }\n414                 f = f.includeProperty(name);\n415                 if (f == null) {\n416                     delegate.nextToken();\n417                     delegate.skipChildren();\n418                     break;\n419                 }\n420                 _itemFilter = f;\n421                 if (f == TokenFilter.INCLUDE_ALL) {\n422                     if (_includePath) {\n423                         return (_currToken = t);\n424                     }\n425                 }\n426                 if (_includePath) {\n427                     t = _nextTokenWithBuffering(_headContext);\n428                     if (t != null) {\n429                         _currToken = t;\n430                         return t;\n431                     }\n432                 }\n433                 break;\n434             }\n435 \n436         default: // scalar value\n437             f = _itemFilter;\n438             if (f == TokenFilter.INCLUDE_ALL) {\n439                 return (_currToken = t);\n440             }\n441             if (f != null) {\n442                 f = _headContext.checkValue(f);\n443                 if ((f == TokenFilter.INCLUDE_ALL)\n444                         || ((f != null) && f.includeValue(delegate))) {\n445                     return (_currToken = t);\n446                 }\n447             }\n448             // Otherwise not included (leaves must be explicitly included)\n449             break;\n450         }\n451 \n452         // We get here if token was not yet found; offlined handling\n453         return _nextToken2();\n454     }", "bm_classpath": "com.fasterxml.jackson.core.filter.FilteringParserDelegate"}, {"bug_name": "JacksonCore_22", "report_text": "> Make use of _matchCount in FilteringParserDelegate\n> \n> Currently, it looks like that the \\_matchCount attribute in FilteringGeneratorDelegate is not utilised (i.e. no value is assigned to this variable). Re. the documentation this attribute offers some useful functionality. So it would be nice, if it could be implemented properly. See <https://groups.google.com/d/msg/jackson-user/VzZ94G9hvrs/JGFozl6lCQAJ>", "test_name": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest::testSingleMatchFilteringWithPath", "test_method": "    public void testSingleMatchFilteringWithPath() throws Exception\n    {\n        String jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'b':true}\");\n        JsonParser p0 = JSON_F.createParser(jsonString);\n        FilteringParserDelegate p = new FilteringParserDelegate(p0,\n                new NameMatchFilter(\"a\"),\n                true, // includePath\n                false // multipleMatches\n        );\n        String result = readAndWrite(JSON_F, p);\n        assertEquals(1, p.getMatchCount()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\tcom.fasterxml.jackson.core.filter.BasicParserFilteringTest.testSingleMatchFilteringWithPath(BasicParserFilteringTest.java:105)", "buggy_method": "226 @Override\n227     public JsonToken nextToken() throws IOException\n228     {\n229         // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all\n230         //    conditionals; and it seems odd to return `null` but NOT considering input\n231         //    as closed... would love a rewrite to simplify/clear up logic here.\n232         \n233         // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken\n234         // check for no buffered context _exposedContext - null\n235         // If all the conditions matches then check for scalar / non-scalar property\n236 \n237         if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {\n238             // if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL\n239             // matched once, return null\n240             if (_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath\n241                     && (_itemFilter == TokenFilter.INCLUDE_ALL)) {\n242                 return (_currToken = null);\n243             }\n244         }\n245         // Anything buffered?\n246         TokenFilterContext ctxt = _exposedContext;\n247 \n248         if (ctxt != null) {\n249             while (true) {\n250                 JsonToken t = ctxt.nextTokenToRead();\n251                 if (t != null) {\n252                     _currToken = t;\n253                     return t;\n254                 }\n255                 // all done with buffered stuff?\n256                 if (ctxt == _headContext) {\n257                     _exposedContext = null;\n258                     if (ctxt.inArray()) {\n259                         t = delegate.getCurrentToken();\n260 // Is this guaranteed to work without further checks?\n261 //                        if (t != JsonToken.START_ARRAY) {\n262                         _currToken = t;\n263                         return t;\n264                     }\n265 \n266                     // Almost! Most likely still have the current token;\n267                     // with the sole exception of \n268                     /*\n269                     t = delegate.getCurrentToken();\n270                     if (t != JsonToken.FIELD_NAME) {\n271                         _currToken = t;\n272                         return t;\n273                     }\n274                     */\n275                     break;\n276                 }\n277                 // If not, traverse down the context chain\n278                 ctxt = _headContext.findChildOf(ctxt);\n279                 _exposedContext = ctxt;\n280                 if (ctxt == null) { // should never occur\n281                     throw _constructError(\"Unexpected problem: chain of filtered context broken\");\n282                 }\n283             }\n284         }\n285 \n286         // If not, need to read more. If we got any:\n287         JsonToken t = delegate.nextToken();\n288         if (t == null) {\n289             // no strict need to close, since we have no state here\n290             _currToken = t;\n291             return t;\n292         }\n293 \n294         // otherwise... to include or not?\n295         TokenFilter f;\n296         \n297         switch (t.id()) {\n298         case ID_START_ARRAY:\n299             f = _itemFilter;\n300             if (f == TokenFilter.INCLUDE_ALL) {\n301                 _headContext = _headContext.createChildArrayContext(f, true);\n302                 return (_currToken = t);\n303             }\n304             if (f == null) { // does this occur?\n305                 delegate.skipChildren();\n306                 break;\n307             }\n308             // Otherwise still iffy, need to check\n309             f = _headContext.checkValue(f);\n310             if (f == null) {\n311                 delegate.skipChildren();\n312                 break;\n313             }\n314             if (f != TokenFilter.INCLUDE_ALL) {\n315                 f = f.filterStartArray();\n316             }\n317             _itemFilter = f;\n318             if (f == TokenFilter.INCLUDE_ALL) {\n319                 _headContext = _headContext.createChildArrayContext(f, true);\n320                 return (_currToken = t);\n321             }\n322             _headContext = _headContext.createChildArrayContext(f, false);\n323             \n324             // Also: only need buffering if parent path to be included\n325             if (_includePath) {\n326                 t = _nextTokenWithBuffering(_headContext);\n327                 if (t != null) {\n328                     _currToken = t;\n329                     return t;\n330                 }\n331             }\n332             break;\n333 \n334         case ID_START_OBJECT:\n335             f = _itemFilter;\n336             if (f == TokenFilter.INCLUDE_ALL) {\n337                 _headContext = _headContext.createChildObjectContext(f, true);\n338                 return (_currToken = t);\n339             }\n340             if (f == null) { // does this occur?\n341                 delegate.skipChildren();\n342                 break;\n343             }\n344             // Otherwise still iffy, need to check\n345             f = _headContext.checkValue(f);\n346             if (f == null) {\n347                 delegate.skipChildren();\n348                 break;\n349             }\n350             if (f != TokenFilter.INCLUDE_ALL) {\n351                 f = f.filterStartObject();\n352             }\n353             _itemFilter = f;\n354             if (f == TokenFilter.INCLUDE_ALL) {\n355                 _headContext = _headContext.createChildObjectContext(f, true);\n356                 return (_currToken = t);\n357             }\n358             _headContext = _headContext.createChildObjectContext(f, false);\n359             // Also: only need buffering if parent path to be included\n360             if (_includePath) {\n361                 t = _nextTokenWithBuffering(_headContext);\n362                 if (t != null) {\n363                     _currToken = t;\n364                     return t;\n365                 }\n366             }\n367             // note: inclusion of surrounding Object handled separately via\n368             // FIELD_NAME\n369             break;\n370 \n371         case ID_END_ARRAY:\n372         case ID_END_OBJECT:\n373             {\n374                 boolean returnEnd = _headContext.isStartHandled();\n375                 f = _headContext.getFilter();\n376                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n377                     f.filterFinishArray();\n378                 }\n379                 _headContext = _headContext.getParent();\n380                 _itemFilter = _headContext.getFilter();\n381                 if (returnEnd) {\n382                     return (_currToken = t);\n383                 }\n384             }\n385             break;\n386 \n387         case ID_FIELD_NAME:\n388             {\n389                 final String name = delegate.getCurrentName();\n390                 // note: this will also set 'needToHandleName'\n391                 f = _headContext.setFieldName(name);\n392                 if (f == TokenFilter.INCLUDE_ALL) {\n393                     _itemFilter = f;\n394                     if (!_includePath) {\n395                         // Minor twist here: if parent NOT included, may need to induce output of\n396                         // surrounding START_OBJECT/END_OBJECT\n397                         if (_includeImmediateParent && !_headContext.isStartHandled()) {\n398                             t = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n399                             _exposedContext = _headContext;\n400                         }\n401                     }\n402                     return (_currToken = t);\n403                 }\n404                 if (f == null) {\n405                     delegate.nextToken();\n406                     delegate.skipChildren();\n407                     break;\n408                 }\n409                 f = f.includeProperty(name);\n410                 if (f == null) {\n411                     delegate.nextToken();\n412                     delegate.skipChildren();\n413                     break;\n414                 }\n415                 _itemFilter = f;\n416                 if (f == TokenFilter.INCLUDE_ALL) {\n417                     if (_includePath) {\n418                         return (_currToken = t);\n419                     }\n420                 }\n421                 if (_includePath) {\n422                     t = _nextTokenWithBuffering(_headContext);\n423                     if (t != null) {\n424                         _currToken = t;\n425                         return t;\n426                     }\n427                 }\n428                 break;\n429             }\n430 \n431         default: // scalar value\n432             f = _itemFilter;\n433             if (f == TokenFilter.INCLUDE_ALL) {\n434                 return (_currToken = t);\n435             }\n436             if (f != null) {\n437                 f = _headContext.checkValue(f);\n438                 if ((f == TokenFilter.INCLUDE_ALL)\n439                         || ((f != null) && f.includeValue(delegate))) {\n440                         return (_currToken = t);\n441                 }\n442             }\n443             // Otherwise not included (leaves must be explicitly included)\n444             break;\n445         }\n446 \n447         // We get here if token was not yet found; offlined handling\n448         return _nextToken2();\n449     }", "bm_classpath": "com.fasterxml.jackson.core.filter.FilteringParserDelegate"}, {"bug_name": "JacksonCore_23", "report_text": "> Make DefaultPrettyPrinter.createInstance() to fail for sub-classes\n> \n> Pattern of \"blueprint object\" (that is, having an instance not used as-is, but that has factory method for creating actual instance) is used by Jackson in couple of places; often for things that implement `Instantiatable`. But one problem is that unless method is left abstract, sub-classing can be problematic -- if sub-class does not override method, then calls will result in an instance of wrong type being created.\n> And this is what can easily happen with `DefaultPrettyPrinter`.\n> A simple solution is for base class to make explicit that if base implementation is called, then instance can not be a sub-class (that is, it is only legal to call on `DefaultPrettyPrinter`, but no sub-class). This is not optimal (ideally check would be done compile-time), but better than getting a mysterious failure.", "test_name": "com.fasterxml.jackson.core.util.TestDefaultPrettyPrinter::testInvalidSubClass", "test_method": "    public void testInvalidSubClass() throws Exception\n    {\n        DefaultPrettyPrinter pp = new MyPrettyPrinter();\n        try {\n            pp.createInstance();\n            fail(\"Should not pass\");\n        } catch (IllegalStateException e) {\n            verifyException(e, \"does not override\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should not pass\n\tcom.fasterxml.jackson.core.util.TestDefaultPrettyPrinter.testInvalidSubClass(TestDefaultPrettyPrinter.java:169)", "buggy_method": "253 @Override\n254     public DefaultPrettyPrinter createInstance() {\n255         return new DefaultPrettyPrinter(this);\n256     }", "bm_classpath": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter"}, {"bug_name": "JacksonCore_24", "report_text": "> Add new exception type InputCoercionException to be used for failed coercions like overflow for int\n> \n> Currently problems like overflow for numeric type (when JSON number value exceeds range of requested target type like `int`) simply use `JsonParseException` to indicate the problem (both at streaming and databind level).\n> But it would be better if we could use more targeted exception, to let calling application potentially handle problems differently. We can also add some metadata about type of failure, such as initial token type and expected target type.  \n> It is also true that coercion failures -- where we start from valid JSON value, but fail to convert into desired target type -- are not parse (decode) problems at all, but rather mismatch problems.\n> So let's add something like `InputCoercionException`, which extends `JsonProcessingException`, but not `JsonParseException`.\n> With 3.x we may want to tackle other problems: for example, lack of context for \"lower level\" `JsonProcessingException`s (compared to `JsonMappingException`)", "test_name": "com.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest::testToLongFailing", "test_method": "    public void testToLongFailing() throws Exception\n    {\n        AsyncReaderWrapper p;\n\n        // BigInteger -> error\n        BigInteger big = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.TEN);\n        p = createParser(String.valueOf(big));\n        try {\n            p.getLongValue();\n            fail(\"Should not pass\");\n        } catch (InputCoercionException e) {\n            verifyException(e, \"out of range of long\");\n            assertEquals(JsonToken.VALUE_NUMBER_INT, e.getInputType());\n            assertEquals(Long.TYPE, e.getTargetType());\n        } // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.core.JsonParseException: Numeric value (9223372036854775817) out of range of long (-9223372036854775808 - 9223372036854775807)\n\tcom.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:1833)\n\tcom.fasterxml.jackson.core.base.ParserMinimalBase._reportError(ParserMinimalBase.java:704)\n\tcom.fasterxml.jackson.core.base.ParserMinimalBase.reportOverflowLong(ParserMinimalBase.java:582)\n\tcom.fasterxml.jackson.core.base.ParserMinimalBase.reportOverflowLong(ParserMinimalBase.java:577)\n\tcom.fasterxml.jackson.core.base.ParserBase.convertNumberToLong(ParserBase.java:921)\n\tcom.fasterxml.jackson.core.base.ParserBase.getLongValue(ParserBase.java:663)\n\tcom.fasterxml.jackson.core.testsupport.AsyncReaderWrapper.getLongValue(AsyncReaderWrapper.java:57)\n\tcom.fasterxml.jackson.core.json.async.AsyncNumberCoercionTest.testToLongFailing(AsyncNumberCoercionTest.java:189)", "buggy_method": "867 protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n868     {\n869         final String numDesc = _longIntegerDesc(rawNum);\n870         _reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n871                 (expType == NR_LONG) ? \"long\" : \"int\");\n872     }", "bm_classpath": "com.fasterxml.jackson.core.base.ParserBase"}, {"bug_name": "JacksonCore_25", "report_text": "> Fix ArrayIndexOutofBoundsException found by LGTM.com\n> \n> First of all, thank you for reporting this.\n> But would it be possible to write a test that shows how this actually works? It would be great to have a regression test, to guard against this happening in future.", "test_name": "com.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest::testUnquotedIssue510", "test_method": "    public void testUnquotedIssue510() throws Exception\n    {\n        // NOTE! Requires longer input buffer to trigger longer codepath\n        char[] fullChars = new char[4001];\n        for (int i = 0; i < 3998; i++) {\n             fullChars[i] = ' ';\n        }\n        fullChars[3998] = '{';\n        fullChars[3999] = 'a';\n        fullChars[4000] = 256;\n\n        JsonParser p = UNQUOTED_FIELDS_F.createParser(new java.io.StringReader(new String(fullChars)));\n        try {\n            p.nextToken();\n            fail(\"Should not pass\");\n        } catch (JsonParseException e) {\n            ; // should fail here\n        } // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 256\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddName2(ReaderBasedJsonParser.java:1964)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._handleOddName(ReaderBasedJsonParser.java:1807)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:692)\n\tcom.fasterxml.jackson.core.read.NonStandardUnquotedNamesTest.testUnquotedIssue510(NonStandardUnquotedNamesTest.java:49)", "buggy_method": "1948 private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n1949     {\n1950         _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n1951         char[] outBuf = _textBuffer.getCurrentSegment();\n1952         int outPtr = _textBuffer.getCurrentSegmentSize();\n1953         final int maxCode = codes.length;\n1954 \n1955         while (true) {\n1956             if (_inputPtr >= _inputEnd) {\n1957                 if (!_loadMore()) { // acceptable for now (will error out later)\n1958                     break;\n1959                 }\n1960             }\n1961             char c = _inputBuffer[_inputPtr];\n1962             int i = (int) c;\n1963             if (i <= maxCode) {\n1964                 if (codes[i] != 0) {\n1965                     break;\n1966                 }\n1967             } else if (!Character.isJavaIdentifierPart(c)) {\n1968                 break;\n1969             }\n1970             ++_inputPtr;\n1971             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n1972             // Ok, let's add char to output:\n1973             outBuf[outPtr++] = c;\n1974 \n1975             // Need more room?\n1976             if (outPtr >= outBuf.length) {\n1977                 outBuf = _textBuffer.finishCurrentSegment();\n1978                 outPtr = 0;\n1979             }\n1980         }\n1981         _textBuffer.setCurrentLength(outPtr);\n1982         {\n1983             TextBuffer tb = _textBuffer;\n1984             char[] buf = tb.getTextBuffer();\n1985             int start = tb.getTextOffset();\n1986             int len = tb.size();\n1987 \n1988             return _symbols.findSymbol(buf, start, len, hash);\n1989         }\n1990     }", "bm_classpath": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser"}, {"bug_name": "JacksonCore_26", "report_text": "> Non-blocking parser reports incorrect locations when fed with non-zero offset\n> \n> When feeding a non-blocking parser, the input array offset leaks into the offsets reported by `getCurrentLocation()` and `getTokenLocation()`.\n> For example, feeding with an offset of 7 yields tokens whose reported locations are 7 greater than they should be. Likewise the current location reported by the parser is 7 greater than the correct location.\n> It's not possible for a user to work around this issue by subtracting 7 from the reported locations, because the token location may have been established by an earlier feeding with a different offset.\n> Jackson version: 2.9.8\n> Unit test:\n> ```\n> import com.fasterxml.jackson.core.JsonFactory;\n> import com.fasterxml.jackson.core.JsonParser;\n> import com.fasterxml.jackson.core.JsonToken;\n> import com.fasterxml.jackson.core.async.ByteArrayFeeder;\n> import org.junit.Test;\n> import static java.nio.charset.StandardCharsets.UTF\\_8;\n> import static org.junit.Assert.assertEquals;\n> public class FeedingOffsetTest {\n>   @Test\n>   public void inputOffsetShouldNotAffectLocations() throws Exception {\n>     JsonFactory jsonFactory = new JsonFactory();\n>     JsonParser parser = jsonFactory.createNonBlockingByteArrayParser();\n>     ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n>     byte[] input = \"[[[\".getBytes(UTF\\_8);\n>     feeder.feedInput(input, 2, 3);\n>     assertEquals(JsonToken.START\\_ARRAY, parser.nextToken());\n>     assertEquals(1, parser.getCurrentLocation().getByteOffset()); // ACTUAL = 3\n>     assertEquals(1, parser.getTokenLocation().getByteOffset());   // ACTUAL = 3\n>     feeder.feedInput(input, 0, 1);\n>     assertEquals(JsonToken.START\\_ARRAY, parser.nextToken());\n>     assertEquals(2, parser.getCurrentLocation().getByteOffset());\n>     assertEquals(2, parser.getTokenLocation().getByteOffset());\n>   }\n> }\n> ```", "test_name": "com.fasterxml.jackson.core.json.async.AsyncLocationTest::testLocationOffsets", "test_method": "    public void testLocationOffsets() throws Exception\n    {\n        JsonParser parser = DEFAULT_F.createNonBlockingByteArrayParser();\n        ByteArrayFeeder feeder = (ByteArrayFeeder) parser.getNonBlockingInputFeeder();\n\n        byte[] input = utf8Bytes(\"[[[\");\n\n        feeder.feedInput(input, 2, 3);\n        assertEquals(1, parser.getCurrentLocation().getByteOffset()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<3>\n\tcom.fasterxml.jackson.core.json.async.AsyncLocationTest.testLocationOffsets(AsyncLocationTest.java:21)", "buggy_method": "87 @Override\n88     public void feedInput(byte[] buf, int start, int end) throws IOException\n89     {\n90         // Must not have remaining input\n91         if (_inputPtr < _inputEnd) {\n92             _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n93         }\n94         if (end < start) {\n95             _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n96         }\n97         // and shouldn't have been marked as end-of-input\n98         if (_endOfInput) {\n99             _reportError(\"Already closed, can not feed more input\");\n100         }\n101         // Time to update pointers first\n102         _currInputProcessed += _origBufferLen;\n103 \n104         // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n105         _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n106 \n107         // And then update buffer settings\n108         _inputBuffer = buf;\n109         _inputPtr = start;\n110         _inputEnd = end;\n111         _origBufferLen = end - start;\n112     }", "bm_classpath": "com.fasterxml.jackson.core.json.async.NonBlockingJsonParser"}, {"bug_name": "JacksonDatabind_1", "report_text": "> NULL values are duplicated when serializing as array [via @JsonFormat(shape = JsonFormat.Shape.ARRAY)]\n> \n> Example:\n> ```\n> public class TestOuter {\n>     @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n>     public ArrayList<TestInner> array;\n>     public TestOuter() {\n>         this.array = new ArrayList<TestInner>();\n>         this.array.add(new TestInner(1, \"one\"));\n>         this.array.add(new TestInner(0, null));\n>     }\n>     private class TestInner {\n>         public int i;\n>         public String mayBeNull;\n>         public TestInner(int i, String s) {\n>             this.i = i;\n>             this.mayBeNull = s;\n>         }\n>     }\n> }\n> ```\n> Serializing an instance of TestOuter will produce the following incorrect result (as of Jackson 2.2.1):\n> ```\n> \"array\": [[1, \"one\"], [0, null, null]]\n> ```\n> where the null value is duplicated. The expected result would be:\n> ```\n> \"array\": [[1, \"one\"], [0, null]]\n> ```\n> I tracked the issue down to:\n> ```\n> package com.fasterxml.jackson.databind.ser;\n> // ...\n> public class BeanPropertyWriter {\n> // ...\n>     public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n>         throws Exception\n>     {\n>         Object value = get(bean);\n>         if (value == null) { // nulls need specialized handling\n>             if (\\_nullSerializer != null) {\n>                 \\_nullSerializer.serialize(null, jgen, prov);\n>             } else { // can NOT suppress entries in tabular output\n>                 jgen.writeNull();\n>             }\n>         }\n>         // otherwise find serializer to use\n>         JsonSerializer<Object> ser = \\_serializer;\n>     // ... ...\n> ```\n> where I suspect there is a missing \"return\", to exit the function once handling of the null value in the dedicated branch is done.  \n> As it is now, a null value is first serialized in the dedicated branch (jgen.writeNull()), and then execution continues on the \"normal\" (non-null) path and eventually the value is serialized once again.", "test_name": "com.fasterxml.jackson.databind.struct.TestPOJOAsArray::testNullColumn", "test_method": "    public void testNullColumn() throws Exception\n    {\n        assertEquals(\"[null,\\\"bar\\\"]\", MAPPER.writeValueAsString(new TwoStringsBean())); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[null,[]\"bar\"]> but was:<[null,[null,]\"bar\"]>\n\tcom.fasterxml.jackson.databind.struct.TestPOJOAsArray.testNullColumn(TestPOJOAsArray.java:151)", "buggy_method": "582 public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n583         throws Exception\n584     {\n585         Object value = get(bean);\n586         if (value == null) { // nulls need specialized handling\n587             if (_nullSerializer != null) {\n588                 _nullSerializer.serialize(null, jgen, prov);\n589             } else { // can NOT suppress entries in tabular output\n590                 jgen.writeNull();\n591             }\n592         }\n593         // otherwise find serializer to use\n594         JsonSerializer<Object> ser = _serializer;\n595         if (ser == null) {\n596             Class<?> cls = value.getClass();\n597             PropertySerializerMap map = _dynamicSerializers;\n598             ser = map.serializerFor(cls);\n599             if (ser == null) {\n600                 ser = _findAndAddDynamic(map, cls, prov);\n601             }\n602         }\n603         // and then see if we must suppress certain values (default, empty)\n604         if (_suppressableValue != null) {\n605             if (MARKER_FOR_EMPTY == _suppressableValue) {\n606                 if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n607                     serializeAsPlaceholder(bean, jgen, prov);\n608                     return;\n609                 }\n610             } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n611                 serializeAsPlaceholder(bean, jgen, prov);\n612                 return;\n613             }\n614         }\n615         // For non-nulls: simple check for direct cycles\n616         if (value == bean) {\n617             _handleSelfReference(bean, ser);\n618         }\n619         if (_typeSerializer == null) {\n620             ser.serialize(value, jgen, prov);\n621         } else {\n622             ser.serializeWithType(value, jgen, prov, _typeSerializer);\n623         }\n624     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.BeanPropertyWriter"}, {"bug_name": "JacksonDatabind_2", "report_text": "> Unwanted POJO's embedded in tree via serialization to tree\n> \n> I have a class, more or less:\n> ```\n>    class X<T> {\n>        String s;\n>        List<T> items;\n>   };\n> ```\n> It has a custom serializer.\n> When I serialize to a tree, the entire list ends up as a  \n> VALUE\\_EMBEDDED\\_OBJECT: the ArrayList itself.\n> Here's the serializer class, note the use of writeObjectField.\n> ```\n> public class ListAttributeSerializer extends JsonSerializer<ListAttribute> {\n>     @Override\n>     public void serialize(ListAttribute value, JsonGenerator jgen,\n> SerializerProvider provider) throws IOException {\n>         jgen.writeStartObject();\n>         jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n>         jgen.writeObjectField(\"items\", value.getItems());\n>         jgen.writeEndObject();\n>     }\n>     @Override\n>     public void serializeWithType(ListAttribute value, JsonGenerator\n> jgen, SerializerProvider provider, TypeSerializer typeSer) throws\n> IOException {\n>         typeSer.writeTypePrefixForObject(value, jgen);\n>         jgen.writeStringField(\"itemType\", value.getItemJsonKey());\n>         jgen.writeObjectField(\"items\", value.getItems());\n>         typeSer.writeTypeSuffixForObject(value, jgen);\n> }\n> }\n> ```\n> And Tatu wrote me:\n> Ok. valueToTree() uses TokenBuffer as target, so it probably then simply retains Object passed as-is, to defer conversion/serialization, for common use case of buffering. But in your case you would rather get actual serialization into JsonNodes.\n> You will probably want to write conversion out then, something like:\n> byte[] json = mapper.writeValueAsBytes(referenceText);  \n> JsonNode tree = mapper.readTree(json);\n> This is just the work-around on short term.  \n> But this is one thing where configurability might be needed; or possibly different methods. One that forces full serialization into JSON with no POJONodes, other that leaves things as is.", "test_name": "com.fasterxml.jackson.databind.node.TestConversions::testConversionOfPojos", "test_method": "    public void testConversionOfPojos() throws Exception\n    {\n        final Issue467Bean input = new Issue467Bean(13);\n        final String EXP = \"{\\\"x\\\":13}\";\n        \n        // first, sanity check\n        String json = MAPPER.writeValueAsString(input);\n\n        // then via conversions: should become JSON Object\n        JsonNode tree = MAPPER.valueToTree(input);\n        assertTrue(\"Expected Object, got \"+tree.getNodeType(), tree.isObject()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected Object, got POJO\n\tcom.fasterxml.jackson.databind.node.TestConversions.testConversionOfPojos(TestConversions.java:263)", "buggy_method": "780 @Override\n781     public void writeObject(Object value) throws IOException\n782     {\n783             _append(JsonToken.VALUE_EMBEDDED_OBJECT, value);\n784             /* 28-May-2014, tatu: Tricky choice here; if no codec, should we\n785              *   err out, or just embed? For now, do latter.\n786              */\n787 //          throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\");\n788     }", "bm_classpath": "com.fasterxml.jackson.databind.util.TokenBuffer"}, {"bug_name": "JacksonDatabind_3", "report_text": "> Regression updating from 2.3.3 to 2.4.0: null won't deserialize in String[]\n> \n> Steps to reproduce\n> 1. Clone the repository at <https://github.com/huxi/sulky>\n> 2. Execute the contained `./gradlew` or `gradlew.bat`\n> 3. Clone the repository at <https://github.com/huxi/lilith/>\n> 4. Change jackson-version [in the project.ext.versions map of dependencyDefinitions.gradle](https://github.com/huxi/lilith/blob/master/dependencyDefinitions.gradle#L6) from `'2.3.3'` to `'2.4.0'`.\n> 5. Execute the contained `./gradlew` or `gradlew.bat`\n> There will be six test-failures with 2.4.0 that won't happen with 2.3.3.\n> There are actually only 2 test-methods that fail 3 times each.\n> Those methods reside at [full()](https://github.com/huxi/lilith/blob/master/lilith-data/logging-io-test/src/main/java/de/huxhorn/lilith/data/logging/test/LoggingEventIOTestBase.java#L230) and [nullArgument()](https://github.com/huxi/lilith/blob/master/lilith-data/logging-io-test/src/main/java/de/huxhorn/lilith/data/logging/test/LoggingEventIOTestBase.java#L120).\n> I first suspected that `AfterburnerModule` might be the culprit but removing it from `LoggingJsonDecoder`/`LoggingJsonEncoder` didn't fix the problem.\n> Sorry for not narrowing down the problem further. I'll give this another look tomorrow but you may already be able to find the issue in the meantime.\n> The interesting thing is that several other test cases are working as intended...", "test_name": "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testStringArray", "test_method": "    public void testStringArray() throws Exception\n    {\n        final String[] STRS = new String[] {\n            \"a\", \"b\", \"abcd\", \"\", \"???\", \"\\\"quoted\\\"\", \"lf: \\n\",\n        };\n        StringWriter sw = new StringWriter();\n        JsonGenerator jg = MAPPER.getFactory().createGenerator(sw);\n        jg.writeStartArray();\n        for (String str : STRS) {\n            jg.writeString(str);\n        }\n        jg.writeEndArray();\n        jg.close();\n\n        String[] result = MAPPER.readValue(sw.toString(), String[].class);\n\n        for (int i = 0; i < STRS.length; ++i) {\n            assertEquals(STRS[i], result[i]);\n        }\n\n        // [#479]: null handling was busted in 2.4.0\n        result = MAPPER.readValue(\" [ null ]\", String[].class); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.fasterxml.jackson.databind.deser.std.StringArrayDeserializer.deserialize(StringArrayDeserializer.java:66)\n\tcom.fasterxml.jackson.databind.deser.std.StringArrayDeserializer.deserialize(StringArrayDeserializer.java:18)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3051)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2146)\n\tcom.fasterxml.jackson.databind.deser.TestArrayDeserialization.testStringArray(TestArrayDeserialization.java:266)", "buggy_method": "43 @Override\n44     public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n45     {\n46         // Ok: must point to START_ARRAY (or equivalent)\n47         if (!jp.isExpectedStartArrayToken()) {\n48             return handleNonArray(jp, ctxt);\n49         }\n50         if (_elementDeserializer != null) {\n51             return _deserializeCustom(jp, ctxt);\n52         }\n53 \n54         final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n55         Object[] chunk = buffer.resetAndStart();\n56         \n57         int ix = 0;\n58         JsonToken t;\n59         \n60         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n61             // Ok: no need to convert Strings, but must recognize nulls\n62             String value;\n63             if (t == JsonToken.VALUE_STRING) {\n64                 value = jp.getText();\n65             } else if (t == JsonToken.VALUE_NULL) {\n66                 value = _elementDeserializer.getNullValue();\n67             } else {\n68                 value = _parseString(jp, ctxt);\n69             }\n70             if (ix >= chunk.length) {\n71                 chunk = buffer.appendCompletedChunk(chunk);\n72                 ix = 0;\n73             }\n74             chunk[ix++] = value;\n75         }\n76         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n77         ctxt.returnObjectBuffer(buffer);\n78         return result;\n79     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StringArrayDeserializer"}, {"bug_name": "JacksonDatabind_4", "report_text": "> Index is never set for Collection and Array in InvalidFormatException.Reference\n> \n> When a InvalidFormatException is created, index values is always '-1'.  \n> Indeed, in StringCollectionDeserializer, and CollectionDeserializer the exception is not caught.  \n> The JsonMappingException shoud be caught and the index should be added and based on the \"result\" size.  \n> Without this information, there is no way to get the index of the item involved in the mapping error.", "test_name": "com.fasterxml.jackson.databind.deser.TestCollectionDeserialization::testArrayIndexForExceptions", "test_method": "    public void testArrayIndexForExceptions() throws Exception\n    {\n        final String OBJECTS_JSON = \"[ \\\"KEY2\\\", false ]\";\n        try {\n            MAPPER.readValue(OBJECTS_JSON, Key[].class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not deserialize\");\n            List<JsonMappingException.Reference> refs = e.getPath();\n            assertEquals(1, refs.size());\n            assertEquals(1, refs.get(0).getIndex());\n        }\n\n        try {\n            MAPPER.readValue(\"[ \\\"xyz\\\", { } ]\", String[].class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Can not deserialize\");\n            List<JsonMappingException.Reference> refs = e.getPath();\n            assertEquals(1, refs.size());\n            assertEquals(1, refs.get(0).getIndex());\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<0>\n\tcom.fasterxml.jackson.databind.deser.TestCollectionDeserialization.testArrayIndexForExceptions(TestCollectionDeserialization.java:224)", "buggy_method": "42 @Override\n43     public String[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n44     {\n45         // Ok: must point to START_ARRAY (or equivalent)\n46         if (!jp.isExpectedStartArrayToken()) {\n47             return handleNonArray(jp, ctxt);\n48         }\n49         if (_elementDeserializer != null) {\n50             return _deserializeCustom(jp, ctxt);\n51         }\n52 \n53         final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n54         Object[] chunk = buffer.resetAndStart();\n55 \n56         int ix = 0;\n57         JsonToken t;\n58 \n59             while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n60                 // Ok: no need to convert Strings, but must recognize nulls\n61                 String value;\n62                 if (t == JsonToken.VALUE_STRING) {\n63                     value = jp.getText();\n64                 } else if (t == JsonToken.VALUE_NULL) {\n65                     value = null; // since we have established that '_elementDeserializer == null' earlier\n66                 } else {\n67                     value = _parseString(jp, ctxt);\n68                 }\n69                 if (ix >= chunk.length) {\n70                     chunk = buffer.appendCompletedChunk(chunk);\n71                     ix = 0;\n72                 }\n73                 chunk[ix++] = value;\n74             }\n75             // note: pass String.class, not String[].class, as we need element type for error info\n76         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n77         ctxt.returnObjectBuffer(buffer);\n78         return result;\n79     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StringArrayDeserializer"}, {"bug_name": "JacksonDatabind_5", "report_text": "> Mixin annotations lost when using a mixin class hierarchy with non-mixin interfaces\n> \n> In summary, mixin annotations are lost when Jackson scans a parent mixin class with Json annotations followed by an interface implemented by the parent mixin class that does not have the same Json annotations.  \n> Jackson version: 2.4.0\n> Detail:  \n> I have the following class structure\n> ```\n> public interface Contact {\n>     String getCity();\n> }\n> public class ContactImpl implements Contact {\n>     public String getCity() { ... }\n> }\n> public class ContactMixin implements Contact {\n>     @JsonProperty\n>     public String getCity() { return null; }\n> }\n> public interface Person extends Contact {}\n> public class PersonImpl extends ContactImpl implements Person {}\n> public class PersonMixin extends ContactMixin implements Person {}\n> ```\n> and I configure a module as\n> ```\n> // There are other getters/properties in the Impl class that do not need to be serialized and so\n> // I am using the Mixin to match the interface and explicitly annotate all the inherited methods\n> module.disable(MapperFeature.ALLOW\\_FINAL\\_FIELDS\\_AS\\_MUTATORS)\n>     .disable(MapperFeature.AUTO\\_DETECT\\_FIELDS)\n>     .disable(MapperFeature.AUTO\\_DETECT\\_GETTERS)\n>     .disable(MapperFeature.AUTO\\_DETECT\\_IS\\_GETTERS)\n>     .disable(MapperFeature.INFER\\_PROPERTY\\_MUTATORS);\n> module.setMixInAnnotation(Person.class, PersonMixin.class);\n> ```\n> When a `PersonImpl` instance is serialized, `city` is not included.\n> I debugged the code and this is what happens:  \n> In `AnnotatedClass.resolveMemberMethods()` the supertypes of `PersonImpl` are `[Person.class, Contact.class, ContactImpl.class]` in that order.\n> It starts with `Person` for which it finds `PersonMixin` and proceeds to `AnnotatedClass._addMethodMixIns()`. Here the `parents` list has `[PersonMixin, ContactMixin, Contact]`. When it processes `ContactMixin` it adds `getCity()` with the `JsonProperty` annotation. Then it processes `Contact`, doesn't find `getCity()` in `methods` map and so creates a new `AnnotatedMethod` for `getCity()` with the one from the interface which has no annotation which replaces the one from `ContactMixin`\n> The workaround for this issue is to explicitly add any parent mixins to the module i.e.\n> ```\n> module.setMixInAnnotation(Contact.class, ContactMixin.class);\n> ```", "test_name": "com.fasterxml.jackson.databind.introspect.TestMixinMerging::testDisappearingMixins515", "test_method": "    public void testDisappearingMixins515() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS)\n            .disable(MapperFeature.AUTO_DETECT_FIELDS)\n            .disable(MapperFeature.AUTO_DETECT_GETTERS)\n            .disable(MapperFeature.AUTO_DETECT_IS_GETTERS)\n            .disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n        SimpleModule module = new SimpleModule(\"Test\");\n        module.setMixInAnnotation(Person.class, PersonMixin.class);        \n        mapper.registerModule(module);\n\n        assertEquals(\"{\\\"city\\\":\\\"Seattle\\\"}\", mapper.writeValueAsString(new PersonImpl())); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.fasterxml.jackson.databind.introspect.TestMixinMerging$PersonImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )\n\tcom.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:59)\n\tcom.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:26)\n\tcom.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:114)\n\tcom.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:2866)\n\tcom.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2323)\n\tcom.fasterxml.jackson.databind.introspect.TestMixinMerging.testDisappearingMixins515(TestMixinMerging.java:48)", "buggy_method": "634 protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n635             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n636     {\n637         List<Class<?>> parents = new ArrayList<Class<?>>();\n638         parents.add(mixInCls);\n639         ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n640         for (Class<?> mixin : parents) {\n641             for (Method m : mixin.getDeclaredMethods()) {\n642                 if (!_isIncludableMemberMethod(m)) {\n643                     continue;\n644                 }\n645                 AnnotatedMethod am = methods.find(m);\n646                 /* Do we already have a method to augment (from sub-class\n647                  * that will mask this mixIn)? If so, add if visible\n648                  * without masking (no such annotation)\n649                  */\n650                 if (am != null) {\n651                     _addMixUnders(m, am);\n652                     /* Otherwise will have precedence, but must wait\n653                      * until we find the real method (mixIn methods are\n654                      * just placeholder, can't be called)\n655                      */\n656                 } else {\n657                     // Well, or, as per [Issue#515], multi-level merge within mixins...\n658                         mixIns.add(_constructMethod(m));\n659                 }\n660             }\n661         }\n662     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.AnnotatedClass"}, {"bug_name": "JacksonDatabind_6", "report_text": "> Add Support for Parsing All Compliant ISO-8601 Date Formats\n> \n> Some providers create JSON date stamps in ISO-8601 formats that cannot be parsed by the jackson-databind library. Here is a sampling of some valid formats that do not parse correctly:\n> 2014-10-03T18:00:00.6-05:00  \n> 2014-10-03T18:00:00.61-05:00  \n> 1997-07-16T19:20+01:00  \n> 1997-07-16T19:20:30.45+01:00\n> The last two actually come from the ISO-8601 notes on <http://www.w3.org/TR/NOTE-datetime>.", "test_name": "com.fasterxml.jackson.databind.deser.TestDateDeserialization::testISO8601MissingSeconds", "test_method": "    public void testISO8601MissingSeconds() throws Exception\n    {\n        String inputStr;\n        Date inputDate;\n        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n    \n        inputStr = \"1997-07-16T19:20+01:00\";\n        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct instance of java.util.Date from String value '1997-07-16T19:20+01:00': not a valid representation (error: Failed to parse Date value '1997-07-16T19:20+01:00': Can not parse date \"1997-07-16T19:20+01:00\": not compatible with any of standard forms (\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", \"EEE, dd MMM yyyy HH:mm:ss zzz\", \"yyyy-MM-dd\"))\n\tcom.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:55)\n\tcom.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:797)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer._parseDate(StdDeserializer.java:740)\n\tcom.fasterxml.jackson.databind.deser.std.DateDeserializers$DateBasedDeserializer._parseDate(DateDeserializers.java:176)\n\tcom.fasterxml.jackson.databind.deser.std.DateDeserializers$DateDeserializer.deserialize(DateDeserializers.java:262)\n\tcom.fasterxml.jackson.databind.deser.std.DateDeserializers$DateDeserializer.deserialize(DateDeserializers.java:246)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3051)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2146)\n\tcom.fasterxml.jackson.databind.deser.TestDateDeserialization.testISO8601MissingSeconds(TestDateDeserialization.java:193)", "buggy_method": "359 protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n360     {\n361         /* 21-May-2009, tatu: DateFormat has very strict handling of\n362          * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n363          */\n364 \n365         /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n366          * quite simple because we already set date format timezone to be\n367          * GMT, and hence can just strip out 'Z' altogether\n368          */\n369         int len = dateStr.length();\n370         char c = dateStr.charAt(len-1);\n371         DateFormat df;\n372 \n373         // [JACKSON-200]: need to support \"plain\" date...\n374         if (len <= 10 && Character.isDigit(c)) {\n375             df = _formatPlain;\n376             if (df == null) {\n377                 df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, DATE_FORMAT_STR_PLAIN, _timezone, _locale);\n378             }\n379         } else if (c == 'Z') {\n380             df = _formatISO8601_z;\n381             if (df == null) {\n382                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z, _timezone, _locale);\n383             }\n384             // [JACKSON-334]: may be missing milliseconds... if so, add\n385             if (dateStr.charAt(len-4) == ':') {\n386                 StringBuilder sb = new StringBuilder(dateStr);\n387                 sb.insert(len-1, \".000\");\n388                 dateStr = sb.toString();\n389             }\n390         } else {\n391             // Let's see if we have timezone indicator or not...\n392             if (hasTimeZone(dateStr)) {\n393                 c = dateStr.charAt(len-3);\n394                 if (c == ':') { // remove optional colon\n395                     // remove colon\n396                     StringBuilder sb = new StringBuilder(dateStr);\n397                     sb.delete(len-3, len-2);\n398                     dateStr = sb.toString();\n399                 } else if (c == '+' || c == '-') { // missing minutes\n400                     // let's just append '00'\n401                     dateStr += \"00\";\n402                 }\n403                 // Milliseconds partial or missing; and even seconds are optional\n404                 len = dateStr.length();\n405                 // remove 'T', '+'/'-' and 4-digit timezone-offset\n406                 c = dateStr.charAt(len-9);\n407                 if (Character.isDigit(c)) {\n408                     StringBuilder sb = new StringBuilder(dateStr);\n409                     sb.insert(len-5, \".000\");\n410                     dateStr = sb.toString();\n411                 }\n412                 df = _formatISO8601;\n413                 if (_formatISO8601 == null) {\n414                     df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n415                 }\n416             } else {\n417                 // If not, plain date. Easiest to just patch 'Z' in the end?\n418                 StringBuilder sb = new StringBuilder(dateStr);\n419                 // And possible also millisecond part if missing\n420                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n421                 if (timeLen <= 8) {\n422                         sb.append(\".000\");\n423                 }\n424                 sb.append('Z');\n425                 dateStr = sb.toString();\n426                 df = _formatISO8601_z;\n427                 if (df == null) {\n428                     df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, DATE_FORMAT_STR_ISO8601_Z,\n429                             _timezone, _locale);\n430                 }\n431             }\n432         }\n433         return df.parse(dateStr, pos);\n434     }", "bm_classpath": "com.fasterxml.jackson.databind.util.StdDateFormat"}, {"bug_name": "JacksonDatabind_7", "report_text": "> Possibly wrong TokenBuffer delegate deserialization using @JsonCreator\n> \n> ```\n> class Value {\n> @JsonCreator\n> public static Value from(TokenBuffer buffer) {\n> ...\n> }\n> ```\n> Given JSON string is `{ \"a\":1, \"b\":null }`, it is expected that while deserializing using delegate buffer,  \n> current token will be start object `{`, and rest of the tokens will be available in buffer:\n> ```\n> [START_OBJECT, FIELD_NAME, VALUE_NUMBER_INT, FIELD_NAME, VALUE_NULL, END_OBJECT]\n> ```\n> But, buffers ends up being started with field name and then contains single attribute value\n> ```\n> [FIELD_NAME, VALUE_NUMBER_INT]\n> ```\n> It's due to how `TokenBuffer#copyCurrentStructure` works when we have current token as a `FIELD_NAME`, rather than `START_OBJECT`, because it's forced to move to next token [BeanDeserializer.java:120](https://github.com/FasterXML/jackson-databind/blob/2.4/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java#L120)\n> Hope this helps to nail it down. Is it an intended behavior, or it's regression/bug?", "test_name": "com.fasterxml.jackson.databind.creators.TestCreatorsDelegating::testDelegateWithTokenBuffer", "test_method": "    public void testDelegateWithTokenBuffer() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n        Object ob = value.stuff;\n        JsonParser jp = ((TokenBuffer) ob).asParser();\n        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected token START_OBJECT, current token FIELD_NAME\n\tcom.fasterxml.jackson.test.BaseTest.assertToken(BaseTest.java:333)\n\tcom.fasterxml.jackson.databind.creators.TestCreatorsDelegating.testDelegateWithTokenBuffer(TestCreatorsDelegating.java:132)", "buggy_method": "403 public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n404     {\n405             copyCurrentStructure(jp);\n406         /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n407          *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n408          *    to assume one did exist.\n409          */\n410         return this;\n411     }", "bm_classpath": "com.fasterxml.jackson.databind.util.TokenBuffer"}, {"bug_name": "JacksonDatabind_8", "report_text": "> Problem with bogus conflict between single-arg-String vs CharSequence constructor\n> \n> Although it is good idea to allow recognizing `CharSequence` as almost like an alias for `String`, this can cause problems for classes like `StringBuilder` that have separate constructors for both.  \n> This actually throws a bogus exception for 2.5.0, due to introduction of ability to recognize `CharSequence`.", "test_name": "com.fasterxml.jackson.databind.deser.TestJdkTypes::testStringBuilder", "test_method": "    public void testStringBuilder() throws Exception\n    {\n        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Conflicting String creators: already had explicitly marked [constructor for java.lang.StringBuilder, annotations: [null]], encountered [constructor for java.lang.StringBuilder, annotations: [null]]\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:267)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:242)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:143)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:439)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3664)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3556)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2576)\n\tcom.fasterxml.jackson.databind.deser.TestJdkTypes.testStringBuilder(TestJdkTypes.java:425)", "buggy_method": "276 protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n277     {\n278         final int mask = (1 << typeIndex);\n279         _hasNonDefaultCreator = true;\n280         AnnotatedWithParams oldOne = _creators[typeIndex];\n281         // already had an explicitly marked one?\n282         if (oldOne != null) {\n283 \n284             if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n285                 // but skip, if new one not annotated\n286                 if (!explicit) {\n287                     return;\n288                 }\n289                 // both explicit: verify\n290                 // otherwise only verify if neither explicitly annotated.\n291             }\n292 \n293             // one more thing: ok to override in sub-class\n294             if (oldOne.getClass() == newOne.getClass()) {\n295                 // [databind#667]: avoid one particular class of bogus problems\n296 \n297                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n298                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n299                 // otherwise, which one to choose?\n300                     // new type more generic, use old\n301                 // new type more specific, use it\n302             }\n303         }\n304         if (explicit) {\n305             _explicitCreators |= mask;\n306         }\n307         _creators[typeIndex] = _fixAccess(newOne);\n308     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.CreatorCollector"}, {"bug_name": "JacksonDatabind_9", "report_text": "> Deserializing Map<Class<? extends Object>, String>\n> \n> I am having problems deserializing my `Map<Class<? extends Object>, String>`. Simple test case demonstrates it:\n> ```\n> @Test\n> public void testMapWithClassAsKey() throws Exception {\n>     Map<Class<? extends Object>, String> map = new HashMap<>();\n>     map.put(ArrayList.class, \"ArrayList\");\n>     map.put(HashMap.class, \"HashMap\");\n>     ObjectMapper mapper = new ObjectMapper();\n>     String json = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);\n>     System.out.println(json);\n>     mapper.readValue(json, new TypeReference<Map<Class<? extends Object>, String>>(){});\n> }\n> ```\n> This test serializes the map as:\n> ```\n> {\n>     \"class java.util.ArrayList\" : \"ArrayList\",\n>     \"class java.util.HashMap\" : \"HashMap\"\n> }\n> ```\n> `mapper.readValue(json, new TypeReference<Map<Class<? extends Object>, String>>(){});` then throws a `Exception`:\n> ```\n> com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct     Map key of type java.lang.Class from String \"class java.util.ArrayList\": not a valid representation: Can not construct Map key of type java.lang.Class from String \"class java.util.ArrayList\": unable to parse key as Class\n>  at [Source: ...\n> ```\n> As i understood from [#630](https://github.com/FasterXML/jackson-databind/issues/630) the KeyDeserializer for Class should be part of Jackson. Am I missing something?", "test_name": "com.fasterxml.jackson.databind.ser.TestMapSerialization::testClassKey", "test_method": "    public void testClassKey() throws IOException\n    {\n        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();\n        map.put(String.class, 2);\n        String json = MAPPER.writeValueAsString(map);\n        assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"[]java.lang.String\":2}> but was:<{\"[class ]java.lang.String\":2}>\n\tcom.fasterxml.jackson.databind.ser.TestMapSerialization.testClassKey(TestMapSerialization.java:256)", "buggy_method": "24 @Override\n25     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n26         String str;\n27         \n28         if (value instanceof Date) {\n29             provider.defaultSerializeDateKey((Date) value, jgen);\n30             return;\n31         } else {\n32             str = value.toString();\n33         }\n34         jgen.writeFieldName(str);\n35     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.StdKeySerializer"}, {"bug_name": "JacksonDatabind_10", "report_text": "> JsonAnyGetter doesn't work with JsonSerialize (except with keyUsing)\n> \n> (This is happening with 2.5.0. Haven't tried 2.5.1 but I couldn't see any related issue anyway)\n> Jackson ignores JsonSerialize annotation when there is JsonAnyGetter annotation.\n> ```\n>   @JsonSerialize(using = MySerializer.class)\n>   // or\n>   @JsonSerialize(converter = MyConverter.class)\n>   @JsonAnyGetter\n>   public Map<String, String> getParameters(){\n>     return parameters;\n>   }\n> ```\n> except\n> ```\n> @JsonSerialize(keyUsing = MyKeySerializer.class)\n> ```\n> (haven't tried each setting. Only tried keyUsing because I've seen a different issue ([#661](https://github.com/FasterXML/jackson-databind/issues/661)) with it)  \n> Then it works. But I need the converter, so..\n> For the time being I will use\n> ```\n>   @JsonAnyGetter\n>   public Map<String, JsonNode> getParameters(){\n>     return new MyConverter().convert(parameters);\n>   }\n> ```\n> but I'd prefer to stick to annotations.", "test_name": "com.fasterxml.jackson.databind.ser.TestAnyGetter::testIssue705", "test_method": "    public void testIssue705() throws Exception\n    {\n        Issue705Bean input = new Issue705Bean(\"key\", \"value\");        \n        String json = MAPPER.writeValueAsString(input);\n        assertEquals(\"{\\\"stuff\\\":\\\"[key/value]\\\"}\", json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"[stuff\":\"[key/value]]\"}> but was:<{\"[key\":\"value]\"}>\n\tcom.fasterxml.jackson.databind.ser.TestAnyGetter.testIssue705(TestAnyGetter.java:139)", "buggy_method": "36 public void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n37         throws Exception\n38     {\n39         Object value = _accessor.getValue(bean);\n40         if (value == null) {\n41             return;\n42         }\n43         if (!(value instanceof Map<?,?>)) {\n44             throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n45                     +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n46         }\n47         // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n48         if (_mapSerializer != null) {\n49             _mapSerializer.serializeFields((Map<?,?>) value, gen, provider);\n50             return;\n51         }\n52     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.AnyGetterWriter"}, {"bug_name": "JacksonDatabind_11", "report_text": "> Problem resolving locally declared generic type\n> \n> (reported by Hal H)\n> Case like:\n> ```\n> class Something {\n>     public <T extends Ruleform> T getEntity()\n>     public <T extends Ruleform> void setEntity(T entity) \n> }\n> ```\n> appears to fail on deserialization.", "test_name": "com.fasterxml.jackson.databind.type.TestJavaType::testLocalType728", "test_method": "    public void testLocalType728() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m = Issue728.class.getMethod(\"method\", CharSequence.class);\n\n        // Start with return type\n        // first type-erased\n        JavaType t = tf.constructType(m.getReturnType());\n        // then generic\n        t = tf.constructType(m.getGenericReturnType());\n        assertEquals(CharSequence.class, t.getRawClass()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<interface java.lang.CharSequence> but was:<class java.lang.Object>\n\tcom.fasterxml.jackson.databind.type.TestJavaType.testLocalType728(TestJavaType.java:43)", "buggy_method": "889 protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n890     {\n891         final String name = type.getName();\n892         // 19-Mar-2015: Without context, all we can check are bounds.\n893         if (context == null) {\n894             // And to prevent infinite loops, now need this:\n895             return _unknownType();\n896         } else {\n897             // Ok: here's where context might come in handy!\n898             /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n899              *   unresolved type variables to handle some cases where bounds\n900              *   are enough. Let's hope it does not hide real fail cases.\n901              */\n902             JavaType actualType = context.findType(name);\n903             if (actualType != null) {\n904                 return actualType;\n905             }\n906         }\n907 \n908         /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n909          *   bound: but the problem is that this can occur for generic \"base\"\n910          *   method, overridden by sub-class. If so, we will want to ignore\n911          *   current type (for method) since it will be masked.\n912          */\n913         Type[] bounds = type.getBounds();\n914 \n915         // With type variables we must use bound information.\n916         // Theoretically this gets tricky, as there may be multiple\n917         // bounds (\"... extends A & B\"); and optimally we might\n918         // want to choose the best match. Also, bounds are optional;\n919         // but here we are lucky in that implicit \"Object\" is\n920         // added as bounds if so.\n921         // Either way let's just use the first bound, for now, and\n922         // worry about better match later on if there is need.\n923 \n924         /* 29-Jan-2010, tatu: One more problem are recursive types\n925          *   (T extends Comparable<T>). Need to add \"placeholder\"\n926          *   for resolution to catch those.\n927          */\n928         context._addPlaceholder(name);\n929         return _constructType(bounds[0], context);\n930     }", "bm_classpath": "com.fasterxml.jackson.databind.type.TypeFactory"}, {"bug_name": "JacksonDatabind_12", "report_text": "> @JsonDeserialize on Map with contentUsing custom deserializer overwrites default behavior\n> \n> I recently updated from version 2.3.3 to 2.5.1 and encountered a new issue with our custom deserializers. They either seemed to stop working or were active on the wrong fields.  \n> I could narrow it down to some change in version 2.4.4 (2.4.3 is still working for me)\n> I wrote a test to show this behavior. It seems to appear when there a two maps with the same key and value types in a bean, and only one of them has a custom deserializer. The deserializer is then falsely used either for both or none of the maps.\n> This test works for me in version 2.4.3 and fails with higher versions.\n> ```\n> import static org.junit.Assert.assertEquals;\n> import java.io.IOException;\n> import java.util.Map;\n> import org.junit.Test;\n> import com.fasterxml.jackson.annotation.JsonProperty;\n> import com.fasterxml.jackson.core.JsonParser;\n> import com.fasterxml.jackson.core.JsonProcessingException;\n> import com.fasterxml.jackson.databind.DeserializationContext;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n> import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n> public class DeserializeTest {\n>     @Test\n>     public void testIt() throws Exception {\n>         ObjectMapper om = new ObjectMapper();\n>         String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n>         TestBean bean = om.readValue(json.getBytes(), TestBean.class);\n>         assertEquals(100, bean.getMap1().get(\"a\").intValue());\n>         assertEquals(1, bean.getMap2().get(\"a\").intValue());\n>     }\n>     public static class TestBean {\n>         @JsonProperty(\"map1\")\n>         @JsonDeserialize(contentUsing = CustomDeserializer.class)\n>         Map<String, Integer> map1;\n>         @JsonProperty(\"map2\")\n>         Map<String, Integer> map2;\n>         public Map<String, Integer> getMap1() {\n>             return map1;\n>         }\n>         public void setMap1(Map<String, Integer> map1) {\n>             this.map1 = map1;\n>         }\n>         public Map<String, Integer> getMap2() {\n>             return map2;\n>         }\n>         public void setMap2(Map<String, Integer> map2) {\n>             this.map2 = map2;\n>         }\n>     }\n>     public static class CustomDeserializer extends StdDeserializer<Integer> {\n>         public CustomDeserializer() {\n>             super(Integer.class);\n>         }\n>         @Override\n>         public Integer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n>             Integer value = p.readValueAs(Integer.class);\n>             return value * 100;\n>         }\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.TestCustomDeserializers::testCustomMapValueDeser735", "test_method": "    public void testCustomMapValueDeser735() throws Exception {\n        String json = \"{\\\"map1\\\":{\\\"a\\\":1},\\\"map2\\\":{\\\"a\\\":1}}\";\n        TestMapBean735 bean = MAPPER.readValue(json, TestMapBean735.class);\n\n        assertEquals(1, bean.map2.get(\"a\").intValue()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<100>\n\tcom.fasterxml.jackson.databind.deser.TestCustomDeserializers.testCustomMapValueDeser735(TestCustomDeserializers.java:370)", "buggy_method": "298 @Override\n299     public boolean isCachable() {\n300         /* As per [databind#735], existence of value or key deserializer (only passed\n301          * if annotated to use non-standard one) should also prevent caching.\n302          */\n303         return (_valueTypeDeserializer == null)\n304                 && (_ignorableProperties == null);\n305     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.MapDeserializer"}, {"bug_name": "JacksonDatabind_13", "report_text": "> Allow deserialization of null Object Id\n> \n> (note: related to [FasterXML/jackson-annotations#56](https://github.com/FasterXML/jackson-annotations/issues/56))\n> For some use cases (one known case being use from ORM like Hibernate) it makes sense to allow use of `null` (or missing) Object Id, in cases where actual Id will be generated by something other than Jackson. It may also make sense to add matching `DeserializationFeature` which allows such a condition to either be acceptable (default), or not (throw an exception), to allow for strict checks in cases where null/missing Object Id is not a legal use case.", "test_name": "com.fasterxml.jackson.databind.struct.TestObjectIdDeserialization::testNullObjectId", "test_method": "    public void testNullObjectId() throws Exception\n    {\n        // Ok, so missing Object Id is ok, but so is null.\n        \n        Identifiable value = MAPPER.readValue\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), Identifiable.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.struct.Identifiable[\"id\"])\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:210)\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:177)\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.wrapAndThrow(BeanPropertyMap.java:439)\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap._findDeserializeAndSet2(BeanPropertyMap.java:315)\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.findDeserializeAndSet(BeanPropertyMap.java:291)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:335)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithObjectId(BeanDeserializerBase.java:1045)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:140)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3562)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2578)\n\tcom.fasterxml.jackson.databind.struct.TestObjectIdDeserialization.testNullObjectId(TestObjectIdDeserialization.java:464)", "buggy_method": "81 @Override\n82     public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n83     {\n84         /* 02-Apr-2015, tatu: As per [databind#742] should allow 'null', similar to how\n85          *   missing id already works.\n86          */\n87 \n88         final ObjectIdGenerator.IdKey key = gen.key(id);\n89 \n90         if (_objectIds == null) {\n91             _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n92         } else {\n93             ReadableObjectId entry = _objectIds.get(key);\n94             if (entry != null) {\n95                 return entry;\n96             }\n97         }\n98 \n99         // Not seen yet, must create entry and configure resolver.\n100         ObjectIdResolver resolver = null;\n101 \n102         if (_objectIdResolvers == null) {\n103             _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n104         } else {\n105             for (ObjectIdResolver res : _objectIdResolvers) {\n106                 if (res.canUseFor(resolverType)) {\n107                     resolver = res;\n108                     break;\n109                 }\n110             }\n111         }\n112 \n113         if (resolver == null) {\n114             resolver = resolverType.newForDeserialization(this);\n115             // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n116             //   needed to clear state between calls.\n117             // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n118             //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n119             /*\n120             if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n121                 resolver = new SimpleObjectIdResolver();\n122             }\n123             */\n124             _objectIdResolvers.add(resolver);\n125         }\n126 \n127         ReadableObjectId entry = new ReadableObjectId(key);\n128         entry.setResolver(resolver);\n129         _objectIds.put(key, entry);\n130         return entry;\n131     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.DefaultDeserializationContext"}, {"bug_name": "JacksonDatabind_14", "report_text": "> Custom deserializer with parent object update\n> \n> Hi, I have custom deserializer for `DataA`. An instance of `DataA` is contained in `DataB`, when updating an existing instance of `DataB` (as opposed to creating a new one) I get an exception when deserializing via a `JsonNode` object (deserializing via a `String` object works).\n> ```\n> import java.io.IOException;\n> import org.junit.Assert;\n> import org.junit.Test;\n> import com.fasterxml.jackson.core.JsonParser;\n> import com.fasterxml.jackson.core.JsonProcessingException;\n> import com.fasterxml.jackson.core.JsonToken;\n> import com.fasterxml.jackson.databind.DeserializationContext;\n> import com.fasterxml.jackson.databind.JsonNode;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n> import com.fasterxml.jackson.databind.module.SimpleModule;\n> public class TestDeserTest {\n>     static class DataA {\n>         public int i = 1;\n>         public int j = 2;\n>     }\n>     static class DataB {\n>         public DataA da = new DataA();\n>         public int k = 3;\n>     }\n>     static class DataADeserializer extends StdDeserializer<DataA> {\n>         private static final long serialVersionUID = 1L;\n>         DataADeserializer() {\n>             super(DataA.class);\n>         }\n>         public DataA deserialize(JsonParser jp, DeserializationContext ctxt)\n>                 throws JsonProcessingException, IOException {\n>             assert (jp.getCurrentToken() == JsonToken.START\\_OBJECT);\n>             JsonNode node = jp.getCodec().readTree(jp);\n>             DataA da = new DataA();\n>             da.i = 5;\n>             return da;\n>         }\n>     }\n>     @Test\n>     public void test() throws IOException {\n>         ObjectMapper mapper = new ObjectMapper();\n>         SimpleModule module = new SimpleModule();\n>         module.addDeserializer(DataA.class, new DataADeserializer());\n>         mapper.registerModule(module);\n>         DataB db = new DataB();\n>         db.da.i = 11;\n>         db.k = 13;\n>         String jsonBString = mapper.writeValueAsString(db);\n>         JsonNode jsonBNode = mapper.valueToTree(db);\n>         // create parent\n>         DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n>         Assert.assertEquals(5, dbNewViaString.da.i);\n>         Assert.assertEquals(13, dbNewViaString.k);\n>         DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n>         Assert.assertEquals(5, dbNewViaNode.da.i);\n>         Assert.assertEquals(13, dbNewViaNode.k);\n>         // update parent\n>         DataB dbUpdViaString = new DataB();\n>         DataB dbUpdViaNode = new DataB();\n>         Assert.assertEquals(1, dbUpdViaString.da.i);\n>         Assert.assertEquals(3, dbUpdViaString.k);\n>         mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n>         Assert.assertEquals(5, dbUpdViaString.da.i);\n>         Assert.assertEquals(13, dbUpdViaString.k);\n>         Assert.assertEquals(1, dbUpdViaNode.da.i);\n>         Assert.assertEquals(3, dbUpdViaNode.k);\n>         // FAILS HERE:\n>         mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode);\n>         Assert.assertEquals(5, dbUpdViaNode.da.i);\n>         Assert.assertEquals(13, dbUpdViaNode.k);\n>     }\n> }\n> ```\n> The trace:\n> ```\n> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"i\" (class myorg.TestDeserTest$DataB), not marked as ignorable (2 known properties: \"da\", \"k\"])\n>  at [Source: N/A; line: -1, column: -1] (through reference chain: myorg.DataB[\"da\"]->myorg.DataB[\"i\"])\n>     at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:51)\n>     at com.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:817)\n>     at com.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:954)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1324)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1302)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:249)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:136)\n>     at com.fasterxml.jackson.databind.ObjectReader.\\_bindAsTree(ObjectReader.java:1478)\n>     at com.fasterxml.jackson.databind.ObjectReader.readTree(ObjectReader.java:1020)\n>     at myorg.TestDeserTest$DataADeserializer.deserialize(TestDeserTest.java:39)\n>     at myorg.TestDeserTest$DataADeserializer.deserialize(TestDeserTest.java:1)\n>     at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:523)\n>     at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n>     at com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.findDeserializeAndSet(BeanPropertyMap.java:285)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:220)\n>     at com.fasterxml.jackson.databind.ObjectReader.\\_bindAndClose(ObjectReader.java:1443)\n>     at com.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1154)\n>     at myorg.TestDeserTest.test(TestDeserTest.java:81)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:606)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)", "test_name": "com.fasterxml.jackson.databind.convert.TestUpdateValue::testIssue744", "test_method": "    public void testIssue744() throws IOException\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        SimpleModule module = new SimpleModule();\n        module.addDeserializer(DataA.class, new DataADeserializer());\n        mapper.registerModule(module);\n\n        DataB db = new DataB();\n        db.da.i = 11;\n        db.k = 13;\n        String jsonBString = mapper.writeValueAsString(db);\n        JsonNode jsonBNode = mapper.valueToTree(db);\n\n        // create parent\n        DataB dbNewViaString = mapper.readValue(jsonBString, DataB.class);\n\n        DataB dbNewViaNode = mapper.treeToValue(jsonBNode, DataB.class);\n\n        // update parent\n        DataB dbUpdViaString = new DataB();\n        DataB dbUpdViaNode = new DataB();\n\n        mapper.readerForUpdating(dbUpdViaString).readValue(jsonBString);\n\n        \n        mapper.readerForUpdating(dbUpdViaNode).readValue(jsonBNode); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"i\" (class com.fasterxml.jackson.databind.convert.TestUpdateValue$DataB), not marked as ignorable (2 known properties: \"da\", \"k\"])\n\tcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:51)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:817)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:958)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1324)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1302)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:249)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:136)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAsTree(ObjectReader.java:1480)\n\tcom.fasterxml.jackson.databind.ObjectReader.readTree(ObjectReader.java:1022)\n\tcom.fasterxml.jackson.core.JsonParser.readValueAsTree(JsonParser.java:1465)\n\tcom.fasterxml.jackson.databind.convert.TestUpdateValue$DataADeserializer.deserialize(TestUpdateValue.java:76)\n\tcom.fasterxml.jackson.databind.convert.TestUpdateValue$DataADeserializer.deserialize(TestUpdateValue.java:63)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:523)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.findDeserializeAndSet(BeanPropertyMap.java:285)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:220)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1445)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1156)\n\tcom.fasterxml.jackson.databind.convert.TestUpdateValue.testIssue744(TestUpdateValue.java:222)", "buggy_method": "1468 protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n1469     {\n1470         JsonNode result;\n1471         JsonToken t = _initForReading(jp);\n1472         if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n1473             result = NullNode.instance;\n1474         } else {\n1475             DeserializationContext ctxt = createDeserializationContext(jp, _config);\n1476             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n1477             if (_unwrapRoot) {\n1478                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n1479             } else {\n1480                 result = (JsonNode) deser.deserialize(jp, ctxt);\n1481             }\n1482         }\n1483         // Need to consume the token too\n1484         jp.clearCurrentToken();\n1485         return result;\n1486     }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectReader"}, {"bug_name": "JacksonDatabind_16", "report_text": "> Annotation bundles ignored when added to Mixin\n> \n> When updating from v 2.4.4 to 2.5.\\* it appears as though annotation bundles created with `@JacksonAnnotationsInside` are ignored when placed on a mixin. Moving the annotation bundel to the actual class seems to resolve the issue. Below is a simple test that attempts to rename a property. I have more complicated test cases that are also failing but this should provide some context.\n> ```\n> public class Fun {\n>     @Test\n>     public void test() throws JsonProcessingException {\n>         ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n>         String result = mapper.writeValueAsString(new Foo(\"result\"));\n>         Assert.assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result);\n>     }\n>     @Target(value={ ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD })\n>     @Retention(value=RetentionPolicy.RUNTIME)\n>     @JacksonAnnotationsInside\n>     @JsonProperty(\"bar\")\n>     public @interface ExposeStuff {\n>     }\n>     public abstract class FooMixin {\n>         @ExposeStuff\n>         public abstract String getStuff();\n>     }\n>     public class Foo {\n>         private String stuff;\n>         Foo(String stuff) {\n>             this.stuff = stuff;\n>         }\n>         public String getStuff() {\n>             return stuff;\n>         }\n>     }\n> }\n> ```\n> I'm expecting the \"stuff\" property to be serialized as \"bar\".\n> I apologize I haven't been able to identify the culprit (and perhaps it's in my usage). Let me know your thoughts. I'm always happy to provide more details!", "test_name": "com.fasterxml.jackson.databind.mixins.MixinsWithBundlesTest::testMixinWithBundles", "test_method": "    public void testMixinWithBundles() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().addMixIn(Foo.class, FooMixin.class);\n        String result = mapper.writeValueAsString(new Foo(\"result\"));\n        assertEquals(\"{\\\"bar\\\":\\\"result\\\"}\", result); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"[bar]\":\"result\"}> but was:<{\"[stuff]\":\"result\"}>\n\tcom.fasterxml.jackson.databind.mixins.MixinsWithBundlesTest.testMixinWithBundles(MixinsWithBundlesTest.java:41)", "buggy_method": "107 protected final boolean _add(Annotation ann) {\n108         if (_annotations == null) {\n109             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n110         }\n111         Annotation previous = _annotations.put(ann.annotationType(), ann);\n112         return (previous != null) && previous.equals(ann);\n113     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.AnnotationMap"}, {"bug_name": "JacksonDatabind_17", "report_text": "> readTree does not work with defaultTyping enabled but no type info provided\n> \n> I have enabled `defaultTyping`, and serialized `Foo` entity with no type info. I'm trying to read json as a tree with `mapper.readTree(json)`, and it throws an exception\n> ```\n> Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: \n> Unexpected token (START\\_OBJECT), expected START\\_ARRAY: need JSON Array to contain As.WRAPPER\\_ARRAY \n> type information for class com.fasterxml.jackson.databind.JsonNode\n>  at [Source: {\n>   \"bar\" : \"bar\"\n> }; line: 1, column: 1]\n>     at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n>     at com.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:927)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.\\_locateTypeId(AsArrayTypeDeserializer.java:127)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.\\_deserialize(AsArrayTypeDeserializer.java:93)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromAny(AsArrayTypeDeserializer.java:68)\n>     at com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:144)\n>     at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:14)\n>     at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:42)\n>     at com.fasterxml.jackson.databind.ObjectMapper.\\_readMapAndClose(ObjectMapper.java:3562)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2136)\n>     at test.App.main(App.java:23)\n> ```\n> However, if I disable `defaultTyping`, the same code works fine. So, `readTree(json)` does not actually need type info for the root element, because it works when `defaultTyping` is disabled (i.e. `{\"bar\" : \"bar\"}`), but it throws the exception when `defaultTyping` is enabled, that's why it looks like a bug. The same thing happens for `valueToTree(foo)`.  \n> Jackson version is `2.5.3`  \n> Full code is provided.\n> ```\n> import com.fasterxml.jackson.databind.JsonNode;\n> import com.fasterxml.jackson.databind.MapperFeature;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.SerializationFeature;\n> import java.io.IOException;\n> public class App {\n>     public static void main(String[] args) throws IOException {\n>         ObjectMapper mapper = new ObjectMapper()\n>                 .enableDefaultTyping() // works fine with disableDefaultTyping()\n>                 .enable(MapperFeature.AUTO\\_DETECT\\_GETTERS)\n>                 .enable(MapperFeature.REQUIRE\\_SETTERS\\_FOR\\_GETTERS)\n>                 .disable(MapperFeature.USE\\_GETTERS\\_AS\\_SETTERS)\n>                 .disable(MapperFeature.CAN\\_OVERRIDE\\_ACCESS\\_MODIFIERS)\n>                 .enable(SerializationFeature.INDENT\\_OUTPUT)\n>                 .disable(SerializationFeature.FAIL\\_ON\\_EMPTY\\_BEANS);\n>         Foo foo = new Foo(\"bar\");\n>         String serialized = mapper.writeValueAsString(foo); // {\"bar\" : \"bar\"}\n>         JsonNode jsonNode = mapper.readTree(serialized); // exception here\n>         JsonNode node = mapper.valueToTree(foo); // and here\n>     }\n>     public static class Foo {\n>         private String bar;\n>         public Foo() {\n>         }\n>         public Foo(String bar) {\n>             this.bar = bar;\n>         }\n>         public String getBar() {\n>             return bar;\n>         }\n>         public void setBar(String bar) {\n>             this.bar = bar;\n>         }\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.node.TestJsonNode::testArrayWithDefaultTyping", "test_method": "    public void testArrayWithDefaultTyping() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .enableDefaultTyping();\n\n        JsonNode array = mapper.readTree(\"[ 1, 2 ]\"); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (VALUE_NUMBER_INT), expected VALUE_STRING: need JSON String that contains type id (for subtype of com.fasterxml.jackson.databind.JsonNode)\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:854)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._locateTypeId(AsArrayTypeDeserializer.java:134)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:93)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromAny(AsArrayTypeDeserializer.java:68)\n\tcom.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:144)\n\tcom.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserializeWithType(JsonNodeDeserializer.java:14)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:41)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3070)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:1837)\n\tcom.fasterxml.jackson.databind.node.TestJsonNode.testArrayWithDefaultTyping(TestJsonNode.java:114)", "buggy_method": "167 public boolean useForType(JavaType t)\n168         {\n169             switch (_appliesFor) {\n170             case NON_CONCRETE_AND_ARRAYS:\n171                 while (t.isArrayType()) {\n172                     t = t.getContentType();\n173                 }\n174                 // fall through\n175             case OBJECT_AND_NON_CONCRETE:\n176 //                return t.isJavaLangObject() || \n177                 return (t.getRawClass() == Object.class)\n178                         || (!t.isConcrete()\n179                                 // [databind#88] Should not apply to JSON tree models:\n180                         || TreeNode.class.isAssignableFrom(t.getRawClass()));\n181 \n182             case NON_FINAL:\n183                 while (t.isArrayType()) {\n184                     t = t.getContentType();\n185                 }\n186                 // [Issue#88] Should not apply to JSON tree models:\n187                 return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n188             default:\n189             //case JAVA_LANG_OBJECT:\n190 //                return t.isJavaLangObject();\n191                 return (t.getRawClass() == Object.class);\n192             }\n193         }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectMapper$DefaultTypeResolverBuilder"}, {"bug_name": "JacksonDatabind_18", "report_text": "> Add basic error-recovery for ObjectReader.readValues()\n> \n> (follow up for [#733](https://github.com/FasterXML/jackson-databind/issues/733))\n> In case of `JsonProcessingException`, `MappingIterator` will currently be left pointing right after whatever token was last tokenized (or character following tokenization error). While this is better than indeterminate state, ideally it should try to do some error recover. And although it may not be possible to recover successfully from all kinds of issues, it should be possible to do best effort given that iterator has some knowledge of state when it was opened; that is, it can try to heuristically match closing `END_OBJECT`, depending on nesting level it was created at.\n> In addition it may make sense to add a switch to prevent using of any automated heuristics, for those users who want full control over recovery.", "test_name": "com.fasterxml.jackson.databind.seq.ReadRecoveryTest::testSimpleRootRecovery", "test_method": "    public void testSimpleRootRecovery() throws Exception\n    {\n        final String JSON = aposToQuotes(\"{'a':3}{'a':27,'foo':[1,2],'b':{'x':3}}  {'a':1,'b':2} \");\n\n        MappingIterator<Bean> it = MAPPER.readerFor(Bean.class).readValues(JSON);\n        Bean bean = it.nextValue();\n\n\n        // second one problematic\n        try {\n            it.nextValue();\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Unrecognized field \\\"foo\\\"\");\n        }\n\n        // but should recover nicely\n        bean = it.nextValue(); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not instantiate value of type [simple type, class com.fasterxml.jackson.databind.seq.ReadRecoveryTest$Bean] from Integral number (1); no single-int-arg constructor/factory method\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:860)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromInt(StdValueInstantiator.java:304)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromNumber(BeanDeserializerBase.java:1134)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:145)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:134)\n\tcom.fasterxml.jackson.databind.MappingIterator.nextValue(MappingIterator.java:249)\n\tcom.fasterxml.jackson.databind.seq.ReadRecoveryTest.testSimpleRootRecovery(ReadRecoveryTest.java:67)", "buggy_method": "112 @SuppressWarnings(\"unchecked\")\n113     protected MappingIterator(JavaType type, JsonParser p, DeserializationContext ctxt,\n114             JsonDeserializer<?> deser,\n115             boolean managedParser, Object valueToUpdate)\n116     {\n117         _type = type;\n118         _parser = p;\n119         _context = ctxt;\n120         _deserializer = (JsonDeserializer<T>) deser;\n121         _closeParser = managedParser;\n122         if (valueToUpdate == null) {\n123             _updatedValue = null;\n124         } else {\n125             _updatedValue = (T) valueToUpdate;\n126         }\n127 \n128         /* Ok: one more thing; we may have to skip START_ARRAY, assuming\n129          * \"wrapped\" sequence; but this is ONLY done for 'managed' parsers\n130          * and never if JsonParser was directly passed by caller (if it\n131          * was, caller must have either positioned it over first token of\n132          * the first element, or cleared the START_ARRAY token explicitly).\n133          * Note, however, that we do not try to guess whether this could be\n134          * an unwrapped sequence of arrays/Lists: we just assume it is wrapped;\n135          * and if not, caller needs to hand us JsonParser instead, pointing to\n136          * the first token of the first element.\n137          */\n138         if (managedParser && (p != null) && p.isExpectedStartArrayToken()) {\n139                 // If pointing to START_ARRAY, context should be that ARRAY\n140                 p.clearCurrentToken();\n141                 // regardless, recovery context should be whatever context we have now,\n142                 // with sole exception of pointing to a start marker, in which case it's\n143                 // the parent\n144         }\n145     }", "bm_classpath": "com.fasterxml.jackson.databind.MappingIterator"}, {"bug_name": "JacksonDatabind_19", "report_text": "> Force value coercion for java.util.Properties, so that values are Strings\n> \n> Currently there is no custom handling for `java.util.Properties`, and although it is possible to use it (since it really is a `Map` under the hood), results are only good if values are already `String`s.  \n> The problem here is that `Properties` is actually declared as `Map<String,Object>`, probably due to backwards-compatibility constraints.\n> But Jackson should know better: perhaps by `TypeFactory` tweaking parameterizations a bit?", "test_name": "com.fasterxml.jackson.databind.convert.TestMapConversions::testMapToProperties", "test_method": "    public void testMapToProperties() throws Exception\n    {\n        Bean bean = new Bean();\n        bean.A = 129;\n        bean.B = \"13\";\n        Properties props = MAPPER.convertValue(bean, Properties.class);\n\n\n        // should coercce non-Strings to Strings\n        assertEquals(\"129\", props.getProperty(\"A\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<129> but was:<null>\n\tcom.fasterxml.jackson.databind.convert.TestMapConversions.testMapToProperties(TestMapConversions.java:113)", "buggy_method": "1018 private JavaType _mapType(Class<?> rawClass)\n1019     {\n1020         // 28-May-2015, tatu: Properties are special, as per [databind#810]\n1021         JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n1022         // ok to have no types (\"raw\")\n1023         if (typeParams == null) {\n1024             return MapType.construct(rawClass, _unknownType(), _unknownType());\n1025         }\n1026         // but exactly 2 types if any found\n1027         if (typeParams.length != 2) {\n1028             throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n1029         }\n1030         return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n1031     }", "bm_classpath": "com.fasterxml.jackson.databind.type.TypeFactory"}, {"bug_name": "JacksonDatabind_20", "report_text": "> Presence of PropertyNamingStrategy Makes Deserialization Fail\n> \n> I originally came across this issue using Dropwizard - [dropwizard/dropwizard#1095](https://github.com/dropwizard/dropwizard/issues/1095). But it looks like this is a Jackson issue. Here's the rerproducer:\n> ```\n> public class TestPropertyNamingStrategyIssue {\n>   public static class ClassWithObjectNodeField {\n>     public String id;\n>     public ObjectNode json;\n>   }\n>   @Test\n>   public void reproducer() throws Exception {\n>     ObjectMapper mapper = new ObjectMapper();\n>     mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER\\_CASE);\n>     ClassWithObjectNodeField deserialized =\n>         mapper.readValue(\n>             \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\n>             ClassWithObjectNodeField.class);\n>   }\n> }\n> ```\n> Looks like the presence of any PropertyNamingStrategy make deserialization to ObjectNode fail. This works fine if I remove the property naming strategy.", "test_name": "com.fasterxml.jackson.databind.introspect.TestNamingStrategyStd::testNamingWithObjectNode", "test_method": "    public void testNamingWithObjectNode() throws Exception\r\n    {\r\n        ObjectMapper m = new ObjectMapper();\r\n        m.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CASE);\r\n        ClassWithObjectNodeField result =\r\n            m.readValue(\r\n                \"{ \\\"id\\\": \\\"1\\\", \\\"json\\\": { \\\"foo\\\": \\\"bar\\\", \\\"baz\\\": \\\"bing\\\" } }\",\r\n                ClassWithObjectNodeField.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Conflicting setter definitions for property \"all\": com.fasterxml.jackson.databind.node.ObjectNode#setAll(1 params) vs com.fasterxml.jackson.databind.node.ObjectNode#setAll(1 params)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:270)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:245)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:143)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:406)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:882)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:436)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:297)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:245)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:143)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:439)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3668)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3560)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2580)\n\tcom.fasterxml.jackson.databind.introspect.TestNamingStrategyStd.testNamingWithObjectNode(TestNamingStrategyStd.java:309)", "buggy_method": "324 public JsonNode setAll(Map<String,? extends JsonNode> properties)\n325     {\n326         for (Map.Entry<String,? extends JsonNode> en : properties.entrySet()) {\n327             JsonNode n = en.getValue();\n328             if (n == null) {\n329                 n = nullNode();\n330             }\n331             _children.put(en.getKey(), n);\n332         }\n333         return this;\n334     }", "bm_classpath": "com.fasterxml.jackson.databind.node.ObjectNode"}, {"bug_name": "JacksonDatabind_22", "report_text": "> Custom serializer not used if POJO has @JsonValue\n> \n> Looks like serializers constructed for `@JsonValue` have higher precedence than custom serializers; that is, registered custom serializer is not found if POJO type has `@JsonValue` annotation.  \n> This is wrong.", "test_name": "com.fasterxml.jackson.databind.ser.TestJsonValue::testJsonValueWithCustomOverride", "test_method": "    public void testJsonValueWithCustomOverride() throws Exception\n    {\n        final Bean838 INPUT = new Bean838();\n\n        // by default, @JsonValue should be used\n\n        // but custom serializer should override it\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerModule(new SimpleModule()\n            .addSerializer(Bean838.class, new Bean838Serializer())\n            );\n        assertEquals(\"42\", mapper.writeValueAsString(INPUT)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[42]> but was:<[\"value\"]>\n\tcom.fasterxml.jackson.databind.ser.TestJsonValue.testJsonValueWithCustomOverride(TestJsonValue.java:282)", "buggy_method": "544 protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n545             JavaType type, BeanDescription beanDesc, boolean staticTyping)\n546         throws JsonMappingException\n547     {\n548         final SerializationConfig config = prov.getConfig();\n549 \n550         /* [databind#23], 15-Mar-2013, tatu: must force static handling of root value type,\n551          *   with just one important exception: if value type is \"untyped\", let's\n552          *   leave it as is; no clean way to make it work.\n553          */\n554         if (!staticTyping && type.useStaticType()) {\n555             if (!type.isContainerType() || type.getContentType().getRawClass() != Object.class) {\n556                 staticTyping = true;\n557             }\n558         }\n559         \n560         // Let's see what we can learn about element/content/value type, type serializer for it:\n561         JavaType elementType = type.getContentType();\n562         TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n563                 elementType);\n564 \n565         // if elements have type serializer, can not force static typing:\n566         if (elementTypeSerializer != null) {\n567             staticTyping = false;\n568         }\n569         JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n570                 beanDesc.getClassInfo());\n571         if (type.isMapLikeType()) { // implements java.util.Map\n572             MapLikeType mlt = (MapLikeType) type;\n573             /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n574              *  key serializer from property annotations, and can lead to caching\n575              *  issues (see [databind#75]). Instead, must be done from 'createContextual()' call.\n576              *  But we do need to check class annotations.\n577              */\n578             JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n579             if (mlt.isTrueMapType()) {\n580                 return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n581                         keySerializer, elementTypeSerializer, elementValueSerializer);\n582             }\n583             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n584             JsonSerializer<?> ser = null;\n585             for (Serializers serializers : customSerializers()) { // (1) Custom\n586                 MapLikeType mlType = (MapLikeType) type;\n587                 ser = serializers.findMapLikeSerializer(config,\n588                         mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n589             if (ser != null) {\n590                 if (_factoryConfig.hasSerializerModifiers()) {\n591                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n592                         ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n593                     }\n594                     }\n595                     return ser;\n596                 }\n597             }\n598             return null;\n599         }\n600         if (type.isCollectionLikeType()) {\n601             CollectionLikeType clt = (CollectionLikeType) type;\n602             if (clt.isTrueCollectionType()) {\n603                 return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n604                         elementTypeSerializer, elementValueSerializer);\n605             }\n606             // With Map-like, just 2 options: (1) Custom, (2) Annotations\n607             JsonSerializer<?> ser = null;\n608             CollectionLikeType clType = (CollectionLikeType) type;\n609             for (Serializers serializers : customSerializers()) { // (1) Custom\n610                 ser = serializers.findCollectionLikeSerializer(config,\n611                         clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n612             if (ser != null) {\n613                 if (_factoryConfig.hasSerializerModifiers()) {\n614                     for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n615                         ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n616                         }\n617                     }\n618                     return ser;\n619                 }\n620             }\n621             return null;\n622         }\n623         if (type.isArrayType()) {\n624             return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n625                     elementTypeSerializer, elementValueSerializer);\n626         }\n627         return null;\n628     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.BasicSerializerFactory"}, {"bug_name": "JacksonDatabind_24", "report_text": "> Configuring an ObjectMapper's DateFormat changes time zone when serialising Joda DateTime\n> \n> The serialisation of Joda `DateTime` instances behaves differently in 2.6.0 vs 2.5.4 when the `ObjectMapper`'s had its `DateFormat` configured. The behaviour change is illustrated by the following code:\n> ```\n> public static void main(String[] args) throws JsonProcessingException {\n>     System.out.println(createObjectMapper()\n>             .writeValueAsString(new DateTime(1988, 6, 25, 20, 30, DateTimeZone.UTC)));\n> }\n> private static ObjectMapper createObjectMapper() {\n>     ObjectMapper mapper = new ObjectMapper();\n>     mapper.registerModule(createJodaModule());\n>     mapper.configure(SerializationFeature.WRITE\\_DATES\\_AS\\_TIMESTAMPS, false);\n>     System.out.println(mapper.getSerializationConfig().getTimeZone());\n>     mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"));\n>     System.out.println(mapper.getSerializationConfig().getTimeZone());\n>     return mapper;\n> }\n> private static SimpleModule createJodaModule() {\n>     SimpleModule module = new SimpleModule();\n>     module.addSerializer(DateTime.class, new DateTimeSerializer(\n>             new JacksonJodaDateFormat(DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\")\n>                     .withZoneUTC())));\n>         return module;\n>     }\n> ```\n> When run with Jackson 2.5.4 the output is:\n> ```\n> sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\n> sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\n> \"1988-06-25 20:30:00\"\n> ```\n> When run with Jackson 2.6.0 the output is:\n> ```\n> sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]\n> sun.util.calendar.ZoneInfo[id=\"Europe/London\",offset=0,dstSavings=3600000,useDaylight=true,transitions=242,lastRule=java.util.SimpleTimeZone[id=Europe/London,offset=0,dstSavings=3600000,useDaylight=true,startYear=0,startMode=2,startMonth=2,startDay=-1,startDayOfWeek=1,startTime=3600000,startTimeMode=2,endMode=2,endMonth=9,endDay=-1,endDayOfWeek=1,endTime=3600000,endTimeMode=2]]\n> \"1988-06-25 21:30:00\"\n> ```\n> It looks like the fix for [#824](https://github.com/FasterXML/jackson-databind/issues/824) is the cause. In 2.6, the call to `mapper.setDateFormat` causes the `ObjectMapper`'s time zone to be set to the JVM's default time zone. In 2.5.x, calling `mapper.setDateFormat` has no effect on its time zone.", "test_name": "com.fasterxml.jackson.databind.ser.TestConfig::testDateFormatConfig", "test_method": "    public void testDateFormatConfig() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        TimeZone tz1 = TimeZone.getTimeZone(\"America/Los_Angeles\");\n        TimeZone tz2 = TimeZone.getTimeZone(\"Central Standard Time\");\n\n        // sanity checks\n        if (tz1.equals(tz2)) {\n            fail();\n        }\n\n        mapper.setTimeZone(tz1);\n\n        // also better stick via reader/writer as well\n        \n        SimpleDateFormat f = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        f.setTimeZone(tz2);\n        mapper.setDateFormat(f);\n\n        // should not change the timezone tho\n        assertEquals(tz1, mapper.getSerializationConfig().getTimeZone()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<sun.util.calendar.ZoneInfo[id=\"America/Los_Angeles\",offset=-28800000,dstSavings=3600000,useDaylight=true,transitions=185,lastRule=java.util.SimpleTimeZone[id=America/Los_Angeles,offset=-28800000,dstSavings=3600000,useDaylight=true,startYear=0,startMode=3,startMonth=2,startDay=8,startDayOfWeek=1,startTime=7200000,startTimeMode=0,endMode=3,endMonth=10,endDay=1,endDayOfWeek=1,endTime=7200000,endTimeMode=0]]> but was:<sun.util.calendar.ZoneInfo[id=\"GMT\",offset=0,dstSavings=0,useDaylight=false,transitions=0,lastRule=null]>\n\tcom.fasterxml.jackson.databind.ser.TestConfig.testDateFormatConfig(TestConfig.java:221)", "buggy_method": "230 public BaseSettings withDateFormat(DateFormat df) {\n231         if (_dateFormat == df) {\n232             return this;\n233         }\n234         TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n235         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n236                 _typeResolverBuilder, df, _handlerInstantiator, _locale,\n237                 tz, _defaultBase64);\n238     }", "bm_classpath": "com.fasterxml.jackson.databind.cfg.BaseSettings"}, {"bug_name": "JacksonDatabind_25", "report_text": "> Exception deserializing a byte[] when the target type comes from an annotation\n> \n> When trying to deserialize a `byte[]` from a `Map` when the deserialization type comes from an annotation, I'm seeing the following exception:\n> ```\n> java.lang.IllegalArgumentException: Can not deserialize Class [B (of type array) as a Bean\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.isPotentialBeanType(BeanDeserializerFactory.java:808)\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:138)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n>         at com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)\n>         at com.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n>         at com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n>         at com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)\n>         at com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)\n>         at com.fasterxml.jackson.databind.ObjectMapper._convert(ObjectMapper.java:3418)\n>         at com.fasterxml.jackson.databind.ObjectMapper.convertValue(ObjectMapper.java:3351)\n> ```\n> The below is a repro.\n> ```\n> public class JacksonTest {\n>     static class Foo {\n>         @JsonProperty\n>         @JsonDeserialize(as=byte[].class)\n>         Object someBytes;\n>     }\n>     public void testFooFromMap() {\n>         Map<String, Object> map = new HashMap<>();\n>         map.put(\"someBytes\", \"HelloWorld\".getBytes());\n>         ObjectMapper m = new ObjectMapper();\n>         m.convertValue(map, Foo.class);\n>     }\n> }\n> ```\n> I discovered this on 2.5.1, but I tried 2.6.0 and it's exhibiting the same behavior.\n> Thanks!", "test_name": "com.fasterxml.jackson.databind.deser.TestArrayDeserialization::testByteArrayTypeOverride890", "test_method": "    public void testByteArrayTypeOverride890() throws Exception\n    {\n        HiddenBinaryBean890 result = MAPPER.readValue(\n                aposToQuotes(\"{'someBytes':'AQIDBA=='}\"), HiddenBinaryBean890.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize Class [B (of type array) as a Bean\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:428)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.findDeserializer(StdDeserializer.java:947)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:439)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:296)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:461)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3804)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3698)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2714)\n\tcom.fasterxml.jackson.databind.deser.TestArrayDeserialization.testByteArrayTypeOverride890(TestArrayDeserialization.java:563)", "buggy_method": "1747 @SuppressWarnings({ \"unchecked\" })\n1748     protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n1749             Annotated a, T type)\n1750         throws JsonMappingException\n1751     {\n1752         // first: let's check class for the instance itself:\n1753         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n1754         Class<?> subclass = intr.findDeserializationType(a, type);\n1755         if (subclass != null) {\n1756             try {\n1757                 type = (T) type.narrowBy(subclass);\n1758             } catch (IllegalArgumentException iae) {\n1759                 throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n1760             }\n1761         }\n1762 \n1763         // then key class\n1764         if (type.isContainerType()) {\n1765             Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n1766             if (keyClass != null) {\n1767                 // illegal to use on non-Maps\n1768                 if (!(type instanceof MapLikeType)) {\n1769                     throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n1770                 }\n1771                 try {\n1772                     type = (T) ((MapLikeType) type).narrowKey(keyClass);\n1773                 } catch (IllegalArgumentException iae) {\n1774                     throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n1775                 }\n1776             }\n1777             JavaType keyType = type.getKeyType();\n1778             /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n1779              *   (not 100% why or how, but this does seem to get called more than once, which\n1780              *   is not good: for now, let's just avoid errors)\n1781              */\n1782             if (keyType != null && keyType.getValueHandler() == null) {\n1783                 Object kdDef = intr.findKeyDeserializer(a);\n1784                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n1785                 if (kd != null) {\n1786                     type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n1787                     keyType = type.getKeyType(); // just in case it's used below\n1788                 }\n1789             }            \n1790            \n1791            // and finally content class; only applicable to structured types\n1792            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n1793            if (cc != null) {\n1794                try {\n1795                    type = (T) type.narrowContentsBy(cc);\n1796                } catch (IllegalArgumentException iae) {\n1797                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n1798                }\n1799            }\n1800            // ... as well as deserializer for contents:\n1801            JavaType contentType = type.getContentType();\n1802            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n1803                Object cdDef = intr.findContentDeserializer(a);\n1804                 JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n1805                 if (cd != null) {\n1806                     type = (T) type.withContentValueHandler(cd);\n1807                 }\n1808             }\n1809         }\n1810         return type;\n1811     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"}, {"bug_name": "JacksonDatabind_27", "report_text": "> Problem deserializing External Type Id if type id comes before POJO\n> \n> (note: seems to be similar or related to [FasterXML/jackson-module-afterburner#58](https://github.com/FasterXML/jackson-module-afterburner/issues/58))\n> With 2.6, looks like handling of External Type Id is broken in some rare (?) cases; existing unit tests did not catch this. At this point I am speculating this is due to some refactoring, or change to use more efficient 'nextFieldName()' method.", "test_name": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testInverseExternalId928", "test_method": "    public void testInverseExternalId928() throws Exception\n    {\n        final String CLASS = Payload928.class.getName();\n\n        ObjectMapper mapper = new ObjectMapper();\n\n        final String successCase = \"{\\\"payload\\\":{\\\"something\\\":\\\"test\\\"},\\\"class\\\":\\\"\"+CLASS+\"\\\"}\";\n        Envelope928 envelope1 = mapper.readValue(successCase, Envelope928.class);\n\n        // and then re-ordered case that was problematic\n        final String failCase = \"{\\\"class\\\":\\\"\"+CLASS+\"\\\",\\\"payload\\\":{\\\"something\\\":\\\"test\\\"}}\";\n        Envelope928 envelope2 = mapper.readValue(failCase, Envelope928.class); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: No fallback setter/field defined: can not use creator property for com.fasterxml.jackson.databind.deser.CreatorProperty\n\tcom.fasterxml.jackson.databind.deser.CreatorProperty.set(CreatorProperty.java:198)\n\tcom.fasterxml.jackson.databind.deser.CreatorProperty.deserializeAndSet(CreatorProperty.java:180)\n\tcom.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler._deserializeAndSet(ExternalTypeHandler.java:253)\n\tcom.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler.handlePropertyValue(ExternalTypeHandler.java:119)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId(BeanDeserializer.java:794)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:716)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:292)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:131)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3731)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2724)\n\tcom.fasterxml.jackson.databind.jsontype.TestExternalId.testInverseExternalId928(TestExternalId.java:495)", "buggy_method": "773 @SuppressWarnings(\"resource\")\n774     protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n775         throws IOException\n776     {\n777         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n778         final PropertyBasedCreator creator = _propertyBasedCreator;\n779         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n780 \n781         TokenBuffer tokens = new TokenBuffer(p);\n782         tokens.writeStartObject();\n783 \n784         JsonToken t = p.getCurrentToken();\n785         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n786             String propName = p.getCurrentName();\n787             p.nextToken(); // to point to value\n788             // creator property?\n789             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n790             if (creatorProp != null) {\n791                 // first: let's check to see if this might be part of value with external type id:\n792                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n793                 //   since it is not the bean\n794                 if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n795                     ;\n796                 } else {\n797                     // Last creator property to set?\n798                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n799                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n800                         Object bean;\n801                         try {\n802                             bean = creator.build(ctxt, buffer);\n803                         } catch (Exception e) {\n804                             wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n805                             continue; // never gets here\n806                         }\n807                         // if so, need to copy all remaining tokens into buffer\n808                         while (t == JsonToken.FIELD_NAME) {\n809                             p.nextToken(); // to skip name\n810                             tokens.copyCurrentStructure(p);\n811                             t = p.nextToken();\n812                         }\n813                         if (bean.getClass() != _beanType.getRawClass()) {\n814                             // !!! 08-Jul-2011, tatu: Could theoretically support; but for now\n815                             //   it's too complicated, so bail out\n816                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n817                         }\n818                         return ext.complete(p, ctxt, bean);\n819                     }\n820                 }\n821                 continue;\n822             }\n823             // Object Id property?\n824             if (buffer.readIdProperty(propName)) {\n825                 continue;\n826             }\n827             // regular property? needs buffering\n828             SettableBeanProperty prop = _beanProperties.find(propName);\n829             if (prop != null) {\n830                 buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n831                 continue;\n832             }\n833             // external type id (or property that depends on it)?\n834             if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n835                 continue;\n836             }\n837             /* As per [JACKSON-313], things marked as ignorable should not be\n838              * passed to any setter\n839              */\n840             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n841                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n842                 continue;\n843             }\n844             // \"any property\"?\n845             if (_anySetter != null) {\n846                 buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n847             }\n848         }\n849 \n850         // We hit END_OBJECT; resolve the pieces:\n851         try {\n852             return ext.complete(p, ctxt, buffer, creator);\n853         } catch (Exception e) {\n854             wrapInstantiationProblem(e, ctxt);\n855             return null; // never gets here\n856         }\n857     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializer"}, {"bug_name": "JacksonDatabind_28", "report_text": "> Deserialization from \"{}\" to ObjectNode field causes \"out of END_OBJECT token\" error\n> \n> I found that deserializing from an empty object (`{}`) to ObjectNode field in a class field fails.\n> Here is the minimum code to reproduce:\n> ```\n> public class Main\n> {\n>     public static class MyValue\n>     {\n>         private final ObjectNode object;\n>         @JsonCreator\n>         public MyValue(ObjectNode object) { this.object = object; }\n>         @JsonValue\n>         public ObjectNode getObject() { return object; }\n>     }\n>     public static void main(String[] args)\n>             throws Exception\n>     {\n>         ObjectMapper om = new ObjectMapper();\n>         ObjectNode object = new ObjectNode(JsonNodeFactory.instance);\n>         String json = om.writeValueAsString(object);\n>         System.out.println(\"json: \"+json);\n>         ObjectNode de1 = om.readValue(json, ObjectNode.class);  // this works\n>         System.out.println(\"Deserialized to ObjectNode: \"+de1);\n>         MyValue de2 = om.readValue(json, MyValue.class);  // but this throws exception\n>         System.out.println(\"Deserialized to MyValue: \"+de2);\n>     }\n> }\n> ```\n> Result is:\n> ```\n> json: {}\n> Deserialized to ObjectNode: {}\n> Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token\n>  at [Source: {}; line: 1, column: 2]\n>         at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n>         at com.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:854)\n>         at com.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:850)\n>         at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:104)\n>         at com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:83)\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1095)\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:294)\n>         at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:131)\n>         at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3731)\n>         at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2724)\n>         at Main.main(Main.java:35)\n> ```\n> If the object is not empty (e.g. `{\"k\":\"v\"}`), it works:\n> ```\n>         ...\n>         ObjectNode object = new ObjectNode(JsonNodeFactory.instance);\n>         object.put(\"k\", \"v\");  // added\n>         ...\n> ```\n> ```\n> json: {\"k\":\"v\"}\n> Deserialized to ObjectNode: {\"k\":\"v\"}\n> Deserialized to MyValue: io.digdag.cli.Main$MyValue@17550481\n> ```\n> Environment:\n> * jackson-core 2.6.2\n> * jackson-databind 2.6.2\n> * Java 8 (`Java(TM) SE Runtime Environment (build 1.8.0_20-b26)`)", "test_name": "com.fasterxml.jackson.databind.node.TestObjectNode::testIssue941", "test_method": "    public void testIssue941() throws Exception\n    {\n        ObjectNode object = MAPPER.createObjectNode();\n\n        String json = MAPPER.writeValueAsString(object);\n        System.out.println(\"json: \"+json);\n\n        ObjectNode de1 = MAPPER.readValue(json, ObjectNode.class);  // this works\n        System.out.println(\"Deserialized to ObjectNode: \"+de1);\n\n        MyValue de2 = MAPPER.readValue(json, MyValue.class);  // but this throws exception // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.node.ObjectNode out of END_OBJECT token\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:854)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:850)\n\tcom.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:106)\n\tcom.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer.deserialize(JsonNodeDeserializer.java:83)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1095)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:296)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:133)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3731)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2724)\n\tcom.fasterxml.jackson.databind.node.TestObjectNode.testIssue941(TestObjectNode.java:411)", "buggy_method": "94 @Override\n95         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n96         {\n97             if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n98                 p.nextToken();\n99                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n100             }\n101             // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n102             //    if caller has advanced to the first token of Object, but for empty Object\n103             if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n104                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n105             }\n106             throw ctxt.mappingException(ObjectNode.class);\n107          }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer$ObjectDeserializer"}, {"bug_name": "JacksonDatabind_29", "report_text": "> Handle null type id for polymorphic values that use external type id\n> \n> What actual problem is this fixing? Could you provide a test case to show the problem you have. I am not sure, looking at the patch alone, that this is a valid change. Type Ids are typically required, unless there is `defaultImpl` defined. How should actual expected polymorphic type determined, if no type id is available?", "test_name": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testExternalTypeIdWithNull", "test_method": "    public void testExternalTypeIdWithNull() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.registerSubtypes(ValueBean.class);\n        ExternalBean b;\n        b = mapper.readValue(aposToQuotes(\"{'bean':null,'extType':'vbean'}\"),\n                ExternalBean.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.jsontype.TestExternalId$ValueBean out of VALUE_STRING token\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:854)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:850)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:168)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:136)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:110)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromAny(AsArrayTypeDeserializer.java:68)\n\tcom.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:550)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:518)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler._deserializeAndSet(ExternalTypeHandler.java:260)\n\tcom.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler.handlePropertyValue(ExternalTypeHandler.java:119)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:756)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:720)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:294)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:133)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3730)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2723)\n\tcom.fasterxml.jackson.databind.jsontype.TestExternalId.testExternalTypeIdWithNull(TestExternalId.java:288)", "buggy_method": "221 @SuppressWarnings(\"resource\")\n222     protected final Object _deserialize(JsonParser p, DeserializationContext ctxt,\n223             int index, String typeId) throws IOException\n224     {\n225         JsonParser p2 = _tokens[index].asParser(p);\n226         JsonToken t = p2.nextToken();\n227         // 29-Sep-2015, tatu: As per [databind#942], nulls need special support\n228 \n229         TokenBuffer merged = new TokenBuffer(p);\n230         merged.writeStartArray();\n231         merged.writeString(typeId);\n232         merged.copyCurrentStructure(p2);\n233         merged.writeEndArray();\n234 \n235         // needs to point to START_OBJECT (or whatever first token is)\n236         JsonParser mp = merged.asParser(p);\n237         mp.nextToken();\n238         return _properties[index].getProperty().deserialize(mp, ctxt);\n239     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"}, {"bug_name": "JacksonDatabind_30", "report_text": "> BigDecimal values via @JsonTypeInfo/@JsonSubTypes get rounded\n> \n> When using an `ObjectMapper` to serialize/deserialize a class with an `Object` field annotated with a `@JsonSubTypes.Type` that indicate `BigDecimal`, it looks like the value is getting rounded to a double.\n> I tried configuring `DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS`, but that didn't seem to help.\n> What I think is a valid repro is below, but let me know if I'm actually doing something wrong here.\n> Thanks!\n> ```\n> import org.junit.Test;\n> import org.junit.Assert;\n> import java.math.BigDecimal;\n> import com.fasterxml.jackson.annotation.*;\n> import com.fasterxml.jackson.databind.DeserializationFeature;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class JacksonTest {\n>     enum Type { BIG\\_DECIMAL }\n>     static class Wrapper {\n>         @JsonIgnore\n>         Type typeEnum;\n>         @JsonIgnore\n>         Object value;\n>         Wrapper() { }\n>         @JsonGetter(value = \"type\")\n>         String getTypeString() {\n>             return typeEnum.name();\n>         }\n>         @JsonSetter(value = \"type\")\n>         void setTypeString(String type) {\n>             this.typeEnum = Type.valueOf(type);\n>         }\n>         @JsonGetter(value = \"objectValue\") \n>         Object getValue() {\n>             return value;\n>         }\n>         @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXTERNAL\\_PROPERTY, property = \"type\")\n>         @JsonSubTypes({ @JsonSubTypes.Type(name = \"BIG\\_DECIMAL\", value = BigDecimal.class) })\n>         @JsonSetter(value = \"objectValue\") \n>         private void setValue(Object value) {\n>             this.value = value;\n>         }\n>     }\n>     @Test\n>     public void test() throws Exception {\n>         ObjectMapper m = new ObjectMapper();\n>         m.configure(DeserializationFeature.USE\\_BIG\\_DECIMAL\\_FOR\\_FLOATS, true);\n>         Wrapper w = new Wrapper();\n>         w.typeEnum = Type.BIG\\_DECIMAL;\n>         w.value = new BigDecimal(\"-10000000000.0000000001\");\n>         String json = m.writeValueAsString(w);\n>         Wrapper w2 = m.readValue(json, Wrapper.class);\n>         Assert.assertEquals(w.typeEnum, w2.typeEnum);\n>         Assert.assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n>             w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n>             w.value.equals(w2.value));\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.jsontype.TestExternalId::testBigDecimal965", "test_method": "    public void testBigDecimal965() throws Exception\n    {\n\n        Wrapper965 w = new Wrapper965();\n        w.typeEnum = Type965.BIG_DECIMAL;\n        final String NUM_STR = \"-10000000000.0000000001\";\n        w.value = new BigDecimal(NUM_STR);\n\n        String json = MAPPER.writeValueAsString(w);\n\n        // simple sanity check so serialization is faithful\n        if (!json.contains(NUM_STR)) {\n            fail(\"JSON content should contain value '\"+NUM_STR+\"', does not appear to: \"+json);\n        }\n        \n        Wrapper965 w2 = MAPPER.readerFor(Wrapper965.class)\n                .with(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n                .readValue(json);\n\n        assertTrue(String.format(\"Expected %s = %s; got back %s = %s\",\n            w.value.getClass().getSimpleName(), w.value.toString(), w2.value.getClass().getSimpleName(), w2.value.toString()),\n            w.value.equals(w2.value)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected BigDecimal = -10000000000.0000000001; got back BigDecimal = -1.0E+10\n\tcom.fasterxml.jackson.databind.jsontype.TestExternalId.testBigDecimal965(TestExternalId.java:564)", "buggy_method": "2504 @SuppressWarnings({ \"unchecked\", \"resource\" })\n2505     public <T extends JsonNode> T valueToTree(Object fromValue)\n2506         throws IllegalArgumentException\n2507     {\n2508         if (fromValue == null) return null;\n2509         TokenBuffer buf = new TokenBuffer(this, false);\n2510         JsonNode result;\n2511         try {\n2512             writeValue(buf, fromValue);\n2513             JsonParser jp = buf.asParser();\n2514             result = readTree(jp);\n2515             jp.close();\n2516         } catch (IOException e) { // should not occur, no real i/o...\n2517             throw new IllegalArgumentException(e.getMessage(), e);\n2518         }\n2519         return (T) result;\n2520     }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectMapper"}, {"bug_name": "JacksonDatabind_31", "report_text": "> JsonStreamContexts are not build the same way for write.. and convert methods\n> \n> HI  \n> I got an issue reported in my jackson-antpathfilter project that the filtering is not working correctly when it is used together with Jackson's convert feature: [Antibrumm/jackson-antpathfilter#2](https://github.com/Antibrumm/jackson-antpathfilter/issues/2)\n> During the investigation i found out that the cause is that the writeContext is created differently and I am wondering if this is the desired behavior or if that's a bug for you.\n> In this comment ([Antibrumm/jackson-antpathfilter#2 (comment)](https://github.com/Antibrumm/jackson-antpathfilter/issues/2#issuecomment-145211847)) I print out what is found in the writeContext and I have created a TestCase to reproduce the error.\n> Please let me know what you think.", "test_name": "com.fasterxml.jackson.databind.util.TestTokenBuffer::testOutputContext", "test_method": "    public void testOutputContext() throws IOException\n    {\n        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec\n        StringWriter w = new StringWriter();\n        JsonGenerator gen = MAPPER.getFactory().createGenerator(w);\n \n        // test content: [{\"a\":1,\"b\":{\"c\":2}},{\"a\":2,\"b\":{\"c\":3}}]\n\n        buf.writeStartArray();\n        gen.writeStartArray();\n        _verifyOutputContext(buf, gen);\n        \n        buf.writeStartObject();\n        gen.writeStartObject();\n        _verifyOutputContext(buf, gen);\n        \n        buf.writeFieldName(\"a\");\n        gen.writeFieldName(\"a\");\n        _verifyOutputContext(buf, gen);\n\n        buf.writeNumber(1);\n        gen.writeNumber(1);\n        _verifyOutputContext(buf, gen);\n\n        buf.writeFieldName(\"b\");\n        gen.writeFieldName(\"b\");\n        _verifyOutputContext(buf, gen); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected name 'b' (JsonParser), TokenBuffer had 'a'\n\tcom.fasterxml.jackson.databind.util.TestTokenBuffer._verifyOutputContext(TestTokenBuffer.java:338)\n\tcom.fasterxml.jackson.databind.util.TestTokenBuffer._verifyOutputContext(TestTokenBuffer.java:315)\n\tcom.fasterxml.jackson.databind.util.TestTokenBuffer.testOutputContext(TestTokenBuffer.java:283)", "buggy_method": "681 @Override\n682     public void writeString(SerializableString text) throws IOException {\n683         if (text == null) {\n684             writeNull();\n685         } else {\n686             _append(JsonToken.VALUE_STRING, text);\n687         }\n688     }", "bm_classpath": "com.fasterxml.jackson.databind.util.TokenBuffer"}, {"bug_name": "JacksonDatabind_32", "report_text": "> Deserialization from \"{}\" to java.lang.Object causes \"out of END_OBJECT token\" error\n> \n> Hi, I've faced with a problem that is too similar this one [#941](https://github.com/FasterXML/jackson-databind/issues/941). I expect that \"{}\" will be parsed correctly to empty Map when I'm using `@JsonCreator`\n> I've found that this case is invalid <https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.6.3/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java#L272>, but why?\n> Here is the minimum code to reproduce:\n> ```\n> import java.io.IOException;\n> import com.fasterxml.jackson.annotation.JsonCreator;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class Main {\n>     public static void main(String[] args) throws IOException {\n>         ObjectMapper mapper = new ObjectMapper();\n>         mapper.readValue(\"[]\", SomeObjectThatCanBeAggregated.class);\n>         mapper.readValue(\"[{}]\", SomeObjectThatCanBeAggregated.class);\n>         mapper.readValue(\"{\\\"key\\\":null}\", SomeObjectThatCanBeAggregated.class);\n>         mapper.readValue(\"{}\", SomeObjectThatCanBeAggregated.class);\n>     }\n> }\n> class SomeObjectThatCanBeAggregated {\n>     @JsonCreator\n>     public SomeObjectThatCanBeAggregated(Object obj) {\n>         System.out.println(obj + \" //\" + obj.getClass());\n>     }\n> }\n> ```\n> Output:\n> ```\n> [] //class java.util.ArrayList\n> [{}] //class java.util.ArrayList\n> {key=null} //class java.util.LinkedHashMap\n> Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of java.lang.Object out of END_OBJECT token\n>  at [Source: {}; line: 1, column: 2]\n> ...\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.TestUntypedDeserialization::testNestedUntyped989", "test_method": "    public void testNestedUntyped989() throws IOException\n    {\n        Untyped989 pojo;\n        ObjectReader r = MAPPER.readerFor(Untyped989.class);\n\n        pojo = r.readValue(\"[]\");\n        pojo = r.readValue(\"[{}]\");\n        \n        pojo = r.readValue(\"{}\"); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of java.lang.Object out of END_OBJECT token\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:857)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:853)\n\tcom.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserialize(UntypedObjectDeserializer.java:540)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1095)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:296)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:133)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1511)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1136)\n\tcom.fasterxml.jackson.databind.deser.TestUntypedDeserialization.testNestedUntyped989(TestUntypedDeserialization.java:264)", "buggy_method": "483 @Override\n484         public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n485         {\n486             switch (p.getCurrentTokenId()) {\n487             case JsonTokenId.ID_START_OBJECT:\n488                 {\n489                     JsonToken t = p.nextToken();\n490                     if (t == JsonToken.END_OBJECT) {\n491                         return new LinkedHashMap<String,Object>(2);\n492                     }\n493                 }\n494             case JsonTokenId.ID_FIELD_NAME:\n495                 return mapObject(p, ctxt);\n496             case JsonTokenId.ID_START_ARRAY:\n497                 {\n498                     JsonToken t = p.nextToken();\n499                     if (t == JsonToken.END_ARRAY) { // and empty one too\n500                         if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n501                             return NO_OBJECTS;\n502                         }\n503                         return new ArrayList<Object>(2);\n504                     }\n505                 }\n506                 if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n507                     return mapArrayToArray(p, ctxt);\n508                 }\n509                 return mapArray(p, ctxt);\n510             case JsonTokenId.ID_EMBEDDED_OBJECT:\n511                 return p.getEmbeddedObject();\n512             case JsonTokenId.ID_STRING:\n513                 return p.getText();\n514 \n515             case JsonTokenId.ID_NUMBER_INT:\n516                 if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n517                     return _coerceIntegral(p, ctxt);\n518                 }\n519                 return p.getNumberValue(); // should be optimal, whatever it is\n520 \n521             case JsonTokenId.ID_NUMBER_FLOAT:\n522                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n523                     return p.getDecimalValue();\n524                 }\n525                 return Double.valueOf(p.getDoubleValue());\n526 \n527             case JsonTokenId.ID_TRUE:\n528                 return Boolean.TRUE;\n529             case JsonTokenId.ID_FALSE:\n530                 return Boolean.FALSE;\n531 \n532             case JsonTokenId.ID_NULL: // should not get this but...\n533                 return null;\n534 \n535                 // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n536                 //    if caller has advanced to the first token of Object, but for empty Object\n537 \n538             //case JsonTokenId.ID_END_ARRAY: // invalid\n539             default:\n540                 throw ctxt.mappingException(Object.class);\n541             }\n542         }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla"}, {"bug_name": "JacksonDatabind_33", "report_text": "> @JsonUnwrapped is not treated as assuming @JsonProperty(\"\")\n> \n> See discussion [here](https://groups.google.com/forum/#!topic/jackson-user/QLpWb8YzIoE) but basically `@JsonUnwrapped` on a private field by itself does not cause that field to be serialized, currently, You need to add an explicit `@JsonProperty`. You shouldn't have to do that. (Following test fails currently, should pass, though you can make it pass by commenting out the line with `@JsonProperty`. Uses TestNG and AssertJ.)\n> ```\n> package com.bakins\\_bits;\n> import static org.assertj.core.api.Assertions.assertThat;\n> import org.testng.annotations.Test;\n> import com.fasterxml.jackson.annotation.JsonUnwrapped;\n> import com.fasterxml.jackson.core.JsonProcessingException;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class TestJsonUnwrappedShouldMakePrivateFieldsSerializable\n> {\n>     public static class Inner\n>     {\n>         public String animal;\n>     }\n>     public static class Outer\n>     {\n>         // @JsonProperty\n>         @JsonUnwrapped\n>         private Inner inner;\n>     }\n>     @Test\n>     public void jsonUnwrapped\\_should\\_make\\_private\\_fields\\_serializable() throws JsonProcessingException {\n>         // ARRANGE\n>         Inner inner = new Inner();\n>         inner.animal = \"Zebra\";\n>         Outer outer = new Outer();\n>         outer.inner = inner;\n>         ObjectMapper sut = new ObjectMapper();\n>         // ACT\n>         String actual = sut.writeValueAsString(outer);\n>         // ASSERT\n>         assertThat(actual).contains(\"animal\");\n>         assertThat(actual).contains(\"Zebra\");\n>         assertThat(actual).doesNotContain(\"inner\");\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.struct.TestUnwrapped::testUnwrappedAsPropertyIndicator", "test_method": "    public void testUnwrappedAsPropertyIndicator() throws Exception\n    {\n        Inner inner = new Inner();\n        inner.animal = \"Zebra\";\n\n        Outer outer = new Outer();\n        outer.inner = inner;\n\n        String actual = MAPPER.writeValueAsString(outer); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class com.fasterxml.jackson.databind.struct.TestUnwrapped$Outer and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )\n\tcom.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:69)\n\tcom.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:32)\n\tcom.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:130)\n\tcom.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3559)\n\tcom.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:2927)\n\tcom.fasterxml.jackson.databind.struct.TestUnwrapped.testUnwrappedAsPropertyIndicator(TestUnwrapped.java:189)", "buggy_method": "730 @Override\n731     public PropertyName findNameForSerialization(Annotated a)\n732     {\n733         String name = null;\n734 \n735         JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n736         if (jg != null) {\n737             name = jg.value();\n738         } else {\n739             JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n740             if (pann != null) {\n741                 name = pann.value();\n742                 /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n743                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n744                  *   add more lookups; AnnotationMap costs etc)\n745                  */\n746             } else if (_hasAnnotation(a, JsonSerialize.class)\n747                     || _hasAnnotation(a, JsonView.class)\n748                     || _hasAnnotation(a, JsonRawValue.class)) {\n749                 name = \"\";\n750             } else {\n751                 return null;\n752             }\n753         }\n754         return PropertyName.construct(name);\n755     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector"}, {"bug_name": "JacksonDatabind_34", "report_text": "> Regression in 2.7.0-rc2, for schema/introspection for BigDecimal\n> \n> (found via Avro module, but surprisingly json schema module has not test to catch it)\n> Looks like schema type for `BigDecimal` is not correctly produced, due to an error in refactoring (made to simplify introspection for simple serializers): it is seen as `BigInteger` (and for Avro, for example, results in `long` getting written).", "test_name": "com.fasterxml.jackson.databind.jsonschema.NewSchemaTest::testSimpleNumbers", "test_method": "    public void testSimpleNumbers() throws Exception\n    {\n        final StringBuilder sb = new StringBuilder();\n        \n        MAPPER.acceptJsonFormatVisitor(Numbers.class,\n                new JsonFormatVisitorWrapper.Base() {\n            @Override\n            public JsonObjectFormatVisitor expectObjectFormat(final JavaType type) {\n                return new JsonObjectFormatVisitor.Base(getProvider()) {\n                    @Override\n                    public void optionalProperty(BeanProperty prop) throws JsonMappingException {\n                        sb.append(\"[optProp \").append(prop.getName()).append(\"(\");\n                        JsonSerializer<Object> ser = null;\n                        if (prop instanceof BeanPropertyWriter) {\n                            BeanPropertyWriter bpw = (BeanPropertyWriter) prop;\n                            ser = bpw.getSerializer();\n                        }\n                        final SerializerProvider prov = getProvider();\n                        if (ser == null) {\n                            ser = prov.findValueSerializer(prop.getType(), prop);\n                        }\n                        ser.acceptJsonFormatVisitor(new JsonFormatVisitorWrapper.Base() {\n                            @Override\n                            public JsonNumberFormatVisitor expectNumberFormat(\n                                    JavaType type) throws JsonMappingException {\n                                return new JsonNumberFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[numberFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n\n                            @Override\n                            public JsonIntegerFormatVisitor expectIntegerFormat(JavaType type) throws JsonMappingException {\n                                return new JsonIntegerFormatVisitor() {\n                                    @Override\n                                    public void format(JsonValueFormat format) {\n                                        sb.append(\"[integerFormat=\").append(format).append(\"]\");\n                                    }\n\n                                    @Override\n                                    public void enumTypes(Set<String> enums) { }\n\n                                    @Override\n                                    public void numberType(NumberType numberType) {\n                                        sb.append(\"[numberType=\").append(numberType).append(\"]\");\n                                    }\n                                };\n                            }\n                        }, prop.getType());\n\n                        sb.append(\")]\");\n                    }\n                };\n            }\n        });\n        assertEquals(\"[optProp dec([numberType=BIG_DECIMAL])][optProp bigInt([numberType=BIG_INTEGER])]\",\n                sb.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...dec([numberType=BIG_[DECIMAL]])][optProp bigInt([...> but was:<...dec([numberType=BIG_[INTEGER]])][optProp bigInt([...>\n\tcom.fasterxml.jackson.databind.jsonschema.NewSchemaTest.testSimpleNumbers(NewSchemaTest.java:204)", "buggy_method": "73 @Override\n74     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n75     {\n76         if (_isInt) {\n77             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n78         } else {\n79             Class<?> h = handledType();\n80             if (h == BigDecimal.class) {\n81                 visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n82             } else {\n83                 // otherwise bit unclear what to call... but let's try:\n84                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n85             }\n86         }\n87     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.NumberSerializer"}, {"bug_name": "JacksonDatabind_35", "report_text": "> Problem with Object Id and Type Id as Wrapper Object (regression in 2.5.1)\n> \n> (note: originally from [FasterXML/jackson-module-jaxb-annotations#51](https://github.com/FasterXML/jackson-module-jaxb-annotations/issues/51))\n> Looks like fix for [#669](https://github.com/FasterXML/jackson-databind/issues/669) caused a regression for the special use case of combining type and object ids, with wrapper-object type id inclusion. The problem started with 2.5.1.", "test_name": "com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest::testSimple", "test_method": "    public void testSimple() throws Exception\n    {\n        Company comp = new Company();\n        comp.addComputer(new DesktopComputer(\"computer-1\", \"Bangkok\"));\n        comp.addComputer(new DesktopComputer(\"computer-2\", \"Pattaya\"));\n        comp.addComputer(new LaptopComputer(\"computer-3\", \"Apple\"));\n\n        final ObjectMapper mapper = new ObjectMapper();\n\n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(comp);\n\n        System.out.println(\"JSON: \"+json);\n\n        Company result = mapper.readValue(json, Company.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (FIELD_NAME), expected START_OBJECT: need JSON Object to contain As.WRAPPER_OBJECT type information for class com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest$Computer\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:148)\n\tcom.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:927)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer._deserialize(AsWrapperTypeDeserializer.java:90)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer.deserializeTypedFromObject(AsWrapperTypeDeserializer.java:49)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:966)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:247)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:217)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:25)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:523)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.findDeserializeAndSet(BeanPropertyMap.java:285)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:248)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:136)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3564)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2580)\n\tcom.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest.testSimple(WrapperObjectWithObjectIdTest.java:83)", "buggy_method": "78 @SuppressWarnings(\"resource\")\n79     private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n80     {\n81         // 02-Aug-2013, tatu: May need to use native type ids\n82         if (p.canReadTypeId()) {\n83             Object typeId = p.getTypeId();\n84             if (typeId != null) {\n85                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n86             }\n87         }\n88         // first, sanity checks\n89         if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n90             throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n91                     \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n92         }\n93             // should always get field name, but just in case...\n94             if (p.nextToken() != JsonToken.FIELD_NAME) {\n95                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n96                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n97             }\n98         final String typeId = p.getText();\n99         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n100         p.nextToken();\n101 \n102         // Minor complication: we may need to merge type id in?\n103         if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {\n104             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n105             TokenBuffer tb = new TokenBuffer(null, false);\n106             tb.writeStartObject(); // recreate START_OBJECT\n107             tb.writeFieldName(_typePropertyName);\n108             tb.writeString(typeId);\n109             p = JsonParserSequence.createFlattened(tb.asParser(p), p);\n110             p.nextToken();\n111         }\n112         \n113         Object value = deser.deserialize(p, ctxt);\n114         // And then need the closing END_OBJECT\n115         if (p.nextToken() != JsonToken.END_OBJECT) {\n116             throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,\n117                     \"expected closing END_OBJECT after type information and deserialized value\");\n118         }\n119         return value;\n120     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer"}, {"bug_name": "JacksonDatabind_36", "report_text": "> Allow use\tof StdDateFormat.setLenient()\n> \n> ObjectMapper uses the StdDateFormat for date serialization. Jackson date parsing is lenient by default, so 2015-01-32 gets parsed as 2015-02-01. Jackson\u2019s StdDateParser is matching default behavior of DateParser.\n> StdDateParser wasn\u2019t really designed for extension to just enable strict date parsing. If it were, we could just call objectMapper.setDateFormat(new StdDateFormat().setLenient(false)). But StdDateFomrat doesn't support setting lenient to false. And i.e. the reason date like 2015-01-32 gets parsed as 2015-02-01 ad Jackson date parsing is lenient by defualt.\n> Can StdDateFormat can be enhanced to support to non lenient date parsing?", "test_name": "com.fasterxml.jackson.databind.TestStdDateFormat::testLenient", "test_method": "    public void testLenient() throws Exception\n    {\n        StdDateFormat f = StdDateFormat.instance;\n\n        // default should be lenient\n\n        StdDateFormat f2 = f.clone();\n\n        f2.setLenient(false); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tjava.text.DateFormat.setLenient(DateFormat.java:716)\n\tcom.fasterxml.jackson.databind.TestStdDateFormat.testLenient(TestStdDateFormat.java:29)", "buggy_method": "545 private final static DateFormat _cloneFormat(DateFormat df, String format,\n546             TimeZone tz, Locale loc, Boolean lenient)\n547     {\n548         if (!loc.equals(DEFAULT_LOCALE)) {\n549             df = new SimpleDateFormat(format, loc);\n550             df.setTimeZone((tz == null) ? DEFAULT_TIMEZONE : tz);\n551         } else {\n552             df = (DateFormat) df.clone();\n553             if (tz != null) {\n554                 df.setTimeZone(tz);\n555             }\n556         }\n557         return df;\n558     }", "bm_classpath": "com.fasterxml.jackson.databind.util.StdDateFormat"}, {"bug_name": "JacksonDatabind_37", "report_text": "> Field in base class is not recognized, when using @JsonType.defaultImpl\n> \n> When deserializing JSON to Java POJOS, a field inherited from a base class is not recognized. Here is the stack:\n> ```\n> com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"name\" (class org.apache.calcite.model.JsonMapSchema), not marked as ignorable (2 known properties: \"functions\", \"tables\"])\n>  at [Source: {\n>   version: '1.0',\n>    schemas: [\n>      {\n>        name: 'FoodMart',\n>        tables: [\n>          {\n>            name: 'time_by_day',\n>            columns: [\n>              {\n>                name: 'time_id'\n>              }\n>            ]\n>          },\n>          {\n>            name: 'sales_fact_1997',\n>            columns: [\n>              {\n>                name: 'time_id'\n>              }\n>            ]\n>          }\n>        ]\n>      }\n>    ]\n> }; line: 24, column: 7] (through reference chain: org.apache.calcite.model.JsonRoot[\"schemas\"]->java.util.ArrayList[0]->org.apache.calcite.model.JsonMapSchema[\"name\"])\n>     at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:62)\n>     at com.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:855)\n>     at com.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1083)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1389)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1367)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:266)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:163)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:136)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:99)\n>     at com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserializeWithType(AbstractDeserializer.java:142)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:279)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:249)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n>     at com.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490)\n>     at com.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125)\n>     at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n>     at org.apache.calcite.test.ModelTest.testRead(ModelTest.java:58)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:483)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n>     at org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n>     at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n>     at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)\n>     at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:483)\n>     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)\n> ```\n> My `JsonMapSchema` class has a base class `JsonSchema` and it has a public field `name`. See <https://github.com/apache/calcite/blob/master/core/src/test/java/org/apache/calcite/test/ModelTest.java>.\n> I have an application that worked in 2.6.3, fails in 2.7.0, so I suspect this is a regression.", "test_name": "com.fasterxml.jackson.databind.objectid.Objecid1083Test::testSimple", "test_method": "      public void testSimple() throws Exception {\n          final ObjectMapper mapper = new ObjectMapper();\n          final String json = aposToQuotes(\"{'schemas': [{\\n\"\n              + \"  'name': 'FoodMart'\\n\"\n              + \"}]}\\n\");\n          mapper.readValue(json, JsonRoot.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"name\" (class com.fasterxml.jackson.databind.objectid.Objecid1083Test$JsonMapSchema), not marked as ignorable (0 known properties: ])\n\tcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:62)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:855)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1083)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1389)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1367)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:266)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:163)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:136)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:99)\n\tcom.fasterxml.jackson.databind.deser.AbstractDeserializer.deserializeWithType(AbstractDeserializer.java:142)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:279)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:249)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)", "buggy_method": "119 @Override\n120     protected JavaType _narrow(Class<?> subclass)\n121     {\n122         if (_class == subclass) {\n123             return this;\n124         }\n125         // Should we check that there is a sub-class relationship?\n126         // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n127         //    placeholder values, so no.\n128         /*\n129         if (!_class.isAssignableFrom(subclass)) {\n130             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n131                     +_class.getName());\n132         }\n133         */\n134         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n135         return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n136                 _valueHandler, _typeHandler, _asStatic);\n137     }", "bm_classpath": "com.fasterxml.jackson.databind.type.SimpleType"}, {"bug_name": "JacksonDatabind_38", "report_text": "> (2.7-regress) Handling of deprecated SimpleType.construct() too minimalistic\n> \n> (note: spun from <https://github.com/FasterXML/jackson/issues/48>)\n> Due to changes in type resolution, most direct construction methods in `JavaType` sub-classes can not be fully supported. Failure modes are typically with complex cases (and expected to be rare), with one exception: use of `SimpleType.construct(Class)`, because:\n> 1. This is mostly used for complex types, and not just \"well-known\" interfaces like `List`, `Map`; so actual access to at least immediate fields is necessary (and similarly lack of super-type info is problematic), and\n> 2. Its usage is likely to be wide-spread, despite existence of preferable methods (`TypeFactory`)\n> 3. Since refactoring of type resolution was not anticipated early enough in advance, deprecation of methods we want to move users away from could not be done in 2.6, as it should have been (in perfect case)\n> Exact reasoning behind problems is quite complicated: but the fundamental reason is that `TypeFactory` has all the logic to do the generic resolution; `JavaType` has (and should have) very little if any. Since no reference to the factory is passed via constructors/factory methods, they can not properly delegate resolution tasks. This is why direct calls should only be made with all necessary, pre-resolved information; passing `JavaType`s for elements, not `Class`.  \n> Inability to resolve things means that super-types can not be properly resolved, for example. Handling of fields, methods will also be inexact wrt generic types.\n> The first immediate problem is something that should be addressable: introspection by POJO deserializer builder does not find any fields or methods. It should be possible to at least find them, even if type resolution for generic types will not work well. This should be acceptable for the common (and reported) case of constructing element types for `Collection`s and `Map`s: generic parameterization will not be accessible anyway.\n> There are other potential issues to address as best we can, but first things first.", "test_name": "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testExplicitMapType", "test_method": "    @SuppressWarnings(\"deprecation\")\n    public void testExplicitMapType() throws Exception\n    {\n        JavaType key = SimpleType.construct(String.class);\n        JavaType elem = SimpleType.construct(Point.class);\n        JavaType t = MapType.construct(Map.class, key, elem);\n\n        final String json = aposToQuotes(\"{'x':{'x':3,'y':5}}\");        \n\n        Map<String,Point> m = MAPPER.readValue(json, t);\n        Object ob = m.values().iterator().next();\n        assertEquals(Point.class, ob.getClass()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test$Point> but was:<class java.util.LinkedHashMap>\n\tcom.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test.testExplicitMapType(DeprecatedTypeHandling1102Test.java:85)", "buggy_method": "46 @Deprecated // since 2.7\n47     public static CollectionType construct(Class<?> rawType, JavaType elemT) {\n48         // First: may need to fabricate TypeBindings (needed for refining into\n49         // concrete collection types, as per [databind#1102])\n50         return new CollectionType(rawType, null,\n51                 // !!! TODO: Wrong, does have supertypes, but:\n52                 _bogusSuperClass(rawType), null, elemT,\n53                 null, null, false);\n54     }", "bm_classpath": "com.fasterxml.jackson.databind.type.CollectionType"}, {"bug_name": "JacksonDatabind_39", "report_text": "> Jackson not continue to parse after DeserializationFeature.FAIL_ON_INVALID_SUBTYPE error\n> \n> After FAIL\\_ON\\_INVALID\\_SUBTYPE error, jackson should continue to parse, but seems jackson doesn't.\n> The output:\n> ```\n> CallRecord [version=0.0, application=123, ] // doesn't read item2 which is valid\n> CallRecord [version=0.0, application=123, ]\n> CallRecord [version=0.0, ] // doesn't read application after invalid item.\n> ```\n> ```\n> @JsonInclude(Include.NON_NULL)\n> public class CallRecord {\n>     public float version;\n>     public String application;\n>     public Item item;\n>     public Item item2;\n>     public CallRecord() {}\n>     public static void main(final String[] args) throws IOException {\n>         final ObjectMapper objectMapper = new ObjectMapper().disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n>                 DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES);\n>         final CallRecord call = new CallRecord();\n>         final Event event = new Event();\n>         event.location = \"location1\";\n>         call.item = event;\n>         call.item2 = event;\n>         call.application = \"123\";\n>         // System.out.println(objectMapper.writeValueAsString(call));\n>         String json =\n>                 \"{\\\"version\\\":0.0,\\\"application\\\":\\\"123\\\",\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"},\\\"item2\\\":{\\\"type\\\":\\\"event\\\",\\\"location\\\":\\\"location1\\\"}}\";\n>         // can't read item2 - which is valid\n>         System.out.println(objectMapper.readValue(json, CallRecord.class));\n>         json = \"{\\\"version\\\":0.0,\\\"application\\\":\\\"123\\\"},{\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"}\";\n>         System.out.println(objectMapper.readValue(json, CallRecord.class));\n>         json = \"{\\\"item\\\":{\\\"type\\\":\\\"xevent\\\",\\\"location\\\":\\\"location1\\\"}, \\\"version\\\":0.0,\\\"application\\\":\\\"123\\\"}\";\n>         // order matters: move item to the fornt, now it can't read application property\n>         System.out.println(objectMapper.readValue(json, CallRecord.class));\n>     }\n>     @Override\n>     public String toString() {\n>         final StringBuilder builder = new StringBuilder();\n>         builder.append(\"CallRecord [version=\").append(version).append(\", \");\n>         if (application != null) {\n>             builder.append(\"application=\").append(application).append(\", \");\n>         }\n>         if (item != null) {\n>             builder.append(\"item=\").append(item);\n>         }\n>         builder.append(\"]\");\n>         return builder.toString();\n>     }\n> }\n> @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = \"type\", visible = true)\n> @JsonSubTypes({@Type(value = Event.class, name = Event.TYPE)})\n> public interface Item {\n> }\n> public final class Event implements Item {\n>     public String location;\n>     public static final String TYPE = \"event\";\n>     public Event() {}\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl::testUnknownTypeIDRecovery", "test_method": "    public void testUnknownTypeIDRecovery() throws Exception\n    {\n        ObjectReader reader = MAPPER.readerFor(CallRecord.class).without(\n                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n        String json = aposToQuotes(\"{'version':0.0,'application':'123',\"\n                +\"'item':{'type':'xevent','location':'location1'},\"\n                +\"'item2':{'type':'event','location':'location1'}}\");\n        // can't read item2 - which is valid\n        CallRecord r = reader.readValue(json); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"location\" (class com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl$CallRecord), not marked as ignorable (4 known properties: \"version\", \"item\", \"item2\", \"application\"])\n\tcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:51)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:839)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1045)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1352)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1330)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:264)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1511)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1136)\n\tcom.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl.testUnknownTypeIDRecovery(TestPolymorphicWithDefaultImpl.java:223)", "buggy_method": "30 @Override\n31     public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n32     {\n33         // 29-Jan-2016, tatu: Simple skipping for all other tokens, but FIELD_NAME bit\n34         //    special unfortunately\n35             p.skipChildren();\n36         return null;\n37     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.NullifyingDeserializer"}, {"bug_name": "JacksonDatabind_41", "report_text": "> Problems with deprecated TypeFactory.constructType(type, ctxt) methods if ctxt is null\n> \n> (note: continuation of [#1079](https://github.com/FasterXML/jackson-databind/issues/1079))\n> Looks like earlier fix was incomplete, and there is one more edge case to handle: if passed-in context is `null`, attempt to resolve that will fail. This should not occur since previously passing of `null` would simply have used \"empty\" bindings. Code needs to take care to handle this as version 2.6 did.", "test_name": "com.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test::testDeprecatedTypeResolution", "test_method": "    @SuppressWarnings(\"deprecation\")\n    public void testDeprecatedTypeResolution() throws Exception\n    {\n        TypeFactory tf = MAPPER.getTypeFactory();\n\n        // first, with real (if irrelevant) context\n        JavaType t = tf.constructType(Point.class, getClass());\n\n        // and then missing context\n        JavaType t2 = tf.constructType(Point.class, (Class<?>) null); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Unrecognized Type: [null]\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1109)\n\tcom.fasterxml.jackson.databind.type.TypeFactory.constructType(TypeFactory.java:566)\n\tcom.fasterxml.jackson.databind.type.TypeFactory.constructType(TypeFactory.java:602)\n\tcom.fasterxml.jackson.databind.interop.DeprecatedTypeHandling1102Test.testDeprecatedTypeResolution(DeprecatedTypeHandling1102Test.java:102)", "buggy_method": "608 @Deprecated\n609     public JavaType constructType(Type type, JavaType contextType) {\n610         return _fromAny(null, type, contextType.getBindings());\n611     }", "bm_classpath": "com.fasterxml.jackson.databind.type.TypeFactory"}, {"bug_name": "JacksonDatabind_42", "report_text": "> Serializing and Deserializing Locale.ROOT\n> \n> Serializing and Deserializing Locale objects seems to work just fine, until you try on the Root Locale.  \n> It writes it out as an empty string and when it reads it in, the value is null\n> ```\n> @Test\n>     public void testLocaleDeserialization() throws IOException {\n>         ObjectMapper objectMapper = new ObjectMapper();\n>         Locale root = Locale.ROOT;\n>         String json = objectMapper.writeValueAsString(root);\n>         System.out.printf(\"Root Locale: '%s'\", json);\n>         Locale actual = objectMapper.readValue(json, Locale.class);\n>         Assert.assertEquals(root, actual);\n>     }\n> ```\n> Here is the output:  \n> Root Locale: '\"\"'  \n> java.lang.AssertionError:  \n> Expected :  \n> Actual :null", "test_name": "com.fasterxml.jackson.databind.deser.TestJdkTypes::testLocale", "test_method": "    public void testLocale() throws IOException\n    {\n        // [databind#1123]\n        Locale loc = MAPPER.readValue(quote(\"\"), Locale.class);\n        assertSame(Locale.ROOT, loc); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected same:<> was not:<null>\n\tcom.fasterxml.jackson.databind.deser.TestJdkTypes.testLocale(TestJdkTypes.java:150)", "buggy_method": "277 @Override\n278         protected Object _deserializeFromEmptyString() throws IOException {\n279             // As per [databind#398], URI requires special handling\n280             if (_kind == STD_URI) {\n281                 return URI.create(\"\");\n282             }\n283             // As per [databind#1123], Locale too\n284             return super._deserializeFromEmptyString();\n285         }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.FromStringDeserializer$Std"}, {"bug_name": "JacksonDatabind_43", "report_text": "> Problem with Object id handling, explicit null token\n> \n> I'd like bit more explanation here, as well as unit test showing in what cases should this be a problem.  \n> Deserializers are typically never called with null tokens, as it is caller's responsibility to handle that (for root value handling it's mapper/reader, for POJO/Collection/Map properties, deserializer for that structured type)", "test_name": "com.fasterxml.jackson.databind.objectid.TestObjectIdSerialization::testNullStringPropertyId", "test_method": "    public void testNullStringPropertyId() throws Exception\n    {\n        IdentifiableStringId value = MAPPER.readValue\n                (aposToQuotes(\"{'value':3, 'next':null, 'id':null}\"), IdentifiableStringId.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of java.lang.String out of VALUE_NULL token\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:216)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:873)\n\tcom.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:61)\n\tcom.fasterxml.jackson.databind.deser.std.StringDeserializer.deserialize(StringDeserializer.java:11)\n\tcom.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty.deserializeSetAndReturn(ObjectIdValueProperty.java:78)\n\tcom.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty.deserializeAndSet(ObjectIdValueProperty.java:71)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:341)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithObjectId(BeanDeserializerBase.java:1094)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:131)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3789)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n\tcom.fasterxml.jackson.databind.objectid.TestObjectIdSerialization.testNullStringPropertyId(TestObjectIdSerialization.java:316)", "buggy_method": "74 @Override\n75     public Object deserializeSetAndReturn(JsonParser p,\n76     \t\tDeserializationContext ctxt, Object instance) throws IOException\n77     {\n78         Object id = _valueDeserializer.deserialize(p, ctxt);\n79         /* 02-Apr-2015, tatu: Actually, as per [databind#742], let it be;\n80          *  missing or null id is needed for some cases, such as cases where id\n81          *  will be generated externally, at a later point, and is not available\n82          *  quite yet. Typical use case is with DB inserts.\n83          */\n84         // note: no null checks (unlike usually); deserializer should fail if one found\n85         if (id == null) {\n86             return null;\n87         }\n88         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n89         roid.bindItem(instance);\n90         // also: may need to set a property value as well\n91         SettableBeanProperty idProp = _objectIdReader.idProperty;\n92         if (idProp != null) {\n93             return idProp.setAndReturn(instance, id);\n94         }\n95         return instance;\n96     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.ObjectIdValueProperty"}, {"bug_name": "JacksonDatabind_44", "report_text": "> Problem with polymorphic types, losing properties from base type(s)\n> \n> (background, see: [dropwizard/dropwizard#1449](https://github.com/dropwizard/dropwizard/pull/1449))\n> Looks like sub-type resolution may be broken for one particular case: that of using `defaultImpl`. If so, appears like properties from super-types are not properly resolved; guessing this could be follow-up item for [#1083](https://github.com/FasterXML/jackson-databind/issues/1083) (even sooner than I thought...).", "test_name": "com.fasterxml.jackson.databind.jsontype.TestSubtypes::testIssue1125WithDefault", "test_method": "    public void testIssue1125WithDefault() throws Exception\n    {\n        Issue1125Wrapper result = MAPPER.readValue(aposToQuotes(\"{'value':{'a':3,'def':9,'b':5}}\"),\n        \t\tIssue1125Wrapper.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"b\" (class com.fasterxml.jackson.databind.jsontype.TestSubtypes$Default1125), not marked as ignorable (2 known properties: \"a\", \"def\"])\n\tcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:62)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportUnknownProperty(DeserializationContext.java:855)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1083)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1389)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1367)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:266)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:163)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:135)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:136)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:99)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:1017)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:488)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:260)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:125)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3789)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n\tcom.fasterxml.jackson.databind.jsontype.TestSubtypes.testIssue1125WithDefault(TestSubtypes.java:319)", "buggy_method": "121 @Override\n122     @Deprecated\n123     protected JavaType _narrow(Class<?> subclass)\n124     {\n125         if (_class == subclass) {\n126             return this;\n127         }\n128         // Should we check that there is a sub-class relationship?\n129         // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n130         //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n131         // TODO: fix in 2.8\n132             /*\n133             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n134                     +_class.getName());\n135                     */\n136             return new SimpleType(subclass, _bindings, this, _superInterfaces,\n137                     _valueHandler, _typeHandler, _asStatic);\n138         // Otherwise, stitch together the hierarchy. First, super-class\n139         // if not found, try a super-interface\n140         // should not get here but...\n141     }", "bm_classpath": "com.fasterxml.jackson.databind.type.SimpleType"}, {"bug_name": "JacksonDatabind_45", "report_text": "> Fix for #1154\n> \n> Looks pretty good, but would it be possible to have a unit test that would fail before fix, pass after? Would be great to have something to guard against regression.\n> I may want to change the logic a little bit, however; if shape is explicitly defined as `NUMBER`, textual representation should not be enabled even if `Locale` (etc) happen to be specified: explicit shape value should have precedence. I can make that change, or you can do it, either way is fine.  \n> I'll also need to merge this again 2.7 branch instead of master, to get in 2.7.3.", "test_name": "com.fasterxml.jackson.databind.ser.DateSerializationTest::testDateDefaultShape", "test_method": "    public void testDateDefaultShape() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        // No @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        String json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBean(0L));\n\n        // Empty @JsonFormat => default to user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithEmptyJsonFormat(0L));\n\n        // @JsonFormat with Shape.ANY and pattern => STRING shape, regardless of user config\n        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        json = mapper.writeValueAsString(new DateAsDefaultBeanWithPattern(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01'}\"), json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"date\":[\"1970-01-01\"]}> but was:<{\"date\":[0]}>\n\tcom.fasterxml.jackson.databind.ser.DateSerializationTest.testDateDefaultShape(DateSerializationTest.java:288)", "buggy_method": "49 @Override\n50     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n51             BeanProperty property) throws JsonMappingException\n52     {\n53         if (property != null) {\n54             JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n55             if (format != null) {\n56 \n57             \t// Simple case first: serialize as numeric timestamp?\n58                 JsonFormat.Shape shape = format.getShape();\n59                 if (shape.isNumeric()) {\n60                     return withFormat(Boolean.TRUE, null);\n61                 }\n62 \n63                 if (format.getShape() == JsonFormat.Shape.STRING) {\n64                     TimeZone tz = format.getTimeZone();\n65                     final String pattern = format.hasPattern()\n66                                     ? format.getPattern()\n67                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n68                     final Locale loc = format.hasLocale()\n69                                     ? format.getLocale()\n70                                     : serializers.getLocale();\n71                     SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n72                     if (tz == null) {\n73                         tz = serializers.getTimeZone();\n74                     }\n75                     df.setTimeZone(tz);\n76                     return withFormat(Boolean.FALSE, df);\n77                 }\n78             }\n79         }\n80         return this;\n81     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase"}, {"bug_name": "JacksonDatabind_46", "report_text": "> Incorrect signature for generic type via `JavaType.getGenericSignature\n> \n> (see [FasterXML/jackson-modules-base#8](https://github.com/FasterXML/jackson-modules-base/issues/8) for background)\n> It looks like generic signature generation is missing one closing `>` character to produce:\n> ```\n> ()Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;;\n> ```\n> instead of expected\n> ```\n> ()Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\n> ```\n> that is, closing '>' is missing.", "test_name": "com.fasterxml.jackson.databind.type.TestJavaType::testGenericSignature1195", "test_method": "    public void testGenericSignature1195() throws Exception\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        Method m;\n        JavaType t;\n\n        m = Generic1195.class.getMethod(\"getList\");\n        t  = tf.constructType(m.getGenericReturnType());\n\n        m = Generic1195.class.getMethod(\"getMap\");\n        t  = tf.constructType(m.getGenericReturnType());\n\n        m = Generic1195.class.getMethod(\"getGeneric\");\n        t  = tf.constructType(m.getGenericReturnType());\n        assertEquals(\"Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String;>;\", t.getGenericSignature()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...e<Ljava/lang/String;[>];> but was:<...e<Ljava/lang/String;[];>\n\tcom.fasterxml.jackson.databind.type.TestJavaType.testGenericSignature1195(TestJavaType.java:56)", "buggy_method": "150 @Override\n151     public StringBuilder getGenericSignature(StringBuilder sb)\n152     {\n153         _classSignature(_class, sb, false);\n154         sb.append('<');\n155         sb = _referencedType.getGenericSignature(sb);\n156         sb.append(';');\n157         return sb;\n158     }", "bm_classpath": "com.fasterxml.jackson.databind.type.ReferenceType"}, {"bug_name": "JacksonDatabind_47", "report_text": "> @JsonSerialize(as=superType) behavior disallowed in 2.7.4\n> \n> [#1178](https://github.com/FasterXML/jackson-databind/issues/1178) fixed the problem with collections, but I'm seeing a problem with individual objects.\n> I'm getting:\n> ```\n> com.fasterxml.jackson.databind.JsonMappingException: Failed to widen type [simple type, class org.pharmgkb.model.AccessionIdentifier] with annotation (value org.pharmgkb.model.BaseAccessionIdentifier), from 'getReference': Class org.pharmgkb.model.BaseAccessionIdentifier not a super-type of [simple type, class org.pharmgkb.model.AccessionIdentifier]\n>     at com.fasterxml.jackson.databind.AnnotationIntrospector.refineSerializationType(AnnotationIntrospector.java:821)\n>     at com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair.refineSerializationType(AnnotationIntrospectorPair.java:488)\n>     at com.fasterxml.jackson.databind.ser.PropertyBuilder.findSerializationType(PropertyBuilder.java:194)\n>     at com.fasterxml.jackson.databind.ser.PropertyBuilder.buildWriter(PropertyBuilder.java:73)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory._constructWriter(BeanSerializerFactory.java:805)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanProperties(BeanSerializerFactory.java:608)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.constructBeanSerializer(BeanSerializerFactory.java:388)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanSerializer(BeanSerializerFactory.java:271)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory._createSerializer2(BeanSerializerFactory.java:223)\n>     at com.fasterxml.jackson.databind.ser.BeanSerializerFactory.createSerializer(BeanSerializerFactory.java:157)\n>     at com.fasterxml.jackson.databind.SerializerProvider._createUntypedSerializer(SerializerProvider.java:1215)\n>     at com.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer(SerializerProvider.java:1167)\n>     at com.fasterxml.jackson.databind.SerializerProvider.findValueSerializer(SerializerProvider.java:490)\n>     at com.fasterxml.jackson.databind.SerializerProvider.findTypedValueSerializer(SerializerProvider.java:688)\n>     at com.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:107)\n>     at com.fasterxml.jackson.databind.ObjectWriter$Prefetch.serialize(ObjectWriter.java:1428)\n>     at com.fasterxml.jackson.databind.ObjectWriter._configAndWriteValue(ObjectWriter.java:1129)\n>     at com.fasterxml.jackson.databind.ObjectWriter.writeValueAsString(ObjectWriter.java:1001)\n>     at org.pharmgkb.jackson.JacksonTest.testModelObjects(JacksonTest.java:48)\n> ```\n> On something like:\n> ```\n> public class Foo {\n>   @JsonSerialize(as = BaseAccessionIdentifier.class)\n>   @JsonDeserialize(as = BaseAccessionIdentifier.class)\n>   public AccessionIdentifier getReference() {\n>   }\n> }\n> ```\n> ```\n> public interface AccessionIdentifier {\n> }\n> ```\n> ```\n> public class BaseAccessionIdentifier implements AccessionIdentifier {\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.ser.TestJsonSerialize::testBrokenAnnotation", "test_method": "    public void testBrokenAnnotation() throws Exception\n    {\n        try {\n            serializeAsString(MAPPER, new BrokenClass());\n        } catch (Exception e) {\n            verifyException(e, \"types not related\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([types not related]): got one with message \"Failed to widen type [simple type, class java.lang.Long] with annotation (value java.lang.String), from 'getValue': Class java.lang.String not a super-type of [simple type, class java.lang.Long]\"\n\tcom.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:368)\n\tcom.fasterxml.jackson.databind.ser.TestJsonSerialize.testBrokenAnnotation(TestJsonSerialize.java:152)", "buggy_method": "795 public JavaType refineSerializationType(final MapperConfig<?> config,\n796             final Annotated a, final JavaType baseType) throws JsonMappingException\n797     {\n798         JavaType type = baseType;\n799         final TypeFactory tf = config.getTypeFactory();\n800         \n801         // 10-Oct-2015, tatu: For 2.7, we'll need to delegate back to\n802         //    now-deprecated secondary methods; this because while\n803         //    direct sub-class not yet retrofitted may only override\n804         //    those methods. With 2.8 or later we may consider removal\n805         //    of these methods\n806 \n807         \n808         // Ok: start by refining the main type itself; common to all types\n809         Class<?> serClass = findSerializationType(a);\n810         if (serClass != null) {\n811             if (type.hasRawClass(serClass)) {\n812                 // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n813                 //    static typing this way\n814                 type = type.withStaticTyping();\n815             } else {\n816                 try {\n817                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n818                     //   may be needed here too in future?\n819                         type = tf.constructGeneralizedType(type, serClass);\n820                 } catch (IllegalArgumentException iae) {\n821                     throw new JsonMappingException(null,\n822                             String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n823                                     type, serClass.getName(), a.getName(), iae.getMessage()),\n824                                     iae);\n825                 }\n826             }\n827         }\n828         // Then further processing for container types\n829 \n830         // First, key type (for Maps, Map-like types):\n831         if (type.isMapLikeType()) {\n832             JavaType keyType = type.getKeyType();\n833             Class<?> keyClass = findSerializationKeyType(a, keyType);\n834             if (keyClass != null) {\n835                 if (keyType.hasRawClass(keyClass)) {\n836                     keyType = keyType.withStaticTyping();\n837                 } else {\n838                     Class<?> currRaw = keyType.getRawClass();\n839                     try {\n840                         // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n841                         //   specialize (narrow) type sometimes, even if more commonly opposite\n842                         //   is needed.\n843                         if (keyClass.isAssignableFrom(currRaw)) { // common case\n844                             keyType = tf.constructGeneralizedType(keyType, keyClass);\n845                         } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n846                             keyType = tf.constructSpecializedType(keyType, keyClass);\n847                         } else {\n848                             throw new JsonMappingException(null,\n849                                     String.format(\"Can not refine serialization key type %s into %s; types not related\",\n850                                             keyType, keyClass.getName()));\n851                         }\n852                     } catch (IllegalArgumentException iae) {\n853                         throw new JsonMappingException(null,\n854                                 String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n855                                         type, keyClass.getName(), a.getName(), iae.getMessage()),\n856                                         iae);\n857                     }\n858                 }\n859                 type = ((MapLikeType) type).withKeyType(keyType);\n860             }\n861         }\n862 \n863         JavaType contentType = type.getContentType();\n864         if (contentType != null) { // collection[like], map[like], array, reference\n865             // And then value types for all containers:\n866            Class<?> contentClass = findSerializationContentType(a, contentType);\n867            if (contentClass != null) {\n868                if (contentType.hasRawClass(contentClass)) {\n869                    contentType = contentType.withStaticTyping();\n870                } else {\n871                    // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n872                    //   specialize (narrow) type sometimes, even if more commonly opposite\n873                    //   is needed.\n874                    Class<?> currRaw = contentType.getRawClass();\n875                    try {\n876                        if (contentClass.isAssignableFrom(currRaw)) { // common case\n877                            contentType = tf.constructGeneralizedType(contentType, contentClass);\n878                        } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n879                            contentType = tf.constructSpecializedType(contentType, contentClass);\n880                        } else {\n881                            throw new JsonMappingException(null,\n882                                    String.format(\"Can not refine serialization content type %s into %s; types not related\",\n883                                            contentType, contentClass.getName()));\n884                        }\n885                    } catch (IllegalArgumentException iae) { // shouldn't really happen\n886                        throw new JsonMappingException(null,\n887                                String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n888                                        type, contentClass.getName(), a.getName(), iae.getMessage()),\n889                                        iae);\n890                    }\n891                }\n892                type = type.withContentType(contentType);\n893            }\n894         }\n895         return type;\n896     }", "bm_classpath": "com.fasterxml.jackson.databind.AnnotationIntrospector"}, {"bug_name": "JacksonDatabind_48", "report_text": "> BasicClassIntrospector.forSerialization(...).findProperties should respect MapperFeature.AUTO_DETECT_GETTERS/SETTERS\n> \n> When I set the ObjectMapper MapperConfig to not AutoDetect and use the BasicClassIntrospector to get the properties, I seem to still be getting the Methods. I am currently using version 2.7.3.\n> The following code produces this output:  \n> Found property count 2, there should only be one??  \n> Found property: name=name, internalName=name  \n> Found property: name=groupname, internalName=groupname\n> I think it should produce only this output:  \n> Found property: name=groupname, internalName=groupname\n> ```\n> public static void main(String [] args) {\n>     class TCls {\n>         @JsonProperty(\"groupname\")\n>         private String groupname;\n>         public void setName(String str) {\n>             this.groupname = str;\n>         }\n>         public String getName() {\n>             return groupname;\n>         }\n>     }\n>     ObjectMapper om = new ObjectMapper();\n>     // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_FIELDS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_GETTERS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_SETTERS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.USE_GETTERS_AS_SETTERS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.INFER_PROPERTY_MUTATORS, false);\n>     om.configure(com.fasterxml.jackson.databind.MapperFeature.USE_ANNOTATIONS, true);\n>     JavaType javaType = om.getTypeFactory().constructType(TCls.class);\n>     BasicClassIntrospector introspector = new BasicClassIntrospector();\n>     BasicBeanDescription bdesc = introspector.forSerialization(om.getSerializationConfig(), javaType, null);\n>     List<BeanPropertyDefinition> bprops = bdesc.findProperties();\n>     if (1 != bprops.size()) {\n>         System.out.println(\"Found property count \" + bprops.size() + \", there should only be one??\");\n>     }\n>     bprops.forEach(prop -> {\n>         System.out.println(\"Found property: name=\" + prop.getName() + \", internalName=\" + prop.getInternalName());\n>     });\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.ser.TestFeatures::testVisibilityFeatures", "test_method": "    public void testVisibilityFeatures() throws Exception\n    {\n        ObjectMapper om = new ObjectMapper();\n        // Only use explicitly specified values to be serialized/deserialized (i.e., JSONProperty).\n        om.configure(MapperFeature.AUTO_DETECT_FIELDS, false);\n        om.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_SETTERS, false);\n        om.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n        om.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n        om.configure(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS, true);\n        om.configure(MapperFeature.INFER_PROPERTY_MUTATORS, false);\n        om.configure(MapperFeature.USE_ANNOTATIONS, true);\n\n        JavaType javaType = om.getTypeFactory().constructType(TCls.class);        \n        BeanDescription desc = (BeanDescription) om.getSerializationConfig().introspect(javaType);\n        List<BeanPropertyDefinition> props = desc.findProperties();\n        if (props.size() != 1) {\n            fail(\"Should find 1 property, not \"+props.size()+\"; properties = \"+props);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should find 1 property, not 2; properties = [[Property 'name'; ctors: null, field(s): null, getter(s): null, setter(s): [method com.fasterxml.jackson.databind.ser.TestFeatures$TCls#setName(1 params)][visible=true,ignore=false,explicitName=false]], [Property 'groupname'; ctors: null, field(s): [field com.fasterxml.jackson.databind.ser.TestFeatures$TCls#groupname][visible=true,ignore=false,explicitName=true], getter(s): null, setter(s): null]]\n\tcom.fasterxml.jackson.databind.ser.TestFeatures.testVisibilityFeatures(TestFeatures.java:300)", "buggy_method": "770 @Override\n771     public VisibilityChecker<?> getDefaultVisibilityChecker()\n772     {\n773         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n774         if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n775             vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n776         }\n777         if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n778             vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n779         }\n780         if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n781             vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n782         }\n783         return vchecker;\n784     }", "bm_classpath": "com.fasterxml.jackson.databind.DeserializationConfig"}, {"bug_name": "JacksonDatabind_49", "report_text": "> JsonIdentityInfo incorrectly serializing forward references\n> \n> I wrote this small test program to demonstrate the issue:\n> ```\n> import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n> import com.fasterxml.jackson.annotation.JsonIdentityReference;\n> import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class ObjectIdTest {\n>     public static class Foo {\n>         @JsonIdentityReference(alwaysAsId = true)\n>         public Bar bar1;\n>         @JsonIdentityReference()\n>         public Bar bar2;\n>     }\n>     @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n>     public static class Bar {\n>     }\n>     public static void main(String[] args) throws Exception {\n>         ObjectMapper mapper = new ObjectMapper();\n>         // create structure to serialize\n>         Foo mo = new Foo();\n>         mo.bar1 = new Bar();\n>         mo.bar2 = mo.bar1;\n>         // serialize it\n>         System.out.println(mapper.writeValueAsString(mo));\n>     }\n> }\n> ```\n> When executing this test program in the latest version (2.7.4), the output will be `{\"bar1\":1,\"bar2\":{\"@id\":2}}` - the second field will be written with a new id even though both fields reference the same object. Because of this, writing forward references is essentially impossible.\n> The issue seems to be the fact that BeanSerializerBase will always call WritableObjectId.generateId if the referenced object has not been written in plain format yet (<https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java#L600>). This will also happen if an id has been generated before.  \n> It might also be smarter to only generate a new id in WritableObjectId.generateId if that hasn't happened before; as that method doesn't have a javadoc I can't tell how it is supposed to work.", "test_name": "com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1255", "test_method": "    public void testIssue1255() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Foo mo = new Foo();\n        mo.bar1 = new Bar();\n        mo.bar2 = mo.bar1;\n\n        String json = mapper.writeValueAsString(mo);\n\n        Foo result = mapper.readValue(json, Foo.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.deser.UnresolvedForwardReference: Unresolved forward references for: Object id [1] (for com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest$Bar) at [Source: {\"bar1\":1,\"bar2\":{\"@id\":2,\"value\":3}}; line: 1, column: 10].\n\tcom.fasterxml.jackson.databind.deser.DefaultDeserializationContext.checkUnresolvedObjectId(DefaultDeserializationContext.java:154)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3738)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2726)\n\tcom.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest.testIssue1255(AlwaysAsReferenceFirstTest.java:32)", "buggy_method": "46 public Object generateId(Object forPojo) {\n47         // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n48         //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n49         //    need to use existing id if there is one:\n50             id = generator.generateId(forPojo);\n51         return id;\n52     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.impl.WritableObjectId"}, {"bug_name": "JacksonDatabind_50", "report_text": "> @JsonIdentityInfo deserialization fails with combination of forward references, @JsonCreator\n> \n> As a follow-up to bug [#1255](https://github.com/FasterXML/jackson-databind/issues/1255), the patch I provided exposes related deserialization problems.  \n> I have attached a small project ('jackson-test.zip') to demonstrate these issues. When run with both patches from [#1255](https://github.com/FasterXML/jackson-databind/issues/1255), the output is provided in the attached 'both.txt'. When run with just the first patch from [#1255](https://github.com/FasterXML/jackson-databind/issues/1255), the output is provided in the attached 'first.txt'.  \n> Important points:\n> 1. When the object expressed as an id is contained within a collection or map (List in this example), deserialization works correctly. When it is a field of an object, deserialization is broken.\n> 2. This particular example doesn't have forward references, but it does have cycles. Nevertheless, I have seen situations where non-cyclical forward-references also do not deserialize properly, with the same caveat as in 1.  \n> [jackson-test.zip](https://github.com/FasterXML/jackson-databind/files/301884/jackson-test.zip)  \n> [both.txt](https://github.com/FasterXML/jackson-databind/files/301885/both.txt)  \n> [first.txt](https://github.com/FasterXML/jackson-databind/files/301886/first.txt)", "test_name": "com.fasterxml.jackson.databind.objectid.ObjectWithCreator1261Test::testObjectIds1261", "test_method": "    public void testObjectIds1261() throws Exception\n    {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.enable(SerializationFeature.INDENT_OUTPUT);\n         mapper.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n\n         Answer initialAnswer = createInitialAnswer();\n         String initialAnswerString = mapper.writeValueAsString(initialAnswer);\n// System.out.println(\"Initial answer:\\n\"+initialAnswerString);\n         JsonNode tree = mapper.readTree(initialAnswerString);\n         Answer deserializedAnswer = mapper.readValue(initialAnswerString,\n               Answer.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not deserialize instance of com.fasterxml.jackson.databind.objectid.ObjectWithCreator1261Test$Child out of START_ARRAY token\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:261)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportMappingException(DeserializationContext.java:1233)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1121)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1074)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromArray(BeanDeserializerBase.java:1362)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:173)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:149)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBindStringKeyMap(MapDeserializer.java:507)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:352)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:356)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithObjectId(BeanDeserializerBase.java:1156)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:145)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBindStringKeyMap(MapDeserializer.java:507)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:352)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:490)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)", "buggy_method": "376 @Override\n377     @SuppressWarnings(\"resource\")\n378     protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n379         throws IOException\n380     {\n381         final PropertyBasedCreator creator = _propertyBasedCreator;\n382         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n383 \n384         TokenBuffer unknown = null;\n385 \n386         JsonToken t = p.getCurrentToken();\n387         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n388             String propName = p.getCurrentName();\n389             p.nextToken(); // to point to value\n390             // creator property?\n391             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n392             if (creatorProp != null) {\n393                 // Last creator property to set?\n394                 if (buffer.assignParameter(creatorProp,\n395                         _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n396                     p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n397                     Object bean;\n398                     try {\n399                         bean = creator.build(ctxt, buffer);\n400                     } catch (Exception e) {\n401                         bean = wrapInstantiationProblem(e, ctxt);\n402                     }\n403                     if (bean == null) {\n404                         return ctxt.handleInstantiationProblem(handledType(), null,\n405                                 _creatorReturnedNullException());\n406                     }\n407                     // [databind#631]: Assign current value, to be accessible by custom serializers\n408                     p.setCurrentValue(bean);\n409 \n410                     //  polymorphic?\n411                     if (bean.getClass() != _beanType.getRawClass()) {\n412                         return handlePolymorphic(p, ctxt, bean, unknown);\n413                     }\n414                     if (unknown != null) { // nope, just extra unknown stuff...\n415                         bean = handleUnknownProperties(ctxt, bean, unknown);\n416                     }\n417                     // or just clean?\n418                     return deserialize(p, ctxt, bean);\n419                 }\n420                 continue;\n421             }\n422             // Object Id property?\n423             if (buffer.readIdProperty(propName)) {\n424                 continue;\n425             }\n426             // regular property? needs buffering\n427             SettableBeanProperty prop = _beanProperties.find(propName);\n428             if (prop != null) {\n429                     buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n430                     // 14-Jun-2016, tatu: As per [databind#1261], looks like we need additional\n431                     //    handling of forward references here. Not exactly sure why existing\n432                     //    facilities did not cover, but this does appear to solve the problem\n433                 continue;\n434             }\n435             // Things marked as ignorable should not be passed to any setter\n436             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n437                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n438                 continue;\n439             }\n440             // \"any property\"?\n441             if (_anySetter != null) {\n442                 try {\n443                     buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n444                 } catch (Exception e) {\n445                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n446                 }\n447                 continue;\n448             }\n449             // Ok then, let's collect the whole field; name and value\n450             if (unknown == null) {\n451                 unknown = new TokenBuffer(p, ctxt);\n452             }\n453             unknown.writeFieldName(propName);\n454             unknown.copyCurrentStructure(p);\n455         }\n456 \n457         // We hit END_OBJECT, so:\n458         Object bean;\n459         try {\n460             bean =  creator.build(ctxt, buffer);\n461         } catch (Exception e) {\n462             wrapInstantiationProblem(e, ctxt);\n463             bean = null; // never gets here\n464         }\n465         if (unknown != null) {\n466             // polymorphic?\n467             if (bean.getClass() != _beanType.getRawClass()) {\n468                 return handlePolymorphic(null, ctxt, bean, unknown);\n469             }\n470             // no, just some extra unknown properties\n471             return handleUnknownProperties(ctxt, bean, unknown);\n472         }\n473         return bean;\n474     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializer"}, {"bug_name": "JacksonDatabind_51", "report_text": "> Generic type returned from type id resolver seems to be ignored\n> \n> <https://github.com/benson-basis/jackson-custom-mess-tc>\n> Here's the situation, with Jackson 2.7.4.\n> I have a TypeIdResolver that returns a JavaType for a generic type. However, something seems to be forgetting/erasing the generic, as it is failing to use the generic type param to understand the type of a field in the class.\n> All the information is in the test case, so I'm not putting any code to read here in the issue.", "test_name": "com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver::testPolymorphicTypeViaCustom", "test_method": "    public void testPolymorphicTypeViaCustom() throws Exception {\n        Base1270<Poly1> req = new Base1270<Poly1>();\n        Poly1 o = new Poly1();\n        o.val = \"optionValue\";\n        req.options = o;\n        req.val = \"some value\";\n        Top1270 top = new Top1270();\n        top.b = req;\n        String json = MAPPER.writeValueAsString(top);\n        JsonNode tree = MAPPER.readTree(json);\n\n        // Can we reverse the process? I have some doubts\n        Top1270 itemRead = MAPPER.readValue(json, Top1270.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Problem deserializing property 'options' (expected type: [simple type, class java.lang.Object]; actual type: java.util.LinkedHashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver$Poly1Base field com.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver$Base1270.options to java.util.LinkedHashMap\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:268)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty._throwAsIOE(SettableBeanProperty.java:516)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:105)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:276)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:178)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:126)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:97)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:1079)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:488)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:101)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:276)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:140)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3789)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2833)\n\tcom.fasterxml.jackson.databind.jsontype.TestCustomTypeIdResolver.testPolymorphicTypeViaCustom(TestCustomTypeIdResolver.java:226)", "buggy_method": "140 protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n141             String typeId) throws IOException\n142     {\n143         JsonDeserializer<Object> deser = _deserializers.get(typeId);\n144         if (deser == null) {\n145             /* As per [Databind#305], need to provide contextual info. But for\n146              * backwards compatibility, let's start by only supporting this\n147              * for base class, not via interface. Later on we can add this\n148              * to the interface, assuming deprecation at base class helps.\n149              */\n150             JavaType type = _idResolver.typeFromId(ctxt, typeId);\n151             if (type == null) {\n152                 // As per [JACKSON-614], use the default impl if no type id available:\n153                 deser = _findDefaultImplDeserializer(ctxt);\n154                 if (deser == null) {\n155                     // 10-May-2016, tatu: We may get some help...\n156                     JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n157                     if (actual == null) { // what should this be taken to mean?\n158                         // TODO: try to figure out something better\n159                         return null;\n160                     }\n161                     // ... would this actually work?\n162                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n163                 }\n164             } else {\n165                 /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n166                  *   we actually now need to explicitly narrow from base type (which may have parameterization)\n167                  *   using raw type.\n168                  *\n169                  *   One complication, though; can not change 'type class' (simple type to container); otherwise\n170                  *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n171                  *   type in process (getting SimpleType of Map.class which will not work as expected)\n172                  */\n173                 if ((_baseType != null)\n174                         && _baseType.getClass() == type.getClass()) {\n175                     /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n176                      *   but it appears to check that JavaType impl class is the same which is\n177                      *   important for some reason?\n178                      *   Disabling the check will break 2 Enum-related tests.\n179                      */\n180                     // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n181                     //   generic type with custom type resolvers. If so, should try to retain them.\n182                     //  Whether this is sufficient to avoid problems remains to be seen, but for\n183                     //  now it should improve things.\n184                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n185                 }\n186                 deser = ctxt.findContextualValueDeserializer(type, _property);\n187             }\n188             _deserializers.put(typeId, deser);\n189         }\n190         return deser;\n191     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"}, {"bug_name": "JacksonDatabind_52", "report_text": "> External property is not deserialized\n> \n> I think it's easier to show the code than explain the issue, so i prepared a test project:  \n> <https://github.com/crew4ok/jackson-databind-test>\n> So basically the issue is that the external property, by which another's property type is deduced, after deserialization is null.  \n> See the failing test:  \n> <https://github.com/crew4ok/jackson-databind-test/blob/master/src/test/java/jackson/ExternalIdDeserTest.java>\n> Am i missing something?", "test_name": "com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeId999Test::testExternalTypeId", "test_method": "    public void testExternalTypeId() throws Exception\n    {\n        TypeReference<?> type = new TypeReference<Message<FooPayload>>() { };\n\n        Message<?> msg = MAPPER.readValue(aposToQuotes(\"{ 'type':'foo', 'payload': {} }\"), type);\n        assertEquals(\"foo\", msg.type); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<foo> but was:<null>\n\tcom.fasterxml.jackson.databind.jsontype.ext.ExternalTypeId999Test.testExternalTypeId(ExternalTypeId999Test.java:47)", "buggy_method": "456 @Override\n457     public void resolve(DeserializationContext ctxt)\n458         throws JsonMappingException\n459     {\n460         ExternalTypeHandler.Builder extTypes = null;\n461         // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n462         SettableBeanProperty[] creatorProps;\n463 \n464         if (_valueInstantiator.canCreateFromObjectWith()) {\n465             creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n466 \n467             // 21-Jun-2015, tatu: This resolution was duplicated later on and seems like\n468             //    it really should be only done at a later point. So commented out in 2.8.\n469             //   However, just in case there was a reason for it, leaving commented out\n470             //   here instead of immediately removing.\n471 \n472             /*\n473             // also: need to try to resolve 'external' type ids...\n474             for (SettableBeanProperty prop : creatorProps) {\n475                 if (prop.hasValueTypeDeserializer()) {\n476                     TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n477                     if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n478                         if (extTypes == null) {\n479                             extTypes = new ExternalTypeHandler.Builder();\n480                         }\n481                         extTypes.addExternal(prop, typeDeser);\n482                     }\n483                 }\n484             }\n485             */\n486         } else {\n487             creatorProps = null;\n488         }\n489 \n490         UnwrappedPropertyHandler unwrapped = null;\n491 \n492         for (SettableBeanProperty origProp : _beanProperties) {\n493             SettableBeanProperty prop = origProp;\n494 \n495             // May already have deserializer from annotations, if so, skip:\n496             if (!prop.hasValueDeserializer()) {\n497                 // [databind#125]: allow use of converters\n498                 JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop);\n499                 if (deser == null) {\n500                     deser = findDeserializer(ctxt, prop.getType(), prop);\n501                 }\n502                 prop = prop.withValueDeserializer(deser);\n503             } else { // may need contextual version\n504                 JsonDeserializer<Object> deser = prop.getValueDeserializer();\n505                 /* Important! This is the only place where actually handle \"primary\"\n506                  * property deserializers -- call is different from other places.\n507                  */\n508                 JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n509                         prop.getType());\n510                 if (cd != deser) {\n511                     prop = prop.withValueDeserializer(cd);\n512                 }\n513             }\n514 \n515             // Need to link managed references with matching back references\n516             prop = _resolveManagedReferenceProperty(ctxt, prop);\n517 \n518             // [databind#351[: need to wrap properties that require object id resolution.\n519             if (!(prop instanceof ManagedReferenceProperty)) {\n520                 prop = _resolvedObjectIdProperty(ctxt, prop);\n521             }\n522             // Support unwrapped values (via @JsonUnwrapped)\n523             SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n524             if (u != null) {\n525                 prop = u;\n526                 if (unwrapped == null) {\n527                     unwrapped = new UnwrappedPropertyHandler();\n528                 }\n529                 unwrapped.addProperty(prop);\n530                 /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n531                  *    the original property is left in place. So let's remove it now.\n532                  */\n533                 _beanProperties.remove(prop);\n534                 continue;\n535             }\n536             // non-static inner classes too:\n537             prop = _resolveInnerClassValuedProperty(ctxt, prop);\n538             if (prop != origProp) {\n539                 _beanProperties.replace(prop);\n540                 // [databind#795]: Make sure PropertyBasedCreator's properties stay in sync\n541                 if (creatorProps != null) {\n542                     // 18-May-2015, tatu: _Should_ start with consistent set. But can we really\n543                     //   fully count on this? May need to revisit in future; seems to hold for now.\n544                     for (int i = 0, len = creatorProps.length; i < len; ++i) {\n545                         if (creatorProps[i] == origProp) {\n546                             creatorProps[i] = prop;\n547                             break;\n548                         }\n549                         // ... as per above, it is possible we'd need to add this as fallback\n550                         // if (but only if) identity check fails?\n551                         /*\n552                         if (creatorProps[i].getName().equals(prop.getName())) {\n553                             creatorProps[i] = prop;\n554                             break;\n555                         }\n556                         */\n557                     }\n558                 }\n559             }\n560             // one more thing: if this property uses \"external property\" type inclusion,\n561             // it needs different handling altogether\n562             if (prop.hasValueTypeDeserializer()) {\n563                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n564                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n565                     if (extTypes == null) {\n566                         extTypes = new ExternalTypeHandler.Builder();\n567                     }\n568                     extTypes.addExternal(prop, typeDeser);\n569                     // In fact, remove from list of known properties to simplify later handling\n570                     _beanProperties.remove(prop);\n571                     continue;\n572                 }\n573             }\n574         }\n575         // \"any setter\" may also need to be resolved now\n576         if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n577             _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt,\n578                     _anySetter.getType(), _anySetter.getProperty()));\n579         }\n580         // as well as delegate-based constructor:\n581         if (_valueInstantiator.canCreateUsingDelegate()) {\n582             JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n583             if (delegateType == null) {\n584                 throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n585                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n586                         +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n587             }\n588             _delegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n589                     _valueInstantiator.getDelegateCreator());\n590         }\n591 \n592         // and array-delegate-based constructor:\n593         if (_valueInstantiator.canCreateUsingArrayDelegate()) {\n594             JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig());\n595             if (delegateType == null) {\n596                 throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_beanType\n597                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n598                         +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\");\n599             }\n600             _arrayDelegateDeserializer = _findDelegateDeserializer(ctxt, delegateType,\n601                     _valueInstantiator.getArrayDelegateCreator());\n602         }\n603 \n604         // And now that we know CreatorProperty instances are also resolved can finally create the creator:\n605         if (creatorProps != null) {\n606             _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps);\n607         }\n608 \n609         if (extTypes != null) {\n610             // 21-Jun-2016, tatu: related to [databind#999], may need to link type ids too,\n611             //    so need to pass collected properties\n612             _externalTypeIdHandler = extTypes.build();\n613             // we consider this non-standard, to offline handling\n614             _nonStandardCreation = true;\n615         }\n616         \n617         _unwrappedPropertyHandler = unwrapped;\n618         if (unwrapped != null) { // we consider this non-standard, to offline handling\n619             _nonStandardCreation = true;\n620         }\n621 \n622         // may need to disable vanilla processing, if unwrapped handling was enabled...\n623         _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;\n624     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase"}, {"bug_name": "JacksonDatabind_54", "report_text": "> Optional.empty() not excluded if property declared with type Object\n> \n> Jackson version is 2.6.6  \n> **Here is the code:**\n> ```\n>         ObjectMapper mapper = new ObjectMapper();\n>         mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n>         mapper.registerModule(new Jdk8Module());\n>         JsonResult result = new JsonResult();\n>         result.setA(Optional.empty());\n>         result.setB(Optional.empty());\n>         System.out.println(mapper.writeValueAsString(result));\n> ```\n> ```\n> @Data\n> public class JsonResult {\n>     private Object a;\n>     private Optional<Object> b;\n> }\n> ```\n> **Then I got the output: {\"a\":null}**\n> **The real value of both is the same, why the results are different?**\n> **How can I avoid null in such case?**\n> By the way, I tried 'NON\\_EMPTY'. It can work, but it also ignores zero and empty array. I want to keep them.", "test_name": "com.fasterxml.jackson.databind.deser.TestJDKAtomicTypes::testEmpty1256", "test_method": "    public void testEmpty1256() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);\n\n        String json = mapper.writeValueAsString(new Issue1256Bean());\n        assertEquals(\"{}\", json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[\"a\":null]}>\n\tcom.fasterxml.jackson.databind.deser.TestJDKAtomicTypes.testEmpty1256(TestJDKAtomicTypes.java:268)", "buggy_method": "67 @SuppressWarnings(\"deprecation\")\n68     protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n69             BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n70             TypeSerializer typeSer, TypeSerializer contentTypeSer,\n71             AnnotatedMember am, boolean defaultUseStaticTyping)\n72         throws JsonMappingException\n73     {\n74         // do we have annotation that forces type to use (to declared type or its super type)?\n75         JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n76 \n77         // Container types can have separate type serializers for content (value / element) type\n78         if (contentTypeSer != null) {\n79             /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n80              *    type information for contents. Should work well (for JAXB case); can be\n81              *    revisited if this causes problems.\n82              */\n83             if (serializationType == null) {\n84 //                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n85                 serializationType = declaredType;\n86             }\n87             JavaType ct = serializationType.getContentType();\n88             // Not exactly sure why, but this used to occur; better check explicitly:\n89             if (ct == null) {\n90                 throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n91                         +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n92             }\n93             serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n94             ct = serializationType.getContentType();\n95         }\n96         \n97         Object valueToSuppress = null;\n98         boolean suppressNulls = false;\n99 \n100         JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n101         JsonInclude.Include inclusion = inclV.getValueInclusion();\n102         if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n103             inclusion = JsonInclude.Include.ALWAYS;\n104         }\n105 \n106         // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n107         JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n108         \n109         switch (inclusion) {\n110         case NON_DEFAULT:\n111             // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n112             //    so that if enclosing class has this, we may need to values of property,\n113             //    whereas for global defaults OR per-property overrides, we have more\n114             //    static definition. Sigh.\n115             // First: case of class specifying it; try to find POJO property defaults\n116             if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n117                 valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n118             } else {\n119                 valueToSuppress = getDefaultValue(actualType);\n120             }\n121             if (valueToSuppress == null) {\n122                 suppressNulls = true;\n123             } else {\n124                 if (valueToSuppress.getClass().isArray()) {\n125                     valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n126                 }\n127             }\n128 \n129             break;\n130         case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n131             // always suppress nulls\n132             suppressNulls = true;\n133             // and for referential types, also \"empty\", which in their case means \"absent\"\n134             if (declaredType.isReferenceType()) {\n135                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n136             }\n137             break;\n138         case NON_EMPTY:\n139             // always suppress nulls\n140             suppressNulls = true;\n141             // but possibly also 'empty' values:\n142             valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n143             break;\n144         case NON_NULL:\n145             suppressNulls = true;\n146             // fall through\n147         case ALWAYS: // default\n148         default:\n149             // we may still want to suppress empty collections, as per [JACKSON-254]:\n150             if (declaredType.isContainerType()\n151                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n152                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n153             }\n154             break;\n155         }\n156         BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n157                 am, _beanDesc.getClassAnnotations(), declaredType,\n158                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n159 \n160         // How about custom null serializer?\n161         Object serDef = _annotationIntrospector.findNullSerializer(am);\n162         if (serDef != null) {\n163             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n164         }\n165         // And then, handling of unwrapping\n166         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n167         if (unwrapper != null) {\n168             bpw = bpw.unwrappingWriter(unwrapper);\n169         }\n170         return bpw;\n171     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.PropertyBuilder"}, {"bug_name": "JacksonDatabind_55", "report_text": "> EnumMap keys not using enum's @JsonProperty values unlike Enum values\n> \n> Based on these issues:  \n> [#677](https://github.com/FasterXML/jackson-databind/issues/677)  \n> [#1148](https://github.com/FasterXML/jackson-databind/issues/1148)  \n> [FasterXML/jackson-annotations#96](https://github.com/FasterXML/jackson-annotations/issues/96)\n> I implemented @JsonProperty for my enum constants and they show up nicely when they are property values. But I also have an EnumMap which uses the enum, and it's generated JSON uses the original enum names for the keys and not the JsonProperty values.\n> Using 2.8.1 (in spring boot 4.3.2)\n> Thanks!", "test_name": "com.fasterxml.jackson.databind.ser.TestEnumSerialization::testEnumsWithJsonPropertyAsKey", "test_method": "    public void testEnumsWithJsonPropertyAsKey() throws Exception\n    {\n        EnumMap<EnumWithJsonProperty,String> input = new EnumMap<EnumWithJsonProperty,String>(EnumWithJsonProperty.class);\n        input.put(EnumWithJsonProperty.A, \"b\");\n        assertEquals(\"{\\\"aleph\\\":\\\"b\\\"}\", MAPPER.writeValueAsString(input)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"[aleph]\":\"b\"}> but was:<{\"[A]\":\"b\"}>\n\tcom.fasterxml.jackson.databind.ser.TestEnumSerialization.testEnumsWithJsonPropertyAsKey(TestEnumSerialization.java:441)", "buggy_method": "67 @SuppressWarnings(\"unchecked\")\n68     public static JsonSerializer<Object> getFallbackKeySerializer(SerializationConfig config,\n69             Class<?> rawKeyType)\n70     {\n71         if (rawKeyType != null) {\n72             // 29-Sep-2015, tatu: Odd case here, of `Enum`, which we may get for `EnumMap`; not sure\n73             //   if that is a bug or feature. Regardless, it seems to require dynamic handling\n74             //   (compared to getting actual fully typed Enum).\n75             //  Note that this might even work from the earlier point, but let's play it safe for now\n76             // 11-Aug-2016, tatu: Turns out we get this if `EnumMap` is the root value because\n77             //    then there is no static type\n78             if (rawKeyType == Enum.class) {\n79                 return new Dynamic();\n80             }\n81             if (rawKeyType.isEnum()) {\n82                 return new Default(Default.TYPE_ENUM, rawKeyType);\n83             }\n84         }\n85         return DEFAULT_KEY_SERIALIZER;\n86     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.StdKeySerializers"}, {"bug_name": "JacksonDatabind_56", "report_text": "> Deserializing locale assumes JDK separator (underscore), does not accept RFC specified (hyphen)\n> \n> When deserializing a locale Jackson currently uses the underscore character as the separator rather than the dash. Specifically, in FromStringDeserializer.java line 234:\n> ```\n> int ix = value.indexOf('_');\n> ```\n> Many locale implementations use dash as the separator as per <https://tools.ietf.org/html/rfc5646>\n> Given the RFC states that only the characters a-z A-Z and - are valid it should be possible to leave the current code in for backward-compatibility but it should also check for '-' as a separator.", "test_name": "com.fasterxml.jackson.databind.deser.TestJdkTypes::testLocale", "test_method": "    public void testLocale() throws IOException\n    {\n        assertEquals(new Locale(\"en\", \"US\"),\n                MAPPER.readValue(quote(\"en-US\"), Locale.class)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<en_US> but was:<en-us>\n\tcom.fasterxml.jackson.databind.deser.TestJdkTypes.testLocale(TestJdkTypes.java:148)", "buggy_method": "205 @Override\n206         protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException\n207         {\n208             switch (_kind) {\n209             case STD_FILE:\n210                 return new File(value);\n211             case STD_URL:\n212                 return new URL(value);\n213             case STD_URI:\n214                 return URI.create(value);\n215             case STD_CLASS:\n216                 try {\n217                     return ctxt.findClass(value);\n218                 } catch (Exception e) {\n219                     throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n220                 }\n221             case STD_JAVA_TYPE:\n222                 return ctxt.getTypeFactory().constructFromCanonical(value);\n223             case STD_CURRENCY:\n224                 // will throw IAE if unknown:\n225                 return Currency.getInstance(value);\n226             case STD_PATTERN:\n227                 // will throw IAE (or its subclass) if malformed\n228                 return Pattern.compile(value);\n229             case STD_LOCALE:\n230                 {\n231                     int ix = value.indexOf('_');\n232                     if (ix < 0) { // single argument\n233                         return new Locale(value);\n234                     }\n235                     String first = value.substring(0, ix);\n236                     value = value.substring(ix+1);\n237                     ix = value.indexOf('_');\n238                     if (ix < 0) { // two pieces\n239                         return new Locale(first, value);\n240                     }\n241                     String second = value.substring(0, ix);\n242                     return new Locale(first, second, value.substring(ix+1));\n243                 }\n244             case STD_CHARSET:\n245                 return Charset.forName(value);\n246             case STD_TIME_ZONE:\n247                 return TimeZone.getTimeZone(value);\n248             case STD_INET_ADDRESS:\n249                 return InetAddress.getByName(value);\n250             case STD_INET_SOCKET_ADDRESS:\n251                 if (value.startsWith(\"[\")) {\n252                     // bracketed IPv6 (with port number)\n253 \n254                     int i = value.lastIndexOf(']');\n255                     if (i == -1) {\n256                         throw new InvalidFormatException(ctxt.getParser(),\n257                                 \"Bracketed IPv6 address must contain closing bracket\",\n258                                 value, InetSocketAddress.class);\n259                     }\n260 \n261                     int j = value.indexOf(':', i);\n262                     int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n263                     return new InetSocketAddress(value.substring(0, i + 1), port);\n264                 } else {\n265                     int ix = value.indexOf(':');\n266                     if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n267                         // host:port\n268                         int port = Integer.parseInt(value.substring(ix+1));\n269                         return new InetSocketAddress(value.substring(0, ix), port);\n270                     }\n271                     // host or unbracketed IPv6, without port number\n272                     return new InetSocketAddress(value, 0);\n273                 }\n274             }\n275             throw new IllegalArgumentException();\n276         }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.FromStringDeserializer$Std"}, {"bug_name": "JacksonDatabind_57", "report_text": "> ObjectReader.readValues() ignores offset and length when reading an array\n> \n> ObjectReader.readValues ignores offset and length when reading an array. If \\_dataFormatReaders it will always use the full array:\n> <https://github.com/FasterXML/jackson-databind/blob/2.7/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java#L1435>", "test_name": "com.fasterxml.jackson.databind.seq.ReadValuesTest::testRootBeans", "test_method": "    public void testRootBeans() throws Exception\n    {\n        for (Source src : Source.values()) {\n            _testRootBeans(src);\n        } // <-- fails here\n    }", "error_message": "java.io.CharConversionException: Invalid UTF-32 character 0x2261223a(above 10ffff)  at char #1, byte #7)\n\tcom.fasterxml.jackson.core.io.UTF32Reader.reportInvalid(UTF32Reader.java:189)\n\tcom.fasterxml.jackson.core.io.UTF32Reader.read(UTF32Reader.java:150)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser.loadMore(ReaderBasedJsonParser.java:180)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser._skipWSOrEnd(ReaderBasedJsonParser.java:2259)\n\tcom.fasterxml.jackson.core.json.ReaderBasedJsonParser.nextToken(ReaderBasedJsonParser.java:601)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndReadValues(ObjectReader.java:1630)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValues(ObjectReader.java:1441)\n\tcom.fasterxml.jackson.databind.seq.ReadValuesTest._iterator(ReadValuesTest.java:71)\n\tcom.fasterxml.jackson.databind.seq.ReadValuesTest._testRootBeans(ReadValuesTest.java:87)\n\tcom.fasterxml.jackson.databind.seq.ReadValuesTest.testRootBeans(ReadValuesTest.java:49)", "buggy_method": "1435 public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n1436         throws IOException, JsonProcessingException\n1437     {\n1438         if (_dataFormatReaders != null) {\n1439             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n1440         }\n1441         return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n1442                 true));\n1443     }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectReader"}, {"bug_name": "JacksonDatabind_58", "report_text": "> @JsonIgnoreProperties: ignoring the \"cause\" property of Throwable on GAE\n> \n> Deserializing an exception class from json on Google App Engine causes this error:\n> ```\n> Caused by: java.lang.IllegalArgumentException: Can not access private java.lang.Throwable java.lang.Throwable.cause (from class java.lang.Throwable; failed to set access: java.lang.IllegalAccessException: Reflection is not allowed on private java.lang.Throwable java.lang.Throwable.cause\n>     at com.fasterxml.jackson.databind.util.ClassUtil.checkAndFixAccess(ClassUtil.java:505)\n>     at com.fasterxml.jackson.databind.introspect.AnnotatedMember.fixAccess(AnnotatedMember.java:123)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.constructSettableProperty(BeanDeserializerFactory.java:704)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:501)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildThrowableDeserializer(BeanDeserializerFactory.java:356)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:114)\n> ```\n> I tried preventing this by using `@JsonIgnoreProperties`:\n> ```\n> @JsonIgnoreProperties(\"cause\")\n> public class MyException extends RuntimeException { ... }\n> ```\n> ... but the same error still occurs. What am I doing wrong? What else could I do?\n> I've also considered setting `MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS` to false, but I don't like this solution because I need this setting to be `true` in some other cases (in particular, I provide no-arg constructors for Jackson, but they should't be public in my API).", "test_name": "com.fasterxml.jackson.databind.misc.AccessFixTest::testCauseOfThrowableIgnoral", "test_method": "    public void testCauseOfThrowableIgnoral() throws Exception\n    {\n        final SecurityManager origSecMan = System.getSecurityManager();\n        try {\n            System.setSecurityManager(new CauseBlockingSecurityManager());\n            _testCauseOfThrowableIgnoral();\n        } finally {\n            System.setSecurityManager(origSecMan);\n        } // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not access private java.lang.Throwable java.lang.Throwable.cause (from class java.lang.Throwable; failed to set access: Can not force permission: (\"java.lang.reflect.ReflectPermission\" \"suppressAccessChecks\")\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:290)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:269)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3908)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3803)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2797)\n\tcom.fasterxml.jackson.databind.misc.AccessFixTest._testCauseOfThrowableIgnoral(AccessFixTest.java:39)\n\tcom.fasterxml.jackson.databind.misc.AccessFixTest.testCauseOfThrowableIgnoral(AccessFixTest.java:29)", "buggy_method": "703 protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n704             BeanDescription beanDesc, BeanPropertyDefinition propDef,\n705             JavaType propType0)\n706         throws JsonMappingException\n707     {\n708         // need to ensure method is callable (for non-public)\n709         AnnotatedMember mutator = propDef.getNonConstructorMutator();\n710 \n711         if (ctxt.canOverrideAccessModifiers()) {\n712             // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n713             // never needed and attempts may cause problems on some platforms.\n714             // !!! NOTE: should be handled better for 2.8 and later\n715                 mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n716         }\n717         // note: this works since we know there's exactly one argument for methods\n718         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n719                 propType0, propDef.getWrapperName(),\n720                 beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n721         JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n722         // did type change?\n723         if (type != propType0) {\n724             property = property.withType(type);\n725         }\n726 \n727         // First: does the Method specify the deserializer to use? If so, let's use it.\n728         JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n729         type = modifyTypeByAnnotation(ctxt, mutator, type);\n730         TypeDeserializer typeDeser = type.getTypeHandler();\n731         SettableBeanProperty prop;\n732         if (mutator instanceof AnnotatedMethod) {\n733             prop = new MethodProperty(propDef, type, typeDeser,\n734                     beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n735         } else {\n736             prop = new FieldProperty(propDef, type, typeDeser,\n737                     beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n738         }\n739         if (propDeser != null) {\n740             prop = prop.withValueDeserializer(propDeser);\n741         }\n742         // need to retain name of managed forward references:\n743         AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n744         if (ref != null && ref.isManagedReference()) {\n745             prop.setManagedReferenceName(ref.getName());\n746         }\n747         ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n748         if(objectIdInfo != null){\n749             prop.setObjectIdInfo(objectIdInfo);\n750         }\n751         return prop;\n752     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"}, {"bug_name": "JacksonDatabind_60", "report_text": "> Polymorphic type lost when using @JsonValue\n> \n> When suppressing all getters but one with [@JsonIgnore](https://github.com/JsonIgnore) and choosing to use a byte array for serialization (marking its getter with @JsonValue), the typing of the object is changed to \"[B\", which is deserialized to a byte array. I would have expected verbose typing and usage of the constructor marked with @JsonCreator that accepts the byte array to construct the object on deserialization. The behavior is as expected when choosing more fields for serialization, which is redundant data in this case.\n> Running jackson-databind 2.7.4 on Java 1.8.0\\_91.\n> Configuration of the ObjectMapper:\n> ```\n> private final ObjectMapper mapper;\n> public JsonFilter() {\n>     this.mapper = new ObjectMapper();\n>     mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n>     mapper.enableDefaultTyping();\n> }\n> ```\n> Serialization: `mapper.writeValueAsString(message)`  \n> Deserialization: `mapper.readValue(json, RemoteCall.class)`\n> Getter and field:\n> ```\n> /** @serial */\n> private byte[] apdu;\n> @JsonValue\n> public byte[] getBytes() {\n>     return apdu.clone();\n> }\n> ```\n> Constructor:\n> ```\n> @JsonCreator\n> public CommandAPDU(@JsonProperty(value = \"bytes\") byte[] apdu) {\n>     this.apdu = apdu.clone();\n>     parse();\n>     LOG.v(\"com.ubitricity.devices.common.pal.CommandAPDU creator (1)\");\n> }\n> ```\n> Serializes to `\"args\":[[\"[B\",\"AKQEAAnw8fLz9AAAAgA=\"],[\"net.sf.lipermi.call.RemoteInstance\",{\"instanceId\":\"b0e15098-f49e-4328-b072-fc5df42799bd\",\"className\":\"com.ubitricity.devices.common.tasks.ResponseReceiver\"}]]` where \"args\" is an Object array field of the enclosing object.", "test_name": "com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators::testWithCreatorAndJsonValue", "test_method": "    public void testWithCreatorAndJsonValue() throws Exception\n    {\n        final byte[] BYTES = new byte[] { 1, 2, 3, 4, 5 };\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        String json = mapper.writeValueAsString(new Bean1385Wrapper(\n                new Bean1385(BYTES)\n        ));\n        Bean1385Wrapper result = mapper.readValue(json, Bean1385Wrapper.class);\n        assertEquals(Bean1385.class, result.value.getClass()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<class com.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators$Bean1385> but was:<class [B>\n\tcom.fasterxml.jackson.databind.jsontype.TestDefaultWithCreators.testWithCreatorAndJsonValue(TestDefaultWithCreators.java:94)", "buggy_method": "195 @Override\n196     public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n197             TypeSerializer typeSer0) throws IOException\n198     {\n199         // Regardless of other parts, first need to find value to serialize:\n200         Object value = null;\n201         try {\n202             value = _accessorMethod.getValue(bean);\n203             // and if we got null, can also just write it directly\n204             if (value == null) {\n205                 provider.defaultSerializeNull(gen);\n206                 return;\n207             }\n208             JsonSerializer<Object> ser = _valueSerializer;\n209             if (ser == null) { // no serializer yet? Need to fetch\n210 //                ser = provider.findTypedValueSerializer(value.getClass(), true, _property);\n211                 ser = provider.findValueSerializer(value.getClass(), _property);\n212             } else {\n213                 /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n214                  *    this (note: type is for the wrapper type, not enclosed value!)\n215                  */\n216                 if (_forceTypeInformation) {\n217                     typeSer0.writeTypePrefixForScalar(bean, gen);\n218                     ser.serialize(value, gen, provider);\n219                     typeSer0.writeTypeSuffixForScalar(bean, gen);\n220                     return;\n221                 }\n222             }\n223             // 28-Sep-2016, tatu: As per [databind#1385], we do need to do some juggling\n224             //    to use different Object for type id (logical type) and actual serialization\n225             //    (delegat type).\n226             ser.serializeWithType(value, gen, provider, typeSer0);\n227         } catch (IOException ioe) {\n228             throw ioe;\n229         } catch (Exception e) {\n230             Throwable t = e;\n231             // Need to unwrap this specific type, to see infinite recursion...\n232             while (t instanceof InvocationTargetException && t.getCause() != null) {\n233                 t = t.getCause();\n234             }\n235             // Errors shouldn't be wrapped (and often can't, as well)\n236             if (t instanceof Error) {\n237                 throw (Error) t;\n238             }\n239             // let's try to indicate the path best we can...\n240             throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n241         }\n242     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.JsonValueSerializer"}, {"bug_name": "JacksonDatabind_61", "report_text": "> Problems deserializing primitive long field while using TypeResolverBuilder\n> \n> When running the following test app\n> ```\n> import com.fasterxml.jackson.annotation.JsonTypeInfo;\n> import com.fasterxml.jackson.core.JsonFactory;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.SerializationFeature;\n> import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n> import java.io.IOException;\n> import java.util.HashMap;\n> import java.util.Map;\n> public class Main {\n>     public static void main(String[] args) throws IOException {\n>         // Create test data\n>         Data data = new Data();\n>         data.key = 1;\n>         Map<String, Object> mapData = new HashMap<>();\n>         mapData.put(\"longInMap\", 2L);\n>         mapData.put(\"longAsField\", data);\n>         // Configure Jackson to preserve types\n>         JsonFactory factory = new JsonFactory();\n>         ObjectMapper mapper = new ObjectMapper(factory);\n>         StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n>         resolver.init(JsonTypeInfo.Id.CLASS, null);\n>         resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n>         resolver.typeProperty(\"\\_\\_t\");\n>         mapper.setDefaultTyping(resolver);\n>         mapper.enable(SerializationFeature.INDENT\\_OUTPUT);\n>         // Serialize\n>         String json = mapper.writeValueAsString(mapData);\n>         System.out.println(\"json = \" + json);\n>         // Deserialize\n>         Map deserializedData = mapper.readValue(json, Map.class);\n>     }\n>     static class Data {\n>         public long key;\n>     }\n> }\n> ```\n> I get this output and exception\n> ```\n> json = {\n>   \"\\_\\_t\" : \"java.util.HashMap\",\n>   \"longInMap\" : [ \"java.lang.Long\", 2 ],\n>   \"longAsField\" : {\n>     \"\\_\\_t\" : \"com.pinkmatter.bean.serialization.Main$Data\",\n>     \"key\" : [ \"java.lang.Long\", 1 ]\n>   }\n> }\n> Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[\"longAsField\"]->com.pinkmatter.bean.serialization.Data[\"key\"])\n>   at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:379)\n>   at com.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:339)\n>   at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.wrapAndThrow(BeanDeserializerBase.java:1591)\n>   at com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:278)\n>   ...\n> Caused by: java.lang.IllegalArgumentException: Class java.lang.Long not subtype of [simple type, class long]\n>   at com.fasterxml.jackson.databind.type.TypeFactory.constructSpecializedType(TypeFactory.java:359)\n>   at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver.\\_typeFromId(ClassNameIdResolver.java:72)\n>   at com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver.typeFromId(ClassNameIdResolver.java:42)\n>   ...\n> ```\n> I am trying to serialize a bunch of basic plain old java objects from libraries we are using (so we cannot modify the classes or add annotations), while also trying to preserve the types of values in collections (\"longInMap\" in the above example must stay a Long object).\n> The problem is that Jackson throws the above exception when trying to deserialize the primitive `public long key` in the `Data` class. If I change the type to `public int key` then no exception is thrown and deserialization works.\n> Also, since there are many different types of objects and I don't know at compile time exactly what will be serialized I don't think using mix-ins will work.\n> I am using Jackson 2.8.3.", "test_name": "com.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest::testDefaultTypingWithLong", "test_method": "    public void testDefaultTypingWithLong() throws Exception\n    {\n        Data data = new Data();\n        data.key = 1L;\n        Map<String, Object> mapData = new HashMap<String, Object>();\n        mapData.put(\"longInMap\", 2L);\n        mapData.put(\"longAsField\", data);\n\n        // Configure Jackson to preserve types\n        ObjectMapper mapper = new ObjectMapper();\n        StdTypeResolverBuilder resolver = new StdTypeResolverBuilder();\n        resolver.init(JsonTypeInfo.Id.CLASS, null);\n        resolver.inclusion(JsonTypeInfo.As.PROPERTY);\n        resolver.typeProperty(\"__t\");\n        mapper.setDefaultTyping(resolver);\n        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n\n        // Serialize\n        String json = mapper.writeValueAsString(mapData);\n\n        // Deserialize\n        Map<?,?> result = mapper.readValue(json, Map.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Class java.lang.Long not subtype of [simple type, class long] (through reference chain: java.util.HashMap[\"longAsField\"]->com.fasterxml.jackson.databind.jsontype.Data[\"key\"])\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:379)\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:339)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.wrapAndThrow(BeanDeserializerBase.java:1591)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:278)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:178)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:129)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:97)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromAny(AsPropertyTypeDeserializer.java:174)\n\tcom.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer$Vanilla.deserializeWithType(UntypedObjectDeserializer.java:554)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBindStringKeyMap(MapDeserializer.java:509)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:352)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:129)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:97)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserializeWithType(MapDeserializer.java:387)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:63)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3795)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2839)\n\tcom.fasterxml.jackson.databind.jsontype.DefaultTypingWithPrimitivesTest.testDefaultTypingWithLong(DefaultTypingWithPrimitivesTest.java:38)", "buggy_method": "228 public boolean useForType(JavaType t)\n229         {\n230             // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n231             //  primitive types too, regardless\n232 \n233             switch (_appliesFor) {\n234             case NON_CONCRETE_AND_ARRAYS:\n235                 while (t.isArrayType()) {\n236                     t = t.getContentType();\n237                 }\n238                 // fall through\n239             case OBJECT_AND_NON_CONCRETE:\n240                 // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n241                 while (t.isReferenceType()) {\n242                     t = t.getReferencedType();\n243                 }\n244                 return t.isJavaLangObject()\n245                         || (!t.isConcrete()\n246                                 // [databind#88] Should not apply to JSON tree models:\n247                                 && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n248 \n249             case NON_FINAL:\n250                 while (t.isArrayType()) {\n251                     t = t.getContentType();\n252                 }\n253                 // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n254                 while (t.isReferenceType()) {\n255                     t = t.getReferencedType();\n256                 }\n257                 // [databind#88] Should not apply to JSON tree models:\n258                 return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n259             default:\n260             //case JAVA_LANG_OBJECT:\n261                 return t.isJavaLangObject();\n262             }\n263         }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectMapper$DefaultTypeResolverBuilder"}, {"bug_name": "JacksonDatabind_62", "report_text": "> Custom UnmodifiableSetMixin Fails in Jackson 2.7+ but works in Jackson 2.6\n> \n> I'd like to be able to deserialize an `UnmodifiableSet` with default typing enabled. To do this I have created an `UnmodifiableSetMixin` as shown below:\n> **NOTE**: You can find a minimal project with all the source code to reproduce this issue at <https://github.com/rwinch/jackson-unmodifiableset-mixin>\n> ```\n> import com.fasterxml.jackson.annotation.JsonCreator;\n> import com.fasterxml.jackson.annotation.JsonTypeInfo;\n> import java.util.Set;\n> @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)\n> public abstract class UnmodifiableSetMixin {\n>     @JsonCreator\n>     public UnmodifiableSetMixin(Set<?> s) {}\n> }\n> ```\n> I then try to use this to deserialize an empty set.\n> ```\n> public class UnmodifiableSetMixinTest {\n>     static final String EXPECTED\\_JSON = \"[\\\"java.util.Collections$UnmodifiableSet\\\",[]]\";\n>     ObjectMapper mapper;\n>     @Before\n>     public void setup() {\n>         mapper = new ObjectMapper();\n>         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON\\_FINAL, JsonTypeInfo.As.PROPERTY);\n>         mapper.addMixIn(Collections.unmodifiableSet(Collections.<String>emptySet()).getClass(), UnmodifiableSetMixin.class);\n>     }    \n>     @Test\n>     @SuppressWarnings(\"unchecked\")\n>     public void read() throws Exception {\n>         Set<String> foo = mapper.readValue(EXPECTED\\_JSON, Set.class);\n>         assertThat(foo).isEmpty();\n>     }\n> }\n> ```\n> The test passes with Jackson 2.6, but fails using Jackson 2.7+ (including Jackson 2.8.3) with the following stack trace:\n> ```\n> java.lang.IllegalStateException: No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]\n>     at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:240)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:249)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:110)\n>     at com.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:50)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeWithType(CollectionDeserializer.java:310)\n>     at com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:42)\n>     at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3788)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2779)\n>     at sample.UnmodifiableSetMixinTest.read(UnmodifiableSetMixinTest.java:36)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:498)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n>     at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> ```\n> This seems like a passivity issue. Is there a workaround for this problem?", "test_name": "com.fasterxml.jackson.databind.creators.ArrayDelegatorCreatorForCollectionTest::testUnmodifiable", "test_method": "    public void testUnmodifiable() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Class<?> unmodSetType = Collections.unmodifiableSet(Collections.<String>emptySet()).getClass();\n        mapper.addMixIn(unmodSetType, UnmodifiableSetMixin.class);\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n\n        final String EXPECTED_JSON = \"[\\\"\"+unmodSetType.getName()+\"\\\",[]]\";\n\n        Set<?> foo = mapper.readValue(EXPECTED_JSON, Set.class); // <-- fails here\n    }", "error_message": "java.lang.IllegalStateException: No default constructor for [collection type; class java.util.Collections$UnmodifiableSet, contains [simple type, class java.lang.Object]]\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:240)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:251)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:110)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:50)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeWithType(CollectionDeserializer.java:312)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:63)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3807)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2797)\n\tcom.fasterxml.jackson.databind.creators.ArrayDelegatorCreatorForCollectionTest.testUnmodifiable(ArrayDelegatorCreatorForCollectionTest.java:28)", "buggy_method": "169 @Override\n170     public CollectionDeserializer createContextual(DeserializationContext ctxt,\n171             BeanProperty property) throws JsonMappingException\n172     {\n173         // May need to resolve types for delegate-based creators:\n174         JsonDeserializer<Object> delegateDeser = null;\n175         if (_valueInstantiator != null) {\n176             if (_valueInstantiator.canCreateUsingDelegate()) {\n177                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n178                 if (delegateType == null) {\n179                     throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n180                             +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n181                             +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n182                 }\n183                 delegateDeser = findDeserializer(ctxt, delegateType, property);\n184             }\n185         }\n186         // [databind#1043]: allow per-property allow-wrapping of single overrides:\n187         // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n188         //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n189         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n190                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n191         // also, often value deserializer is resolved here:\n192         JsonDeserializer<?> valueDeser = _valueDeserializer;\n193         \n194         // May have a content converter\n195         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n196         final JavaType vt = _collectionType.getContentType();\n197         if (valueDeser == null) {\n198             valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n199         } else { // if directly assigned, probably not yet contextual, so:\n200             valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n201         }\n202         // and finally, type deserializer needs context as well\n203         TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n204         if (valueTypeDeser != null) {\n205             valueTypeDeser = valueTypeDeser.forProperty(property);\n206         }\n207         return withResolved(delegateDeser, valueDeser, valueTypeDeser, unwrapSingle);\n208     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.CollectionDeserializer"}, {"bug_name": "JacksonDatabind_63", "report_text": "> Reference-chain hints use incorrect class-name for inner classes\n> \n> ```\n> import com.fasterxml.jackson.annotation.JsonCreator;\n> import com.fasterxml.jackson.annotation.JsonProperty;\n> import com.fasterxml.jackson.databind.JsonMappingException;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import org.junit.jupiter.api.Test;\n> import java.io.IOException;\n> import static com.google.common.truth.Truth.assertThat;\n> import static org.junit.jupiter.api.Assertions.expectThrows;\n> public class ReferenceChainTest {\n>     // illustrates that jackson's \"reference chain\" help-text uses incorrect class-names for inner classes\n>     @Test public void incorrectReferenceChain() throws IOException {\n>         JsonMappingException jsonMappingException = expectThrows(JsonMappingException.class, () -> {\n>             ObjectMapper objectMapper = new ObjectMapper();\n>             objectMapper.readValue(objectMapper.writeValueAsBytes(new Outer()), Outer.class);\n>         });\n>         JsonMappingException.Reference reference = jsonMappingException.getPath().get(0);\n>         assertThat(reference.toString()).isEqualTo(\"ReferenceChainTest$Outer[\\\"inner\\\"]\");\n>     }\n>     static class Outer {\n>         public Inner inner = new Inner();\n>     }\n>     static class Inner {\n>         public int x;\n>         @JsonCreator public static Inner create(@JsonProperty(\"x\") int x) {\n>             throw new RuntimeException(\"test-exception\");\n>         }\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.exc.ExceptionPathTest::testReferenceChainForInnerClass", "test_method": "    public void testReferenceChainForInnerClass() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new Outer());\n        try {\n            MAPPER.readValue(json, Outer.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            JsonMappingException.Reference reference = e.getPath().get(0);\n            assertEquals(getClass().getName()+\"$Outer[\\\"inner\\\"]\",\n                    reference.toString());\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<....databind.deser.exc.[ExceptionPathTest$]Outer[\"inner\"]> but was:<....databind.deser.exc.[]Outer[\"inner\"]>\n\tcom.fasterxml.jackson.databind.deser.exc.ExceptionPathTest.testReferenceChainForInnerClass(ExceptionPathTest.java:37)", "buggy_method": "119 public String getDescription() {\n120             if (_desc == null) {\n121                 StringBuilder sb = new StringBuilder();\n122 \n123                 if (_from == null) { // can this ever occur?\n124                     sb.append(\"UNKNOWN\");\n125                 } else {\n126                     Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n127                     // Hmmh. Although Class.getName() is mostly ok, it does look\n128                     // butt-ugly for arrays.\n129                     // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n130                     //   as it drops enclosing class. So let's try bit different approach\n131                     String pkgName = ClassUtil.getPackageName(cls);\n132                     if (pkgName != null) {\n133                         sb.append(pkgName);\n134                         sb.append('.');\n135                     }\n136                     sb.append(cls.getSimpleName());\n137                 }\n138                 sb.append('[');\n139                 if (_fieldName != null) {\n140                     sb.append('\"');\n141                     sb.append(_fieldName);\n142                     sb.append('\"');\n143                 } else if (_index >= 0) {\n144                     sb.append(_index);\n145                 } else {\n146                     sb.append('?');\n147                 }\n148                 sb.append(']');\n149                 _desc = sb.toString();\n150             }\n151             return _desc;\n152         }", "bm_classpath": "com.fasterxml.jackson.databind.JsonMappingException$Reference"}, {"bug_name": "JacksonDatabind_64", "report_text": "> Further issues with @JsonInclude with NON_DEFAULT\n> \n> (follow-up to [#1351](https://github.com/FasterXML/jackson-databind/issues/1351))\n> Looks like there are still cases where class annotation like:\n> ```\n> @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n> ```\n> does not work for default `null` value suppression for `String` type (at least).", "test_name": "com.fasterxml.jackson.databind.filter.JsonIncludeTest::testIssue1351", "test_method": "    public void testIssue1351() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);\n        // [databind#1417]\n        assertEquals(aposToQuotes(\"{}\"),\n                mapper.writeValueAsString(new Issue1351NonBean(0))); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{[]}> but was:<{[\"str\":null]}>\n\tcom.fasterxml.jackson.databind.filter.JsonIncludeTest.testIssue1351(JsonIncludeTest.java:320)", "buggy_method": "89 @SuppressWarnings(\"deprecation\")\n90     protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n91             BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n92             TypeSerializer typeSer, TypeSerializer contentTypeSer,\n93             AnnotatedMember am, boolean defaultUseStaticTyping)\n94         throws JsonMappingException\n95     {\n96         // do we have annotation that forces type to use (to declared type or its super type)?\n97         JavaType serializationType;\n98         try {\n99             serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n100         } catch (JsonMappingException e) {\n101             return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n102         }\n103 \n104         // Container types can have separate type serializers for content (value / element) type\n105         if (contentTypeSer != null) {\n106             /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n107              *    type information for contents. Should work well (for JAXB case); can be\n108              *    revisited if this causes problems.\n109              */\n110             if (serializationType == null) {\n111 //                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n112                 serializationType = declaredType;\n113             }\n114             JavaType ct = serializationType.getContentType();\n115             // Not exactly sure why, but this used to occur; better check explicitly:\n116             if (ct == null) {\n117                 prov.reportBadPropertyDefinition(_beanDesc, propDef,\n118                         \"serialization type \"+serializationType+\" has no content\");\n119             }\n120             serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n121             ct = serializationType.getContentType();\n122         }\n123 \n124         Object valueToSuppress = null;\n125         boolean suppressNulls = false;\n126 \n127         // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n128         JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n129         \n130         // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n131         //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n132         //   for declared property type... and finally property annotation overrides\n133         JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n134                 _defaultInclusion);\n135 \n136         // property annotation override\n137         \n138         inclV = inclV.withOverrides(propDef.findInclusion());\n139         JsonInclude.Include inclusion = inclV.getValueInclusion();\n140 \n141         if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n142             inclusion = JsonInclude.Include.ALWAYS;\n143         }\n144         \n145         switch (inclusion) {\n146         case NON_DEFAULT:\n147             // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n148             //    so that if enclosing class has this, we may need to access values of property,\n149             //    whereas for global defaults OR per-property overrides, we have more\n150             //    static definition. Sigh.\n151             // First: case of class/type specifying it; try to find POJO property defaults\n152 \n153             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n154             //    revert logic to the case of general/per-property handling, so both\n155             //    type-default AND null are to be excluded.\n156             //    (as per [databind#1417]\n157             if (_useRealPropertyDefaults) {\n158                 // 07-Sep-2016, tatu: may also need to front-load access forcing now\n159                 if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n160                     am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n161                 }\n162                 valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n163             } else {\n164                 valueToSuppress = getDefaultValue(actualType);\n165                 suppressNulls = true;\n166             }\n167             if (valueToSuppress == null) {\n168                 suppressNulls = true;\n169             } else {\n170                 if (valueToSuppress.getClass().isArray()) {\n171                     valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n172                 }\n173             }\n174             break;\n175         case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n176             // always suppress nulls\n177             suppressNulls = true;\n178             // and for referential types, also \"empty\", which in their case means \"absent\"\n179             if (actualType.isReferenceType()) {\n180                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n181             }\n182             break;\n183         case NON_EMPTY:\n184             // always suppress nulls\n185             suppressNulls = true;\n186             // but possibly also 'empty' values:\n187             valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n188             break;\n189         case NON_NULL:\n190             suppressNulls = true;\n191             // fall through\n192         case ALWAYS: // default\n193         default:\n194             // we may still want to suppress empty collections, as per [JACKSON-254]:\n195             if (actualType.isContainerType()\n196                     && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n197                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n198             }\n199             break;\n200         }\n201         BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n202                 am, _beanDesc.getClassAnnotations(), declaredType,\n203                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n204 \n205         // How about custom null serializer?\n206         Object serDef = _annotationIntrospector.findNullSerializer(am);\n207         if (serDef != null) {\n208             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n209         }\n210         // And then, handling of unwrapping\n211         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n212         if (unwrapper != null) {\n213             bpw = bpw.unwrappingWriter(unwrapper);\n214         }\n215         return bpw;\n216     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.PropertyBuilder"}, {"bug_name": "JacksonDatabind_65", "report_text": "> StdKeyDeserializer can erroneously use a static factory method with more than one argument\n> \n> While investigating an issue, I found that there was different behavior for normal deserializers and key deserializers where deserializing a value as a field works as expected, but as a map key fails with \"not a valid representation: wrong number of arguments\".\n> A basic example:\n> ```\n> import com.fasterxml.jackson.annotation.*;\n> import com.fasterxml.jackson.core.type.TypeReference;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import org.junit.Test;\n> import java.io.IOException;\n> import java.util.Map;\n> import java.util.Map.Entry;\n> import static org.junit.Assert.assertEquals;\n> public class KeyVsFieldTest {\n>     @Test\n>     public void deserializeAsField() throws IOException {\n>         AsField as\\_field = new ObjectMapper().readValue(\"{\\\"name\\\": \\\"first.last\\\"}\", AsField.class);\n>         assertEquals(as\\_field.getName().\\_firstname, \"first\");\n>         assertEquals(as\\_field.getName().\\_lastname, \"last\");\n>     }\n>     @Test\n>     public void deserializeAsKey() throws IOException {\n>         Map<FullName, Double> map =\n>             new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\", new TypeReference<Map<FullName, Double>>() {\n>             });\n>        /\\* \n>  Fails with: com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not construct Map key of type KeyVsFieldTest$FullName from String \"first.last\": not a valid representation: wrong number of arguments\n>  at [Source: java.io.StringReader@7113b13f; line: 1, column: 2]\n>  \\*/\n>         Entry<FullName, Double> entry = map.entrySet().iterator().next();\n>         assertEquals(entry.getKey().\\_firstname, \"first\");\n>         assertEquals(entry.getKey().\\_lastname, \"last\");\n>         assertEquals(entry.getValue().doubleValue(), 42, 0);\n>     }\n>     public static class AsField {\n>         private final FullName \\_name;\n>         public AsField(@JsonProperty(\"name\") FullName aName) {\n>             \\_name = aName;\n>         }\n>         public FullName getName() {\n>             return \\_name;\n>         }\n>     }\n>     public static class FullName {\n>         private final String \\_firstname;\n>         private final String \\_lastname;\n>         private FullName(String firstname, String lastname) {\n>             \\_firstname = firstname;\n>             \\_lastname = lastname;\n>         }\n>         @JsonCreator\n>         public static FullName valueOf(String value) {\n>             String[] mySplit = value.split(\"\\\\.\");\n>             return new FullName(mySplit[0], mySplit[1]);\n>         }\n>         public static FullName valueOf(String firstname, String lastname) {\n>             return new FullName(firstname, lastname);\n>         }\n>         @JsonValue\n>         @Override\n>         public String toString() {\n>             return \\_firstname + \".\" + \\_lastname;\n>         }\n>     }\n> }\n> ```\n> It looks like this is because in `BasicBeanDescriptor`, `findFactoryMethod` has an incorrect assumption about the contents of `_classInfo.getStaticMethods()`, which will have any method named `valueOf` and static methods annotated with `@JsonCreator`:\n> ```\n>     @Override\n>     public Method findFactoryMethod(Class<?>... expArgTypes)\n>     {\n>         // So, of all single-arg static methods:\n>         for (AnnotatedMethod am : \\_classInfo.getStaticMethods()) {\n>             if (isFactoryMethod(am)) {\n>                 // And must take one of expected arg types (or supertype)\n>                 Class<?> actualArgType = am.getRawParameterType(0);\n>                 for (Class<?> expArgType : expArgTypes) {\n>                     // And one that matches what we would pass in\n>                     if (actualArgType.isAssignableFrom(expArgType)) {\n>                         return am.getAnnotated();\n>                     }\n>                 }\n>             }\n>         }\n>         return null;\n>     }\n> ```\n> This can be worked around by annotating static factory methods not intended to be used as `@JsonCreator`s with `@JsonIgnore`, due to the resolution in `_classInfo.getStaticMethods()`, so is not really urgent.\n> Please let me know if you have any questions about the issue!\n> Thanks,  \n> Chris", "test_name": "com.fasterxml.jackson.databind.deser.KeyDeser1429Test::testDeserializeKeyViaFactory", "test_method": "    public void testDeserializeKeyViaFactory() throws Exception\n    {\n        Map<FullName, Double> map =\n            new ObjectMapper().readValue(\"{\\\"first.last\\\": 42}\",\n                    new TypeReference<Map<FullName, Double>>() { }); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.deser.KeyDeser1429Test$FullName from String \"first.last\": not a valid representation, problem: wrong number of arguments\n\tcom.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:74)\n\tcom.fasterxml.jackson.databind.DeserializationContext.weirdKeyException(DeserializationContext.java:1389)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleWeirdKey(DeserializationContext.java:880)\n\tcom.fasterxml.jackson.databind.deser.std.StdKeyDeserializer.deserializeKey(StdKeyDeserializer.java:128)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBind(MapDeserializer.java:445)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:365)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2861)\n\tcom.fasterxml.jackson.databind.deser.KeyDeser1429Test.testDeserializeKeyViaFactory(KeyDeser1429Test.java:39)", "buggy_method": "115 @Override\n116     public Object deserializeKey(String key, DeserializationContext ctxt)\n117         throws IOException\n118     {\n119         if (key == null) { // is this even legal call?\n120             return null;\n121         }\n122         try {\n123             Object result = _parse(key, ctxt);\n124             if (result != null) {\n125                 return result;\n126             }\n127         } catch (Exception re) {\n128             return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n129         }\n130         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n131             return null;\n132         }\n133         return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n134     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"}, {"bug_name": "JacksonDatabind_66", "report_text": "> Failure with custom Enum key deserializer, polymorphic types\n> \n> Normally the `JsonParser` and the `DeserializationContext` is passed to a `Module`'s `JsonDeserializer`.\n> However, in the `MapDeserializer`, when deserializing a `Map` with an `Enum` key, the `KeyDeserializer` doesn't accept the `JsonParser` as an argument:\n> <https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java#L453>  \n> Object key = keyDes.deserializeKey(keyStr, ctxt);\n> and the `StdKeyDeserializer.DelegatingKD` uses the context's parser\n> <https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java#L315>  \n> Object result = \\_delegate.deserialize(ctxt.getParser(), ctxt);\n> When the type info field is missing from the json, the `DeserializationContext`'s `JsonParser`'s token is `END_OBJECT` (presumably because it `nextToken`'d through the object to find type and whiffed).\n> This makes the module fail since the `JsonParser` in the `Module` is wrong, i.e. not the same as the `JsonParser` in the `MapDeserializer`.\n> Class:\n> ```\n> import com.fasterxml.jackson.annotation.JsonTypeInfo;\n> import java.util.Map;\n> import static com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME;\n> @JsonTypeInfo(use = NAME, property = \"@type\", defaultImpl = SuperType.class)\n> public class SuperType {\n>     private Map<SuperTypeEnum, String> someMap;\n>     public Map<SuperTypeEnum, String> getSomeMap() {\n>         return someMap;\n>     }\n>     public void setSomeMap(Map<SuperTypeEnum, String> someMap) {\n>         this.someMap = someMap;\n>     }\n> }\n> ```\n> Enum:\n> ```\n> public enum SuperTypeEnum {\n>     FOO\n> }\n> ```\n> Test:\n> ```\n> import com.fasterxml.jackson.core.JsonParser;\n> import com.fasterxml.jackson.databind.DeserializationContext;\n> import com.fasterxml.jackson.databind.JsonDeserializer;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.module.SimpleModule;\n> import org.junit.*;\n> import java.io.IOException;\n> import static org.junit.Assert.assertEquals;\n> public class TestDeserializeType {\n>     @Test\n>     public void testNoTypeShouldDeserialize() throws IOException {\n>         String json = \"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\";\n>         ObjectMapper mapper = new ObjectMapper();\n>         SuperType superType = mapper.readValue(json, SuperType.class);\n>         assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\", superType.getSomeMap().get(SuperTypeEnum.FOO));\n>     }\n>     @Test\n>     public void testNoTypeWithModuleShouldDeserialize() throws IOException {\n>         String json = \"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\";\n>         ObjectMapper mapper = new ObjectMapper();\n>         SimpleModule simpleModule = new SimpleModule();\n>         simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\n>             @Override\n>             public SuperTypeEnum deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\n>                     throws IOException {\n>                 return SuperTypeEnum.valueOf(jsonParser.getText());\n>             }\n>         });\n>         mapper.registerModule(simpleModule);\n>         SuperType superType = mapper.readValue(json, SuperType.class);\n>         assertEquals(\"Deserialized someMap.FOO should equal bar\", \"bar\", superType.getSomeMap().get(SuperTypeEnum.FOO));\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumKeySerializerWithPolymorphic", "test_method": "    public void testCustomEnumKeySerializerWithPolymorphic() throws IOException\n    {\n        SimpleModule simpleModule = new SimpleModule();\n        simpleModule.addDeserializer(SuperTypeEnum.class, new JsonDeserializer<SuperTypeEnum>() {\n            @Override\n            public SuperTypeEnum deserialize(JsonParser p, DeserializationContext deserializationContext)\n                    throws IOException\n            {\n                return SuperTypeEnum.valueOf(p.getText());\n            }\n        });\n        ObjectMapper mapper = new ObjectMapper()\n                .registerModule(simpleModule);\n\n        SuperType superType = mapper.readValue(\"{\\\"someMap\\\": {\\\"FOO\\\": \\\"bar\\\"}}\",\n                SuperType.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$SuperTypeEnum from String \"FOO\": not a valid representation: No enum constant com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer.SuperTypeEnum.}\n\tcom.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:74)\n\tcom.fasterxml.jackson.databind.DeserializationContext.weirdKeyException(DeserializationContext.java:1389)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleWeirdKey(DeserializationContext.java:880)\n\tcom.fasterxml.jackson.databind.deser.std.StdKeyDeserializer$DelegatingKD.deserializeKey(StdKeyDeserializer.java:322)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer._readAndBind(MapDeserializer.java:445)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:365)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.deserialize(MapDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:499)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:108)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:276)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:178)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:146)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:105)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:1089)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:63)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n\tcom.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer.testCustomEnumKeySerializerWithPolymorphic(TestCustomEnumKeyDeserializer.java:221)", "buggy_method": "306 @SuppressWarnings(\"resource\")\n307         @Override\n308         public final Object deserializeKey(String key, DeserializationContext ctxt)\n309             throws IOException\n310         {\n311             if (key == null) { // is this even legal call?\n312                 return null;\n313             }\n314             try {\n315                 // Ugh... should not have to give parser which may or may not be correct one...\n316                 Object result = _delegate.deserialize(ctxt.getParser(), ctxt);\n317                 if (result != null) {\n318                     return result;\n319                 }\n320                 return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n321             } catch (Exception re) {\n322                 return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation: %s\", re.getMessage());\n323             }\n324         }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer$DelegatingKD"}, {"bug_name": "JacksonDatabind_67", "report_text": "> Map key deserializerModifiers ignored\n> \n> We have a module that extends simple model to allow us to accept enum names in lower case in a fairly generic manner  \n> Inside that we add the `modifyKeyDeserializer`\n> The incoming class (using immutables) is mapped to a guava immutable map.  \n> Walking through the code:\n> > \n> > com.fasterxml.jackson.datatype.guava.deser.ImmutableMapDeserializer.createContextual  \n> > \n> > calls DeserializationContext.findKeyDeserializer  \n> > \n> > calls DeserializerCache.findKeyDeserializer  \n> > \n> > calls BasicDeserializerFactory.createKeyDeserializer\n> > \n> > \n> > \n> which has the code:\n> ```\n>         // the only non-standard thing is this:\n>         if (deser == null) {\n>             if (type.isEnumType()) {\n>                 return \\_createEnumKeyDeserializer(ctxt, type);\n>             }\n>             deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n>         }\n> ```\n> Since we are an enum type, it returns the value in the `_createEnumKeyDeserializer`, which is the standard enum deserializer.  \n> Below that block is the check for the hasDeserializerModifiers, but since we have returned already, it is never called, so we can't override the behaviour.\n> Module fragment:\n> ```\n>     setDeserializerModifier(new BeanDeserializerModifier() {\n>                 @Override\n>                 @SuppressWarnings(\"unchecked\")\n>                 public JsonDeserializer<Enum> modifyEnumDeserializer(\n>                         DeserializationConfig config,\n>                         final JavaType type,\n>                         BeanDescription beanDesc,\n>                         final JsonDeserializer<?> deserializer) {\n>                     return new JsonDeserializer<Enum>() {\n>                         @Override\n>                         public Enum deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n>                             Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n>                             return Enum.valueOf(rawClass, jp.getValueAsString().toUpperCase());\n>                         }\n>                     };\n>                 }\n>                 @Override\n>                 public KeyDeserializer modifyKeyDeserializer(\n>                         DeserializationConfig config,\n>                         JavaType type,\n>                         KeyDeserializer deserializer) {\n>                     if (!type.isEnumType()) {\n>                         return super.modifyKeyDeserializer(config, type, deserializer);\n>                     }\n>                     return new KeyDeserializer() {\n>                         @Override\n>                         @SuppressWarnings(\"unchecked\")\n>                         public Object deserializeKey(String key, DeserializationContext ctxt)\n>                                 throws IOException, JsonProcessingException {\n>                             Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n>                             return Enum.valueOf(rawClass, key.toUpperCase());\n>                         }\n>                     };\n>                 }\n>             });\n> ```\n> I appreciate the code around here is fairly complex.\n> Related issues (possibly):  \n> [#749](https://github.com/FasterXML/jackson-databind/issues/749)  \n> [#1313](https://github.com/FasterXML/jackson-databind/issues/1313)", "test_name": "com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer::testCustomEnumValueAndKeyViaModifier", "test_method": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testCustomEnumValueAndKeyViaModifier() throws IOException\n    {\n        SimpleModule module = new SimpleModule();\n        module.setDeserializerModifier(new BeanDeserializerModifier() {        \n            @Override\n            public JsonDeserializer<Enum> modifyEnumDeserializer(DeserializationConfig config,\n                    final JavaType type, BeanDescription beanDesc,\n                    final JsonDeserializer<?> deserializer) {\n                return new JsonDeserializer<Enum>() {\n                    @Override\n                    public Enum deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        final String str = p.getValueAsString().toLowerCase();\n                        return KeyEnum.valueOf(rawClass, str);\n                    }\n                };\n            }\n\n            @Override\n            public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config,\n                    final JavaType type, KeyDeserializer deserializer)\n            {\n                if (!type.isEnumType()) {\n                    return deserializer;\n                }\n                return new KeyDeserializer() {\n                    @Override\n                    public Object deserializeKey(String key, DeserializationContext ctxt)\n                            throws IOException\n                    {\n                        Class<? extends Enum> rawClass = (Class<Enum<?>>) type.getRawClass();\n                        return Enum.valueOf(rawClass, key.toLowerCase());\n                    }\n                };\n            }\n        });\n        ObjectMapper mapper = new ObjectMapper()\n                .registerModule(module);\n\n        // First, enum value as is\n        KeyEnum key = mapper.readValue(quote(KeyEnum.replacements.name().toUpperCase()),\n                KeyEnum.class);\n\n        // and then as key\n        EnumMap<KeyEnum,String> map = mapper.readValue(\n                aposToQuotes(\"{'REPlaceMENTS':'foobar'}\"),\n                new TypeReference<EnumMap<KeyEnum,String>>() { }); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Can not deserialize Map key of type com.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer$KeyEnum from String \"REPlaceMENTS\": not one of values excepted for Enum class: [rootDirectory, replacements, licenseString]\n\tcom.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:74)\n\tcom.fasterxml.jackson.databind.DeserializationContext.weirdKeyException(DeserializationContext.java:1389)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleWeirdKey(DeserializationContext.java:880)\n\tcom.fasterxml.jackson.databind.deser.std.StdKeyDeserializer.deserializeKey(StdKeyDeserializer.java:130)\n\tcom.fasterxml.jackson.databind.deser.std.EnumMapDeserializer.deserialize(EnumMapDeserializer.java:139)\n\tcom.fasterxml.jackson.databind.deser.std.EnumMapDeserializer.deserialize(EnumMapDeserializer.java:17)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2861)\n\tcom.fasterxml.jackson.databind.module.TestCustomEnumKeyDeserializer.testCustomEnumValueAndKeyViaModifier(TestCustomEnumKeyDeserializer.java:275)", "buggy_method": "1384 @Override\n1385     public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n1386             JavaType type)\n1387         throws JsonMappingException\n1388     {\n1389         final DeserializationConfig config = ctxt.getConfig();\n1390         KeyDeserializer deser = null;\n1391         if (_factoryConfig.hasKeyDeserializers()) {\n1392             BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n1393             for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n1394                 deser = d.findKeyDeserializer(type, config, beanDesc);\n1395                 if (deser != null) {\n1396                     break;\n1397                 }\n1398             }\n1399         }\n1400         // the only non-standard thing is this:\n1401         if (deser == null) {\n1402             if (type.isEnumType()) {\n1403                 return _createEnumKeyDeserializer(ctxt, type);\n1404             }\n1405             deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n1406         }\n1407         // and then post-processing\n1408         if (deser != null) {\n1409             if (_factoryConfig.hasDeserializerModifiers()) {\n1410                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n1411                     deser = mod.modifyKeyDeserializer(config, type, deser);\n1412                 }\n1413             }\n1414         }\n1415         return deser;\n1416     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"}, {"bug_name": "JacksonDatabind_68", "report_text": "> ACCEPT_SINGLE_VALUE_AS_ARRAY partially broken in 2.7.x, 2.8.x\n> \n> In 2.7.x, 2.8.x versions following test fails with an exception:\n> ```\n> public class Test {\n>     private static final String JSON = \"[{\\\"message\\\":\\\"messageHere\\\"}]\";\n>     static class A {\n>         List<B> bs = Collections.emptyList();\n>         @JsonCreator\n>         A(final List<B> bs) {\n>             this.bs = bs;\n>         }\n>     }\n>     static class B {\n>         List<C> cs = Collections.emptyList();\n>         @JsonCreator\n>         B(final List<C> cs) {\n>             this.cs = cs;\n>         }\n>     }\n>     public static class C {\n>         String message;\n>         @JsonCreator\n>         C(@JsonProperty(\"message\") String message) {\n>             this.message = message;\n>         }\n>     }\n>     @Test\n>     public void test() throws IOException {\n>         ObjectMapper om = new ObjectMapper();\n>         om.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n>         om.readValue(JSON, A.class);\n>     }\n> }\n> com.fasterxml.jackson.databind.exc.InputMismatchException: Can not construct instance of com.fasterxml.jackson.databind.creators.JsonCreatorWithCollectionTest$B, problem: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\n>  at [Source: [{\"message\":\"site is missing from bid request (breq) object\"}]; line: 1, column: 3] (through reference chain: java.util.ArrayList[0])\n>     at com.fasterxml.jackson.databind.exc.InputMismatchException.from(InputMismatchException.java:58)\n>     at com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1354)\n>     at com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1019)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1207)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:314)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:148)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:289)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:261)\n>     at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromArray(BeanDeserializerBase.java:1336)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:174)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\n>     at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3806)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2849)\n>     at com.fasterxml.jackson.databind.creators.JsonCreatorWithCollectionTest.test(JsonCreatorWithCollectionTest.java:51)\n> ```\n> While on 2.5 and 2.6 it works fine.", "test_name": "com.fasterxml.jackson.databind.struct.SingleValueAsArrayTest::testSuccessfulDeserializationOfObjectWithChainedArrayCreators", "test_method": "    public void testSuccessfulDeserializationOfObjectWithChainedArrayCreators() throws IOException\n    {\n        MAPPER.readValue(JSON, Bean1421A.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.struct.SingleValueAsArrayTest$Messages: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:270)\n\tcom.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:1456)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1012)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1204)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:314)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:148)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:287)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:259)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:26)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromArray(BeanDeserializerBase.java:1337)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:174)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:150)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n\tcom.fasterxml.jackson.databind.struct.SingleValueAsArrayTest.testSuccessfulDeserializationOfObjectWithChainedArrayCreators(SingleValueAsArrayTest.java:74)", "buggy_method": "1189 protected Object deserializeFromObjectUsingNonDefault(JsonParser p,\n1190             DeserializationContext ctxt) throws IOException\n1191     {\n1192         if (_delegateDeserializer != null) {\n1193             return _valueInstantiator.createUsingDelegate(ctxt,\n1194                     _delegateDeserializer.deserialize(p, ctxt));\n1195         }\n1196         if (_propertyBasedCreator != null) {\n1197             return _deserializeUsingPropertyBased(p, ctxt);\n1198         }\n1199         // should only occur for abstract types...\n1200         if (_beanType.isAbstract()) {\n1201             return ctxt.handleMissingInstantiator(handledType(), p,\n1202                     \"abstract type (need to add/enable type information?)\");\n1203         }\n1204         return ctxt.handleMissingInstantiator(_beanType.getRawClass(), p,\n1205                 \"no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n1206     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerBase"}, {"bug_name": "JacksonDatabind_69", "report_text": "> Wrong constructor picked up when deserializing object\n> \n> I discovered an issue with Jackson 2.7.8 (and Jackson 2.8.4) when several constructors have parameters annotated with `@JsonProperty` but only one is annotated with `@JsonCreator`.\n> Here's a test case to reproduce it:\n> ```\n> import static org.junit.Assert.assertEquals;\n> import java.io.IOException;\n> import org.junit.Test;\n> import com.fasterxml.jackson.annotation.JsonCreator;\n> import com.fasterxml.jackson.annotation.JsonProperty;\n> import com.fasterxml.jackson.core.JsonParseException;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class TestJackson {\n>   public static final class SimplePojo {\n>     private final int intField;\n>     private final String stringField;\n>     public SimplePojo(@JsonProperty(\"intField\") int intField) {\n>       this(intField, \"empty\");\n>     }\n>     public SimplePojo(@JsonProperty(\"stringField\") String stringField) {\n>       this(-1, stringField);\n>     }\n>     @JsonCreator\n>     public SimplePojo(@JsonProperty(\"intField\") int intField, @JsonProperty(\"stringField\") String stringField) {\n>       this.intField = intField;\n>       this.stringField = stringField;\n>     }\n>     public int getIntField() {\n>       return intField;\n>     }\n>     public String getStringField() {\n>       return stringField;\n>     }\n>   }\n>   @Test\n>   public void testJackson() throws JsonParseException, IOException {\n>     ObjectMapper mapper = new ObjectMapper();\n>     SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class);\n>     assertEquals(1, pojo.getIntField());\n>     assertEquals(\"foo\", pojo.getStringField());\n>   }\n> }\n> ```\n> This test throws an the following exception:\n> ```\n> com.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name 'stringField' (in class org.apache.drill.TestJackson$SimplePojo)\n>  at [Source: { \"intField\": 1, \"stringField\": \"foo\" }; line: 1, column: 1]\n> \tat com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:270)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.reportMappingException(DeserializationContext.java:1234)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:551)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:226)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:141)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:476)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3899)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3794)\n> \tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n> \tat TestJackson.testJackson(TestJackson.java:45)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n> \tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n> \tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n> \tat java.lang.reflect.Method.invoke(Method.java:606)\n> \tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)\n> \tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n> \tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)\n> \tat org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n> \tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)\n> \tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)\n> \tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)\n> \tat org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)\n> \tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)\n> \tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)\n> \tat org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)\n> \tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)\n> \tat org.junit.runners.ParentRunner.run(ParentRunner.java:363)\n> \tat org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)\n> \tat org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n> \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n> \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)\n> \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n> \tat org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> ```\n> After some debugging, it looks like that `BasicDeserializerFactory#_addDeserializerConstructors(...)` is looping over all the constructors, and is not favoring an explicit constructor over a non-explicit one.\n> I actually don't know what should be the expected behavior: should jackson fail when two constructors are annotated, or should jackson favor the one annotated with `@JsonCreator`. Both options look reasonable to me (and I'm actually removing one of the constructors).", "test_name": "com.fasterxml.jackson.databind.creators.Creator1476Test::testConstructorChoice", "test_method": "    public void testConstructorChoice() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        SimplePojo pojo = mapper.readValue(\"{ \\\"intField\\\": 1, \\\"stringField\\\": \\\"foo\\\" }\", SimplePojo.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Could not find creator property with name 'intField' (in class com.fasterxml.jackson.databind.creators.Creator1476Test$SimplePojo)\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:256)\n\tcom.fasterxml.jackson.databind.DeserializationContext.mappingException(DeserializationContext.java:993)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:539)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:228)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:143)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:406)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:352)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3908)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3803)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2797)\n\tcom.fasterxml.jackson.databind.creators.Creator1476Test.testConstructorChoice(Creator1476Test.java:38)", "buggy_method": "161 public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n162             SettableBeanProperty[] injectables)\n163     {\n164         if (creator.getParameterType(0).isCollectionLikeType()) {\n165             verifyNonDup(creator, C_ARRAY_DELEGATE, explicit);\n166                 _arrayDelegateArgs = injectables;\n167         } else {\n168             verifyNonDup(creator, C_DELEGATE, explicit);\n169                 _delegateArgs = injectables;\n170         }\n171     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.CreatorCollector"}, {"bug_name": "JacksonDatabind_70", "report_text": "> ACCEPT_CASE_INSENSITIVE_PROPERTIES fails with @JsonUnwrapped\n> \n> (note: moved from [FasterXML/jackson-dataformat-csv#133](https://github.com/FasterXML/jackson-dataformat-csv/issues/133))\n> When trying to deserialize type like:\n> ```\n> public class Person {\n>   @JsonUnwrapped(prefix = \"businessAddress.\")\n>   public Address businessAddress;\n> }\n> public class Address {\n>   public String street;\n>   public String addon;\n>   public String zip = \"\";\n>   public String town;    \n>   public String country;\n> }\n> ```\n> with case-insensitive mapper (`mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);`) I get exception:\n> ```\n> java.util.NoSuchElementException: No entry 'businessAddress' found, can't remove\n> \tat com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.remove(BeanPropertyMap.java:447)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:534)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\n>    ...\n> ```", "test_name": "com.fasterxml.jackson.databind.struct.TestUnwrapped::testCaseInsensitiveUnwrap", "test_method": "    public void testCaseInsensitiveUnwrap() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n        Person p = mapper.readValue(\"{ }\", Person.class); // <-- fails here\n    }", "error_message": "java.util.NoSuchElementException: No entry 'businessAddress' found, can't remove\n\tcom.fasterxml.jackson.databind.deser.impl.BeanPropertyMap.remove(BeanPropertyMap.java:450)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:534)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:476)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3899)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3794)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n\tcom.fasterxml.jackson.databind.struct.TestUnwrapped.testCaseInsensitiveUnwrap(TestUnwrapped.java:215)", "buggy_method": "426 public void remove(SettableBeanProperty propToRm)\n427     {\n428         ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n429         String key = getPropertyName(propToRm);\n430         boolean found = false;\n431 \n432         for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n433             SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n434             if (prop == null) {\n435                 continue;\n436             }\n437             if (!found) {\n438                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n439                 //   as only former is lower-case in case-insensitive case\n440                 found = key.equals(prop.getName());\n441                 if (found) {\n442                     // need to leave a hole here\n443                     _propsInOrder[_findFromOrdered(prop)] = null;\n444                     continue;\n445                 }\n446             }\n447             props.add(prop);\n448         }\n449         if (!found) {\n450             throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n451         }\n452         init(props);\n453     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap"}, {"bug_name": "JacksonDatabind_71", "report_text": "> Missing KeyDeserializer for CharSequence\n> \n> Looks like use of nominal Map key type of `CharSequence` does not work yet (as of 2.7.8 / 2.8.6).  \n> This is something that is needed to work with certain frameworks, such as Avro's generated POJOs.", "test_name": "com.fasterxml.jackson.databind.deser.TestMapDeserialization::testcharSequenceKeyMap", "test_method": "    public void testcharSequenceKeyMap() throws Exception {\n        String JSON = aposToQuotes(\"{'a':'b'}\");\n        Map<CharSequence,String> result = MAPPER.readValue(JSON, new TypeReference<Map<CharSequence,String>>() { }); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not find a (Map) Key deserializer for type [simple type, class java.lang.CharSequence]\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:284)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._handleUnknownKeyDeserializer(DeserializerCache.java:587)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findKeyDeserializer(DeserializerCache.java:168)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findKeyDeserializer(DeserializationContext.java:500)\n\tcom.fasterxml.jackson.databind.deser.std.MapDeserializer.createContextual(MapDeserializer.java:231)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleSecondaryContextualization(DeserializationContext.java:685)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:482)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3908)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3803)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2816)\n\tcom.fasterxml.jackson.databind.deser.TestMapDeserialization.testcharSequenceKeyMap(TestMapDeserialization.java:507)", "buggy_method": "70 public static StdKeyDeserializer forType(Class<?> raw)\n71     {\n72         int kind;\n73 \n74         // first common types:\n75         if (raw == String.class || raw == Object.class) {\n76             return StringKD.forType(raw);\n77         } else if (raw == UUID.class) {\n78             kind = TYPE_UUID;\n79         } else if (raw == Integer.class) {\n80             kind = TYPE_INT;\n81         } else if (raw == Long.class) {\n82             kind = TYPE_LONG;\n83         } else if (raw == Date.class) {\n84             kind = TYPE_DATE;\n85         } else if (raw == Calendar.class) {\n86             kind = TYPE_CALENDAR;\n87         // then less common ones...\n88         } else if (raw == Boolean.class) {\n89             kind = TYPE_BOOLEAN;\n90         } else if (raw == Byte.class) {\n91             kind = TYPE_BYTE;\n92         } else if (raw == Character.class) {\n93             kind = TYPE_CHAR;\n94         } else if (raw == Short.class) {\n95             kind = TYPE_SHORT;\n96         } else if (raw == Float.class) {\n97             kind = TYPE_FLOAT;\n98         } else if (raw == Double.class) {\n99             kind = TYPE_DOUBLE;\n100         } else if (raw == URI.class) {\n101             kind = TYPE_URI;\n102         } else if (raw == URL.class) {\n103             kind = TYPE_URL;\n104         } else if (raw == Class.class) {\n105             kind = TYPE_CLASS;\n106         } else if (raw == Locale.class) {\n107             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n108             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n109         } else if (raw == Currency.class) {\n110             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n111             return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n112         } else {\n113             return null;\n114         }\n115         return new StdKeyDeserializer(kind, raw);\n116     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer"}, {"bug_name": "JacksonDatabind_73", "report_text": "> @JsonProperty(access = Access.READ_ONLY) - unexpected behaviour\n> \n> Hey,\n> I was hoping to make use of @JsonProperty(access = Access.READ\\_ONLY), but failed.\n> Assume this class:\n> ```\n> public class TestPojo\n> {\n>     private String firstName;\n>     private String lastName;\n>     @JsonProperty(access = Access.READ_ONLY)\n>     public String getFullName()\n>     {\n>         return firstName + \" \" + lastName;\n>     }\n>     public String getFirstName()\n>     {\n>         return firstName;\n>     }\n>     public void setFirstName(String firstName)\n>     {\n>         this.firstName = firstName;\n>     }\n>     public String getLastName()\n>     {\n>         return lastName;\n>     }\n>     public void setLastName(String lastName)\n>     {\n>         this.lastName = lastName;\n>     }\n> }\n> ```\n> I couldn't find a way to stop the deserializer from attempting to deserialize the field \"fullName\".  \n> The only thing that helps is to create a setter and annotate it with `@JsonIgnore`. However, that setter does not make sense and I don't want to have it. Is this a bug in behaviour or am I missing something? Thanks", "test_name": "com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest::testReadOnlyAndWriteOnly", "test_method": "    public void testReadOnlyAndWriteOnly() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReadXWriteY());\n\n        ReadXWriteY result = MAPPER.readValue(\"{\\\"x\\\":5, \\\"y\\\":6}\", ReadXWriteY.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field \"x\" (class com.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest$ReadXWriteY), not marked as ignorable (one known property: \"y\"])\n\tcom.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:62)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleUnknownProperty(DeserializationContext.java:834)\n\tcom.fasterxml.jackson.databind.deser.std.StdDeserializer.handleUnknownProperty(StdDeserializer.java:1093)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownProperty(BeanDeserializerBase.java:1485)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.handleUnknownVanilla(BeanDeserializerBase.java:1463)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:282)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:140)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n\tcom.fasterxml.jackson.databind.deser.ReadOrWriteOnlyTest.testReadOnlyAndWriteOnly(ReadOrWriteOnlyTest.java:66)", "buggy_method": "723 protected void _removeUnwantedAccessor(Map<String, POJOPropertyBuilder> props)\n724     {\n725         final boolean inferMutators = _config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n726         Iterator<POJOPropertyBuilder> it = props.values().iterator();\n727 \n728         while (it.hasNext()) {\n729             POJOPropertyBuilder prop = it.next();\n730             // 26-Jan-2017, tatu: [databind#935]: need to denote removal of\n731             prop.removeNonVisible(inferMutators);\n732         }\n733     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector"}, {"bug_name": "JacksonDatabind_74", "report_text": "> AsPropertyTypeDeserializer ignores DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT\n> \n> The `AsPropertyTypeDeserializer`  implementation does not respect the `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` feature. When deserializing an empty String it throws `DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT` instead of creating a null Object.", "test_name": "com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl::testWithEmptyStringAsNullObject1533", "test_method": "    public void testWithEmptyStringAsNullObject1533() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper().enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n        AsPropertyWrapper wrapper = mapper.readValue(\"{ \\\"value\\\": \\\"\\\" }\", AsPropertyWrapper.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Unexpected token (VALUE_STRING), expected FIELD_NAME: missing property 'type' that is to contain type id  (for class com.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl$AsProperty)\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:270)\n\tcom.fasterxml.jackson.databind.DeserializationContext.wrongTokenException(DeserializationContext.java:1376)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportWrongTokenException(DeserializationContext.java:1197)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedUsingDefaultImpl(AsPropertyTypeDeserializer.java:157)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:88)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:1089)\n\tcom.fasterxml.jackson.databind.deser.SettableBeanProperty.deserialize(SettableBeanProperty.java:502)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:108)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:276)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:140)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3798)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2842)\n\tcom.fasterxml.jackson.databind.jsontype.TestPolymorphicWithDefaultImpl.testWithEmptyStringAsNullObject1533(TestPolymorphicWithDefaultImpl.java:274)", "buggy_method": "133 @SuppressWarnings(\"resource\")\n134     protected Object _deserializeTypedUsingDefaultImpl(JsonParser p, DeserializationContext ctxt,\n135             TokenBuffer tb) throws IOException\n136     {\n137         // As per [JACKSON-614], may have default implementation to use\n138         JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n139         if (deser != null) {\n140             if (tb != null) {\n141                 tb.writeEndObject();\n142                 p = tb.asParser(p);\n143                 // must move to point to the first token:\n144                 p.nextToken();\n145             }\n146             return deser.deserialize(p, ctxt);\n147         }\n148         // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n149         Object result = TypeDeserializer.deserializeIfNatural(p, ctxt, _baseType);\n150         if (result != null) {\n151             return result;\n152         }\n153         // or, something for which \"as-property\" won't work, changed into \"wrapper-array\" type:\n154         if (p.getCurrentToken() == JsonToken.START_ARRAY) {\n155             return super.deserializeTypedFromAny(p, ctxt);\n156         }\n157         ctxt.reportWrongTokenException(p, JsonToken.FIELD_NAME,\n158                 \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n159         return null;\n160     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer"}, {"bug_name": "JacksonDatabind_75", "report_text": "> JsonFormat.Shape.NUMBER_INT does not work when defined on enum type in 2.8\n> \n> Before 2.8 the following worked for years. Now this annotation is not applied and enum is serialized as string. It would work if annotating the field. I am not sure if this is an expected change or not, could you please check?\n> ```\n> public class Test {\n>     @JsonFormat(shape = JsonFormat.Shape.NUMBER\\_INT)\n>     enum Color {\n>         RED,\n>         YELLOW,\n>         GREEN\n>     }\n>     static class Foo {\n>         public final Color color;\n>         Foo(Color color) {\n>             this.color = color;\n>         }\n>     }\n>     public static void main(String[] args) throws JsonProcessingException {\n>         final ObjectMapper mapper = new ObjectMapper();\n>         System.out.println(mapper.writeValueAsString(new Foo(Color.GREEN)));\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.struct.EnumFormatShapeTest::testEnumPropertyAsNumber", "test_method": "    public void testEnumPropertyAsNumber() throws Exception {\n        assertEquals(String.format(aposToQuotes(\"{'color':%s}\"), Color.GREEN.ordinal()),\n                MAPPER.writeValueAsString(new ColorWrapper(Color.GREEN))); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"color\":[2]}> but was:<{\"color\":[\"GREEN\"]}>\n\tcom.fasterxml.jackson.databind.struct.EnumFormatShapeTest.testEnumPropertyAsNumber(EnumFormatShapeTest.java:113)", "buggy_method": "77 @SuppressWarnings(\"unchecked\")\n78     public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n79             BeanDescription beanDesc, JsonFormat.Value format)\n80     {\n81         /* 08-Apr-2015, tatu: As per [databind#749], we can not statically determine\n82          *   between name() and toString(), need to construct `EnumValues` with names,\n83          *   handle toString() case dynamically (for example)\n84          */\n85         EnumValues v = EnumValues.constructFromName(config, (Class<Enum<?>>) enumClass);\n86         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n87         return new EnumSerializer(v, serializeAsIndex);\n88     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.EnumSerializer"}, {"bug_name": "JacksonDatabind_76", "report_text": "> Missing properties when deserializing using a builder class with a non-default constructor and a mutator annotated with @JsonUnwrapped\n> \n> When deserializing using a builder class with a non-default constructor and any number of mutator methods annotated with @JsonUnwrapped, the `BuilderBasedDeserializer::deserializeUsingPropertyBasedWithUnwrapped` method cuts short the process of adding SettableBeanProperties.\n> The logic dictates that once all properties necessary to construct the builder have been found, the builder is constructed using all known SettableBeanProperties that have been found up to that point in the tokenizing process.\n> Therefore, in the case that the builder has a single property required for construction, and that property is found anywhere other than at the end of the JSON content, any properties subsequent to the constructor property are not evaluated and are left with their default values.\n> Given the following classes:\n> ```\n> @JsonDeserialize(builder = Employee.Builder.class)\n> public class Employee {\n>     private final long id;\n>     private final Name name;\n>     private final int age;\n>     private Employee(Builder builder) {\n>         id = builder.id;\n>         name = builder.name;\n>         age = builder.age;\n>     }\n>     public long getId() {\n>         return id;\n>     }\n>     public Name getName() {\n>         return name;\n>     }\n>     public int getAge() {\n>         return age;\n>     }\n>     @JsonPOJOBuilder(withPrefix = \"set\")\n>     public static class Builder {\n>         private final long id;\n>         private Name name;\n>         private int age;\n>         @JsonCreator\n>         public Builder(@JsonProperty(\"emp\\_id\") long id) {\n>             this.id = id;\n>         }\n>         @JsonUnwrapped\n>         public void setName(Name name) {\n>             this.name = name;\n>         }\n>         @JsonProperty(\"emp\\_age\")\n>         public void setAge(int age) {\n>             this.age = age;\n>         }\n>         public Employee build() {\n>             return new Employee(this);\n>         }\n>     }\n> }\n> public class Name {\n>     private final String first;\n>     private final String last;\n>     @JsonCreator\n>     public Name(\n>         @JsonProperty(\"emp\\_first\\_name\") String first,\n>         @JsonProperty(\"emp\\_last\\_name\") String last\n>     ) {\n>         this.first = first;\n>         this.last = last;\n>     }\n>     public String getFirst() {\n>         return first;\n>     }\n>     public String getLast() {\n>         return last;\n>     }\n> }\n> ```\n> And given the following JSON string:\n> ```\n> {\n>     \"emp\\_age\": 30,\n>     \"emp\\_id\": 1234,\n>     \"emp\\_first\\_name\": \"John\",\n>     \"emp\\_last\\_name\": \"Doe\"\n> }\n> ```\n> We will see the following output:\n> ```\n> Employee emp = new ObjectMapper().readValue(json, Employee.class);\n> System.out.println(emp.getAge()); // 30\n> System.out.println(emp.getId()); // 1234\n> System.out.println(emp.getName()); // null\n> ```\n> However, if we place the `emp_id` property at the end of the JSON string, we would get the following output:\n> ```\n> Employee emp = new ObjectMapper().readValue(json, Employee.class);\n> System.out.println(emp.getAge()); // 30\n> System.out.println(emp.getId()); // 1234\n> System.out.println(emp.getName()); // Name Object\n> ```\n> If we were to place `emp_age` and `emp_first_name` and `emp_last_name` all after the `emp_id` property in the JSON string, we would get the following output:\n> ```\n> Employee emp = new ObjectMapper().readValue(json, Employee.class);\n> System.out.println(emp.getAge()); // 0\n> System.out.println(emp.getId()); // 1234\n> System.out.println(emp.getName()); // null\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest::testWithUnwrappedAndCreatorSingleParameterAtBeginning", "test_method": "    public void testWithUnwrappedAndCreatorSingleParameterAtBeginning() throws Exception {\n        final String json = aposToQuotes(\"{'person_id':1234,'first_name':'John','last_name':'Doe','years_old':30,'living':true}\");\n\n        final ObjectMapper mapper = new ObjectMapper();\n        Person person = mapper.readValue(json, Person.class);\n        assertEquals(\"John\", person.getName().getFirst()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<John> but was:<null>\n\tcom.fasterxml.jackson.databind.deser.builder.BuilderWithUnwrappedTest.testWithUnwrappedAndCreatorSingleParameterAtBeginning(BuilderWithUnwrappedTest.java:176)", "buggy_method": "565 @SuppressWarnings(\"resource\")\n566     protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p,\n567     \t\tDeserializationContext ctxt)\n568         throws IOException, JsonProcessingException\n569     {\n570         final PropertyBasedCreator creator = _propertyBasedCreator;\n571         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n572 \n573         TokenBuffer tokens = new TokenBuffer(p, ctxt);\n574         tokens.writeStartObject();\n575 \n576         JsonToken t = p.getCurrentToken();\n577         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n578             String propName = p.getCurrentName();\n579             p.nextToken(); // to point to value\n580             // creator property?\n581             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n582             if (creatorProp != null) {\n583                 if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n584                     t = p.nextToken();\n585                     Object bean;\n586                     try {\n587                         bean = creator.build(ctxt, buffer);\n588                     } catch (Exception e) {\n589                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n590                         continue;\n591                     }\n592                     while (t == JsonToken.FIELD_NAME) {\n593                         p.nextToken();\n594                         tokens.copyCurrentStructure(p);\n595                         t = p.nextToken();\n596                     }\n597                     tokens.writeEndObject();\n598                     if (bean.getClass() != _beanType.getRawClass()) {\n599                         ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n600                         return null;\n601                     }\n602                     return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n603                 }\n604                 continue;\n605             }\n606             // Object Id property?\n607             if (buffer.readIdProperty(propName)) {\n608                 continue;\n609             }\n610             // regular property? needs buffering\n611             SettableBeanProperty prop = _beanProperties.find(propName);\n612             if (prop != null) {\n613                 buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n614                 continue;\n615             }\n616             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n617                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n618                 continue;\n619             }\n620             tokens.writeFieldName(propName);\n621             tokens.copyCurrentStructure(p);\n622             // \"any property\"?\n623             if (_anySetter != null) {\n624                 buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n625             }\n626         }\n627 \n628         // We hit END_OBJECT, so:\n629         Object bean;\n630         // !!! 15-Feb-2012, tatu: Need to modify creator to use Builder!\n631         try {\n632             bean = creator.build(ctxt, buffer);\n633         } catch (Exception e) {\n634             return wrapInstantiationProblem(e, ctxt);\n635         }\n636         return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n637     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BuilderBasedDeserializer"}, {"bug_name": "JacksonDatabind_77", "report_text": "> Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)\n> \n> I have send email to [info@fasterxml.com](mailto:info@fasterxml.com)", "test_name": "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599", "test_method": "    public void testIssue1599() throws Exception\n    {\n        final String JSON = aposToQuotes(\n \"{'id': 124,\\n\"\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n+\"  {\\n\"\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n+\"    'transletName' : 'a.b',\\n\"\n+\"    'outputProperties' : { }\\n\"\n+\"  }\\n\"\n+\" ]\\n\"\n+\"}\"\n        );\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        try {\n            mapper.readValue(JSON, Bean1599.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Illegal type\");\n            verifyException(e, \"to deserialize\");\n            verifyException(e, \"prevented for security reasons\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Illegal type]): got one with message \"N/A\n\tcom.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:368)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest.testIssue1599(IllegalTypesCheckTest.java:35)", "buggy_method": "96 @Override\n97     public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n98             JavaType type, BeanDescription beanDesc)\n99         throws JsonMappingException\n100     {\n101         final DeserializationConfig config = ctxt.getConfig();\n102         // We may also have custom overrides:\n103         JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n104         if (custom != null) {\n105             return custom;\n106         }\n107         /* One more thing to check: do we have an exception type\n108          * (Throwable or its sub-classes)? If so, need slightly\n109          * different handling.\n110          */\n111         if (type.isThrowable()) {\n112             return buildThrowableDeserializer(ctxt, type, beanDesc);\n113         }\n114         /* Or, for abstract types, may have alternate means for resolution\n115          * (defaulting, materialization)\n116          */\n117         // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n118         //    not something we could materialize anything for\n119         if (type.isAbstract() && !type.isPrimitive()) {\n120             // Let's make it possible to materialize abstract types.\n121             JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n122             if (concreteType != null) {\n123                 /* important: introspect actual implementation (abstract class or\n124                  * interface doesn't have constructors, for one)\n125                  */\n126                 beanDesc = config.introspect(concreteType);\n127                 return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n128             }\n129         }\n130 \n131         // Otherwise, may want to check handlers for standard types, from superclass:\n132         @SuppressWarnings(\"unchecked\")\n133         JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n134         if (deser != null) {\n135             return deser;\n136         }\n137 \n138         // Otherwise: could the class be a Bean class? If not, bail out\n139         if (!isPotentialBeanType(type.getRawClass())) {\n140             return null;\n141         }\n142         // For checks like [databind#1599]\n143         // Use generic bean introspection to build deserializer\n144         return buildBeanDeserializer(ctxt, type, beanDesc);\n145     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"}, {"bug_name": "JacksonDatabind_78", "report_text": "> Jackson Deserializer security vulnerability via default typing (CVE-2017-7525)\n> \n> I have send email to [info@fasterxml.com](mailto:info@fasterxml.com)", "test_name": "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testIssue1599", "test_method": "    public void testIssue1599() throws Exception\n    {\n        final String JSON = aposToQuotes(\n \"{'id': 124,\\n\"\n+\" 'obj':[ 'com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\"\n+\"  {\\n\"\n+\"    'transletBytecodes' : [ 'AAIAZQ==' ],\\n\"\n+\"    'transletName' : 'a.b',\\n\"\n+\"    'outputProperties' : { }\\n\"\n+\"  }\\n\"\n+\" ]\\n\"\n+\"}\"\n        );\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping();\n        try {\n            mapper.readValue(JSON, Bean1599.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"Illegal type\");\n            verifyException(e, \"to deserialize\");\n            verifyException(e, \"prevented for security reasons\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Illegal type]): got one with message \"N/A\n\tcom.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:367)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest.testIssue1599(IllegalTypesCheckTest.java:35)", "buggy_method": "110 @Override\n111     public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n112             JavaType type, BeanDescription beanDesc)\n113         throws JsonMappingException\n114     {\n115         final DeserializationConfig config = ctxt.getConfig();\n116         // We may also have custom overrides:\n117         JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc);\n118         if (custom != null) {\n119             return custom;\n120         }\n121         /* One more thing to check: do we have an exception type\n122          * (Throwable or its sub-classes)? If so, need slightly\n123          * different handling.\n124          */\n125         if (type.isThrowable()) {\n126             return buildThrowableDeserializer(ctxt, type, beanDesc);\n127         }\n128         /* Or, for abstract types, may have alternate means for resolution\n129          * (defaulting, materialization)\n130          */\n131         // 29-Nov-2015, tatu: Also, filter out calls to primitive types, they are\n132         //    not something we could materialize anything for\n133         if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {\n134             // Let's make it possible to materialize abstract types.\n135             JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n136             if (concreteType != null) {\n137                 /* important: introspect actual implementation (abstract class or\n138                  * interface doesn't have constructors, for one)\n139                  */\n140                 beanDesc = config.introspect(concreteType);\n141                 return buildBeanDeserializer(ctxt, concreteType, beanDesc);\n142             }\n143         }\n144         // Otherwise, may want to check handlers for standard types, from superclass:\n145         @SuppressWarnings(\"unchecked\")\n146         JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n147         if (deser != null) {\n148             return deser;\n149         }\n150 \n151         // Otherwise: could the class be a Bean class? If not, bail out\n152         if (!isPotentialBeanType(type.getRawClass())) {\n153             return null;\n154         }\n155         // For checks like [databind#1599]\n156         // Use generic bean introspection to build deserializer\n157         return buildBeanDeserializer(ctxt, type, beanDesc);\n158     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"}, {"bug_name": "JacksonDatabind_79", "report_text": "> @JsonIdentityReference not used when setup on class only\n> \n> I am trying to setup @JsonIdentityInfo/@JsonIdentityReference in order to serialize all references to a given class as Object Id (and deserialize them later using a custom ObjectIdResolver to retrieve the proper referenced instance)\n> I use @JsonIdentityReference(alwaysAsId=true) in order to enforce exporting the object id in all cases.  \n> It does not work as expected when I define the annotation only on the class (but it works fine when I set it directly on the property). I would rather not have to define it on every property as I will probably miss some...\n> From what I see in [BeanSerializerBase](https://github.com/FasterXML/jackson-databind/blob/fea0d29eabcb8e4825a318501b35f8a759c91426/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java#L473), the alwaysAsId is reset when not ObjectIdInfo is found on the accessor:\n> ```\n>             ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n>             if (objectIdInfo == null) {\n>                 // no ObjectId override, but maybe ObjectIdRef?\n>                 if (oiw != null) {\n>                     objectIdInfo = intr.findObjectReferenceInfo(accessor,\n>                             new ObjectIdInfo(NAME\\_FOR\\_OBJECT\\_REF, null, null, null));\n> oiw = \\_objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n> ```\n> Shouldn't it be kept to the current value when no override is found ?  \n> I tried to set it back in the default ObjectIdInfo created with NAME\\_FOR\\_OBJECT\\_REF but I am not sure if this is the right way to fix this.\n> Here is test I added in [TestObjectIdSerialization](https://github.com/vboulaye/jackson-databind/blob/master/src/test/java/com/fasterxml/jackson/databind/objectid/TestObjectIdSerialization.java#L324) for this case:\n> ```\n>     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n>     @JsonIdentityReference(alwaysAsId=true)\n>     static class ReallyAlwaysAsId\n>     {\n>         public int value;\n>         public ReallyAlwaysAsId() { this(0); }\n>         public ReallyAlwaysAsId(int v) {\n>             value = v;\n>         }\n>     }\n>     @JsonPropertyOrder(alphabetic=true)\n>     static class ReallyAlwaysContainer\n>     {\n>         @JsonIdentityReference(alwaysAsId=true)\n>         public AlwaysAsId a = new AlwaysAsId(13);\n>         public ReallyAlwaysAsId b = new ReallyAlwaysAsId(13);\n>     }\n>     public void testReallyAlwaysAsId() throws Exception\n>     {\n>         String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer());\n>         assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2}\", json);\n>     }\n> ```", "test_name": "com.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest::testIssue1607", "test_method": "    public void testIssue1607() throws Exception\n    {\n        String json = MAPPER.writeValueAsString(new ReallyAlwaysContainer());\n        assertEquals(aposToQuotes(\"{'alwaysClass':1,'alwaysProp':2}\"), json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"alwaysClass\":[1],\"alwaysProp\":2}> but was:<{\"alwaysClass\":[{\"id\":1,\"value\":13}],\"alwaysProp\":2}>\n\tcom.fasterxml.jackson.databind.objectid.AlwaysAsReferenceFirstTest.testIssue1607(AlwaysAsReferenceFirstTest.java:82)", "buggy_method": "576 @Override\n577     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n578         JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n579         if (ref != null) {\n580             objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n581         }\n582         return objectIdInfo;\n583     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector"}, {"bug_name": "JacksonDatabind_80", "report_text": "> Extraneous type id mapping added for base type itself\n> \n> Looks like type id (name) matching base type is included in type resolution list, automatically. While this might be useful sometimes it seems quite odd, and probably should only be included if:\n> 1. Base type is concrete and\n> 2. Base type has explicit name (not add if default name used)", "test_name": "com.fasterxml.jackson.databind.jsontype.TestTypeNames::testBaseTypeId1616", "test_method": "    public void testBaseTypeId1616() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Collection<NamedType> subtypes = new StdSubtypeResolver().collectAndResolveSubtypesByTypeId(\n                mapper.getDeserializationConfig(),\n                // note: `null` is fine here as `AnnotatedMember`:\n                null,\n                mapper.constructType(Base1616.class)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.fasterxml.jackson.databind.AnnotationIntrospector._findAnnotation(AnnotationIntrospector.java:1336)\n\tcom.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector.findSubtypes(JacksonAnnotationIntrospector.java:556)\n\tcom.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver.collectAndResolveSubtypesByTypeId(StdSubtypeResolver.java:145)\n\tcom.fasterxml.jackson.databind.jsontype.TestTypeNames.testBaseTypeId1616(TestTypeNames.java:47)", "buggy_method": "57 @Override\n58     public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, \n59             AnnotatedMember property, JavaType baseType)\n60     {\n61         final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n62         // for backwards compatibility, must allow null here:\n63         Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n64         \n65         HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n66         // start with registered subtypes (which have precedence)\n67         if (_registeredSubtypes != null) {\n68             for (NamedType subtype : _registeredSubtypes) {\n69                 // is it a subtype of root type?\n70                 if (rawBase.isAssignableFrom(subtype.getType())) { // yes\n71                     AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n72                             subtype.getType());\n73                     _collectAndResolve(curr, subtype, config, ai, collected);\n74                 }\n75             }\n76         }\n77         \n78         // then annotated types for property itself\n79             Collection<NamedType> st = ai.findSubtypes(property);\n80             if (st != null) {\n81                 for (NamedType nt : st) {\n82                     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config,\n83                             nt.getType());\n84                     _collectAndResolve(ac, nt, config, ai, collected);\n85                 }            \n86         }\n87 \n88         NamedType rootType = new NamedType(rawBase, null);\n89         AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n90             \n91         // and finally subtypes via annotations from base type (recursively)\n92         _collectAndResolve(ac, rootType, config, ai, collected);\n93 \n94         return new ArrayList<NamedType>(collected.values());\n95     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver"}, {"bug_name": "JacksonDatabind_81", "report_text": "> Add support for handling primitive/discrepancy problem with type refinements\n> \n> (note: derived from [FasterXML/jackson-module-jaxb-annotations#64](https://github.com/FasterXML/jackson-module-jaxb-annotations/issues/64))\n> The problem is that although `int` and `java.lang.Integer` are related, logically, they are not related by inheritance (or implementation). Since some legacy code may try refinements in this axis it'd be nice to handle this somehow. Two basic approaches would be:\n> 1. Just ignore primitive/wrapper override, return original type as is\n> 2. Allow wrapper to \"refine\" primitive, return wrapper.\n> There is also related question of whether to allow \"int to long\" and similar refinements, but start with basics.", "test_name": "com.fasterxml.jackson.databind.introspect.TypeCoercion1592Test::testTypeCoercion1592", "test_method": "    public void testTypeCoercion1592() throws Exception\n    {\n        // first, serialize\n        MAPPER.writeValueAsString(new Bean1592()); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid definition for property \"i\" (of type com.fasterxml.jackson.databind.introspect.TypeCoercion1592Test$Bean1592): Can not refine serialization type [simple type, class int] into java.lang.Integer; types not related\n\tcom.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:72)\n\tcom.fasterxml.jackson.databind.SerializerProvider.reportBadPropertyDefinition(SerializerProvider.java:1185)\n\tcom.fasterxml.jackson.databind.ser.PropertyBuilder.buildWriter(PropertyBuilder.java:103)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory._constructWriter(BeanSerializerFactory.java:881)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanProperties(BeanSerializerFactory.java:675)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory.constructBeanSerializer(BeanSerializerFactory.java:456)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory.findBeanSerializer(BeanSerializerFactory.java:284)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory._createSerializer2(BeanSerializerFactory.java:236)\n\tcom.fasterxml.jackson.databind.ser.BeanSerializerFactory.createSerializer(BeanSerializerFactory.java:170)\n\tcom.fasterxml.jackson.databind.SerializerProvider._createUntypedSerializer(SerializerProvider.java:1376)\n\tcom.fasterxml.jackson.databind.SerializerProvider._createAndCacheUntypedSerializer(SerializerProvider.java:1327)\n\tcom.fasterxml.jackson.databind.SerializerProvider.findValueSerializer(SerializerProvider.java:509)\n\tcom.fasterxml.jackson.databind.SerializerProvider.findTypedValueSerializer(SerializerProvider.java:712)\n\tcom.fasterxml.jackson.databind.ser.DefaultSerializerProvider.serializeValue(DefaultSerializerProvider.java:308)\n\tcom.fasterxml.jackson.databind.ObjectMapper._configAndWriteValue(ObjectMapper.java:3881)\n\tcom.fasterxml.jackson.databind.ObjectMapper.writeValueAsString(ObjectMapper.java:3195)\n\tcom.fasterxml.jackson.databind.introspect.TypeCoercion1592Test.testTypeCoercion1592(TypeCoercion1592Test.java:31)", "buggy_method": "738 @Override\n739     public JavaType refineSerializationType(final MapperConfig<?> config,\n740             final Annotated a, final JavaType baseType) throws JsonMappingException\n741     {\n742         JavaType type = baseType;\n743         final TypeFactory tf = config.getTypeFactory();\n744 \n745         final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n746         \n747         // Ok: start by refining the main type itself; common to all types\n748 \n749         final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n750         if (serClass != null) {\n751             if (type.hasRawClass(serClass)) {\n752                 // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n753                 //    static typing this way\n754                 type = type.withStaticTyping();\n755             } else {\n756                 Class<?> currRaw = type.getRawClass();\n757                 try {\n758                     // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n759                     //   may be needed here too in future?\n760                     if (serClass.isAssignableFrom(currRaw)) { // common case\n761                         type = tf.constructGeneralizedType(type, serClass);\n762                     } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well\n763                         type = tf.constructSpecializedType(type, serClass);\n764                         // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n765                     } else {\n766                         throw new JsonMappingException(null,\n767                                 String.format(\"Can not refine serialization type %s into %s; types not related\",\n768                                         type, serClass.getName()));\n769                     }\n770                 } catch (IllegalArgumentException iae) {\n771                     throw new JsonMappingException(null,\n772                             String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\",\n773                                     type, serClass.getName(), a.getName(), iae.getMessage()),\n774                                     iae);\n775                 }\n776             }\n777         }\n778         // Then further processing for container types\n779 \n780         // First, key type (for Maps, Map-like types):\n781         if (type.isMapLikeType()) {\n782             JavaType keyType = type.getKeyType();\n783             final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n784             if (keyClass != null) {\n785                 if (keyType.hasRawClass(keyClass)) {\n786                     keyType = keyType.withStaticTyping();\n787                 } else {\n788                     Class<?> currRaw = keyType.getRawClass();\n789                     try {\n790                         // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n791                         //   specialize (narrow) type sometimes, even if more commonly opposite\n792                         //   is needed.\n793                         if (keyClass.isAssignableFrom(currRaw)) { // common case\n794                             keyType = tf.constructGeneralizedType(keyType, keyClass);\n795                         } else if (currRaw.isAssignableFrom(keyClass)) { // specialization, ok as well\n796                             keyType = tf.constructSpecializedType(keyType, keyClass);\n797                             // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n798                         } else {\n799                             throw new JsonMappingException(null,\n800                                     String.format(\"Can not refine serialization key type %s into %s; types not related\",\n801                                             keyType, keyClass.getName()));\n802                         }\n803                     } catch (IllegalArgumentException iae) {\n804                         throw new JsonMappingException(null,\n805                                 String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\",\n806                                         type, keyClass.getName(), a.getName(), iae.getMessage()),\n807                                         iae);\n808                     }\n809                 }\n810                 type = ((MapLikeType) type).withKeyType(keyType);\n811             }\n812         }\n813 \n814         JavaType contentType = type.getContentType();\n815         if (contentType != null) { // collection[like], map[like], array, reference\n816             // And then value types for all containers:\n817            final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n818            if (contentClass != null) {\n819                if (contentType.hasRawClass(contentClass)) {\n820                    contentType = contentType.withStaticTyping();\n821                } else {\n822                    // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n823                    //   specialize (narrow) type sometimes, even if more commonly opposite\n824                    //   is needed.\n825                    Class<?> currRaw = contentType.getRawClass();\n826                    try {\n827                        if (contentClass.isAssignableFrom(currRaw)) { // common case\n828                            contentType = tf.constructGeneralizedType(contentType, contentClass);\n829                        } else if (currRaw.isAssignableFrom(contentClass)) { // specialization, ok as well\n830                            contentType = tf.constructSpecializedType(contentType, contentClass);\n831                            // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n832                        } else {\n833                            throw new JsonMappingException(null,\n834                                    String.format(\"Can not refine serialization content type %s into %s; types not related\",\n835                                            contentType, contentClass.getName()));\n836                        }\n837                    } catch (IllegalArgumentException iae) { // shouldn't really happen\n838                        throw new JsonMappingException(null,\n839                                String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\",\n840                                        type, contentClass.getName(), a.getName(), iae.getMessage()),\n841                                        iae);\n842                    }\n843                }\n844                type = type.withContentType(contentType);\n845            }\n846         }\n847         return type;\n848     }", "bm_classpath": "com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector"}, {"bug_name": "JacksonDatabind_82", "report_text": "> JsonIgnoreProperties.allowSetters is not working in Jackson 2.8\n> \n> ```\n> @JsonIgnoreProperties(value = { \"password\" }, ignoreUnknown = true, allowSetters = true)\n> public class JsonTest {\n> \tprivate String username;\n> \tprivate String password;\n> \tpublic JsonTest() {\n> \t\tsuper();\n> \t\t// TODO Auto-generated constructor stub\n> \t}\n> \tpublic JsonTest(String username, String password) {\n> \t\tsuper();\n> \t\tthis.username = username;\n> \t\tthis.password = password;\n> \t}\n> \tpublic String getUsername() {\n> \t\treturn username;\n> \t}\n> \tpublic void setUsername(String username) {\n> \t\tthis.username = username;\n> \t}\n> \tpublic String getPassword() {\n> \t\treturn password;\n> \t}\n> \tpublic void setPassword(String password) {\n> \t\tthis.password = password;\n> \t}\n> \tpublic static void main(String[] args) {\n> \t\tObjectMapper mapper = new ObjectMapper();\n> \t\tJsonTest json = new JsonTest(\"user\", \"password\");\n> \t\ttry {\n> \t\t\tSystem.out.println(mapper.writeValueAsString(json));\n> \t\t} catch (JsonProcessingException e) {\n> \t\t\t// TODO Auto-generated catch block\n> \t\t\te.printStackTrace();\n> \t\t}\n> \t\tString jsonString = \"{ \\\"username\\\":\\\"username\\\",\\\"password\\\":\\\"password\\\" }\";\n> \t\ttry {\n> \t\t\tjson = mapper.readValue(jsonString, JsonTest.class);\n> \t\t\tSystem.out.println(json.getPassword());\n> \t\t} catch (IOException e) {\n> \t\t\t// TODO Auto-generated catch block\n> \t\t\te.printStackTrace();\n> \t\t}\n> \t}\n> }\n> ```\n> the version is 2.8.7.  \n> the password cannot deserialize.  \n> the output is:  \n> {\"username\":\"user\"}  \n> null", "test_name": "com.fasterxml.jackson.databind.filter.IgnorePropertyOnDeserTest::testIgnoreGetterNotSetter1595", "test_method": "    public void testIgnoreGetterNotSetter1595() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        Simple1595 config = new Simple1595();\n        config.setId(123);\n        config.setName(\"jack\");\n        String json = mapper.writeValueAsString(config);\n        Simple1595 des = mapper.readValue(aposToQuotes(\"{'id':123,'name':'jack'}\"), Simple1595.class);\n        assertEquals(\"jack\", des.getName()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<jack> but was:<null>\n\tcom.fasterxml.jackson.databind.filter.IgnorePropertyOnDeserTest.testIgnoreGetterNotSetter1595(IgnorePropertyOnDeserTest.java:89)", "buggy_method": "472 protected void addBeanProps(DeserializationContext ctxt,\n473             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n474         throws JsonMappingException\n475     {\n476         final boolean isConcrete = !beanDesc.getType().isAbstract();\n477         final SettableBeanProperty[] creatorProps = isConcrete\n478                 ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n479                 : null;\n480         final boolean hasCreatorProps = (creatorProps != null);\n481         \n482         // 01-May-2016, tatu: Which base type to use here gets tricky, since\n483         //   it may often make most sense to use general type for overrides,\n484         //   but what we have here may be more specific impl type. But for now\n485         //   just use it as is.\n486         JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n487                 .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n488                         beanDesc.getClassInfo());\n489         Set<String> ignored;\n490 \n491         if (ignorals != null) {\n492             boolean ignoreAny = ignorals.getIgnoreUnknown();\n493             builder.setIgnoreUnknownProperties(ignoreAny);\n494             // Or explicit/implicit definitions?\n495             ignored = ignorals.getIgnored();\n496             for (String propName : ignored) {\n497                 builder.addIgnorable(propName);\n498             }\n499         } else {\n500             ignored = Collections.emptySet();\n501         }\n502 \n503         // Also, do we have a fallback \"any\" setter?\n504         AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n505         AnnotatedMember anySetterField = null;\n506         if (anySetterMethod != null) {\n507             builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n508         }\n509         else {\n510         \tanySetterField = beanDesc.findAnySetterField();\n511         \tif(anySetterField != null) {\n512         \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n513         \t}\n514         }\n515         // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n516         // Implicit ones via @JsonIgnore and equivalent?\n517         if (anySetterMethod == null && anySetterField == null) {\n518             Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n519             if (ignored2 != null) {\n520                 for (String propName : ignored2) {\n521                     // allow ignoral of similarly named JSON property, but do not force;\n522                     // latter means NOT adding this to 'ignored':\n523                     builder.addIgnorable(propName);\n524                 }\n525             }\n526         }\n527         final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n528                 && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS);\n529 \n530         // Ok: let's then filter out property definitions\n531         List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n532                 beanDesc, builder, beanDesc.findProperties(), ignored);\n533 \n534         // After which we can let custom code change the set\n535         if (_factoryConfig.hasDeserializerModifiers()) {\n536             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n537                 propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n538             }\n539         }\n540         \n541         // At which point we still have all kinds of properties; not all with mutators:\n542         for (BeanPropertyDefinition propDef : propDefs) {\n543             SettableBeanProperty prop = null;\n544             /* 18-Oct-2013, tatu: Although constructor parameters have highest precedence,\n545              *   we need to do linkage (as per [databind#318]), and so need to start with\n546              *   other types, and only then create constructor parameter, if any.\n547              */\n548             if (propDef.hasSetter()) {\n549                 JavaType propertyType = propDef.getSetter().getParameterType(0);\n550                 prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n551             } else if (propDef.hasField()) {\n552                 JavaType propertyType = propDef.getField().getType();\n553                 prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType);\n554             } else if (useGettersAsSetters && propDef.hasGetter()) {\n555                 /* May also need to consider getters\n556                  * for Map/Collection properties; but with lowest precedence\n557                  */\n558                 AnnotatedMethod getter = propDef.getGetter();\n559                 // should only consider Collections and Maps, for now?\n560                 Class<?> rawPropertyType = getter.getRawType();\n561                 if (Collection.class.isAssignableFrom(rawPropertyType)\n562                         || Map.class.isAssignableFrom(rawPropertyType)) {\n563                     prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n564                 }\n565             }\n566             // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n567             //   (since they are never used anyway)\n568             if (hasCreatorProps && propDef.hasConstructorParameter()) {\n569                 /* If property is passed via constructor parameter, we must\n570                  * handle things in special way. Not sure what is the most optimal way...\n571                  * for now, let's just call a (new) method in builder, which does nothing.\n572                  */\n573                 // but let's call a method just to allow custom builders to be aware...\n574                 final String name = propDef.getName();\n575                 CreatorProperty cprop = null;\n576                 if (creatorProps != null) {\n577                     for (SettableBeanProperty cp : creatorProps) {\n578                         if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) {\n579                             cprop = (CreatorProperty) cp;\n580                             break;\n581                         }\n582                     }\n583                 }\n584                 if (cprop == null) {\n585                     List<String> n = new ArrayList<>();\n586                     for (SettableBeanProperty cp : creatorProps) {\n587                         n.add(cp.getName());\n588                     }\n589                     ctxt.reportBadPropertyDefinition(beanDesc, propDef,\n590                             \"Could not find creator property with name '%s' (known Creator properties: %s)\",\n591                             name, n);\n592                     continue;\n593                 }\n594                 if (prop != null) {\n595                     cprop.setFallbackSetter(prop);\n596                 }\n597                 prop = cprop;\n598                 builder.addCreatorProperty(cprop);\n599                 continue;\n600             }\n601 \n602             if (prop != null) {\n603                 Class<?>[] views = propDef.findViews();\n604                 if (views == null) {\n605                     // one more twist: if default inclusion disabled, need to force empty set of views\n606                     if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n607                         views = NO_VIEWS;\n608                     }\n609                 }\n610                 // one more thing before adding to builder: copy any metadata\n611                 prop.setViews(views);\n612                 builder.addProperty(prop);\n613             }\n614         }\n615     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializerFactory"}, {"bug_name": "JacksonDatabind_83", "report_text": "> FromStringDeserializer ignores registered DeserializationProblemHandler for java.util.UUID\n> \n> Culprit appears to be [lines 155-161 of FromStringDeserializer](https://github.com/FasterXML/jackson-databind/blob/60ae6000d361f910ab0d7d269a5bac1fc66f4cd9/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java#L155-L161):\n> ```\n>             // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n>             JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n>             if (cause != null) {\n>                 e.initCause(cause);\n>             }\n>             throw e;\n>             // nothing to do here, yet? We'll fail anyway\n> ```\n> The above lines appear to show that the exception will be thrown regardless of any problem handling logic.\n> Test Case:\n> ```\n> import com.fasterxml.jackson.databind.DeserializationContext;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n> import org.junit.Test;\n> import java.io.IOException;\n> import java.util.UUID;\n> public class UUIDDeserializerTest {\n>   @Test\n>   public void itUsesDeserializationProblemHandlerProperly() throws IOException {\n>     ObjectMapper mapper = new ObjectMapper().addHandler(new DeserializationProblemHandler() {\n>       @Override\n>       public Object handleWeirdStringValue(final DeserializationContext ctxt, final Class<?> targetType, final String valueToConvert, final String failureMsg) throws IOException {\n>         return null;\n>       }\n>     });\n>     mapper.readValue(\"{\\\"id\\\" : \\\"I am not a UUID\\\"}\", IdBean.class);\n>   }\n>   public static class IdBean {\n>     private UUID id;\n>     public UUID getId() {\n>       return id;\n>     }\n>     public void setId(final UUID id) {\n>       this.id = id;\n>     }\n>   }\n> }\n> ```\n> The handler handles the issue properly; but an exception is thrown anyway:\n> ```\n> an not deserialize value of type java.util.UUID from String \"I am not a UUID\": not a valid textual representation\n>  at [Source: (String)\"{\"id\" : \"I am not a UUID\"}\"; line: 1, column: 9] (through reference chain: com.company.test.UUIDDeserializerTest$IdBean[\"id\"])\n> com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize value of type java.util.UUID from String \"I am not a UUID\": not a valid textual representation\n>  at [Source: (String)\"{\"id\" : \"I am not a UUID\"}\"; line: 1, column: 9] (through reference chain: com.company.test.UUIDDeserializerTest$IdBean[\"id\"])\n> \tat com.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:67)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:1504)\n> \tat com.fasterxml.jackson.databind.deser.std.FromStringDeserializer.deserialize(FromStringDeserializer.java:156)\n> \tat com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:127)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:287)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3999)\n> \tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2980)\n> ```", "test_name": "com.fasterxml.jackson.databind.filter.ProblemHandlerTest::testWeirdStringHandling", "test_method": "    public void testWeirdStringHandling() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper()\n            .addHandler(new WeirdStringHandler(SingleValuedEnum.A))\n            ;\n        SingleValuedEnum result = mapper.readValue(\"\\\"B\\\"\", SingleValuedEnum.class);\n\n        // also, write [databind#1629] try this\n        mapper = new ObjectMapper()\n                .addHandler(new WeirdStringHandler(null));\n        UUID result2 = mapper.readValue(quote(\"not a uuid!\"), UUID.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidFormatException: Can not deserialize value of type java.util.UUID from String \"not a uuid!\": not a valid textual representation\n\tcom.fasterxml.jackson.databind.exc.InvalidFormatException.from(InvalidFormatException.java:74)\n\tcom.fasterxml.jackson.databind.DeserializationContext.weirdStringException(DeserializationContext.java:1410)\n\tcom.fasterxml.jackson.databind.deser.std.FromStringDeserializer.deserialize(FromStringDeserializer.java:135)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3814)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2858)\n\tcom.fasterxml.jackson.databind.filter.ProblemHandlerTest.testWeirdStringHandling(ProblemHandlerTest.java:247)", "buggy_method": "103 @SuppressWarnings(\"unchecked\")\n104     @Override\n105     public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n106     {\n107         // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n108         String text = p.getValueAsString();\n109         if (text != null) { // has String representation\n110             if (text.length() == 0 || (text = text.trim()).length() == 0) {\n111                 // 04-Feb-2013, tatu: Usually should become null; but not always\n112                 return _deserializeFromEmptyString();\n113             }\n114             Exception cause = null;\n115             try {\n116                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n117                 //    indicated error; but that seems wrong. Should be able to return\n118                 //    `null` as value.\n119                 if (_deserialize(text, ctxt) != null) {\n120                 return _deserialize(text, ctxt);\n121                 }\n122             } catch (IllegalArgumentException iae) {\n123                 cause = iae;\n124             } catch (MalformedURLException me) {\n125                 cause = me;\n126             }\n127             String msg = \"not a valid textual representation\";\n128             if (cause != null) {\n129                 String m2 = cause.getMessage();\n130                 if (m2 != null) {\n131                     msg = msg + \", problem: \"+m2;\n132                 }\n133             }\n134             // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n135             JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n136             if (cause != null) {\n137                 e.initCause(cause);\n138             }\n139             throw e;\n140             // nothing to do here, yet? We'll fail anyway\n141         }\n142         JsonToken t = p.getCurrentToken();\n143         // [databind#381]\n144         if (t == JsonToken.START_ARRAY) {\n145             return _deserializeFromArray(p, ctxt);\n146         }\n147         if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n148             // Trivial cases; null to null, instance of type itself returned as is\n149             Object ob = p.getEmbeddedObject();\n150             if (ob == null) {\n151                 return null;\n152             }\n153             if (_valueClass.isAssignableFrom(ob.getClass())) {\n154                 return (T) ob;\n155             }\n156             return _deserializeEmbedded(ob, ctxt);\n157         }\n158         return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n159     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.FromStringDeserializer"}, {"bug_name": "JacksonDatabind_85", "report_text": "> DateTimeSerializerBase ignores configured date format when creating contextual\n> \n> `DateTimeSerializerBase#createContextual` creates a new serializer with `StdDateFormat.DATE_FORMAT_STR_ISO8601` format instead of re-using the actual format that may have been specified on the configuration. See the following code:\n> ```\n> final String pattern = format.hasPattern()\n>                                     ? format.getPattern()\n>                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n> ```\n> Using the `@JsonFormat` annotation on a field will therefore reset the format to Jackson's default even if the annotation doesn't specify any custom format.\n> `DateBasedDeserializer#createContextual` behaves differently and tries to re-use the configured format:\n> ```\n> DateFormat df = ctxt.getConfig().getDateFormat();\n> // one shortcut: with our custom format, can simplify handling a bit\n> if (df.getClass() == StdDateFormat.class) {\n>    ...\n>    StdDateFormat std = (StdDateFormat) df;\n>    std = std.withTimeZone(tz);\n>    ...\n> } else {\n>   // otherwise need to clone, re-set timezone:\n>   df = (DateFormat) df.clone();\n>   df.setTimeZone(tz);\n> }\n> ```\n> Shouldn't the serializer follow the same approach ?", "test_name": "com.fasterxml.jackson.databind.ser.DateSerializationTest::testFormatWithoutPattern", "test_method": "    public void testFormatWithoutPattern() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\"));\n        String json = mapper.writeValueAsString(new DateAsDefaultBeanWithTimezone(0L));\n        assertEquals(aposToQuotes(\"{'date':'1970-01-01X01:00:00'}\"), json); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"date\":\"1970-01-01[X01:00:]00\"}> but was:<{\"date\":\"1970-01-01[T01:00:00.000+01]00\"}>\n\tcom.fasterxml.jackson.databind.ser.DateSerializationTest.testFormatWithoutPattern(DateSerializationTest.java:316)", "buggy_method": "48 @Override\n49     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n50             BeanProperty property) throws JsonMappingException\n51     {\n52         if (property == null) {\n53             return this;\n54         }\n55         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n56         if (format == null) {\n57             return this;\n58         }\n59         // Simple case first: serialize as numeric timestamp?\n60         JsonFormat.Shape shape = format.getShape();\n61         if (shape.isNumeric()) {\n62             return withFormat(Boolean.TRUE, null);\n63         }\n64 \n65         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n66         // First: custom pattern will override things\n67                 if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n68                                 || format.hasLocale() || format.hasTimeZone()) {\n69                     TimeZone tz = format.getTimeZone();\n70                     final String pattern = format.hasPattern()\n71                                     ? format.getPattern()\n72                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n73             final Locale loc = format.hasLocale()\n74                             ? format.getLocale()\n75                             : serializers.getLocale();\n76                     SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n77                     if (tz == null) {\n78                         tz = serializers.getTimeZone();\n79                     }\n80             df.setTimeZone(tz);\n81             return withFormat(Boolean.FALSE, df);\n82         }\n83 \n84         // Otherwise, need one of these changes:\n85 \n86 \n87         // Jackson's own `StdDateFormat` is quite easy to deal with...\n88 \n89         // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n90         //    mechanism for changing `DateFormat` instances (or even clone()ing)\n91         //    So: require it be `SimpleDateFormat`; can't config other types\n92 //            serializers.reportBadDefinition(handledType(), String.format(\n93             // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n94         return this;\n95     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase"}, {"bug_name": "JacksonDatabind_87", "report_text": "> StdDateFormat deserializes dates with no tz/offset as UTC instead of configured timezone\n> \n> Prior to version `2.8.9`, dates without time zone or time offset (eg `1970-01-01T00:00:00.000`) were deserialised in the TimeZone set on the ObjectMapper.  \n> Starting from `2.8.9`, these dates are deserialised in `UTC` - which is a major (breaking) change in behaviour...\n> Example:\n> ```\n> ObjectMapper mapper = new ObjectMapper();\n> mapper.setTimeZone(TimeZone.getTimeZone(\"GMT+2\");\n> Date date = mapper.readValue(\"\\\"1970-01-01T00:00:00.000\\\"\", java.util.Date.class);\n> // date == \"1970-01-01T00:00:00.000+02.00\" with Jackson < 2.8.9\n> // date == \"1970-01-01T00:00:00.000+00.00\" with Jackson  2.8.9\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.TestDateDeserialization::testDateUtilISO8601NoTimezoneNonDefault", "test_method": "    public void testDateUtilISO8601NoTimezoneNonDefault() throws Exception\n    {\n        // In first case, no timezone -> SHOULD use configured timezone\n        ObjectReader r = MAPPER.readerFor(Date.class);\n        TimeZone tz = TimeZone.getTimeZone(\"GMT-2\");\n        Date date1 = r.with(tz)\n                .readValue(quote(\"1970-01-01T00:00:00.000\"));\n        // Second case, should use specified timezone, not configured\n        Date date2 = r.with(TimeZone.getTimeZone(\"GMT+5\"))\n                .readValue(quote(\"1970-01-01T00:00:00.000-02:00\"));\n        assertEquals(date1, date2); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Wed Dec 31 16:00:00 PST 1969> but was:<Wed Dec 31 18:00:00 PST 1969>\n\tcom.fasterxml.jackson.databind.deser.TestDateDeserialization.testDateUtilISO8601NoTimezoneNonDefault(TestDateDeserialization.java:277)", "buggy_method": "428 protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors)\n429             throws ParseException\n430     {\n431         /* 21-May-2009, tatu: DateFormat has very strict handling of\n432          * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n433          */\n434 \n435         /* First: do we have \"zulu\" format ('Z' == \"UTC\")? If yes, that's\n436          * quite simple because we already set date format timezone to be\n437          * UTC, and hence can just strip out 'Z' altogether\n438          */\n439         int len = dateStr.length();\n440         char c = dateStr.charAt(len-1);\n441         DateFormat df;\n442         String formatStr;\n443 \n444         // Need to support \"plain\" date...\n445         if (len <= 10 && Character.isDigit(c)) {\n446             df = _formatPlain;\n447             formatStr = DATE_FORMAT_STR_PLAIN;\n448             if (df == null) {\n449                 df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr,\n450                         _timezone, _locale, _lenient);\n451             }\n452         } else if (c == 'Z') {\n453             df = _formatISO8601_z;\n454             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n455             if (df == null) {\n456                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n457                 //    must use UTC, not whatever is configured as default timezone\n458                 //    (because we know `Z` identifier is used)\n459                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n460                         DEFAULT_TIMEZONE, _locale, _lenient);\n461             }\n462             // may be missing milliseconds... if so, add\n463             if (dateStr.charAt(len-4) == ':') {\n464                 StringBuilder sb = new StringBuilder(dateStr);\n465                 sb.insert(len-1, \".000\");\n466                 dateStr = sb.toString();\n467             }\n468         } else {\n469             // Let's see if we have timezone indicator or not...\n470             if (hasTimeZone(dateStr)) {\n471                 c = dateStr.charAt(len-3);\n472                 if (c == ':') { // remove optional colon\n473                     // remove colon\n474                     StringBuilder sb = new StringBuilder(dateStr);\n475                     sb.delete(len-3, len-2);\n476                     dateStr = sb.toString();\n477                 } else if (c == '+' || c == '-') { // missing minutes\n478                     // let's just append '00'\n479                     dateStr += \"00\";\n480                 }\n481                 // Milliseconds partial or missing; and even seconds are optional\n482                 len = dateStr.length();\n483                 // remove 'T', '+'/'-' and 4-digit timezone-offset\n484                 int timeLen = len - dateStr.lastIndexOf('T') - 6;\n485                 if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n486                     int offset = len - 5; // insertion offset, before tz-offset\n487                     StringBuilder sb = new StringBuilder(dateStr);\n488                     switch (timeLen) {\n489                     case 11:\n490                         sb.insert(offset, '0'); break;\n491                     case 10:\n492                         sb.insert(offset, \"00\"); break;\n493                     case 9: // is this legal? (just second fraction marker)\n494                         sb.insert(offset, \"000\"); break;\n495                     case 8:\n496                         sb.insert(offset, \".000\"); break;\n497                     case 7: // not legal to have single-digit second\n498                         break;\n499                     case 6: // probably not legal, but let's allow\n500                         sb.insert(offset, \"00.000\");\n501                     case 5: // is legal to omit seconds\n502                         sb.insert(offset, \":00.000\");\n503                     }\n504                     dateStr = sb.toString();\n505                 }\n506                 df = _formatISO8601;\n507                 formatStr = DATE_FORMAT_STR_ISO8601;\n508                 if (_formatISO8601 == null) {\n509                     df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr,\n510                             _timezone, _locale, _lenient);\n511                 }\n512             } else {\n513                 // If not, plain date, no timezone\n514                 StringBuilder sb = new StringBuilder(dateStr);\n515                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n516                 // And possible also millisecond part if missing\n517                 if (timeLen < 12) { // missing, or partial\n518                     switch (timeLen) {\n519                     case 11: sb.append('0');\n520                     case 10: sb.append('0');\n521                     case 9: sb.append('0');\n522                         break;\n523                     default:\n524                         sb.append(\".000\");\n525                     }\n526                 }\n527                 sb.append('Z');\n528                 dateStr = sb.toString();\n529                 df = _formatISO8601_z;\n530                 formatStr = DATE_FORMAT_STR_ISO8601_Z;\n531                 if (df == null) {\n532                     // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n533                     //    must use UTC, not whatever is configured as default timezone\n534                     //    (because we know `Z` identifier is used)\n535                     df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr,\n536                             DEFAULT_TIMEZONE, _locale, _lenient);\n537                 }\n538             }\n539         }\n540         Date dt = df.parse(dateStr, pos);\n541         // 22-Dec-2015, tatu: With non-lenient, may get null\n542         if (dt == null) {\n543             throw new ParseException\n544             (String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\",\n545                            dateStr, formatStr, _lenient),\n546                pos.getErrorIndex());\n547         }\n548         return dt;\n549     }", "bm_classpath": "com.fasterxml.jackson.databind.util.StdDateFormat"}, {"bug_name": "JacksonDatabind_88", "report_text": "> Missing type checks when using polymorphic type ids\n> \n> (report by Lukes Euler)\n> `JavaType` supports limited amount of generic typing for textual representation, originally just to support typing needed for `EnumMap` (I think). Based on some reports, it appears that some of type compatibility checks are not performed in those cases; if so, they should be made since there is potential for abuse.  \n> The problem here although actual type assignment will fail later on, ability to trigger some of processing (instantiation of incompatible classes, perhaps assingnment of properties) may itself be vulnerability.", "test_name": "com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test::testNestedTypeCheck1735", "test_method": "    public void testNestedTypeCheck1735() throws Exception\n    {\n        try {\n            MAPPER.readValue(aposToQuotes(\n\"{'w':{'type':'java.util.HashMap<java.lang.String,java.lang.String>'}}\"),\n                    Wrapper1735.class);\n            fail(\"Should not pass\");\n        } catch (JsonMappingException e) {\n            verifyException(e, \"not subtype of\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([not subtype of]): got one (of type com.fasterxml.jackson.databind.JsonMappingException) with message \"Problem deserializing property 'w' (expected type: [simple type, class com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735]; actual type: java.util.HashMap), problem: Can not set com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Payload1735 field com.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test$Wrapper1735.w to java.util.HashMap\n\tcom.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:367)\n\tcom.fasterxml.jackson.databind.jsontype.GenericTypeId1735Test.testNestedTypeCheck1735(GenericTypeId1735Test.java:61)", "buggy_method": "45 protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n46     {\n47         /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n48          *    check if any generics info is added; and only then ask factory\n49          *    to do translation when necessary\n50          */\n51         TypeFactory tf = ctxt.getTypeFactory();\n52         if (id.indexOf('<') > 0) {\n53             // note: may want to try combining with specialization (esp for EnumMap)?\n54             // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n55             //    compatibility -- needed later anyway, and not doing so may open\n56             //    security issues.\n57             JavaType t = tf.constructFromCanonical(id);\n58                 // Probably cleaner to have a method in `TypeFactory` but can't add in patch\n59             return t;\n60         }\n61         Class<?> cls;\n62         try {\n63             cls =  tf.findClass(id);\n64         } catch (ClassNotFoundException e) {\n65             // 24-May-2016, tatu: Ok, this is pretty ugly, but we should always get\n66             //   DeserializationContext, just playing it safe\n67             if (ctxt instanceof DeserializationContext) {\n68                 DeserializationContext dctxt = (DeserializationContext) ctxt;\n69                 // First: we may have problem handlers that can deal with it?\n70                 return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n71             }\n72             // ... meaning that we really should never get here.\n73             return null;\n74         } catch (Exception e) {\n75             throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n76         }\n77         return tf.constructSpecializedType(_baseType, cls);\n78     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.ClassNameIdResolver"}, {"bug_name": "JacksonDatabind_90", "report_text": "> ValueInstantiator.canInstantiate() ignores canCreateUsingArrayDelegate()\n> \n> ### Problem\n> Method Javadoc doesn't match behavior. As a result, delegate collection constructors (for abstract types) don't work properly.\n> ### Tested versions\n> jackson-databind v2.8.7 and v2.9.2.\n> ### Location in code\n> <https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java#L70>\n> ### Expected Behavior\n> Outputs `[]`.\n> ### Observed Behavior\n> ```\n> Exception in thread \"main\" com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `ArrayDelegateDeserializationTest$MyType` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\n>  at [Source: (String)\"[]\"; line: 1, column: 1]\n> \tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1451)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1027)\n> \tat com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:265)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4001)\n> \tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2992)\n> \tat ArrayDelegateDeserializationTest.main(ArrayDelegateDeserializationTest.java:35)\n> ```\n> ### Test code\n> ```\n> import java.util.List;\n> import com.fasterxml.jackson.annotation.JsonCreator;\n> import com.fasterxml.jackson.annotation.JsonValue;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> public class ArrayDelegateDeserializationTest {\n>     public static class MyTypeImpl implements MyType {\n>         private final List<Integer> values;\n>         MyTypeImpl(List<Integer> values) {\n>             this.values = values;\n>         }\n>         @Override\n>         public List<Integer> getValues() {\n>             return values;\n>         }\n>     }\n>     public interface MyType {\n>         @JsonValue\n>         List<Integer> getValues();\n>         @JsonCreator\n>         static MyType of(List<Integer> values) {\n>             return new MyTypeImpl(values);\n>         }\n>     }\n>     public static void main(String[] args) throws Exception {\n>         ObjectMapper mapper = new ObjectMapper();\n>         MyType thing = mapper.readValue(\"[]\", MyType.class);\n>         System.out.println(thing.getValues());\n>     }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test::testDelegatingArray1804", "test_method": "    public void testDelegatingArray1804() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        MyType thing = mapper.readValue(\"[]\", MyType.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test$MyType: abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\n\tcom.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:270)\n\tcom.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:1469)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1012)\n\tcom.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:216)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3814)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2858)\n\tcom.fasterxml.jackson.databind.creators.DelegatingArrayCreator1804Test.testDelegatingArray1804(DelegatingArrayCreator1804Test.java:38)", "buggy_method": "70 public boolean canInstantiate() {\n71         return canCreateUsingDefault()\n72                 || canCreateUsingDelegate() \n73                 || canCreateFromObjectWith() || canCreateFromString()\n74                 || canCreateFromInt() || canCreateFromLong()\n75                 || canCreateFromDouble() || canCreateFromBoolean();\n76     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.ValueInstantiator"}, {"bug_name": "JacksonDatabind_91", "report_text": "> 2.9.2 deserialization regression\n> \n> There seems to be a regression in the latest 2.9.2 release.\n> Using `org.apache.logging.log4j.core.jackson.Log4jJsonObjectMapper` from `org.apache.logging.log4j:log4j-core:2.9.1` to deserialize the appended JSON object is throwing an exception with 2.9.2 but worked with 2.9.1.\n> `org.apache.logging.log4j.core.jackson.Log4jYamlObjectMapper` and `org.apache.logging.log4j.core.jackson.Log4jXmlObjectMapper` fail in similar ways.\n> ### inputString\n> ```\n> {\n>   \"timeMillis\" : 1493121664118,\n>   \"thread\" : \"main\",\n>   \"threadId\" : 1,\n>   \"threadPriority\" : 5,\n>   \"level\" : \"INFO\",\n>   \"loggerName\" : \"HelloWorld\",\n>   \"marker\" : {\n>     \"name\" : \"child\",\n>     \"parents\" : [ {\n>       \"name\" : \"parent\",\n>       \"parents\" : [ {\n>         \"name\" : \"grandparent\"\n>       } ]\n>     } ]\n>   },\n>   \"message\" : \"Hello, world!\",\n>   \"thrown\" : {\n>     \"commonElementCount\" : 0,\n>     \"message\" : \"error message\",\n>     \"name\" : \"java.lang.RuntimeException\",\n>     \"extendedStackTrace\" : [ {\n>       \"class\" : \"logtest.Main\",\n>       \"method\" : \"main\",\n>       \"file\" : \"Main.java\",\n>       \"line\" : 29,\n>       \"exact\" : true,\n>       \"location\" : \"classes/\",\n>       \"version\" : \"?\"\n>     } ]\n>   },\n>   \"contextStack\" : [ \"one\", \"two\" ],\n>   \"loggerFqcn\" : \"org.apache.logging.log4j.spi.AbstractLogger\",\n>   \"endOfBatch\" : false,\n>   \"contextMap\" : {\n>     \"bar\" : \"BAR\",\n>     \"foo\" : \"FOO\"\n>   },\n>   \"source\" : {\n>     \"class\" : \"logtest.Main\",\n>     \"method\" : \"main\",\n>     \"file\" : \"Main.java\",\n>     \"line\" : 29\n>   }\n> }\n> ```\n> ### Exception\n> ```\n> org.apache.logging.log4j.core.parser.ParseException: com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `org.apache.logging.log4j.Level` (although at least one Creator exists): no String-argument constructor/factory method to deserialize from String value ('INFO')\n>  at [Source: (byte[])\"{\n>   \"timeMillis\" : 1493121664118,\n>   \"thread\" : \"main\",\n>   \"threadId\" : 1,\n>   \"threadPriority\" : 5,\n>   \"level\" : \"INFO\",\n>   \"loggerName\" : \"HelloWorld\",\n>   \"marker\" : {\n>     \"name\" : \"child\",\n>     \"parents\" : [ {\n>       \"name\" : \"parent\",\n>       \"parents\" : [ {\n>         \"name\" : \"grandparent\"\n>       } ]\n>     } ]\n>   },\n>   \"message\" : \"Hello, world!\",\n>   \"thrown\" : {\n>     \"commonElementCount\" : 0,\n>     \"message\" : \"error message\",\n>     \"name\" : \"java.lang.RuntimeException\",\n>     \"extendedStackTrace\" : [ {\n>       \"clas\"[truncated 482 bytes]; line: 6, column: 13] (through reference chain: org.apache.logging.log4j.core.impl.Log4jLogEvent[\"level\"])\n> ```\n> ### parsing pseudo code\n> ```\n> import org.apache.logging.log4j.core.LogEvent;\n> import org.apache.logging.log4j.core.parser.LogEventParser;\n> import org.apache.logging.log4j.core.parser.JsonLogEventParser;\n> import java.nio.charset.StandardCharsets;\n> LogEventParser parser = new JsonLogEventParser();\n> LogEvent result = parser.parseFrom(inputString.getBytes(StandardCharsets.UTF\\_8));\n> assert result != null;\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest::testCachedSerialize", "test_method": "    public void testCachedSerialize() throws IOException {\n        ObjectMapper mapper = new ObjectMapper();\n        String json = aposToQuotes(\"{'data':{'1st':'onedata','2nd':'twodata'}}\");\n\n        // Do deserialization with non-annotated map property\n        NonAnnotatedMapHolderClass ignored = mapper.readValue(json, NonAnnotatedMapHolderClass.class);\n\n//mapper = new ObjectMapper();\n        \n        MapHolder model2 = mapper.readValue(json, MapHolder.class);\n        if (!model2.data.containsKey(\"1st (CUSTOM)\")\n            || !model2.data.containsKey(\"2nd (CUSTOM)\")) {\n            fail(\"Not using custom key deserializer for input: \"+json+\"; resulted in: \"+model2.data);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Not using custom key deserializer for input: {\"data\":{\"1st\":\"onedata\",\"2nd\":\"twodata\"}}; resulted in: {1st=onedata, 2nd=twodata}\n\tcom.fasterxml.jackson.databind.deser.jdk.MapDeserializerCachingTest.testCachedSerialize(MapDeserializerCachingTest.java:49)", "buggy_method": "536 private boolean _hasCustomHandlers(JavaType t) {\n537         if (t.isContainerType()) {\n538             // First: value types may have both value and type handlers\n539             JavaType ct = t.getContentType();\n540             if (ct != null) {\n541                 return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n542             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n543             }\n544         }\n545         return false;\n546     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.DeserializerCache"}, {"bug_name": "JacksonDatabind_93", "report_text": "> NullPointerException in SubTypeValidator.validateSubType when validating Spring interface\n> \n> In jackson-databind-2.8.11 jackson-databind-2.9.3 and jackson-databind-2.9.4-SNAPSHOT `SubTypeValidator.validateSubType` fails with a `NullPointerException` if the `JavaType.getRawClass()` is an interface that starts with `org.springframework.` For example, the following will fail:\n> ```\n> package org.springframework.security.core;\n> import java.util.*;\n> public class Authentication {\n> \tprivate List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();\n> \tpublic List<GrantedAuthority> getAuthorities() {\n> \t\treturn this.authorities;\n> \t}\n> \tpublic void setAuthorities(List<GrantedAuthority> authorities) {\n> \t\tthis.authorities = authorities;\n> \t}\n> }\n> ```\n> ```\n> package org.springframework.security.core;\n> public interface GrantedAuthority {\n> \tString getAuthority();\n> }\n> ```\n> ```\n> @Test\n> public void validateSubTypeFailsWithNPE() throws Exception {\n> \tObjectMapper mapper = new ObjectMapper();\n> \tmapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON\\_FINAL, JsonTypeInfo.As.PROPERTY);\n> \tString json = \"{\\\"@class\\\":\\\"org.springframework.security.core.Authentication\\\",\\\"authorities\\\":[\\\"java.util.ArrayList\\\",[]]}\";\n> \tAuthentication authentication = mapper.readValue(json, Authentication.class);\n> }\n> ```\n> with the following stacktrace:\n> ```\n> java.lang.NullPointerException\n> \tat com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator.validateSubType(SubTypeValidator.java:86)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory._validateSubType(BeanDeserializerFactory.java:916)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:135)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:411)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:444)\n> \tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:183)\n> \tat com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:27)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.handlePrimaryContextualization(DeserializationContext.java:651)\n> \tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:471)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n> \tat com.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n> \tat com.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4178)\n> \tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3997)\n> \tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2992)\n> ```\n> In prior versions, the test works.", "test_name": "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testJDKTypes1872", "test_method": "    public void testJDKTypes1872() throws Exception\n    {\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n    \n        String json = aposToQuotes(String.format(\"{'@class':'%s','authorities':['java.util.ArrayList',[]]}\",\n                Authentication1872.class.getName()));\n        Authentication1872 result = mapper.readValue(json, Authentication1872.class); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator.validateSubType(SubTypeValidator.java:85)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory._validateSubType(BeanDeserializerFactory.java:866)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:142)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:403)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findContextualValueDeserializer(DeserializationContext.java:443)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:206)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createContextual(CollectionDeserializer.java:26)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handlePrimaryContextualization(DeserializationContext.java:650)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.resolve(BeanDeserializerBase.java:490)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:293)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:476)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:3915)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3810)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2858)", "buggy_method": "67 public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n68     {\n69         // There are certain nasty classes that could cause problems, mostly\n70         // via default typing -- catch them here.\n71         final Class<?> raw = type.getRawClass();\n72         String full = raw.getName();\n73 \n74         main_check:\n75         do {\n76             if (_cfgIllegalClassNames.contains(full)) {\n77                 break;\n78             }\n79 \n80             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n81             //    for some Spring framework types\n82             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n83             if (full.startsWith(PREFIX_STRING)) {\n84                 for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n85                     String name = cls.getSimpleName();\n86                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n87                     if (\"AbstractPointcutAdvisor\".equals(name)\n88                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n89                             || \"AbstractApplicationContext\".equals(name)) {\n90                         break main_check;\n91                     }\n92                 }\n93             }\n94             return;\n95         } while (false);\n96 \n97         throw JsonMappingException.from(ctxt,\n98                 String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n99     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator"}, {"bug_name": "JacksonDatabind_94", "report_text": "> Block two more gadgets to exploit default typing issue (c3p0, CVE-2018-7489)\n> \n> From an email report there are 2 other c3p0 classes (above and beyond ones listed in [#1737](https://github.com/FasterXML/jackson-databind/issues/1737)) need to be blocked.\n> EDIT 21-Jun-2021: Fix included in:\n> * `2.9.5`\n> * `2.8.11.1`\n> * `2.7.9.3`\n> * `2.6.7.5`", "test_name": "com.fasterxml.jackson.databind.interop.IllegalTypesCheckTest::testC3P0Types", "test_method": "    public void testC3P0Types() throws Exception\n    {\n        _testIllegalType(ComboPooledDataSource.class); // [databind#1931] // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected an exception with one of substrings ([Illegal type]): got one with message \"Can not instantiate value of type [simple type, class com.mchange.v2.c3p0.jacksontest.ComboPooledDataSource] from String value ('/tmp/foobar.txt'); no single-String constructor/factory method\n\tcom.fasterxml.jackson.databind.BaseTest.verifyException(BaseTest.java:368)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest._verifyException(IllegalTypesCheckTest.java:156)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest._verifySecurityException(IllegalTypesCheckTest.java:140)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest._testIllegalType(IllegalTypesCheckTest.java:133)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest._testIllegalType(IllegalTypesCheckTest.java:119)\n\tcom.fasterxml.jackson.databind.interop.IllegalTypesCheckTest.testC3P0Types(IllegalTypesCheckTest.java:115)", "buggy_method": "71 public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n72     {\n73         // There are certain nasty classes that could cause problems, mostly\n74         // via default typing -- catch them here.\n75         final Class<?> raw = type.getRawClass();\n76         String full = raw.getName();\n77 \n78         main_check:\n79         do {\n80             if (_cfgIllegalClassNames.contains(full)) {\n81                 break;\n82             }\n83 \n84             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n85             //    for some Spring framework types\n86             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n87             if (raw.isInterface()) {\n88                 ;\n89             } else if (full.startsWith(PREFIX_SPRING)) {\n90                 for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()){\n91                     String name = cls.getSimpleName();\n92                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n93                     if (\"AbstractPointcutAdvisor\".equals(name)\n94                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n95                             || \"AbstractApplicationContext\".equals(name)) {\n96                         break main_check;\n97                     }\n98                 // [databind#1737]; more 3rd party\n99                 // s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n100                 // s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n101                 // [databind#1931]; more 3rd party\n102                 // com.mchange.v2.c3p0.ComboPooledDataSource\n103                 // com.mchange.v2.c3p0.debug.AfterCloseLoggingComboPooledDataSource \n104                 }\n105             }\n106             return;\n107         } while (false);\n108 \n109         throw JsonMappingException.from(ctxt,\n110                 String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full));\n111     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.SubTypeValidator"}, {"bug_name": "JacksonDatabind_95", "report_text": "> TypeFactory.constructFromCanonical() throws NPE for Unparameterized generic canonical strings\n> \n> When `TypeFactory.constructFromCanonical(returnType)` is used in `2.6.1`, the `returnType` string for generic types is not expected to have parameterized type information. For example, the following code runs fine on 2.6.1:\n> ```\n> returnType = \"java.util.List\";\n> objectMapper.getTypeFactory().constructFromCanonical(returnType);\n> ```\n> But in version `2.8.7`, the same code gives a `NullPointerException` with the stack trace:\n> ```\n> java.rmi.RemoteException: java.lang.NullPointerException:null. \n>     at com.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1421)\n>     at com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1182)\n>     at com.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1404)\n>     at com.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1172)\n>     at com.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1318)\n>     at com.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1261)\n>     at com.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:60)\n>     at com.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:33)\n>     at com.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:544)\n>     at foo.company.package.serialize.Serializer.deserialize(Serializer.java:355)\n> ```\n> But if the `returnType` string is passed with the generic type information, even if it is passed as `Object`, ie, `returnType = \"java.util.List<java.lang.Object>\";`, it works fine.\n> I have 2 questions, is there a way to make this change backward compatible? If not, how can I work around this? PS: The workaround given by Tatu in the mailing list is not clear to *me*, if someone can give me an example, it'd be great help. Thanks!\n> [Link to google groups thread.](https://groups.google.com/forum/#!topic/jackson-user/Ik1oEkUC1E8)", "test_name": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames", "test_method": "    public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n\n        // [databind#1941]: allow \"raw\" types too\n\n        t = tf.constructFromCanonical(\"java.util.List\"); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromVariable(TypeFactory.java:1413)\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1175)\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromParamType(TypeFactory.java:1396)\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromAny(TypeFactory.java:1165)\n\tcom.fasterxml.jackson.databind.type.TypeFactory._resolveSuperInterfaces(TypeFactory.java:1311)\n\tcom.fasterxml.jackson.databind.type.TypeFactory._fromClass(TypeFactory.java:1254)\n\tcom.fasterxml.jackson.databind.type.TypeParser.parseType(TypeParser.java:59)\n\tcom.fasterxml.jackson.databind.type.TypeParser.parse(TypeParser.java:32)\n\tcom.fasterxml.jackson.databind.type.TypeFactory.constructFromCanonical(TypeFactory.java:536)\n\tcom.fasterxml.jackson.databind.type.TestTypeFactory.testCanonicalNames(TestTypeFactory.java:237)", "buggy_method": "342 public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n343     {\n344         // simple optimization to avoid costly introspection if type-erased type does NOT differ\n345         final Class<?> rawBase = baseType.getRawClass();\n346         if (rawBase == subclass) {\n347             return baseType;\n348         }\n349 \n350         JavaType newType;\n351 \n352         // also: if we start from untyped, not much to save\n353         do { // bogus loop to be able to break\n354             if (rawBase == Object.class) {\n355                 newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n356                 break;\n357             }\n358             if (!rawBase.isAssignableFrom(subclass)) {\n359                 throw new IllegalArgumentException(String.format(\n360                         \"Class %s not subtype of %s\", subclass.getName(), baseType));\n361             }\n362             // A few special cases where we can simplify handling:\n363 \n364             // (1) Original target type has no generics -- just resolve subtype\n365             if (baseType.getBindings().isEmpty()) {\n366                 newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n367                 break;\n368             }\n369             // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n370             if (baseType.isContainerType()) {\n371                 if (baseType.isMapLikeType()) {\n372                     if ((subclass == HashMap.class)\n373                             || (subclass == LinkedHashMap.class)\n374                             || (subclass == EnumMap.class)\n375                             || (subclass == TreeMap.class)) {\n376                         newType = _fromClass(null, subclass,\n377                                 TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n378                         break;\n379                     }\n380                 } else if (baseType.isCollectionLikeType()) {\n381                     if ((subclass == ArrayList.class)\n382                             || (subclass == LinkedList.class)\n383                             || (subclass == HashSet.class)\n384                             || (subclass == TreeSet.class)) {\n385                         newType = _fromClass(null, subclass,\n386                                 TypeBindings.create(subclass, baseType.getContentType()));\n387                         break;\n388                     }\n389                     // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n390                     //    but they are impl details and we basically do not care...\n391                     if (rawBase == EnumSet.class) {\n392                         return baseType;\n393                     }\n394                 }\n395             }\n396             // (3) Sub-class does not take type parameters -- just resolve subtype\n397             int typeParamCount = subclass.getTypeParameters().length;\n398             if (typeParamCount == 0) {\n399                 newType = _fromClass(null, subclass, TypeBindings.emptyBindings());     \n400                 break;\n401             }\n402             // (4) If all else fails, do the full traversal using placeholders\n403             TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n404             newType = _fromClass(null, subclass, tb);\n405 \n406         } while (false);\n407 \n408         // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n409         //   copied as well\n410         newType = newType.withHandlersFrom(baseType);\n411         return newType;\n412     }", "bm_classpath": "com.fasterxml.jackson.databind.type.TypeFactory"}, {"bug_name": "JacksonDatabind_96", "report_text": "> Implicit constructor property names are not renamed properly with PropertyNamingStrategy\n> \n> (note: spin-off from [FasterXML/jackson-modules-java8#67](https://github.com/FasterXML/jackson-modules-java8/issues/67))\n> Looks like something with linking of creator properties (constructor arguments for annotated/discovered constructor) to \"regular\" properties does not work when using `PropertyNamingStrategy`. Apparently this was working better until 2.9.1, but broke with 2.9.2.", "test_name": "com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest::testSnakeCaseWithOneArg", "test_method": "    public void testSnakeCaseWithOneArg() throws Exception\n    {\n        final String MSG = \"1st\";\n        OneProperty actual = MAPPER.readValue(\n                \"{\\\"param_name0\\\":\\\"\"+MSG+\"\\\"}\",\n                OneProperty.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Invalid definition for property `param_name0` (of type `com.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest$OneProperty`): Could not find creator property with name 'param_name0' (known Creator properties: [paramName0])\n\tcom.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:62)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportBadPropertyDefinition(DeserializationContext.java:1446)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.addBeanProps(BeanDeserializerFactory.java:567)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.buildBeanDeserializer(BeanDeserializerFactory.java:227)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerFactory.createBeanDeserializer(BeanDeserializerFactory.java:137)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer2(DeserializerCache.java:411)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createDeserializer(DeserializerCache.java:349)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCache2(DeserializerCache.java:264)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache._createAndCacheValueDeserializer(DeserializerCache.java:244)\n\tcom.fasterxml.jackson.databind.deser.DeserializerCache.findValueDeserializer(DeserializerCache.java:142)\n\tcom.fasterxml.jackson.databind.DeserializationContext.findRootValueDeserializer(DeserializationContext.java:477)\n\tcom.fasterxml.jackson.databind.ObjectMapper._findRootDeserializer(ObjectMapper.java:4190)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4009)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)\n\tcom.fasterxml.jackson.databind.deser.creators.CreatorWithNamingStrategyTest.testSnakeCaseWithOneArg(CreatorWithNamingStrategyTest.java:49)", "buggy_method": "701 protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n702             BeanDescription beanDesc, CreatorCollector creators,\n703             CreatorCandidate candidate)\n704         throws JsonMappingException\n705     {\n706         // Looks like there's bit of magic regarding 1-parameter creators; others simpler:\n707         if (1 != candidate.paramCount()) {\n708             // Ok: for delegates, we want one and exactly one parameter without\n709             // injection AND without name\n710             int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n711             if (oneNotInjected >= 0) {\n712                 // getting close; but most not have name\n713                 if (candidate.paramName(oneNotInjected) == null) {\n714                     _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n715                     return;\n716                 }\n717             }\n718             _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n719             return;\n720         }\n721         AnnotatedParameter param = candidate.parameter(0);\n722         JacksonInject.Value injectId = candidate.injection(0);\n723         PropertyName paramName = candidate.explicitParamName(0);\n724         BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n725 \n726         // If there's injection or explicit name, should be properties-based\n727         boolean useProps = (paramName != null) || (injectId != null);\n728         if (!useProps && (paramDef != null)) {\n729             // One more thing: if implicit name matches property with a getter\n730             // or field, we'll consider it property-based as well\n731 \n732             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n733             //    not implicit name, but name with possible strategy-based-rename\n734 //            paramName = candidate.findImplicitParamName(0);\n735             paramName = candidate.findImplicitParamName(0);\n736             useProps = (paramName != null) && paramDef.couldSerialize();\n737         }\n738         if (useProps) {\n739             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n740                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n741             };\n742             creators.addPropertyCreator(candidate.creator(), true, properties);\n743             return;\n744         }\n745         _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n746 \n747         // one more thing: sever link to creator property, to avoid possible later\n748         // problems with \"unresolved\" constructor property\n749         if (paramDef != null) {\n750             ((POJOPropertyBuilder) paramDef).removeConstructors();\n751         }\n752     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BasicDeserializerFactory"}, {"bug_name": "JacksonDatabind_97", "report_text": "> Context attributes are not passed/available to custom serializer if object is in POJO\n> \n> Below is a test case where I create a custom serializer and use it to serialize an object 1) in a HashMap and 2) in an ObjectNode. In both cases I pass attribute to the serializer like this:  \n> `mapper.writer().withAttribute(\"myAttr\", \"Hello!\")`  \n> Serializing HashMap works as expected, but during ObjectNode serialization the attribute is null . It seems that in both cases the custom serializer should get access to the passed attribute and so both lines in the output should contain \"Hello!\"\n> Produced output from running testCase.test()\n> ```\n> {\"data\":{\"aStr\":\"The value is: Hello!\"}}\n> {\"data\":{\"aStr\":\"The value is: NULL\"}}\n> ```\n> Test case:\n> ```\n> import com.fasterxml.jackson.core.JsonGenerator;\n> import com.fasterxml.jackson.databind.ObjectMapper;\n> import com.fasterxml.jackson.databind.SerializerProvider;\n> import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n> import com.fasterxml.jackson.databind.node.ObjectNode;\n> import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n> import java.io.IOException;\n> import java.util.HashMap;\n> import java.util.Map;\n> public class TestCase {\n>   public final static ObjectMapper mapper = new ObjectMapper();\n>   @JsonSerialize(using = TestCase.CustomSer.class)\n>   public static class Data {\n>     public String aStr;\n>   }\n>   public static class CustomSer extends StdSerializer<Data> {\n>     public CustomSer() {\n>       super(Data.class);\n>     }\n>     @Override\n>     public void serialize(Data value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n>       String attrStr = (String) provider.getAttribute(\"myAttr\");\n>       gen.writeStartObject();\n>       gen.writeObjectField(\"aStr\", \"The value is: \" + (attrStr == null ? \"NULL\" : attrStr));\n>       gen.writeEndObject();\n>     }\n>   }\n>   public static void test() throws IOException {\n>     Data data = new Data();\n>     data.aStr = \"Hello\";\n>     Map<String, Object> mapTest = new HashMap<>();\n>     mapTest.put(\"data\", data);\n>     ObjectNode treeTest = mapper.createObjectNode();\n>     treeTest.putPOJO(\"data\", data);\n>     String mapOut = mapper.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\n>     System.out.println(mapOut);\n>     String treeOut = mapper.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\n>     System.out.println(treeOut);\n>   }\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.node.POJONodeTest::testPOJONodeCustomSer", "test_method": "    public void testPOJONodeCustomSer() throws Exception\n    {\n      Data data = new Data();\n      data.aStr = \"Hello\";\n\n      Map<String, Object> mapTest = new HashMap<>();\n      mapTest.put(\"data\", data);\n\n      ObjectNode treeTest = MAPPER.createObjectNode();\n      treeTest.putPOJO(\"data\", data);\n\n      final String EXP = \"{\\\"data\\\":{\\\"aStr\\\":\\\"The value is: Hello!\\\"}}\";\n      \n      String mapOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(mapTest);\n\n      String treeOut = MAPPER.writer().withAttribute(\"myAttr\", \"Hello!\").writeValueAsString(treeTest);\n      assertEquals(EXP, treeOut); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...Str\":\"The value is: [Hello!]\"}}> but was:<...Str\":\"The value is: [NULL]\"}}>\n\tcom.fasterxml.jackson.databind.node.POJONodeTest.testPOJONodeCustomSer(POJONodeTest.java:53)", "buggy_method": "104 @Override\n105     public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n106     {\n107         if (_value == null) {\n108             ctxt.defaultSerializeNull(gen);\n109         } else if (_value instanceof JsonSerializable) {\n110             ((JsonSerializable) _value).serialize(gen, ctxt);\n111         } else {\n112             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n113             //    this to preserve contextual information\n114             gen.writeObject(_value);\n115         }\n116     }", "bm_classpath": "com.fasterxml.jackson.databind.node.POJONode"}, {"bug_name": "JacksonDatabind_98", "report_text": "> External property polymorphic deserialization does not work with enums\n> \n> versions: Jackson 2.8.1, Jackson-module-kotlin 2.8.1\n> Attempting to deserialize a class using external\\_property. In my case, the property is an Enum type with values matching the type name. Now that issue [#999](https://github.com/FasterXML/jackson-databind/issues/999) is fixed, I thought this would work, but now I'm getting a different error:\n> ```\n> Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of enum.Invite, problem: argument type mismatch\n>  at [Source: {\n>   \"kind\": \"CONTACT\",\n>   \"to\": {\n>     \"name\": \"Foo\"\n>   }\n> }; line: 6, column: 1]\n>     at com.fasterxml.jackson.databind.JsonMappingException.from(JsonMappingException.java:268)\n>     at com.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:1405)\n>     at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.wrapAsJsonMappingException(StdValueInstantiator.java:468)\n>     at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.rewrapCtorProblem(StdValueInstantiator.java:487)\n>     at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromObjectWith(StdValueInstantiator.java:276)\n>     at com.fasterxml.jackson.module.kotlin.KotlinValueInstantiator.createFromObjectWith(KotlinValueInstantiator.kt:30)\n>     at com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator.build(PropertyBasedCreator.java:135)\n>     at com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler.complete(ExternalTypeHandler.java:225)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId(BeanDeserializer.java:937)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:792)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:312)\n>     at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:148)\n>     at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:3789)\n>     at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2852)\n>     at enum.Reproduction_KindEnumKt.main(Reproduction-KindEnum.kt:49)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:498)\n>     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n> Caused by: java.lang.IllegalArgumentException: argument type mismatch\n>     at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n>     at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n>     at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n>     at java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n>     at com.fasterxml.jackson.databind.introspect.AnnotatedConstructor.call(AnnotatedConstructor.java:124)\n>     at com.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromObjectWith(StdValueInstantiator.java:274)\n>     ... 15 more\n> Process finished with exit code 1\n> ```\n> Here is the reproduction recipe: <https://github.com/rocketraman/jackson-issue-enum-polymorphism/blob/master/src/main/kotlin/enumtype/Reproduction-KindEnum.kt>", "test_name": "com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdWithEnum1328Test::testExample", "test_method": "    public void testExample() throws Exception {\n        ObjectMapper mapper = new ObjectMapper();\n        \n        String json = mapper.writerWithDefaultPrettyPrinter()\n                .writeValueAsString(Arrays.asList(new AnimalAndType(AnimalType.Dog, new Dog())));\n        List<AnimalAndType> list = mapper.readerFor(new TypeReference<List<AnimalAndType>>() { })\n            .readValue(json); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdWithEnum1328Test$AnimalAndType`, problem: argument type mismatch\n\tcom.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\n\tcom.fasterxml.jackson.databind.DeserializationContext.instantiationException(DeserializationContext.java:1601)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.wrapAsJsonMappingException(StdValueInstantiator.java:484)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.rewrapCtorProblem(StdValueInstantiator.java:503)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromObjectWith(StdValueInstantiator.java:285)\n\tcom.fasterxml.jackson.databind.deser.ValueInstantiator.createFromObjectWith(ValueInstantiator.java:229)\n\tcom.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator.build(PropertyBasedCreator.java:195)\n\tcom.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler.complete(ExternalTypeHandler.java:302)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeUsingPropertyBasedWithExternalTypeId(BeanDeserializer.java:994)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeWithExternalTypeId(BeanDeserializer.java:846)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:324)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:159)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:286)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1611)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1219)\n\tcom.fasterxml.jackson.databind.jsontype.ext.ExternalTypeIdWithEnum1328Test.testExample(ExternalTypeIdWithEnum1328Test.java:87)", "buggy_method": "255 public Object complete(JsonParser p, DeserializationContext ctxt,\n256             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n257         throws IOException\n258     {\n259         // first things first: deserialize all data buffered:\n260         final int len = _properties.length;\n261         Object[] values = new Object[len];\n262         for (int i = 0; i < len; ++i) {\n263             String typeId = _typeIds[i];\n264             final ExtTypedProperty extProp = _properties[i];\n265             if (typeId == null) {\n266                 // let's allow missing both type and property (may already have been set, too)\n267                 if (_tokens[i] == null) {\n268                     continue;\n269                 }\n270                 // but not just one\n271                 // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'\n272                 if (!extProp.hasDefaultType()) {\n273                     ctxt.reportInputMismatch(_beanType,\n274                             \"Missing external type id property '%s'\",\n275                             extProp.getTypePropertyName());\n276                 } else {\n277                     typeId = extProp.getDefaultTypeId();\n278                 }\n279             } else if (_tokens[i] == null) {\n280                 SettableBeanProperty prop = extProp.getProperty();\n281                 ctxt.reportInputMismatch(_beanType,\n282                         \"Missing property '%s' for external type id '%s'\",\n283                         prop.getName(), _properties[i].getTypePropertyName());\n284             }\n285             values[i] = _deserialize(p, ctxt, i, typeId);\n286 \n287             final SettableBeanProperty prop = extProp.getProperty();\n288             // also: if it's creator prop, fill in\n289             if (prop.getCreatorIndex() >= 0) {\n290                 buffer.assignParameter(prop, values[i]);\n291 \n292                 // [databind#999] And maybe there's creator property for type id too?\n293                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n294                 // for now, should only be needed for creator properties, too\n295                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n296                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n297                     //    apply deserializer... fun fun.\n298                     buffer.assignParameter(typeProp, typeId);\n299                 }\n300             }\n301         }\n302         Object bean = creator.build(ctxt, buffer);\n303         // third: assign non-creator properties\n304         for (int i = 0; i < len; ++i) {\n305             SettableBeanProperty prop = _properties[i].getProperty();\n306             if (prop.getCreatorIndex() < 0) {\n307                 prop.set(bean, values[i]);\n308             }\n309         }\n310         return bean;\n311     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.ExternalTypeHandler"}, {"bug_name": "JacksonDatabind_99", "report_text": "> Canonical string for reference type is built incorrectly\n> \n> Canonical string for reference type is built incorrectly.  \n> E.g.:  \n> `new ReferenceType(new TypeFactory(new LRUMap<Object, JavaType>(0, 10000)).constructType(Object.class), new PlaceholderForType(0)).toCanonical()`  \n> yields:  \n> `java.lang.Object<$1`  \n> while the expected value is:  \n> `java.lang.Object<$1>`", "test_name": "com.fasterxml.jackson.databind.type.TestTypeFactory::testCanonicalNames", "test_method": "    public void testCanonicalNames()\n    {\n        TypeFactory tf = TypeFactory.defaultInstance();\n        JavaType t = tf.constructType(java.util.Calendar.class);\n        String can = t.toCanonical();\n\n        // Generic maps and collections will default to Object.class if type-erased\n        t = tf.constructType(java.util.ArrayList.class);\n        can = t.toCanonical();\n\n        t = tf.constructType(java.util.TreeMap.class);\n        can = t.toCanonical();\n\n        // And then EnumMap (actual use case for us)\n        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n        can = t.toCanonical();\n\n        // [databind#2109]: also ReferenceTypes\n        t = tf.constructType(new TypeReference<AtomicReference<Long>>() { });\n        can = t.toCanonical();\n        assertEquals(\"java.util.concurrent.atomic.AtomicReference<java.lang.Long>\",\n                can); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...rence<java.lang.Long[>]> but was:<...rence<java.lang.Long[]>\n\tcom.fasterxml.jackson.databind.type.TestTypeFactory.testCanonicalNames(TestTypeFactory.java:238)", "buggy_method": "162 @Override\n163     protected String buildCanonicalName()\n164     {\n165         StringBuilder sb = new StringBuilder();\n166         sb.append(_class.getName());\n167         sb.append('<');\n168         sb.append(_referencedType.toCanonical());\n169         return sb.toString();\n170     }", "bm_classpath": "com.fasterxml.jackson.databind.type.ReferenceType"}, {"bug_name": "JacksonDatabind_100", "report_text": "> TreeTraversingParser does not take base64 variant into account\n> \n> This affects at least 2.6.4 to current versions. In [TreeTraversingParser#getBinaryValue](https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java#L348), a `Base64Variant` is accepted but ignored. The call to `n.binaryValue()`, when `n` is a `TextNode`, then uses the default Base64 variant instead of what's specified. It seems the correct behavior would be to call `TextNode#getBinaryValue` instead.", "test_name": "com.fasterxml.jackson.databind.node.TestConversions::testBase64Text", "test_method": "    public void testBase64Text() throws Exception\n    {\n        // let's actually iterate over sets of encoding modes, lengths\n        \n        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n        final Base64Variant[] VARIANTS = {\n                Base64Variants.MIME,\n                Base64Variants.MIME_NO_LINEFEEDS,\n                Base64Variants.MODIFIED_FOR_URL,\n                Base64Variants.PEM\n        };\n\n        for (int len : LENS) {\n            byte[] input = new byte[len];\n            for (int i = 0; i < input.length; ++i) {\n                input[i] = (byte) i;\n            }\n            for (Base64Variant variant : VARIANTS) {\n                TextNode n = new TextNode(variant.encode(input));\n                byte[] data = null;\n                try {\n                    data = n.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n\n                // 15-Aug-2018, tatu: [databind#2096] requires another test\n                JsonParser p = new TreeTraversingParser(n);\n                assertEquals(JsonToken.VALUE_STRING, p.nextToken());\n                try {\n                    data = p.getBinaryValue(variant);\n                } catch (Exception e) {\n                    fail(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                }\n                assertNotNull(data);\n                assertArrayEquals(data, input);\n                p.close();\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Failed (variant MODIFIED-FOR-URL, data length 1): Cannot access contents of TextNode as binary due to broken Base64 encoding: Unexpected end-of-String in base64 content\n\tcom.fasterxml.jackson.databind.node.TestConversions.testBase64Text(TestConversions.java:189)", "buggy_method": "354 @Override\n355     public byte[] getBinaryValue(Base64Variant b64variant)\n356         throws IOException, JsonParseException\n357     {\n358         // Multiple possibilities...\n359         JsonNode n = currentNode();\n360         if (n != null) {\n361             // [databind#2096]: although `binaryValue()` works for real binary node\n362             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n363             byte[] data = n.binaryValue();\n364             if (data != null) {\n365                 return data;\n366             }\n367             if (n.isPojo()) {\n368                 Object ob = ((POJONode) n).getPojo();\n369                 if (ob instanceof byte[]) {\n370                     return (byte[]) ob;\n371                 }\n372             }\n373         }\n374         // otherwise return null to mark we have no binary content\n375         return null;\n376     }", "bm_classpath": "com.fasterxml.jackson.databind.node.TreeTraversingParser"}, {"bug_name": "JacksonDatabind_101", "report_text": "> @JsonUnwrapped fields are skipped when using PropertyBasedCreator if they appear after the last creator property\n> \n> Example:\n> ```\n>     static class Bean {\n>         int x;\n>         int y;\n>         @JsonUnwrapped\n>         UnwrappedBean w;\n>         public Bean(@JsonProperty(\"x\") int x, @JsonProperty(\"y\") int y) {\n>             this.x = x;\n>             this.y = y;\n>         }\n>         public void setW(UnwrappedBean w) {\n>             this.w = w;\n>         }\n>     }\n>     static class UnwrappedBean {\n>         int a;\n>         int b;\n>         public UnwrappedBean(@JsonProperty(\"a\") int a, @JsonProperty(\"b\") int b) {\n>             this.a = a;\n>             this.b = b;\n>         }\n>     }\n> ```\n> ```\n>     {\"x\": 1, \"a\": 2, \"y\": 3, \"b\": 4}\n> ```\n> `x`, `y`, and `a` are deserialized as expected. `b` is skipped entirely. I think I've found the root cause and the fix doesn't appear to break any tests; opening a PR for further review.", "test_name": "com.fasterxml.jackson.databind.struct.TestUnwrapped::testIssue2088UnwrappedFieldsAfterLastCreatorProp", "test_method": "    public void testIssue2088UnwrappedFieldsAfterLastCreatorProp() throws Exception\n    {\n        Issue2088Bean bean = MAPPER.readValue(\"{\\\"x\\\":1,\\\"a\\\":2,\\\"y\\\":3,\\\"b\\\":4}\", Issue2088Bean.class);\n        assertEquals(4, bean.w.b); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<4> but was:<0>\n\tcom.fasterxml.jackson.databind.struct.TestUnwrapped.testIssue2088UnwrappedFieldsAfterLastCreatorProp(TestUnwrapped.java:254)", "buggy_method": "735 @SuppressWarnings(\"resource\")\n736     protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n737         throws IOException\n738     {\n739         // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped\n740         //    value itself is NOT passed via `CreatorProperty` (which isn't supported).\n741         //    Ok however to pass via setter or field.\n742         \n743         final PropertyBasedCreator creator = _propertyBasedCreator;\n744         PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n745 \n746         TokenBuffer tokens = new TokenBuffer(p, ctxt);\n747         tokens.writeStartObject();\n748 \n749         JsonToken t = p.getCurrentToken();\n750         for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n751             String propName = p.getCurrentName();\n752             p.nextToken(); // to point to value\n753             // creator property?\n754             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n755             if (creatorProp != null) {\n756                 // Last creator property to set?\n757                 if (buffer.assignParameter(creatorProp,\n758                         _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n759                     t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n760                     Object bean;\n761                     try {\n762                         bean = creator.build(ctxt, buffer);\n763                     } catch (Exception e) {\n764                         bean = wrapInstantiationProblem(e, ctxt);\n765                     }\n766                     // [databind#631]: Assign current value, to be accessible by custom serializers\n767                     p.setCurrentValue(bean);\n768                     // if so, need to copy all remaining tokens into buffer\n769                     while (t == JsonToken.FIELD_NAME) {\n770                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n771                         p.nextToken();\n772                         tokens.copyCurrentStructure(p);\n773                         t = p.nextToken();\n774                     }\n775                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n776                     //    problems if we maintain invariants\n777                     tokens.writeEndObject();\n778                     if (bean.getClass() != _beanType.getRawClass()) {\n779                         // !!! 08-Jul-2011, tatu: Could probably support; but for now\n780                         //   it's too complicated, so bail out\n781                         ctxt.reportInputMismatch(creatorProp,\n782                                 \"Cannot create polymorphic instances with unwrapped values\");\n783                         return null;\n784                     }\n785                     return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n786                 }\n787                 continue;\n788             }\n789             // Object Id property?\n790             if (buffer.readIdProperty(propName)) {\n791                 continue;\n792             }\n793             // regular property? needs buffering\n794             SettableBeanProperty prop = _beanProperties.find(propName);\n795             if (prop != null) {\n796                 buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));\n797                 continue;\n798             }\n799             // Things marked as ignorable should not be passed to any setter\n800             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n801                 handleIgnoredProperty(p, ctxt, handledType(), propName);\n802                 continue;\n803             }\n804             // 29-Nov-2016, tatu: probably should try to avoid sending content\n805             //    both to any setter AND buffer... but, for now, the only thing\n806             //    we can do.\n807             // how about any setter? We'll get copies but...\n808             if (_anySetter == null) {\n809                 // but... others should be passed to unwrapped property deserializers\n810                 tokens.writeFieldName(propName);\n811                 tokens.copyCurrentStructure(p);\n812             } else {\n813                 // Need to copy to a separate buffer first\n814                 TokenBuffer b2 = TokenBuffer.asCopyOfValue(p);\n815                 tokens.writeFieldName(propName);\n816                 tokens.append(b2);\n817                 try {\n818                     buffer.bufferAnyProperty(_anySetter, propName,\n819                             _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));\n820                 } catch (Exception e) {\n821                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n822                 }\n823                 continue;\n824             }\n825         }\n826 \n827         // We hit END_OBJECT, so:\n828         Object bean;\n829         try {\n830             bean = creator.build(ctxt, buffer);\n831         } catch (Exception e) {\n832             wrapInstantiationProblem(e, ctxt);\n833             return null; // never gets here\n834         }\n835         return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n836     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.BeanDeserializer"}, {"bug_name": "JacksonDatabind_102", "report_text": "> Cannot set custom format for SqlDateSerializer globally\n> \n> Version: 2.9.5\n> After [#219](https://github.com/FasterXML/jackson-databind/issues/219) was fixed, the default format for `java.sql.Date` serialization switched from string to numeric, following the default value of `WRITE_DATES_AS_TIMESTAMPS`.\n> In order to prevent breaks, I want `java.sql.Date` to serialize as a string, without changing behavior for `java.util.Date` (which has always serialized as a number by default).\n> According to [#219 (comment)](https://github.com/FasterXML/jackson-databind/issues/219#issuecomment-370690333), I should be able to revert the behavior for `java.sql.Date` only with\n> ```\n> final ObjectMapper mapper = new ObjectMapper();\n> mapper.configOverride(java.sql.Date.class).setFormat(JsonFormat.Value.forPattern(\"yyyy-MM-dd\"));\n> ```\n> This doesn't seem to do anything, though. Looking at the code, it looks like it's because the custom format isn't actually added to `SqlDateSerializer` except in the `createContextual` method (<https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java#L59>).\n> For now, I've reverted this behavior with\n> ```\n> mapper.registerModule(new SimpleModule() {\n>             {\n>                 addSerializer(\n>                         java.sql.Date.class,\n>                         new SqlDateSerializer().withFormat(false, new SimpleDateFormat(\"yyyy-MM-dd\"))\n>                 );\n>             }\n>         });\n> ```\n> but it seems pretty hacky so I'd prefer the other method if possible.", "test_name": "com.fasterxml.jackson.databind.ser.jdk.SqlDateSerializationTest::testSqlDateConfigOverride", "test_method": "    public void testSqlDateConfigOverride() throws Exception\n    {\n        ObjectMapper mapper = newObjectMapper();\n        mapper.configOverride(java.sql.Date.class)\n            .setFormat(JsonFormat.Value.forPattern(\"yyyy+MM+dd\"));        \n        assertEquals(\"\\\"1980+04+14\\\"\",\n            mapper.writeValueAsString(java.sql.Date.valueOf(\"1980-04-14\"))); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[\"1980+04+14\"]> but was:<[324547200000]>\n\tcom.fasterxml.jackson.databind.ser.jdk.SqlDateSerializationTest.testSqlDateConfigOverride(SqlDateSerializationTest.java:104)", "buggy_method": "61 @Override\n62     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n63             BeanProperty property) throws JsonMappingException\n64     {\n65         // Note! Should not skip if `property` null since that'd skip check\n66         // for config overrides, in case of root value\n67         if (property == null) {\n68             return this;\n69         }\n70         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n71         if (format == null) {\n72             return this;\n73         }\n74         // Simple case first: serialize as numeric timestamp?\n75         JsonFormat.Shape shape = format.getShape();\n76         if (shape.isNumeric()) {\n77             return withFormat(Boolean.TRUE, null);\n78         }\n79 \n80         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n81         // First: custom pattern will override things\n82         if (format.hasPattern()) {\n83             final Locale loc = format.hasLocale()\n84                             ? format.getLocale()\n85                             : serializers.getLocale();\n86             SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc);\n87             TimeZone tz = format.hasTimeZone() ? format.getTimeZone()\n88                     : serializers.getTimeZone();\n89             df.setTimeZone(tz);\n90             return withFormat(Boolean.FALSE, df);\n91         }\n92 \n93         // Otherwise, need one of these changes:\n94         final boolean hasLocale = format.hasLocale();\n95         final boolean hasTZ = format.hasTimeZone();\n96         final boolean asString = (shape == JsonFormat.Shape.STRING);\n97 \n98         if (!hasLocale && !hasTZ && !asString) {\n99             return this;\n100         }\n101 \n102         DateFormat df0 = serializers.getConfig().getDateFormat();\n103         // Jackson's own `StdDateFormat` is quite easy to deal with...\n104         if (df0 instanceof StdDateFormat) {\n105             StdDateFormat std = (StdDateFormat) df0;\n106             if (format.hasLocale()) {\n107                 std = std.withLocale(format.getLocale());\n108             }\n109             if (format.hasTimeZone()) {\n110                 std = std.withTimeZone(format.getTimeZone());\n111             }\n112             return withFormat(Boolean.FALSE, std);\n113         }\n114 \n115         // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n116         //    mechanism for changing `DateFormat` instances (or even clone()ing)\n117         //    So: require it be `SimpleDateFormat`; can't config other types\n118         if (!(df0 instanceof SimpleDateFormat)) {\n119             serializers.reportBadDefinition(handledType(), String.format(\n120 \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\",\n121 df0.getClass().getName()));\n122         }\n123         SimpleDateFormat df = (SimpleDateFormat) df0;\n124         if (hasLocale) {\n125             // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n126             df = new SimpleDateFormat(df.toPattern(), format.getLocale());\n127         } else {\n128             df = (SimpleDateFormat) df.clone();\n129         }\n130         TimeZone newTz = format.getTimeZone();\n131         boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone());\n132         if (changeTZ) {\n133             df.setTimeZone(newTz);\n134         }\n135         return withFormat(Boolean.FALSE, df);\n136     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.DateTimeSerializerBase"}, {"bug_name": "JacksonDatabind_103", "report_text": "> Location information included twice for some JsonMappingExceptions\n> \n> Looks like due to some double-processing, certain kinds of `JsonMappingException` (observed with `InvalidFormatException`) seem to include \" at [source]\" twice. This is probably due to calls to `getMessage()` that add location being used to pass `message` property when wrapping or re-creating exceptions.", "test_name": "com.fasterxml.jackson.databind.exc.BasicExceptionTest::testLocationAddition", "test_method": "    public void testLocationAddition() throws Exception\n    {\n        try {\n            /*Map<?,?> map =*/ MAPPER.readValue(\"{\\\"value\\\":\\\"foo\\\"}\",\n                    new TypeReference<Map<ABC, Integer>>() { });\n            fail(\"Should not pass\");\n        } catch (MismatchedInputException e) {\n            String msg = e.getMessage();\n            String[] str = msg.split(\" at \\\\[\");\n            if (str.length != 2) {\n                fail(\"Should only get one 'at [' marker, got \"+(str.length-1)+\", source: \"+msg);\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should only get one 'at [' marker, got 2, source: Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not a valid representation, problem: (com.fasterxml.jackson.databind.exc.InvalidFormatException) Cannot deserialize Map key of type `com.fasterxml.jackson.databind.BaseMapTest$ABC` from String \"value\": not one of values excepted for Enum class: [A, B, C]\n\tcom.fasterxml.jackson.databind.exc.BasicExceptionTest.testLocationAddition(BasicExceptionTest.java:127)", "buggy_method": "170 public JavaType resolveSubType(JavaType baseType, String subClass)\n171         throws JsonMappingException\n172     {\n173         // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n174         //    check if any generics info is added; and only then ask factory\n175         //    to do translation when necessary\n176         if (subClass.indexOf('<') > 0) {\n177             // note: may want to try combining with specialization (esp for EnumMap)?\n178             // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n179             //    compatibility -- needed later anyway, and not doing so may open\n180             //    security issues.\n181             JavaType t = getTypeFactory().constructFromCanonical(subClass);\n182             if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n183                 return t;\n184             }\n185         } else {\n186             Class<?> cls;\n187             try {\n188                 cls =  getTypeFactory().findClass(subClass);\n189             } catch (ClassNotFoundException e) { // let caller handle this problem\n190                 return null;\n191             } catch (Exception e) {\n192                 throw invalidTypeIdException(baseType, subClass, String.format(\n193                         \"problem: (%s) %s\",\n194                         e.getClass().getName(),\n195                         e.getMessage()));\n196             }\n197             if (baseType.isTypeOrSuperTypeOf(cls)) {\n198                 return getTypeFactory().constructSpecializedType(baseType, cls);\n199             }\n200         }\n201         throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n202     }", "bm_classpath": "com.fasterxml.jackson.databind.DatabindContext"}, {"bug_name": "JacksonDatabind_104", "report_text": "> Large ISO-8601 Dates are formatted/serialized incorrectly\n> \n> **The problem**\n> ```\n> java.text.ParseException: Cannot parse date \"\u75dd055-12-02T16:47:04.192+0000\": not compatible with any of standard forms (\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\", \"yyyy-MM-dd'T'HH:mm:ss.SSS\", \"EEE, dd MMM yyyy HH:mm:ss zzz\", \"yyyy-MM-dd\")\n> \tat com.fasterxml.jackson.databind.util.StdDateFormat.parse(StdDateFormat.java:372)\n> ```\n> Years > 9999 are not rendered as 5 numbers or more, but with a non numerical characters for the thousands digit..\n> **The testcase**\n> ```\n> public class MyTestCase{\n>   public static void main(String[] args) throws JsonProcessingException, ParseException {\n>     StdDateFormat formatter = new StdDateFormat();\n>     System.out.println(formatter.format(new Date(Long.MIN_VALUE)));\n>     System.out.println(formatter.format(new Date(Long.MAX_VALUE)));\n>     System.out.println(formatter.parse(formatter.format(new Date(Long.MIN_VALUE))));\n>     System.out.println(formatter.parse(formatter.format(new Date(Long.MAX_VALUE))));\n>     assert formatter.parse(formatter.format(new Date(Long.MAX_VALUE))).getTime() == Long.MAX_VALUE;\n>     // Will fail due to lack of support for negative dates.\n>     //assert formatter.parse(formatter.format(new Date(Long.MIN_VALUE))).getTime() == Long.MIN_VALUE;\n>   }\n> }\n> ```\n> **Expected**\n> a) All dates are formatted correctly, meaning, years bigger than 9999.  \n> b) or some sort of exception telling the data is not supported.\n> **The location**  \n> `'0' + something`  \n> <https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java#L442>\n> **Suggestion**  \n> a) Adding '0' with an integer is not a safe operation. But if you are doing it, you need an upper bound check, e.g.:\n> ```\n>  private static void pad2(StringBuffer buffer, int value) {\n>      int tens = value / 10;\n> +    if (tens >= 10) {\n> +        pad2(buffer, tens);\n> +        buffer.append((char) ('0' + value % 10));\n> +        return;\n> +    }\n>      if (tens == 0) {\n>          buffer.append('0');\n>      } else {\n>          buffer.append((char) ('0' + tens));\n>          value -= 10 * tens;\n>      }\n>      buffer.append((char) ('0' + value));\n>  }\n>  \n>  private static void pad3(StringBuffer buffer, int value) {\n>      int h = value / 100;\n> +    if (h >= 100) {\n> +        pad3(buffer, h);\n> +        pad2(buffer, value % 100);\n> +        return;\n> +    }\n>      if (h == 0) {\n>          buffer.append('0');\n>      } else {\n>          buffer.append((char) ('0' + h));\n>          value -= (h * 100);\n>      }\n>      pad2(buffer, value);\n>  }\n> ```\n> b) Or if you do not want to support such high years, then throw some sort of exception. E.g.:\n> ```\n>      protected void _format(TimeZone tz, Locale loc, Date date,\n>              StringBuffer buffer)\n>      {\n>          Calendar cal = _getCalendar(tz);\n>          cal.setTime(date);\n> +        int year = cal.get(Calendar.YEAR);\n> +        if (cal.get(Calendar.ERA) == 0) {\n> +            year = -year + 1;\n> +        }\n> +        if (year < 0 || 9999 < year) {\n> +            throw new IndexOutOfBoundsException(\"Year not within the range [0,9999]: \" + Integer.toString(year))\n> +        }\n>  \n> -        pad4(buffer, cal.get(Calendar.YEAR));\n> +        pad4(buffer, year);\n>          buffer.append('-');\n>          pad2(buffer, cal.get(Calendar.MONTH) + 1);\n>          buffer.append('-');\n>          pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n> ```", "test_name": "com.fasterxml.jackson.databind.ser.jdk.DateSerializationTest::testDateISO8601_10k", "test_method": "    public void testDateISO8601_10k() throws IOException\n    {\n        ObjectWriter w = MAPPER.writer()\n                .without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n        serialize(w, judate(10204, 1, 1,  00, 00, 00, 0, \"UTC\"),   \"+10204-01-01T00:00:00.000+0000\"); // <-- fails here\n    }", "error_message": "org.junit.ComparisonFailure: expected:<\"[+10]204-01-01T00:00:00.0...> but was:<\"[:]204-01-01T00:00:00.0...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\tcom.fasterxml.jackson.databind.ser.jdk.DateSerializationTest.serialize(DateSerializationTest.java:366)\n\tcom.fasterxml.jackson.databind.ser.jdk.DateSerializationTest.testDateISO8601_10k(DateSerializationTest.java:134)", "buggy_method": "432 protected void _format(TimeZone tz, Locale loc, Date date,\n433             StringBuffer buffer)\n434     {\n435         Calendar cal = _getCalendar(tz);\n436         cal.setTime(date);\n437         // [databind#2167]: handle range beyond [1, 9999]\n438         final int year = cal.get(Calendar.YEAR);\n439 \n440         // Assuming GregorianCalendar, special handling needed for BCE (aka BC)\n441                 // 22-Nov-2018, tatu: Handling beyond 4-digits is not well specified wrt ISO-8601, but\n442                 //   it seems that plus prefix IS mandated. Padding is an open question, but since agreeement\n443                 //   for max length would be needed, we ewould need to limit to arbitrary length\n444                 //   like five digits (erroring out if beyond or padding to that as minimum).\n445                 //   Instead, let's just print number out as is and let decoder try to make sense of it.\n446             pad4(buffer, year);\n447         buffer.append('-');\n448         pad2(buffer, cal.get(Calendar.MONTH) + 1);\n449         buffer.append('-');\n450         pad2(buffer, cal.get(Calendar.DAY_OF_MONTH));\n451         buffer.append('T');\n452         pad2(buffer, cal.get(Calendar.HOUR_OF_DAY));\n453         buffer.append(':');\n454         pad2(buffer, cal.get(Calendar.MINUTE));\n455         buffer.append(':');\n456         pad2(buffer, cal.get(Calendar.SECOND));\n457         buffer.append('.');\n458         pad3(buffer, cal.get(Calendar.MILLISECOND));\n459 \n460         int offset = tz.getOffset(cal.getTimeInMillis());\n461         if (offset != 0) {\n462             int hours = Math.abs((offset / (60 * 1000)) / 60);\n463             int minutes = Math.abs((offset / (60 * 1000)) % 60);\n464             buffer.append(offset < 0 ? '-' : '+');\n465             pad2(buffer, hours);\n466             if( _tzSerializedWithColon ) {\n467             \t\tbuffer.append(':');\n468             }\n469             pad2(buffer, minutes);\n470         } else {\n471             // 24-Jun-2017, tatu: While `Z` would be conveniently short, older specs\n472             //   mandate use of full `+0000`\n473 //            formatted.append('Z');\n474 \t        \tif( _tzSerializedWithColon ) {\n475 \t            buffer.append(\"+00:00\");\n476 \t        \t}\n477 \t        \telse {\n478 \t        \t\tbuffer.append(\"+0000\");\n479 \t        \t}\n480         }\n481     }", "bm_classpath": "com.fasterxml.jackson.databind.util.StdDateFormat"}, {"bug_name": "JacksonDatabind_105", "report_text": "> Illegal reflective access operation warning when using java.lang.Void as value type\n> \n> I'm using Jackson (**2.9.7**) through Spring's RestTemplate:\n> ```\n> ResponseEntity<Void> response = getRestTemplate().exchange(\n> \t\trequestUrl,\n> \t\tHttpMethod.PATCH,\n> \t\tnew HttpEntity<>(dto, authHeaders),\n> \t\tVoid.class\n> );\n> ```\n> When [`Void`](https://docs.oracle.com/javase/7/docs/api/java/lang/Void.html) is used to indicate that the ResponseEntity has no body, the following warning appears in the console:\n> ```\n> WARNING: An illegal reflective access operation has occurred\n> WARNING: Illegal reflective access by com.fasterxml.jackson.databind.util.ClassUtil (file:/<snip>repository/com/fasterxml/jackson/core/jackson-databind/2.9.7/jackson-databind-2.9.7.jar) to constructor java.lang.Void()\n> WARNING: Please consider reporting this to the maintainers of com.fasterxml.jackson.databind.util.ClassUtil\n> WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations\n> WARNING: All illegal access operations will be denied in a future release\n> ```\n> The problem disappears if `String` is used as generic type.", "test_name": "com.fasterxml.jackson.databind.deser.jdk.JDKScalarsTest::testVoidDeser", "test_method": "    public void testVoidDeser() throws Exception\n    {\n        VoidBean bean = MAPPER.readValue(aposToQuotes(\"{'value' : 123 }\"),\n                VoidBean.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `java.lang.Void` (although at least one Creator exists): no int/Int-argument constructor/factory method to deserialize from Number value (123)\n\tcom.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1343)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1032)\n\tcom.fasterxml.jackson.databind.deser.ValueInstantiator.createFromInt(ValueInstantiator.java:262)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createFromInt(StdValueInstantiator.java:356)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromNumber(BeanDeserializerBase.java:1324)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:173)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:161)\n\tcom.fasterxml.jackson.databind.deser.impl.FieldProperty.deserializeAndSet(FieldProperty.java:136)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:288)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)\n\tcom.fasterxml.jackson.databind.deser.jdk.JDKScalarsTest.testVoidDeser(JDKScalarsTest.java:863)", "buggy_method": "28 public static JsonDeserializer<?> find(Class<?> rawType, String clsName)\n29     {\n30         if (_classNames.contains(clsName)) {\n31             JsonDeserializer<?> d = FromStringDeserializer.findDeserializer(rawType);\n32             if (d != null) {\n33                 return d;\n34             }\n35             if (rawType == UUID.class) {\n36                 return new UUIDDeserializer();\n37             }\n38             if (rawType == StackTraceElement.class) {\n39                 return new StackTraceElementDeserializer();\n40             }\n41             if (rawType == AtomicBoolean.class) {\n42                 // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n43                 return new AtomicBooleanDeserializer();\n44             }\n45             if (rawType == ByteBuffer.class) {\n46                 return new ByteBufferDeserializer();\n47             }\n48         }\n49         return null;\n50     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.JdkDeserializers"}, {"bug_name": "JacksonDatabind_106", "report_text": "> TreeTraversingParser does not check int bounds\n> \n> Similar to [#1729](https://github.com/FasterXML/jackson-databind/issues/1729), [TreeTraversingParser](https://github.com/FasterXML/jackson-databind/blob/2.9/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java#L311) does not perform bounds checks on *some* JSON values bound to ints.\n> Using Jackson version 2.9.7, here are several comparisons generated with the following code:\n> ```\n>   public static class IntClass {\n>     public int x;\n>     @Override\n>     public String toString() {\n>       return String.valueOf(x);\n>     }\n>   }\n>   ObjectMapper mapper  = new ObjectMapper();\n>   void readAndPrint(String \\_example) {\n>     String fromTree;\n>     try {\n>       JsonNode tree = mapper.readTree(\\_example);\n>       fromTree = mapper.readerFor(IntClass.class).readValue(tree).toString();\n>     } catch (IOException \\_e) {\n>       fromTree = \\_e.getClass().getSimpleName();\n>     }\n>     String fromString;\n>     try {\n>       fromString = mapper.readerFor(IntClass.class).readValue(\\_example).toString();\n>     } catch (IOException \\_e) {\n>       fromString = \\_e.getClass().getSimpleName();\n>     }\n>     System.out.printf(\"|%30s | %30s | %-30s|\\n\", \\_example, fromTree, fromString);\n>   }\n>   @Test\n>   public void compareFromTree() {\n>     System.out.printf(\"|%30s | %30s | %-30s|\\n\", \"json input\", \"read from tree\", \"read from string\");\n>     System.out.println(\"|-------------------------------|--------------------------------|-------------------------------|\");\n>     readAndPrint(\"{\\\"x\\\": 0}\");\n>     // etc.\n>   }\n> ```\n> | json input | read from tree | read from string |\n> | --- | --- | --- |\n> | {\"x\": 0} | 0 | 0 |\n> | {\"x\": 10} | 10 | 10 |\n> | {\"x\": 1e4} | 10000 | 10000 |\n> | {\"x\": 1e10} | 2147483647 | JsonMappingException |\n> | {\"x\": 1e-1} | 0 | 0 |\n> | {\"x\": 2147483648} | -2147483648 | JsonMappingException |\n> | {\"x\": 2147483649} | -2147483647 | JsonMappingException |\n> | {\"x\": -2147483649} | 2147483647 | JsonMappingException |\n> | {\"x\": -4294967295} | 1 | JsonMappingException |\n> | {\"x\": 0.1} | 0 | 0 |\n> | {\"x\": 1.9} | 1 | 1 |\n> | {\"x\": 1.9999999999999999} | 2 | 2 |\n> | {\"x\": true} | MismatchedInputException | MismatchedInputException |\n> | {\"x\": {}} | MismatchedInputException | MismatchedInputException |\n> | {\"x\": []} | MismatchedInputException | MismatchedInputException |\n> | {\"x\": [0]} | MismatchedInputException | MismatchedInputException |\n> | {\"x\": \"0\"} | 0 | 0 |\n> | {\"x\": \"10\"} | 10 | 10 |\n> | {\"x\": \"1e4\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"1e10\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"1e-1\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"2147483648\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"2147483649\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"-2147483649\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"-4294967295\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"0.1\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"1.9\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"1.9999999999999999\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"true\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"{}\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"[]\"} | InvalidFormatException | InvalidFormatException |\n> | {\"x\": \"[0]\"} | InvalidFormatException | InvalidFormatException |\n> Without digging further into the code, it appears if the JSON value is numeric, `TreeTraversingParser` silently overflows. Maybe this is expected behavior, but to me the inconsistency between reading from a non-tree (reader/string/file, etc) versus directly from a tree seems like a bug. At the very least, it makes it less convenient to do manipulations on a JSON document before binding.\n> I would expect an exception thrown for the all but the first three examples above, but I do understand there are use-cases for coercing values. Even so, I would expect the coercion logic to be\n> * consistent between the parsers (or clearly documented otherwise)\n> * consistent between quoted and unquoted values\n> I'm also curious about the expected behavior when converting non-integral values. Why is `true` `MismatchedInput`, but `0.1` is converted? Similarly, why are `0.1`, `1e4`, and `1e-1` acceptable, but not when in quotes, even though `\"10\"` and other quote integers are acceptable?\n> Thanks for all your hard work on this. I hope this issue doesn't come off as condescending. For our specific use case, we read the value as a tree, validating it against a schema, then using Jackson to bind the tree to an object. While it's true that we can specify type, minimum, and maximum values in the schema, it is prone to mistakes, and there's not necessarily a reason to tie the schema to the language implementation, provided things like overflow consistently result in an exception. Thus, I'm trying to better understand the expectations and limits Jackson has when using the tree parser.", "test_name": "com.fasterxml.jackson.databind.node.TestTreeTraversingParser::testNumberOverflowLong", "test_method": "    public void testNumberOverflowLong() throws IOException\n    {\n        final BigInteger tooBig = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE);\n        try (final JsonParser p = MAPPER.readTree(\"[ \"+tooBig+\" ]\").traverse()) {\n            assertToken(JsonToken.START_ARRAY, p.nextToken());\n            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n            assertEquals(NumberType.BIG_INTEGER, p.getNumberType());\n            try {\n                p.getLongValue();\n                fail(\"Expected failure for `long` overflow\");\n            } catch (InputCoercionException e) {\n                verifyException(e, \"Numeric value (\"+tooBig+\") out of range of long\");\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected failure for `long` overflow\n\tcom.fasterxml.jackson.databind.node.TestTreeTraversingParser.testNumberOverflowLong(TestTreeTraversingParser.java:323)", "buggy_method": "305 @Override\n306     public int getIntValue() throws IOException {\n307         final NumericNode node = (NumericNode) currentNumericNode();\n308         return node.intValue();\n309     }", "bm_classpath": "com.fasterxml.jackson.databind.node.TreeTraversingParser"}, {"bug_name": "JacksonDatabind_107", "report_text": "> DeserializationProblemHandler.handleUnknownTypeId() returning Void.class, enableDefaultTyping causing NPE\n> \n> Returning Void.class from com.fasterxml.jackson.databind.deser.HandleUnknowTypeIdTest.testDeserializationWithDeserializationProblemHandler().new DeserializationProblemHandler() {...}.handleUnknownTypeId(DeserializationContext, JavaType, String, TypeIdResolver, String) is causing a NPE in jackson 2.9. I'll provide a pull request illustrating the issue in a test.", "test_name": "com.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test::testWithDeserializationProblemHandler", "test_method": "    public void testWithDeserializationProblemHandler() throws Exception {\n        final ObjectMapper mapper = new ObjectMapper()\n                .enableDefaultTyping();\n        mapper.addHandler(new DeserializationProblemHandler() {\n            @Override\n            public JavaType handleUnknownTypeId(DeserializationContext ctxt, JavaType baseType, String subTypeId, TypeIdResolver idResolver, String failureMsg) throws IOException {\n//                System.out.println(\"Print out a warning here\");\n                return ctxt.constructType(Void.class);\n            }\n        });\n        GenericContent processableContent = mapper.readValue(JSON, GenericContent.class); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.JsonMappingException: (was java.lang.NullPointerException) (through reference chain: com.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test$GenericContent[\"innerObjects\"]->java.util.ArrayList[1])\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:394)\n\tcom.fasterxml.jackson.databind.JsonMappingException.wrapWithPath(JsonMappingException.java:365)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:302)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:116)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:53)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeWithType(CollectionDeserializer.java:314)\n\tcom.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:136)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:288)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer._deserializeOther(BeanDeserializer.java:189)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:161)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer._deserializeTypedForId(AsPropertyTypeDeserializer.java:130)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsPropertyTypeDeserializer.deserializeTypedFromObject(AsPropertyTypeDeserializer.java:97)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeWithType(BeanDeserializerBase.java:1178)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)\n\tcom.fasterxml.jackson.databind.deser.filter.ProblemHandlerUnknownTypeId2221Test.testWithDeserializationProblemHandler(ProblemHandlerUnknownTypeId2221Test.java:95)", "buggy_method": "146 protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n147             String typeId) throws IOException\n148     {\n149         JsonDeserializer<Object> deser = _deserializers.get(typeId);\n150         if (deser == null) {\n151             /* As per [databind#305], need to provide contextual info. But for\n152              * backwards compatibility, let's start by only supporting this\n153              * for base class, not via interface. Later on we can add this\n154              * to the interface, assuming deprecation at base class helps.\n155              */\n156             JavaType type = _idResolver.typeFromId(ctxt, typeId);\n157             if (type == null) {\n158                 // use the default impl if no type id available:\n159                 deser = _findDefaultImplDeserializer(ctxt);\n160                 if (deser == null) {\n161                     // 10-May-2016, tatu: We may get some help...\n162                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n163                     if (actual == null) { // what should this be taken to mean?\n164                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n165                         return null;\n166                     }\n167                     // ... would this actually work?\n168                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n169                 }\n170             } else {\n171                 /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n172                  *   we actually now need to explicitly narrow from base type (which may have parameterization)\n173                  *   using raw type.\n174                  *\n175                  *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n176                  *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n177                  *   type in process (getting SimpleType of Map.class which will not work as expected)\n178                  */\n179                 if ((_baseType != null)\n180                         && _baseType.getClass() == type.getClass()) {\n181                     /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n182                      *   but it appears to check that JavaType impl class is the same which is\n183                      *   important for some reason?\n184                      *   Disabling the check will break 2 Enum-related tests.\n185                      */\n186                     // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n187                     //   generic type with custom type resolvers. If so, should try to retain them.\n188                     //  Whether this is sufficient to avoid problems remains to be seen, but for\n189                     //  now it should improve things.\n190                     if (!type.hasGenericTypes()) {\n191                         type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n192                     }\n193                 }\n194                 deser = ctxt.findContextualValueDeserializer(type, _property);\n195             }\n196             _deserializers.put(typeId, deser);\n197         }\n198         return deser;\n199     }", "bm_classpath": "com.fasterxml.jackson.databind.jsontype.impl.TypeDeserializerBase"}, {"bug_name": "JacksonDatabind_108", "report_text": "> Change of behavior (2.8 -> 2.9) with ObjectMapper.readTree(input) with no content\n> \n> So, it looks like `readTree()` methods in `ObjectMapper`, `ObjectReader` that take input OTHER than `JsonParser`, and are given \"empty input\" (only white-space available before end), will\n> * Return `NullNode` (Jackson 2.x up to and including 2.8)\n> * Return `null` (Jackson 2.9)\n> Latter behavior is what `readTree(JsonParser)` has and will do; but this accidentally changed other methods due to refactoring that unified underlying call handling (and add checking for new `DeserializationFeature.FAIL_ON_TRAILING_TOKENS`).  \n> Behavior for this edge case was not being tested, apparently.\n> Now: since behavior has been changed for all 2.9.x patch versions, I am not sure it should be changed for 2.9 branch. But it seems sub-optimal as behavior, and something to definitely change for 3.0... but probably also for 2.10.\n> There are multiple things we could do.\n> 1. Change it back to 2.8, to return `NullNode`\n> 2. Change to throw exception, as \"not valid\" use case\n> 3. Change it to return `MissingNode`\n> 4. Leave as-is, for rest of 2.x.\n> Although it might seem best to revert it to (1), that seems somewhat wrong, problematic, as it would now not be possible to distinguish between JSON `null` value and missing content.  \n> And although (2) would probably make sense, if designing API from scratch, it is probably too intrusive.\n> So I think (3) is the best way: it avoids returning `null` or throwing Exception (both being likely to break 2.9 code), but still allows distinguishing between all possible input cases.", "test_name": "com.fasterxml.jackson.databind.node.EmptyContentAsTreeTest::testNullFromEOFWithParserAndReader", "test_method": "    public void testNullFromEOFWithParserAndReader() throws Exception\n    {\n        try (JsonParser p = MAPPER.getFactory().createParser(EMPTY0)) {\n            _assertNullTree(MAPPER.reader().readTree(p));\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should get `null` for reads with `JsonParser`, instead got: com.fasterxml.jackson.databind.node.MissingNode\n\tcom.fasterxml.jackson.databind.node.EmptyContentAsTreeTest._assertNullTree(EmptyContentAsTreeTest.java:129)\n\tcom.fasterxml.jackson.databind.node.EmptyContentAsTreeTest.testNullFromEOFWithParserAndReader(EmptyContentAsTreeTest.java:62)", "buggy_method": "1166 @SuppressWarnings(\"unchecked\")\n1167     @Override\n1168     public <T extends TreeNode> T readTree(JsonParser p) throws IOException {\n1169         return (T) _bindAsTree(p);\n1170     }", "bm_classpath": "com.fasterxml.jackson.databind.ObjectReader"}, {"bug_name": "JacksonDatabind_109", "report_text": "> WRITE_BIGDECIMAL_AS_PLAIN is ignored if @JsonFormat is used\n> \n> I am trying to serialize BigDecimal as json string while avoiding scientific notation (kotlin):\n> ```\n> data class Test(\n>     @JsonFormat(shape= JsonFormat.Shape.STRING)\n>     val value: BigDecimal\n> )\n> fun main() {\n>     val mapper = jacksonObjectMapper()\n>         .configure(JsonGenerator.Feature.WRITE\\_BIGDECIMAL\\_AS\\_PLAIN, true)\n>     val test = Test(0.0000000005.toBigDecimal())\n>     println(mapper.writeValueAsString(test))\n> }\n> ```\n> output `{\"value\":\"5.0E-10\"}`  \n> If `JsonFormat` is removed, then `WRITE_BIGDECIMAL_AS_PLAIN` works and output is `{\"value\":0.00000000050}` (json number, not string), but trying to make it json string with `JsonFormat` results in `WRITE_BIGDECIMAL_AS_PLAIN` being ignored.\n> Using latest version, jackson-bom:2.9.8", "test_name": "com.fasterxml.jackson.databind.ser.jdk.BigDecimalPlain2230Test::testBigIntegerAsPlainTest", "test_method": "    public void testBigIntegerAsPlainTest() throws Exception\n    {\n        final String NORM_VALUE = \"0.0000000005\";\n        final BigDecimal BD_VALUE = new BigDecimal(NORM_VALUE);\n        final BigDecimalAsString INPUT = new BigDecimalAsString(BD_VALUE);\n        // by default, use the default `toString()`\n\n        // but can force to \"plain\" notation\n        final ObjectMapper m = jsonMapperBuilder()\n            .enable(StreamWriteFeature.WRITE_BIGDECIMAL_AS_PLAIN)\n            .build();\n        assertEquals(\"{\\\"value\\\":\\\"\"+NORM_VALUE+\"\\\"}\", m.writeValueAsString(INPUT)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<{\"value\":\"[0.0000000005]\"}> but was:<{\"value\":\"[5E-10]\"}>\n\tcom.fasterxml.jackson.databind.ser.jdk.BigDecimalPlain2230Test.testBigIntegerAsPlainTest(BigDecimalPlain2230Test.java:35)", "buggy_method": "49 @Override\n50     public JsonSerializer<?> createContextual(SerializerProvider prov,\n51             BeanProperty property) throws JsonMappingException\n52     {\n53         JsonFormat.Value format = findFormatOverrides(prov, property, handledType());\n54         if (format != null) {\n55             switch (format.getShape()) {\n56             case STRING:\n57                 // [databind#2264]: Need special handling for `BigDecimal`\n58                 return ToStringSerializer.instance;\n59             default:\n60             }\n61         }\n62         return this;\n63     }", "bm_classpath": "com.fasterxml.jackson.databind.ser.std.NumberSerializer"}, {"bug_name": "JacksonDatabind_110", "report_text": "> Inconsistent handling of Collections$UnmodifiableList VS Collections$UnmodifiableRandomAccessList\n> \n> I'm sorry to bring that one up again, but I'm under the impression that the issue about unmodifiable collections ([#1880](https://github.com/FasterXML/jackson-databind/issues/1880)) is still not solved completely.\n> In fact, the way the `CLASS_UNMODIFIABLE_LIST` is retrieved [here](https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java#L52) yields `Collections$UnmodifiableRandomAccessList`, and therefore only this type is currently supported by Jackson 2.9.8.\n> However, using `Collections.unmodifiableList()` on a `List` implementation that doesn't implement `RandomAccess` will yield a `Collections$UnmodifiableList` instead, which is not deserialized properly and fails with:\n> ```\n> com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `java.util.Collections$UnmodifiableList` (no Creators, like default constructor, exist): no default no-arguments constructor found\n> ```\n> This can be reproduced by adding the following test case in `TestDefaultForUtilCollections1868`:\n> ```\n> public void testUnmodifiableNonRandomAccessList() throws Exception {\n>    \\_verifyCollection(Collections.unmodifiableList(new LinkedList<>(Arrays.asList(\"first\", \"second\"))));\n> }\n> ```\n> Or more generally for outside the project:\n> ```\n> public void testUnmodifiableNonRandomAccessList() throws Exception {\n>     Collection<?> exp = Collections.unmodifiableList(new LinkedList<>(Arrays.asList(\"first\", \"second\")));\n>     ObjectMapper mapper = new ObjectMapper();\n>     mapper.enableDefaultTyping(DefaultTyping.NON\\_FINAL, JsonTypeInfo.As.PROPERTY);\n>     String json = mapper.writeValueAsString(exp);\n>     Collection<?> act = mapper.readValue(json, Collection.class);\n>     assertEquals(exp, act);\n>     assertEquals(exp.getClass(), act.getClass());\n> }\n> ```\n> Currently `java.util.Collections.unmodifiableList()` can only return these 2 types of unmodifiable lists, so I believe it is safe for now to just hardcode yet another special case for this class.\n> This can currently be solved on user side by adding a mixin, but since `Collections$UnmodifiableRandomAccessList` is supported, I would find it natural to also support the non-random access variant.", "test_name": "com.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest::testUnmodifiableListFromLinkedList", "test_method": "   public void testUnmodifiableListFromLinkedList() throws Exception {\n       final List<String> input = new LinkedList<>();\n       input.add(\"first\");\n       input.add(\"second\");\n\n       // Can't use simple \"_verifyCollection\" as type may change; instead use\n       // bit more flexible check:\n       Collection<?> act = _writeReadCollection(Collections.unmodifiableList(input)); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `java.util.Collections$UnmodifiableList` (no Creators, like default construct, exist): no default no-arguments constructor found\n\tcom.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1452)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1028)\n\tcom.fasterxml.jackson.databind.deser.ValueInstantiator.createUsingDefault(ValueInstantiator.java:189)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:267)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.createDefaultInstance(CollectionDeserializer.java:255)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer._deserialize(AsArrayTypeDeserializer.java:116)\n\tcom.fasterxml.jackson.databind.jsontype.impl.AsArrayTypeDeserializer.deserializeTypedFromArray(AsArrayTypeDeserializer.java:53)\n\tcom.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeWithType(CollectionDeserializer.java:314)\n\tcom.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer.deserialize(TypeWrappedDeserializer.java:68)\n\tcom.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)\n\tcom.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)\n\tcom.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest._writeReadCollection(UtilCollectionsTypesTest.java:122)\n\tcom.fasterxml.jackson.databind.deser.jdk.UtilCollectionsTypesTest.testUnmodifiableListFromLinkedList(UtilCollectionsTypesTest.java:71)", "buggy_method": "64 public static JsonDeserializer<?> findForCollection(DeserializationContext ctxt,\n65             JavaType type)\n66         throws JsonMappingException\n67     {\n68         JavaUtilCollectionsConverter conv;\n69 \n70         // 10-Jan-2017, tatu: Some types from `java.util.Collections`/`java.util.Arrays` need bit of help...\n71         if (type.hasRawClass(CLASS_AS_ARRAYS_LIST)) {\n72             conv = converter(TYPE_AS_LIST, type, List.class);\n73         } else if (type.hasRawClass(CLASS_SINGLETON_LIST)) {\n74             conv = converter(TYPE_SINGLETON_LIST, type, List.class);\n75         } else if (type.hasRawClass(CLASS_SINGLETON_SET)) {\n76             conv = converter(TYPE_SINGLETON_SET, type, Set.class);\n77         // [databind#2265]: we may have another impl type for unmodifiable Lists, check both\n78         } else if (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)) {\n79             conv = converter(TYPE_UNMODIFIABLE_LIST, type, List.class);\n80         } else if (type.hasRawClass(CLASS_UNMODIFIABLE_SET)) {\n81             conv = converter(TYPE_UNMODIFIABLE_SET, type, Set.class);\n82         } else {\n83             return null;\n84         }\n85         return new StdDelegatingDeserializer<Object>(conv);\n86     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.impl.JavaUtilCollectionsDeserializers"}, {"bug_name": "JacksonDatabind_111", "report_text": "> Deserialize null, when java type is \"TypeRef of TypeRef of T\", does not provide \"Type(Type(null))\"\n> \n> **Dependency**\n> ```\n> jackson = '2.9.7'\n> compile \"com.fasterxml.jackson.core:jackson-databind:$jackson\"\n> ```\n> **Short explanation**\n> In Kotlin, I got an issue when I deserialize the value in the context of a reference type that include another reference type. I provide here a reproduction scenario in Java based on AtomicReference (I don't think there is a real use-case that use an AR of AR of Integer, but with a kind of DSL, it may happen to have a similar inclusion...)\n> So, when we deserialize an 22, we get an AR of AR of 22 as expected. But when we deserialize the null value, we get an AR of null (instead of AR of AR of null).\n> I think there is 2 issues:\n> (1) the getNull method of AtomicReference always returns \"new AtomicReference()\". I think it should be smarter and use contextual information such fullType or simply call \\_valueDeserializer.getNull() -- but \\_valueDeserializer was null during my tests because of (2).\n> (2) the bean propertyCreator has distinct deserializer and nullProvider. In the case of ReferenceTypeDeserializer, a new contextual deserializer is created, which is able to deserialize its content. Then the deserializer of the bean propertyCreator is updated, but not its nullProvider\n> **To reproduce**\n> ```\n> class MyBean {\n>     private AtomicReference<AtomicReference<Integer>> refRef;\n>     public AtomicReference<AtomicReference<Integer>> getRefRef() {\n>         return refRef;\n>     }\n>     public void setRefRef(AtomicReference<AtomicReference<Integer>> refRef) {\n>         this.refRef = refRef;\n>     }\n> }\n> @Test\n> void myTest() throws IOException {\n>     ObjectMapper objectMapper = new ObjectMapper();\n>     ObjectReader objectReader = objectMapper.readerFor(MyBean.class);\n>     MyBean intRef = objectReader.readValue(\" {\\\"refRef\\\": 2 } \");\n>     Assertions.assertNotNull(intRef.refRef); // succeeds\n>     Assertions.assertNotNull(intRef.refRef.get()); // succeeds\n>     Assertions.assertEquals(intRef.refRef.get().get(), new Integer(2)); // succeeds\n>     MyBean nullRef = objectReader.readValue(\" {\\\"refRef\\\": null } \");\n>     Assertions.assertNotNull(intRef.refRef); // succeeds\n>     Assertions.assertNotNull(intRef.refRef.get()); // fails\n>     Assertions.assertNull(intRef.refRef.get().get()); // fails\n> }\n> ```", "test_name": "com.fasterxml.jackson.databind.deser.jdk.JDKAtomicTypesDeserTest::testNullWithinNested", "test_method": "    public void testNullWithinNested() throws Exception\n    {\n        final ObjectReader r = MAPPER.readerFor(MyBean2303.class);\n        MyBean2303 intRef = r.readValue(\" {\\\"refRef\\\": 2 } \");\n\n        MyBean2303 nullRef = r.readValue(\" {\\\"refRef\\\": null } \");\n        assertNotNull(nullRef.refRef.get()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.fasterxml.jackson.databind.deser.jdk.JDKAtomicTypesDeserTest.testNullWithinNested(JDKAtomicTypesDeserTest.java:298)", "buggy_method": "129 @Override\n130     public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n131         if (_valueDeserializer == deser) {\n132             return this;\n133         }\n134         // 07-May-2019, tatu: As per [databind#2303], must keep VD/NVP in-sync if they were\n135         return new CreatorProperty(this, deser, _nullProvider);\n136     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.CreatorProperty"}, {"bug_name": "JacksonDatabind_112", "report_text": "> StringCollectionDeserializer fails with custom collection\n> \n> Seeing this with Jackson 2.9.8.\n> We have a custom collection implementation, which is wired to use its \"immutable\" version for deserialization. The rationale is that we don't want accidental modifications to the data structures that come from the wire, so they all are forced to be immutable.\n> After upgrade from 2.6.3 to 2.9.8, the deserialization started breaking with the message:\n> > \n> > Cannot construct instance of `XXX` (although at least one Creator exists): no default no-arguments constructor found\n> > \n> > \n> > \n> This happens ONLY when you deserialize a custom collection of strings as a property of the other object. Deserializing the custom collection of strings directly works fine, and so does the deserialization of custom collection of non-strings. I believe either the `StringCollectionDeserializer` should not be invoked for custom collections, or perhaps it does not handle the delegation as expected.\n> Please see comments for repro and workaround.\n> Thanks!", "test_name": "com.fasterxml.jackson.databind.deser.creators.DelegatingArrayCreator2324Test::testDeserializeBagOfStrings", "test_method": "    public void testDeserializeBagOfStrings() throws Exception {\n        WithBagOfStrings result = MAPPER.readerFor(WithBagOfStrings.class)\n                .readValue(\"{\\\"strings\\\": [ \\\"a\\\", \\\"b\\\", \\\"c\\\"]}\"); // <-- fails here\n    }", "error_message": "com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot construct instance of `com.fasterxml.jackson.databind.deser.creators.DelegatingArrayCreator2324Test$ImmutableBag` (although at least one Creator exists): no default no-arguments constructor found\n\tcom.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:63)\n\tcom.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1343)\n\tcom.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1032)\n\tcom.fasterxml.jackson.databind.deser.ValueInstantiator.createUsingDefault(ValueInstantiator.java:189)\n\tcom.fasterxml.jackson.databind.deser.std.StdValueInstantiator.createUsingDefault(StdValueInstantiator.java:267)\n\tcom.fasterxml.jackson.databind.deser.std.StringCollectionDeserializer.deserialize(StringCollectionDeserializer.java:169)\n\tcom.fasterxml.jackson.databind.deser.std.StringCollectionDeserializer.deserialize(StringCollectionDeserializer.java:21)\n\tcom.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:129)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:288)\n\tcom.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)\n\tcom.fasterxml.jackson.databind.ObjectReader._bindAndClose(ObjectReader.java:1611)\n\tcom.fasterxml.jackson.databind.ObjectReader.readValue(ObjectReader.java:1219)\n\tcom.fasterxml.jackson.databind.deser.creators.DelegatingArrayCreator2324Test.testDeserializeBagOfStrings(DelegatingArrayCreator2324Test.java:59)", "buggy_method": "99 @Override\n100     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n101             BeanProperty property) throws JsonMappingException\n102     {\n103         // May need to resolve types for delegate-based creators:\n104         JsonDeserializer<Object> delegate = null;\n105         if (_valueInstantiator != null) {\n106             // [databind#2324]: check both array-delegating and delegating\n107             AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n108             if (delegateCreator != null) {\n109                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n110                 delegate = findDeserializer(ctxt, delegateType, property);\n111             }\n112         }\n113         JsonDeserializer<?> valueDeser = _valueDeserializer;\n114         final JavaType valueType = _containerType.getContentType();\n115         if (valueDeser == null) {\n116             // [databind#125]: May have a content converter\n117             valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n118             if (valueDeser == null) {\n119             // And we may also need to get deserializer for String\n120                 valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n121             }\n122         } else { // if directly assigned, probably not yet contextual, so:\n123             valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n124         }\n125         // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly\n126         //   comes down to \"List vs Collection\" I suppose... for now, pass Collection\n127         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,\n128                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n129         NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);\n130         if (isDefaultDeserializer(valueDeser)) {\n131             valueDeser = null;\n132         }\n133         return withResolved(delegate, valueDeser, nuller, unwrapSingle);\n134     }", "bm_classpath": "com.fasterxml.jackson.databind.deser.std.StringCollectionDeserializer"}, {"bug_name": "JacksonXml_1", "report_text": "> Problem with deserialization of nested non-wrapped lists, with empty inner list\n> \n> Looks like there is a problem, wherein nested structures like say:\n> * Definition POJO, with `records`, unwrapped List with `Record`\n> * `Record` POJO having property `fields`, another unwrapped list of `Field` POJOs\n> and case where inner `List` happens to be empty/missing, cause incorrectly \"split\" parts of outermost `List`s (here for property `records`).\n> I will come up with a full reproduction later on, but observed this in the wild, and I think it occurs with latest 2.7.0-rc code, as well as `2.6.4-1`, so is not just something that has been fixed with a later version.", "test_name": "com.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test::testNestedUnwrappedLists180", "test_method": "    public void testNestedUnwrappedLists180() throws Exception\n    {\n        /*\n        Records recs = new Records();\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.add(new Record());\n        recs.records.get(0).fields.add(new Field(\"a\"));\n        recs.records.get(2).fields.add(new Field(\"b\"));\n\n        String xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(recs);\n        */\n\n        String xml =\n\"<Records>\\n\"\n// Important: it's the empty CDATA here that causes breakage -- empty element alone would be fine\n//+\"<records>\\n</records>\\n\"\n+\"<records></records>\\n\"\n+\"  <records>\\n\"\n+\"   <fields name='b'/>\\n\"\n+\"  </records>\\n\"\n+\"</Records>\\n\"\n;\n        \n//System.out.println(\"XML: \"+xml);\n\n        Records result = MAPPER.readValue(xml, Records.class);\n\n        // also, first one ought not be null should it? Ideally not...\n        assertNotNull(result.records.get(0)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\tcom.fasterxml.jackson.dataformat.xml.lists.NestedUnwrappedLists180Test.testNestedUnwrappedLists180(NestedUnwrappedLists180Test.java:72)", "buggy_method": "444 @Override\n445     public JsonToken nextToken() throws IOException\n446     {\n447         _binaryValue = null;\n448         if (_nextToken != null) {\n449             JsonToken t = _nextToken;\n450             _currToken = t;\n451             _nextToken = null;\n452             switch (t) {\n453             case START_OBJECT:\n454                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n455                 break;\n456             case START_ARRAY:\n457                 _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n458                 break;\n459             case END_OBJECT:\n460             case END_ARRAY:\n461                 _parsingContext = _parsingContext.getParent();\n462                 _namesToWrap = _parsingContext.getNamesToWrap();\n463                 break;\n464             case FIELD_NAME:\n465                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n466                 break;\n467             default: // VALUE_STRING, VALUE_NULL\n468                 // should be fine as is?\n469             }\n470             return t;\n471         }\n472         int token = _xmlTokens.next();\n473 \n474         // Need to have a loop just because we may have to eat/convert\n475         // a start-element that indicates an array element.\n476         while (token == XmlTokenStream.XML_START_ELEMENT) {\n477             // If we thought we might get leaf, no such luck\n478             if (_mayBeLeaf) {\n479                 // leave _mayBeLeaf set, as we start a new context\n480                 _nextToken = JsonToken.FIELD_NAME;\n481                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n482                 return (_currToken = JsonToken.START_OBJECT);\n483             }\n484             if (_parsingContext.inArray()) {\n485                 // Yup: in array, so this element could be verified; but it won't be\n486                 // reported anyway, and we need to process following event.\n487                 token = _xmlTokens.next();\n488                 _mayBeLeaf = true;\n489                 continue;\n490             }\n491             String name = _xmlTokens.getLocalName();\n492             _parsingContext.setCurrentName(name);\n493 \n494             // Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n495             // Couple of ways to do it; but start by making _xmlTokens replay the thing...\n496             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n497                 _xmlTokens.repeatStartElement();\n498             }\n499 \n500             _mayBeLeaf = true;\n501             // Ok: in array context we need to skip reporting field names.\n502             // But what's the best way to find next token?\n503             return (_currToken = JsonToken.FIELD_NAME);\n504         }\n505 \n506         // Ok; beyond start element, what do we get?\n507         switch (token) {\n508         case XmlTokenStream.XML_END_ELEMENT:\n509             // Simple, except that if this is a leaf, need to suppress end:\n510             if (_mayBeLeaf) {\n511                 _mayBeLeaf = false;\n512                     // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n513                     //    expose as empty Object, not null\n514                 return (_currToken = JsonToken.VALUE_NULL);\n515             }\n516             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n517             _parsingContext = _parsingContext.getParent();\n518             _namesToWrap = _parsingContext.getNamesToWrap();\n519             return _currToken;\n520             \n521         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n522             // If there was a chance of leaf node, no more...\n523             if (_mayBeLeaf) {\n524                 _mayBeLeaf = false;\n525                 _nextToken = JsonToken.FIELD_NAME;\n526                 _currText = _xmlTokens.getText();\n527                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n528                 return (_currToken = JsonToken.START_OBJECT);\n529             }\n530             _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n531             return (_currToken = JsonToken.FIELD_NAME);\n532         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n533             _currText = _xmlTokens.getText();\n534             return (_currToken = JsonToken.VALUE_STRING);\n535         case XmlTokenStream.XML_TEXT:\n536             _currText = _xmlTokens.getText();\n537             if (_mayBeLeaf) {\n538                 _mayBeLeaf = false;\n539                 /* One more refinement (pronunced like \"hack\") is that if\n540                  * we had an empty String (or all white space), and we are\n541                  * deserializing an array, we better hide the empty text.\n542                  */\n543                 // Also: must skip following END_ELEMENT\n544                 _xmlTokens.skipEndElement();\n545                 if (_parsingContext.inArray()) {\n546                     if (_isEmpty(_currText)) {\n547                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n548                         //    expose as empty Object, not null (or, worse, as used to\n549                         //    be done, by swallowing the token)\n550                         _currToken = JsonToken.END_ARRAY;\n551                         _parsingContext = _parsingContext.getParent();\n552                         _namesToWrap = _parsingContext.getNamesToWrap();\n553                         return _currToken;\n554                     }\n555                 }\n556                 return (_currToken = JsonToken.VALUE_STRING);\n557             } else {\n558                 // [dataformat-xml#177]: empty text may also need to be skipped\n559                 if (_parsingContext.inObject()\n560                         && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n561                     _currToken = JsonToken.END_OBJECT;\n562                     _parsingContext = _parsingContext.getParent();\n563                     _namesToWrap = _parsingContext.getNamesToWrap();\n564                     return _currToken;\n565                 }\n566             }\n567             // If not a leaf (or otherwise ignorable), need to transform into property...\n568             _parsingContext.setCurrentName(_cfgNameForTextElement);\n569             _nextToken = JsonToken.VALUE_STRING;\n570             return (_currToken = JsonToken.FIELD_NAME);\n571         case XmlTokenStream.XML_END:\n572             return (_currToken = null);\n573         }\n574         \n575         // should never get here\n576         _throwInternal();\n577         return null;\n578     }", "bm_classpath": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser"}, {"bug_name": "JacksonXml_2", "report_text": "> Mixed content not supported if there are child elements.\n> \n> @XmlText is only supported if there are no child elements, support could be improved with some changes in XmlTokenStream.  \n> I successfully made some changes in XmlTokenStream, it's working in my personal case, but it needs more tests.  \n> If agreed, I could provide a patch.\n> Example:  \n> Input string : `\"<windSpeed units=\\\"kt\\\">27<radius>20</radius></windSpeed>\"`  \n> \"CxmlWindSpeed\" class :\n> ```\n> public class WindSpeed {\n>     public static class Radius {\n>         @JacksonXmlProperty(isAttribute = true)\n>         private String sector;\n>         @JacksonXmlProperty(isAttribute = true)\n>         private String units;\n>         @JacksonXmlText\n>         private int value;\n>         ..../ Getters and Setters code/....\n>     }\n>     @JacksonXmlProperty(isAttribute = true)\n>     private String units;\n>     @JacksonXmlProperty(isAttribute = true)\n>     private String source;\n>     @JacksonXmlText\n>     private int value;\n>     @JacksonXmlElementWrapper(useWrapping = false)\n>     private List<Radius> radius;\n>     ..../ Getters and Setters code/....\n> }\n> ```", "test_name": "com.fasterxml.jackson.dataformat.xml.misc.XmlTextTest::testMixedContent", "test_method": "    public void testMixedContent() throws Exception\n    {\n        WindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\n                WindSpeed.class);\n        assertEquals(27, result.value); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<27> but was:<0>\n\tcom.fasterxml.jackson.dataformat.xml.misc.XmlTextTest.testMixedContent(XmlTextTest.java:70)", "buggy_method": "309 private final int _next() throws XMLStreamException\n310     {\n311         switch (_currentState) {\n312         case XML_ATTRIBUTE_VALUE:\n313             ++_nextAttributeIndex;\n314             // fall through\n315         case XML_START_ELEMENT: // attributes to return?\n316             if (_nextAttributeIndex < _attributeCount) {\n317                 _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n318                 _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n319                 _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n320                 return (_currentState = XML_ATTRIBUTE_NAME);\n321             }\n322             // otherwise need to find START/END_ELEMENT or text\n323             String text = _collectUntilTag();\n324             // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n325             if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n326                     return _initStartElement();\n327             }\n328             // For END_ELEMENT we will return text, if any\n329             if (text != null) {\n330                 _textValue = text;\n331                 return (_currentState = XML_TEXT);\n332             }\n333             return _handleEndElement();\n334 \n335         case XML_ATTRIBUTE_NAME:\n336             // if we just returned name, will need to just send value next\n337             return (_currentState = XML_ATTRIBUTE_VALUE);\n338         case XML_TEXT:\n339             // mixed text with other elements\n340             // text followed by END_ELEMENT\n341             return _handleEndElement();\n342         case XML_END:\n343             return XML_END;\n344 //            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n345         }\n346 \n347         // Ok: must be END_ELEMENT; see what tag we get (or end)\n348         switch (_skipUntilTag()) {\n349         case XMLStreamConstants.END_DOCUMENT:\n350             return (_currentState = XML_END);\n351         case XMLStreamConstants.END_ELEMENT:\n352             return _handleEndElement();\n353         }\n354         // START_ELEMENT...\n355         return _initStartElement();\n356     }", "bm_classpath": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream"}, {"bug_name": "JacksonXml_3", "report_text": "> FromXMLParser nextTextValue() incorrect for attributes\n> \n> As of [#129](https://github.com/FasterXML/jackson-dataformat-xml/issues/129) the Method nextTextValue of FromXMLParser will no longer return a value for attributes. As the \\_currToken is JsonToken.VALUE\\_STRING in this case I think it is wrong to return null and it should return \\_currText.", "test_name": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest::testXmlAttributesWithNextTextValue", "test_method": "    public void testXmlAttributesWithNextTextValue() throws Exception\n    {\n        final String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\n\n        FromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n\n        // First: verify handling without forcing array handling:\n\n        assertEquals(\"7\", xp.nextTextValue()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<7> but was:<null>\n\tcom.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest.testXmlAttributesWithNextTextValue(XmlParserNextXxxTest.java:41)", "buggy_method": "600 @Override\n601     public String nextTextValue() throws IOException\n602     {\n603         _binaryValue = null;\n604         if (_nextToken != null) {\n605             JsonToken t = _nextToken;\n606             _currToken = t;\n607             _nextToken = null;\n608 \n609             // expected case; yes, got a String\n610             if (t == JsonToken.VALUE_STRING) {\n611                 return _currText;\n612             }\n613             _updateState(t);\n614             return null;\n615         }\n616 \n617         int token = _xmlTokens.next();\n618 \n619         // mostly copied from 'nextToken()'\n620         while (token == XmlTokenStream.XML_START_ELEMENT) {\n621             if (_mayBeLeaf) {\n622                 _nextToken = JsonToken.FIELD_NAME;\n623                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n624                 _currToken = JsonToken.START_OBJECT;\n625                 return null;\n626             }\n627             if (_parsingContext.inArray()) {\n628                 token = _xmlTokens.next();\n629                 _mayBeLeaf = true;\n630                 continue;\n631             }\n632             String name = _xmlTokens.getLocalName();\n633             _parsingContext.setCurrentName(name);\n634             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n635                 _xmlTokens.repeatStartElement();\n636             }\n637             _mayBeLeaf = true;\n638             _currToken = JsonToken.FIELD_NAME;\n639             return null;\n640         }\n641 \n642         // Ok; beyond start element, what do we get?\n643         switch (token) {\n644         case XmlTokenStream.XML_END_ELEMENT:\n645             if (_mayBeLeaf) {\n646                 // NOTE: this is different from nextToken() -- produce \"\", NOT null\n647                 _mayBeLeaf = false;\n648                 _currToken = JsonToken.VALUE_STRING;\n649                 return (_currText = \"\");\n650             }\n651             _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n652             _parsingContext = _parsingContext.getParent();\n653             _namesToWrap = _parsingContext.getNamesToWrap();\n654             break;\n655         case XmlTokenStream.XML_ATTRIBUTE_NAME:\n656             // If there was a chance of leaf node, no more...\n657             if (_mayBeLeaf) {\n658                 _mayBeLeaf = false;\n659                 _nextToken = JsonToken.FIELD_NAME;\n660                 _currText = _xmlTokens.getText();\n661                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n662                 _currToken = JsonToken.START_OBJECT;\n663             } else {\n664                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n665                 _currToken = JsonToken.FIELD_NAME;\n666             }\n667             break;\n668         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n669             _currText = _xmlTokens.getText();\n670             _currToken = JsonToken.VALUE_STRING;\n671             break;\n672         case XmlTokenStream.XML_TEXT:\n673             _currText = _xmlTokens.getText();\n674             if (_mayBeLeaf) {\n675                 _mayBeLeaf = false;\n676                 // Also: must skip following END_ELEMENT\n677                 _xmlTokens.skipEndElement();\n678 \n679                 // NOTE: this is different from nextToken() -- NO work-around\n680                 // for otherwise empty List/array\n681                 _currToken = JsonToken.VALUE_STRING;\n682                 return _currText;\n683             }\n684             // If not a leaf, need to transform into property...\n685             _parsingContext.setCurrentName(_cfgNameForTextElement);\n686             _nextToken = JsonToken.VALUE_STRING;\n687             _currToken = JsonToken.FIELD_NAME;\n688             break;\n689         case XmlTokenStream.XML_END:\n690             _currToken = null;\n691         }\n692         return null;\n693     }", "bm_classpath": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser"}, {"bug_name": "JacksonXml_4", "report_text": "> XmlSerializerProvider does not use withRootName config for null\n> \n> In `jackson-dataformat-xml/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java`\n> Line 203, I think `_rootNameFromConfig()` should be used if available instead of `ROOT_NAME_FOR_NULL`, so that `withRootName()` config can be used.\n> I don't know whether/how deser would be affected\n> [jackson-dataformat-xml/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java](https://github.com/FasterXML/jackson-dataformat-xml/blob/ca1c671c419e88a18357d497ec3671c73c37452e/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java#L203)\n>  Line 203\n>  in\n>  [ca1c671](/FasterXML/jackson-dataformat-xml/commit/ca1c671c419e88a18357d497ec3671c73c37452e)\n> |  |  |\n> | --- | --- |\n> |  | \\_initWithRootName((ToXmlGenerator) jgen, ROOT\\_NAME\\_FOR\\_NULL);  |", "test_name": "com.fasterxml.jackson.dataformat.xml.misc.RootNameTest::testDynamicRootName", "test_method": "    public void testDynamicRootName() throws IOException\n    {\n        String xml;\n\n        ObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\n\n        xml = w.writeValueAsString(new StringBean(\"foo\"));\n\n        xml = w.writeValueAsString(new StringBean(null));\n\n        // and even with null will respect configured root name\n        xml = w.writeValueAsString(null);\n        assertEquals(\"<rudy/>\", xml); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<<[rudy]/>> but was:<<[null]/>>\n\tcom.fasterxml.jackson.dataformat.xml.misc.RootNameTest.testDynamicRootName(RootNameTest.java:81)", "buggy_method": "200 protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n201     {\n202         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n203         //    configured root name...\n204         if (jgen instanceof ToXmlGenerator) {\n205             _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n206         }\n207         super.serializeValue(jgen, null);\n208     }", "bm_classpath": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider"}, {"bug_name": "JacksonXml_5", "report_text": "> @JacksonXmlRootElement malfunction when using it with multiple XmlMappers and disabling annotations\n> \n> Found this in version 2.9.4 running some tests that go back and forth serializing with an XML mapper that uses annotations, and another one that ignores them. May be related to issue [#171](https://github.com/FasterXML/jackson-dataformat-xml/issues/171) and the cache of class annotations.\n> When running this code, the second print statement should use the annotation's localName but it instead uses the class name.\n> ```\n> @JacksonXmlRootElement(localName = \"myname\")\n> public class XMLTest {\n>     public static void main(String[] s) throws Exception {\n>         final ObjectMapper xmlMapper = new XmlMapper();\n>         final ObjectMapper noAnnotationsXmlMapper = xmlMapper.copy()\n>                 .configure(MapperFeature.USE_ANNOTATIONS, false)\n>                 .configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n>         System.out.println(noAnnotationsXmlMapper.writeValueAsString(new XMLTest()));\n>         System.out.println(xmlMapper.writeValueAsString(new XMLTest()));\n>     }\n> }\n> ```\n> Output:\n> ```\n> <XMLTest/>\n> <XMLTest/>\n> ```", "test_name": "com.fasterxml.jackson.dataformat.xml.MapperCopyTest::testCopyWith", "test_method": "    public void testCopyWith() throws Exception\n    {\n        XmlMapper xmlMapper = newMapper();\n        final ObjectMapper xmlMapperNoAnno = xmlMapper.copy()\n                .disable(MapperFeature.USE_ANNOTATIONS)\n                .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n\n        String xml1 = xmlMapper.writeValueAsString(new Pojo282());\n        String xml2 = xmlMapperNoAnno.writeValueAsString(new Pojo282());\n\n        if (!xml1.contains(\"AnnotatedName\")) {\n            fail(\"Should use name 'AnnotatedName', xml = \"+xml1);\n        }\n        if (!xml2.contains(\"Pojo282\")\n                || xml2.contains(\"AnnotatedName\")) {\n            fail(\"Should NOT use name 'AnnotatedName' but 'Pojo282', xml = \"+xml1);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should NOT use name 'AnnotatedName' but 'Pojo282', xml = <AnnotatedName><a>3</a></AnnotatedName>\n\tcom.fasterxml.jackson.dataformat.xml.MapperCopyTest.testCopyWith(MapperCopyTest.java:89)", "buggy_method": "55 protected XmlSerializerProvider(XmlSerializerProvider src) {\n56         super(src);\n57         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n58         //    root name lookup as that may link back to diff version, configuration\n59         _rootNameLookup = src._rootNameLookup;\n60     }", "bm_classpath": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider"}, {"bug_name": "Jsoup_1", "report_text": "> Parsing a HTML snippet causes the leading text to be moved to back\n> \n> Code:\n> ```\n> String html = \"foo <b>bar</b> baz\";\n> String text = Jsoup.parse(html).text();\n> System.out.println(text);\n> ```\n> Result:\n> ```\n> bar baz foo\n> ```\n> Expected:\n> ```\n> foo bar baz\n> ```", "test_name": "org.jsoup.parser.ParserTest::createsStructureFromBodySnippet", "test_method": "    @Test public void createsStructureFromBodySnippet() {\n        // the bar baz stuff naturally goes into the body, but the 'foo' goes into root, and the normalisation routine\n        // needs to move into the start of the body\n        String html = \"foo <b>bar</b> baz\";\n        Document doc = Jsoup.parse(html);\n        assertEquals (\"foo bar baz\", doc.text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[foo bar baz]> but was:<[bar baz foo]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.ParserTest.createsStructureFromBodySnippet(ParserTest.java:110)", "buggy_method": "113 private void normalise(Element element) {\n114         List<Node> toMove = new ArrayList<Node>();\n115         for (Node node: element.childNodes) {\n116             if (node instanceof TextNode) {\n117                 TextNode tn = (TextNode) node;\n118                 if (!tn.isBlank())\n119                     toMove.add(tn);\n120             }\n121         }\n122 \n123         for (Node node: toMove) {\n124             element.removeChild(node);\n125             body().appendChild(new TextNode(\" \", \"\"));\n126             body().appendChild(node);\n127         }\n128     }", "bm_classpath": "org.jsoup.nodes.Document"}, {"bug_name": "Jsoup_2", "report_text": "> Unadorned text following data-only tags doesn't parse properly\n> \n> This HTML, parsed and immediately printed out, results in:\n> <html>  \n> <body>  \n> <script type=\"text/javascript\">  \n> var inside = true;  \n> </script>  \n> this should be outside.  \n> </body>  \n> </html>\n> Results:\n> <html>  \n> <head>  \n> </head>  \n> <body>  \n> <script type=\"text/javascript\">  \n> var inside = true;\n> this should be outside.\n> </script>  \n> </body>  \n> </html>\n> Note how \"this should be outside\" ends up inside the <script> tag, instead of following it. From what I can tell, this only happens to data-only tags.", "test_name": "org.jsoup.parser.ParserTest::handlesTextAfterData", "test_method": "    @Test public void handlesTextAfterData() {\n        String h = \"<html><body>pre <script>inner</script> aft</body></html>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...dy>pre <script>inner[</script> aft]</body></html>> but was:<...dy>pre <script>inner[ aft</script>]</body></html>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.ParserTest.handlesTextAfterData(ParserTest.java:138)", "buggy_method": "116 private void parseStartTag() {\n117         tq.consume(\"<\");\n118         String tagName = tq.consumeWord();\n119 \n120         if (tagName.length() == 0) { // doesn't look like a start tag after all; put < back on stack and handle as text\n121             tq.addFirst(\"&lt;\");\n122             parseTextNode();\n123             return;\n124         }\n125 \n126         Attributes attributes = new Attributes();\n127         while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\n128             Attribute attribute = parseAttribute();\n129             if (attribute != null)\n130                 attributes.put(attribute);\n131         }\n132 \n133         Tag tag = Tag.valueOf(tagName);\n134         Element child = new Element(tag, baseUri, attributes);\n135 \n136         boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n137         if (tq.matchChomp(\"/>\")) { // close empty element or tag\n138             isEmptyElement = true;\n139         } else {\n140             tq.matchChomp(\">\");\n141         }\n142         addChildToParent(child, isEmptyElement);\n143 \n144         // pc data only tags (textarea, script): chomp to end tag, add content as text node\n145         if (tag.isData()) {\n146             String data = tq.chompTo(\"</\" + tagName);\n147             tq.chompTo(\">\");\n148             \n149             Node dataNode;\n150             if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n151                 dataNode = TextNode.createFromEncoded(data, baseUri);\n152             else\n153                 dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n154             child.appendChild(dataNode);   \n155         }\n156 \n157         // <base href>: update the base uri\n158         if (child.tagName().equals(\"base\")) {\n159             String href = child.absUrl(\"href\");\n160             if (href.length() != 0) { // ignore <base target> etc\n161                 baseUri = href;\n162                 doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n163             }\n164         }\n165     }", "bm_classpath": "org.jsoup.parser.Parser"}, {"bug_name": "Jsoup_3", "report_text": "> Issue with <tr>\n> \n> When calling append to add a table row the resulting tr gets wrapped in a table even though I appended to an existing table.", "test_name": "org.jsoup.nodes.ElementTest::testAppendRowToTable", "test_method": "    @Test public void testAppendRowToTable() {\n        Document doc = Jsoup.parse(\"<table><tr><td>1</td></tr></table>\");\n        Element table = doc.select(\"table\").first();\n        table.append(\"<tr><td>2</td></tr>\");\n\n        assertEquals(\"<table><tr><td>1</td></tr><tr><td>2</td></tr></table>\", TextUtil.stripNewlines(doc.body().html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...tr><td>1</td></tr><t[r><td>2</td></tr]></table>> but was:<...tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.testAppendRowToTable(ElementTest.java:219)", "buggy_method": "267 public Element append(String html) {\n268         Validate.notNull(html);\n269         \n270         Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n271         for (Node node : fragment.childNodes()) {\n272             node.parentNode = null;\n273             appendChild(node);\n274         }\n275         return this;\n276     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_4", "report_text": "> uppercase umlauts get replaced by lowercase umlaut entities\n> \n> The line\n> ```\n> System.out.println(Jsoup.clean(\"<h1>\u00dcberschrift</h1>\", Whitelist.none()));\n> ```\n> should print\n> ```\n> &Uuml;berschrift\n> ```\n> but prints\n> ```\n> &uuml;berschrift\n> ```\n> This used to work correctly in v0.3.1, but fails in v1.2.3.\n> While *baseArray* in *Entities.java* distinguishes between lowercase and uppercase umlauts, the above call yields the wrong result.", "test_name": "org.jsoup.nodes.EntitiesTest::escape", "test_method": "    @Test public void escape() {\n        String text = \"Hello &<> \u00c5 \u00e5 \u03c0 \u65b0 there\";\n        String escapedAscii = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.base);\n        String escapedAsciiFull = Entities.escape(text, Charset.forName(\"ascii\").newEncoder(), Entities.EscapeMode.extended);\n        String escapedUtf = Entities.escape(text, Charset.forName(\"UTF-8\").newEncoder(), Entities.EscapeMode.base);\n\n        assertEquals(\"Hello &amp;&lt;&gt; &Aring; &aring; &#960; &#26032; there\", escapedAscii); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...ello &amp;&lt;&gt; &[A]ring; &aring; &#960;...> but was:<...ello &amp;&lt;&gt; &[a]ring; &aring; &#960;...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.EntitiesTest.escape(EntitiesTest.java:17)", "buggy_method": "47 static String unescape(String string) {\n48         if (!string.contains(\"&\"))\n49             return string;\n50 \n51         Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n52         StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n53 \n54         while (m.find()) {\n55             int charval = -1;\n56             String num = m.group(3);\n57             if (num != null) {\n58                 try {\n59                     int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n60                     charval = Integer.valueOf(num, base);\n61                 } catch (NumberFormatException e) {\n62                 } // skip\n63             } else {\n64                 String name = m.group(1).toLowerCase();\n65                 if (full.containsKey(name))\n66                     charval = full.get(name);\n67             }\n68 \n69             if (charval != -1 || charval > 0xFFFF) { // out of range\n70                 String c = Character.toString((char) charval);\n71                 m.appendReplacement(accum, c);\n72             } else {\n73                 m.appendReplacement(accum, m.group(0)); // replace with original string\n74             }\n75         }\n76         m.appendTail(accum);\n77         return accum.toString();\n78     }", "bm_classpath": "org.jsoup.nodes.Entities"}, {"bug_name": "Jsoup_5", "report_text": "> StringIndexOutOfBoundsException when testing whether String content is valid HTML\n> \n> If I try to parse a tag with an equals sign (an empty attribute) but without any single or double quotes around an attribute value, then I get a StringIndexOutOfBoundsException. The stack trace is pasted below.\n> An example String would be \"<a =a\"\n> The following JUnit test case should not throw a StringIndexOutOfBoundsException:\n> import static org.junit.Assert.assertTrue;  \n> import org.jsoup.Jsoup;  \n> import org.jsoup.safety.Whitelist;  \n> import org.junit.Test;  \n> public class BadAttributeTest {  \n> [@test](https://github.com/test)  \n> public void aTagWithABadAttributeIsValid() throws Exception {  \n> assertTrue(Jsoup.isValid(\"<a =a\", Whitelist.relaxed()));  \n> }  \n> }\n> java.lang.StringIndexOutOfBoundsException: String index out of range: 13  \n> at java.lang.String.charAt(String.java:686)  \n> at org.jsoup.parser.TokenQueue.consume(TokenQueue.java:130)  \n> at org.jsoup.parser.Parser.parseAttribute(Parser.java:207)  \n> at org.jsoup.parser.Parser.parseStartTag(Parser.java:142)  \n> at org.jsoup.parser.Parser.parse(Parser.java:91)  \n> at org.jsoup.parser.Parser.parseBodyFragment(Parser.java:64)  \n> at org.jsoup.Jsoup.parseBodyFragment(Jsoup.java:99)  \n> at org.jsoup.Jsoup.isValid(Jsoup.java:155)", "test_name": "org.jsoup.parser.ParserTest::parsesQuiteRoughAttributes", "test_method": "    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a =a\";\n        Document doc = Jsoup.parse(html); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 14\n\tjava.lang.String.charAt(String.java:658)\n\torg.jsoup.parser.TokenQueue.consume(TokenQueue.java:162)\n\torg.jsoup.parser.Parser.parseAttribute(Parser.java:206)\n\torg.jsoup.parser.Parser.parseStartTag(Parser.java:139)\n\torg.jsoup.parser.Parser.parse(Parser.java:84)\n\torg.jsoup.parser.Parser.parse(Parser.java:54)\n\torg.jsoup.Jsoup.parse(Jsoup.java:41)\n\torg.jsoup.parser.ParserTest.parsesQuiteRoughAttributes(ParserTest.java:45)", "buggy_method": "181 private Attribute parseAttribute() {\n182         tq.consumeWhitespace();\n183         String key = tq.consumeAttributeKey();\n184         String value = \"\";\n185         tq.consumeWhitespace();\n186         if (tq.matchChomp(\"=\")) {\n187             tq.consumeWhitespace();\n188 \n189             if (tq.matchChomp(SQ)) {\n190                 value = tq.chompTo(SQ);\n191             } else if (tq.matchChomp(DQ)) {\n192                 value = tq.chompTo(DQ);\n193             } else {\n194                 StringBuilder valueAccum = new StringBuilder();\n195                 // no ' or \" to look for, so scan to end tag or space (or end of stream)\n196                 while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n197                     valueAccum.append(tq.consume());\n198                 }\n199                 value = valueAccum.toString();\n200             }\n201             tq.consumeWhitespace();\n202         }\n203         if (key.length() != 0)\n204             return Attribute.createFromEncoded(key, value);\n205         else {\n206             tq.consume();\n207                 \n208             return null;\n209         }\n210     }", "bm_classpath": "org.jsoup.parser.Parser"}, {"bug_name": "Jsoup_6", "report_text": "> StringIndexOutOfBoundsException when parsing link http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\n> \n> java.lang.StringIndexOutOfBoundsException: String index out of range: 1  \n> at java.lang.String.charAt(String.java:686)  \n> at java.util.regex.Matcher.appendReplacement(Matcher.java:711)  \n> at org.jsoup.nodes.Entities.unescape(Entities.java:69)  \n> at org.jsoup.nodes.TextNode.createFromEncoded(TextNode.java:95)  \n> at org.jsoup.parser.Parser.parseTextNode(Parser.java:222)  \n> at org.jsoup.parser.Parser.parse(Parser.java:94)  \n> at org.jsoup.parser.Parser.parse(Parser.java:54)  \n> at org.jsoup.Jsoup.parse(Jsoup.java:30)", "test_name": "org.jsoup.integration.ParseTest::testYahooArticle", "test_method": "    @Test\n    public void testYahooArticle() throws IOException {\n        File in = getFile(\"/htmltests/yahoo-article-1.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\", \"http://news.yahoo.com/s/nm/20100831/bs_nm/us_gm_china\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Illegal group reference: group index is missing\n\tjava.util.regex.Matcher.appendReplacement(Matcher.java:819)\n\torg.jsoup.nodes.Entities.unescape(Entities.java:70)\n\torg.jsoup.nodes.TextNode.createFromEncoded(TextNode.java:95)\n\torg.jsoup.parser.Parser.parseTextNode(Parser.java:222)\n\torg.jsoup.parser.Parser.parse(Parser.java:94)\n\torg.jsoup.parser.Parser.parse(Parser.java:54)\n\torg.jsoup.Jsoup.parse(Jsoup.java:31)\n\torg.jsoup.helper.DataUtil.parseByteData(DataUtil.java:80)\n\torg.jsoup.helper.DataUtil.load(DataUtil.java:53)\n\torg.jsoup.helper.DataUtil.load(DataUtil.java:36)\n\torg.jsoup.Jsoup.parse(Jsoup.java:74)\n\torg.jsoup.integration.ParseTest.testYahooArticle(ParseTest.java:145)", "buggy_method": "45 static String unescape(String string) {\n46         if (!string.contains(\"&\"))\n47             return string;\n48 \n49         Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n50         StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n51         // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n52 \n53         while (m.find()) {\n54             int charval = -1;\n55             String num = m.group(3);\n56             if (num != null) {\n57                 try {\n58                     int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n59                     charval = Integer.valueOf(num, base);\n60                 } catch (NumberFormatException e) {\n61                 } // skip\n62             } else {\n63                 String name = m.group(1);\n64                 if (full.containsKey(name))\n65                     charval = full.get(name);\n66             }\n67 \n68             if (charval != -1 || charval > 0xFFFF) { // out of range\n69                 String c = Character.toString((char) charval);\n70                 m.appendReplacement(accum, c);\n71             } else {\n72                 m.appendReplacement(accum, m.group(0));\n73             }\n74         }\n75         m.appendTail(accum);\n76         return accum.toString();\n77     }", "bm_classpath": "org.jsoup.nodes.Entities"}, {"bug_name": "Jsoup_7", "report_text": "> Page results in malformed tree\n> \n> The page I will attach results in a Jsoup tree with two body elements, neither if which is a direct child of the html element.\n> You will find the page in \"[git@github.com](mailto:git@github.com):bimargulies/Misc.git\" under the jsoup-tc directory.", "test_name": "org.jsoup.nodes.DocumentTest::testNormalisesStructure", "test_method": "    @Test public void testNormalisesStructure() {\n        Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body></html>\");\n        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html>\", TextUtil.stripNewlines(doc.html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...</script><noscript><[/noscript></head><body><p>two</p><p>three</p></body]></html>> but was:<...</script><noscript><[body><p>two</p><body><p>three</p></body></body></noscript></head]></html>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.DocumentTest.testNormalisesStructure(DocumentTest.java:59)", "buggy_method": "98 public Document normalise() {\n99         Element htmlEl = findFirstElementByTagName(\"html\", this);\n100         if (htmlEl == null)\n101             htmlEl = appendElement(\"html\");\n102         if (head() == null)\n103             htmlEl.prependElement(\"head\");\n104         if (body() == null)\n105             htmlEl.appendElement(\"body\");\n106 \n107         // pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care\n108         // of. do in inverse order to maintain text order.\n109         normaliseTextNodes(head());\n110         normaliseTextNodes(htmlEl);\n111         normaliseTextNodes(this);\n112 \n113         \n114         return this;\n115     }", "bm_classpath": "org.jsoup.nodes.Document"}, {"bug_name": "Jsoup_8", "report_text": "> toString NPE for orphans\n> \n> I'm working on code that frequently calls 'remove' and then re-adds an element. While the element is in a detached string, toString throws something, so Eclipse prints only an 'invocation target exception.' It would be nice if this were not so.", "test_name": "org.jsoup.nodes.ElementTest::parentlessToString", "test_method": "    @Test public void parentlessToString() {\n        Document doc = Jsoup.parse(\"<img src='foo'>\");\n        Element img = doc.select(\"img\").first();\n\n        img.remove(); // lost its parent\n        assertEquals(\"<img src=\\\"foo\\\" />\", img.toString()); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jsoup.nodes.Node.outerHtml(Node.java:363)\n\torg.jsoup.nodes.Node.outerHtml(Node.java:358)\n\torg.jsoup.nodes.Element.toString(Element.java:1022)\n\torg.jsoup.nodes.ElementTest.parentlessToString(ElementTest.java:422)", "buggy_method": "362 protected void outerHtml(StringBuilder accum) {\n363         new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n364     }", "bm_classpath": "org.jsoup.nodes.Node"}, {"bug_name": "Jsoup_10", "report_text": "> attr(\"abs:href\") , absUrl(\"href\")\n> \n> Document doc = Jsoup.parse(new URL(\"<http://www.oschina.net/bbs/thread/12975>\"), 5\\*1000);  \n> Elements es = doc.select(\"a[href]\");  \n> for(Iterator it = es.iterator();it.hasNext();){  \n> Element e = it.next();  \n> System.out.println(e.absUrl(\"href\"));  \n> }\n> attr(\"abs:href\") ------ <a href=\"?p=1\">1</a>  \n> result: ------------------- <http://www.oschina.net/bbs/thread/?p=1>\n> I think it's a wrong result~.  \n> The correct results should be \"<http://www.oschina.net/bbs/thread/12975?p=1>\"", "test_name": "org.jsoup.nodes.NodeTest::absHandlesRelativeQuery", "test_method": "    @Test public void absHandlesRelativeQuery() {\n        Document doc = Jsoup.parse(\"<a href='?foo'>One</a> <a href='bar.html?foo'>Two</a>\", \"http://jsoup.org/path/file?bar\");\n\n        Element a1 = doc.select(\"a\").first();\n        assertEquals(\"http://jsoup.org/path/file?foo\", a1.absUrl(\"href\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...tp://jsoup.org/path/[file]?foo> but was:<...tp://jsoup.org/path/[]?foo>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.NodeTest.absHandlesRelativeQuery(NodeTest.java:49)", "buggy_method": "156 public String absUrl(String attributeKey) {\n157         Validate.notEmpty(attributeKey);\n158 \n159         String relUrl = attr(attributeKey);\n160         if (!hasAttr(attributeKey)) {\n161             return \"\"; // nothing to make absolute with\n162         } else {\n163             URL base;\n164             try {\n165                 try {\n166                     base = new URL(baseUri);\n167                 } catch (MalformedURLException e) {\n168                     // the base is unsuitable, but the attribute may be abs on its own, so try that\n169                     URL abs = new URL(relUrl);\n170                     return abs.toExternalForm();\n171                 }\n172                 // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n173                 URL abs = new URL(base, relUrl);\n174                 return abs.toExternalForm();\n175             } catch (MalformedURLException e) {\n176                 return \"\";\n177             }\n178         }\n179     }", "bm_classpath": "org.jsoup.nodes.Node"}, {"bug_name": "Jsoup_11", "report_text": "> Implement :not pseudo-selector\n> \n> In version 1.3.3, the pseudo selector :not is not implemented.", "test_name": "org.jsoup.select.SelectorTest::notAll", "test_method": "    @Test public void notAll() {\n        Document doc = Jsoup.parse(\"<p>Two</p> <p><span>Three</span></p>\");\n\n        Elements el1 = doc.body().select(\":not(p)\"); // should just be the span // <-- fails here\n    }", "error_message": "org.jsoup.select.Selector$SelectorParseException: Could not parse query ':not(p)': unexpected token at ':not(p)'\n\torg.jsoup.select.Selector.findElements(Selector.java:182)\n\torg.jsoup.select.Selector.select(Selector.java:111)\n\torg.jsoup.select.Selector.select(Selector.java:84)\n\torg.jsoup.nodes.Element.select(Element.java:199)\n\torg.jsoup.select.SelectorTest.notAll(SelectorTest.java:559)", "buggy_method": "104 private Elements select() {\n105         tq.consumeWhitespace();\n106         \n107         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n108             elements.add(root);\n109             combinator(tq.consume().toString());\n110         } else {\n111             addElements(findElements()); // chomp first element matcher off queue \n112         }            \n113                \n114         while (!tq.isEmpty()) {\n115             // hierarchy and extras\n116             boolean seenWhite = tq.consumeWhitespace();\n117             \n118             if (tq.matchChomp(\",\")) { // group or\n119                 while (!tq.isEmpty()) {\n120                     String subQuery = tq.chompTo(\",\");\n121                     elements.addAll(select(subQuery, root));\n122                 }\n123             } else if (tq.matchesAny(combinators)) {\n124                 combinator(tq.consume().toString());\n125             } else if (seenWhite) {\n126                 combinator(\" \");\n127             } else { // E.class, E#id, E[attr] etc. AND\n128                 Elements candidates = findElements(); // take next el, #. etc off queue\n129                 intersectElements(filterForSelf(elements, candidates));\n130             }\n131         }\n132         return new Elements(elements);\n133     }", "bm_classpath": "org.jsoup.select.Selector"}, {"bug_name": "Jsoup_12", "report_text": "> tag[attr~=regex] fails if preceded by a combinator\n> \n> All following selectors fail with a SelectorParseException:\n> ```\n> div table[class~=x|y]\n> div > table[class~=x|y]\n> div + table[class~=x|y]\n> div ~ table[class~=x|y]\n> ```\n> Note that \n> ```\n> div, table[class~=x|y]\n> ```\n>  does not fail\n> Using: jsoup 1.4.1 and JDK 7 build 116", "test_name": "org.jsoup.select.SelectorTest::testByAttributeRegexCombined", "test_method": "    @Test public void testByAttributeRegexCombined() {\n        Document doc = Jsoup.parse(\"<div><table class=x><td>Hello</td></table></div>\");\n        Elements els = doc.select(\"div table[class~=x|y]\"); // <-- fails here\n    }", "error_message": "org.jsoup.select.Selector$SelectorParseException: Could not parse query '=x|y]': unexpected token at '=x|y]'\n\torg.jsoup.select.Selector.findElements(Selector.java:187)\n\torg.jsoup.select.Selector.select(Selector.java:113)\n\torg.jsoup.select.Selector.select(Selector.java:84)\n\torg.jsoup.select.Selector.combinator(Selector.java:149)\n\torg.jsoup.select.Selector.select(Selector.java:126)\n\torg.jsoup.select.Selector.select(Selector.java:84)\n\torg.jsoup.nodes.Element.select(Element.java:199)\n\torg.jsoup.select.SelectorTest.testByAttributeRegexCombined(SelectorTest.java:129)", "buggy_method": "137 private void combinator(char combinator) {\n138         tq.consumeWhitespace();\n139         String subQuery = tq.consumeToAny(combinators);\n140         \n141         Elements output;\n142         if (combinator == '>')\n143             output = filterForChildren(elements, select(subQuery, elements));\n144         else if (combinator == ' ')\n145             output = filterForDescendants(elements, select(subQuery, elements));\n146         else if (combinator == '+')\n147             output = filterForAdjacentSiblings(elements, select(subQuery, root));\n148         else if (combinator == '~')\n149             output = filterForGeneralSiblings(elements, select(subQuery, root));\n150         else\n151             throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n152         \n153         elements.clear(); elements.addAll(output);\n154     }", "bm_classpath": "org.jsoup.select.Selector"}, {"bug_name": "Jsoup_13", "report_text": "> abs: attribute prefix does not work on Elements.attr()\n> \n> Elements.attr() iterates on its element to look for the first one with the given attrbute.\n> If I try to get the attribute abs:href, the test element.hasAttr(\"abs:herf\") fails, and the returned value is an empty string.", "test_name": "org.jsoup.nodes.NodeTest::handlesAbsPrefixOnHasAttr", "test_method": "    @Test public void handlesAbsPrefixOnHasAttr() {\n        // 1: no abs url; 2: has abs url\n        Document doc = Jsoup.parse(\"<a id=1 href='/foo'>One</a> <a id=2 href='http://jsoup.org/'>Two</a>\");\n        Element one = doc.select(\"#1\").first();\n        Element two = doc.select(\"#2\").first();\n\n\n        assertTrue(two.hasAttr(\"abs:href\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.nodes.NodeTest.handlesAbsPrefixOnHasAttr(NodeTest.java:59)", "buggy_method": "104 public boolean hasAttr(String attributeKey) {\n105         Validate.notNull(attributeKey);\n106 \n107         return attributes.hasKey(attributeKey);\n108     }", "bm_classpath": "org.jsoup.nodes.Node"}, {"bug_name": "Jsoup_15", "report_text": "> <script> containing tags causes issues\n> \n> Thanks for the release, using 1.6.0 now, and getting issues with <http://techcrunch.com>. html has a script tag containing tags inside of javascript strings. Seems to be treating those as real tag openers, creating tag elements and causing the close script tag to be ignored and therefore include a ton of other stuff. I think this was working in 1.5.2.\n> Simplified example:\n> ```\n> <HTML>\n> <body>\n>  <div class=vsc sig=Uga>\n>   <div class=before></div>\n>   <script type=\"text/javascript\">\n>    header = jQuery('#header_features');\n>    if(header.length){\n>     header\n>      .prepend('<a class=\"prevPage browse left \" />')\n>      .append('<a class=\"nextPage browse right\" />');\n>     items\n>      .wrapAll('<div class=\"scrollable\"/>')\n>      .wrapAll('<ul class=\"items\"/>')\n>      .wrap('<li/>');\n>    }\n>    </script>\n>    <div class=after></div>\n>  </div>\n> </body>\n> </HTML>\n> ```\n> Result, notice the script strings become tags and the script tag now subsumes the following div:\n> ```\n> <html>\n>  <body> \n>   <div class=\"vsc\" sig=\"Uga\"> \n>    <div class=\"before\"></div> \n>    <script type=\"text/javascript\">\n>    header = jQuery('#header_features');\n>    if(header.length){\n>     header\n>      .prepend('\n>     <a class=\"prevPage browse left \">') .append('</a>\n>     <a class=\"nextPage browse right\">'); items .wrapAll('\n>      <div class=\"scrollable\">\n>       ') .wrapAll('\n>       <ul class=\"items\">\n>        ') .wrap('\n>        <li>'); }  \n>         <div class=\"after\"></div> </li>\n>       </ul>\n>      </div>  </a>\n>    </script>\n>   </div>\n>  </body>\n> </html>\n> ```", "test_name": "org.jsoup.parser.ParserTest::handlesDataOnlyTags", "test_method": "    @Test public void handlesDataOnlyTags() {\n        String t = \"<style>font-family: bold</style>\";\n        List<Element> tels = Jsoup.parse(t).getElementsByTag(\"style\");\n\n        String s = \"<p>Hello</p><script>obj.insert('<a rel=\\\"none\\\" />');\\ni++;</script><p>There</p>\";\n        Document doc = Jsoup.parse(s);\n        assertEquals(\"Hello There\", doc.text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Hello []There> but was:<Hello ['); i++; ]There>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.ParserTest.handlesDataOnlyTags(ParserTest.java:163)", "buggy_method": "246 boolean process(Token t, TreeBuilder tb) {\n247             switch (t.type) {\n248                 case Character: {\n249                     Token.Character c = t.asCharacter();\n250                     if (c.getData().equals(nullString)) {\n251                         // todo confirm that check\n252                         tb.error(this);\n253                         return false;\n254                     } else if (isWhitespace(c)) {\n255                         tb.reconstructFormattingElements();\n256                         tb.insert(c);\n257                     } else {\n258                         tb.reconstructFormattingElements();\n259                         tb.insert(c);\n260                         tb.framesetOk(false);\n261                     }\n262                     break;\n263                 }\n264                 case Comment: {\n265                     tb.insert(t.asComment());\n266                     break;\n267                 }\n268                 case Doctype: {\n269                     tb.error(this);\n270                     return false;\n271                 }\n272                 case StartTag:\n273                     Token.StartTag startTag = t.asStartTag();\n274                     String name = startTag.name();\n275                     if (name.equals(\"html\")) {\n276                         tb.error(this);\n277                         // merge attributes onto real html\n278                         Element html = tb.getStack().getFirst();\n279                         for (Attribute attribute : startTag.getAttributes()) {\n280                             if (!html.hasAttr(attribute.getKey()))\n281                                 html.attributes().put(attribute);\n282                         }\n283                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n284                         return tb.process(t, InHead);\n285                     } else if (name.equals(\"body\")) {\n286                         tb.error(this);\n287                         LinkedList<Element> stack = tb.getStack();\n288                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n289                             // only in fragment case\n290                             return false; // ignore\n291                         } else {\n292                             tb.framesetOk(false);\n293                             Element body = stack.get(1);\n294                             for (Attribute attribute : startTag.getAttributes()) {\n295                                 if (!body.hasAttr(attribute.getKey()))\n296                                     body.attributes().put(attribute);\n297                             }\n298                         }\n299                     } else if (name.equals(\"frameset\")) {\n300                         tb.error(this);\n301                         LinkedList<Element> stack = tb.getStack();\n302                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n303                             // only in fragment case\n304                             return false; // ignore\n305                         } else if (!tb.framesetOk()) {\n306                             return false; // ignore frameset\n307                         } else {\n308                             Element second = stack.get(1);\n309                             if (second.parent() != null)\n310                                 second.remove();\n311                             // pop up to html element\n312                             while (stack.size() > 1)\n313                                 stack.removeLast();\n314                             tb.insert(startTag);\n315                             tb.transition(InFrameset);\n316                         }\n317                     } else if (StringUtil.in(name,\n318                             \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n319                             \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n320                             \"p\", \"section\", \"summary\", \"ul\")) {\n321                         if (tb.inButtonScope(\"p\")) {\n322                             tb.process(new Token.EndTag(\"p\"));\n323                         }\n324                         tb.insert(startTag);\n325                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n326                         if (tb.inButtonScope(\"p\")) {\n327                             tb.process(new Token.EndTag(\"p\"));\n328                         }\n329                         if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n330                             tb.error(this);\n331                             tb.pop();\n332                         }\n333                         tb.insert(startTag);\n334                     } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n335                         if (tb.inButtonScope(\"p\")) {\n336                             tb.process(new Token.EndTag(\"p\"));\n337                         }\n338                         tb.insert(startTag);\n339                         // todo: ignore LF if next token\n340                         tb.framesetOk(false);\n341                     } else if (name.equals(\"form\")) {\n342                         if (tb.getFormElement() != null) {\n343                             tb.error(this);\n344                             return false;\n345                         }\n346                         if (tb.inButtonScope(\"p\")) {\n347                             tb.process(new Token.EndTag(\"p\"));\n348                         }\n349                         Element form = tb.insert(startTag);\n350                         tb.setFormElement(form);\n351                     } else if (name.equals(\"li\")) {\n352                         tb.framesetOk(false);\n353                         LinkedList<Element> stack = tb.getStack();\n354                         for (int i = stack.size() - 1; i > 0; i--) {\n355                             Element el = stack.get(i);\n356                             if (el.nodeName().equals(\"li\")) {\n357                                 tb.process(new Token.EndTag(\"li\"));\n358                                 break;\n359                             }\n360                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n361                                 break;\n362                         }\n363                         if (tb.inButtonScope(\"p\")) {\n364                             tb.process(new Token.EndTag(\"p\"));\n365                         }\n366                         tb.insert(startTag);\n367                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n368                         tb.framesetOk(false);\n369                         LinkedList<Element> stack = tb.getStack();\n370                         for (int i = stack.size() - 1; i > 0; i--) {\n371                             Element el = stack.get(i);\n372                             if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n373                                 tb.process(new Token.EndTag(el.nodeName()));\n374                                 break;\n375                             }\n376                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n377                                 break;\n378                         }\n379                         if (tb.inButtonScope(\"p\")) {\n380                             tb.process(new Token.EndTag(\"p\"));\n381                         }\n382                         tb.insert(startTag);\n383                     } else if (name.equals(\"plaintext\")) {\n384                         if (tb.inButtonScope(\"p\")) {\n385                             tb.process(new Token.EndTag(\"p\"));\n386                         }\n387                         tb.insert(startTag);\n388                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n389                     } else if (name.equals(\"button\")) {\n390                         if (tb.inButtonScope(\"button\")) {\n391                             // close and reprocess\n392                             tb.error(this);\n393                             tb.process(new Token.EndTag(\"button\"));\n394                             tb.process(startTag);\n395                         } else {\n396                             tb.reconstructFormattingElements();\n397                             tb.insert(startTag);\n398                             tb.framesetOk(false);\n399                         }\n400                     } else if (name.equals(\"a\")) {\n401                         if (tb.getActiveFormattingElement(\"a\") != null) {\n402                             tb.error(this);\n403                             tb.process(new Token.EndTag(\"a\"));\n404 \n405                             // still on stack?\n406                             Element remainingA = tb.getFromStack(\"a\");\n407                             if (remainingA != null) {\n408                                 tb.removeFromActiveFormattingElements(remainingA);\n409                                 tb.removeFromStack(remainingA);\n410                             }\n411                         }\n412                         tb.reconstructFormattingElements();\n413                         Element a = tb.insert(startTag);\n414                         tb.pushActiveFormattingElements(a);\n415                     } else if (StringUtil.in(name,\n416                             \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n417                         tb.reconstructFormattingElements();\n418                         Element el = tb.insert(startTag);\n419                         tb.pushActiveFormattingElements(el);\n420                     } else if (name.equals(\"nobr\")) {\n421                         tb.reconstructFormattingElements();\n422                         if (tb.inScope(\"nobr\")) {\n423                             tb.error(this);\n424                             tb.process(new Token.EndTag(\"nobr\"));\n425                             tb.reconstructFormattingElements();\n426                         }\n427                         Element el = tb.insert(startTag);\n428                         tb.pushActiveFormattingElements(el);\n429                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n430                         tb.reconstructFormattingElements();\n431                         tb.insert(startTag);\n432                         tb.insertMarkerToFormattingElements();\n433                         tb.framesetOk(false);\n434                     } else if (name.equals(\"table\")) {\n435                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n436                             tb.process(new Token.EndTag(\"p\"));\n437                         }\n438                         tb.insert(startTag);\n439                         tb.framesetOk(false);\n440                         tb.transition(InTable);\n441                     } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n442                         tb.reconstructFormattingElements();\n443                         tb.insertEmpty(startTag);\n444                         tb.framesetOk(false);\n445                     } else if (name.equals(\"input\")) {\n446                         tb.reconstructFormattingElements();\n447                         Element el = tb.insertEmpty(startTag);\n448                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n449                             tb.framesetOk(false);\n450                     } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n451                         tb.insertEmpty(startTag);\n452                     } else if (name.equals(\"hr\")) {\n453                         if (tb.inButtonScope(\"p\")) {\n454                             tb.process(new Token.EndTag(\"p\"));\n455                         }\n456                         tb.insertEmpty(startTag);\n457                         tb.framesetOk(false);\n458                     } else if (name.equals(\"image\")) {\n459                         // we're not supposed to ask.\n460                         startTag.name(\"img\");\n461                         return tb.process(startTag);\n462                     } else if (name.equals(\"isindex\")) {\n463                         // how much do we care about the early 90s?\n464                         tb.error(this);\n465                         if (tb.getFormElement() != null)\n466                             return false;\n467 \n468                         tb.tokeniser.acknowledgeSelfClosingFlag();\n469                         tb.process(new Token.StartTag(\"form\"));\n470                         if (startTag.attributes.hasKey(\"action\")) {\n471                             Element form = tb.getFormElement();\n472                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n473                         }\n474                         tb.process(new Token.StartTag(\"hr\"));\n475                         tb.process(new Token.StartTag(\"label\"));\n476                         // hope you like english.\n477                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n478                                 startTag.attributes.get(\"prompt\") :\n479                                 \"This is a searchable index. Enter search keywords: \";\n480 \n481                         tb.process(new Token.Character(prompt));\n482 \n483                         // input\n484                         Attributes inputAttribs = new Attributes();\n485                         for (Attribute attr : startTag.attributes) {\n486                             if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n487                                 inputAttribs.put(attr);\n488                         }\n489                         inputAttribs.put(\"name\", \"isindex\");\n490                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n491                         tb.process(new Token.EndTag(\"label\"));\n492                         tb.process(new Token.StartTag(\"hr\"));\n493                         tb.process(new Token.EndTag(\"form\"));\n494                     } else if (name.equals(\"textarea\")) {\n495                         tb.insert(startTag);\n496                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n497                         tb.tokeniser.transition(TokeniserState.Rcdata);\n498                         tb.markInsertionMode();\n499                         tb.framesetOk(false);\n500                         tb.transition(Text);\n501                     } else if (name.equals(\"xmp\")) {\n502                         if (tb.inButtonScope(\"p\")) {\n503                             tb.process(new Token.EndTag(\"p\"));\n504                         }\n505                         tb.reconstructFormattingElements();\n506                         tb.framesetOk(false);\n507                         handleRawtext(startTag, tb);\n508                     } else if (name.equals(\"iframe\")) {\n509                         tb.framesetOk(false);\n510                         handleRawtext(startTag, tb);\n511                     } else if (name.equals(\"noembed\")) {\n512                         // also handle noscript if script enabled\n513                         handleRawtext(startTag, tb);\n514                     } else if (name.equals(\"select\")) {\n515                         tb.reconstructFormattingElements();\n516                         tb.insert(startTag);\n517                         tb.framesetOk(false);\n518 \n519                         TreeBuilderState state = tb.state();\n520                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n521                             tb.transition(InSelectInTable);\n522                         else\n523                             tb.transition(InSelect);\n524                     } else if (StringUtil.in(\"optgroup\", \"option\")) {\n525                         if (tb.currentElement().nodeName().equals(\"option\"))\n526                             tb.process(new Token.EndTag(\"option\"));\n527                         tb.reconstructFormattingElements();\n528                         tb.insert(startTag);\n529                     } else if (StringUtil.in(\"rp\", \"rt\")) {\n530                         if (tb.inScope(\"ruby\")) {\n531                             tb.generateImpliedEndTags();\n532                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n533                                 tb.error(this);\n534                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n535                             }\n536                             tb.insert(startTag);\n537                         }\n538                     } else if (name.equals(\"math\")) {\n539                         tb.reconstructFormattingElements();\n540                         // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n541                         tb.insert(startTag);\n542                         tb.tokeniser.acknowledgeSelfClosingFlag();\n543                     } else if (name.equals(\"svg\")) {\n544                         tb.reconstructFormattingElements();\n545                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n546                         tb.insert(startTag);\n547                         tb.tokeniser.acknowledgeSelfClosingFlag();\n548                     } else if (StringUtil.in(name,\n549                             \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n550                         tb.error(this);\n551                         return false;\n552                     } else {\n553                         tb.reconstructFormattingElements();\n554                         tb.insert(startTag);\n555                     }\n556                     break;\n557 \n558                 case EndTag:\n559                     Token.EndTag endTag = t.asEndTag();\n560                     name = endTag.name();\n561                     if (name.equals(\"body\")) {\n562                         if (!tb.inScope(\"body\")) {\n563                             tb.error(this);\n564                             return false;\n565                         } else {\n566                             // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n567                             tb.transition(AfterBody);\n568                         }\n569                     } else if (name.equals(\"html\")) {\n570                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n571                         if (notIgnored)\n572                             return tb.process(endTag);\n573                     } else if (StringUtil.in(name,\n574                             \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n575                             \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n576                             \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n577                         // todo: refactor these lookups\n578                         if (!tb.inScope(name)) {\n579                             // nothing to close\n580                             tb.error(this);\n581                             return false;\n582                         } else {\n583                             tb.generateImpliedEndTags();\n584                             if (!tb.currentElement().nodeName().equals(name))\n585                                 tb.error(this);\n586                             tb.popStackToClose(name);\n587                         }\n588                     } else if (name.equals(\"form\")) {\n589                         Element currentForm = tb.getFormElement();\n590                         tb.setFormElement(null);\n591                         if (currentForm == null || !tb.inScope(name)) {\n592                             tb.error(this);\n593                             return false;\n594                         } else {\n595                             tb.generateImpliedEndTags();\n596                             if (!tb.currentElement().nodeName().equals(name))\n597                                 tb.error(this);\n598                             // remove currentForm from stack. will shift anything under up.\n599                             tb.removeFromStack(currentForm);\n600                         }\n601                     } else if (name.equals(\"p\")) {\n602                         if (!tb.inButtonScope(name)) {\n603                             tb.error(this);\n604                             tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n605                             return tb.process(endTag);\n606                         } else {\n607                             tb.generateImpliedEndTags(name);\n608                             if (!tb.currentElement().nodeName().equals(name))\n609                                 tb.error(this);\n610                             tb.popStackToClose(name);\n611                         }\n612                     } else if (name.equals(\"li\")) {\n613                         if (!tb.inListItemScope(name)) {\n614                             tb.error(this);\n615                             return false;\n616                         } else {\n617                             tb.generateImpliedEndTags(name);\n618                             if (!tb.currentElement().nodeName().equals(name))\n619                                 tb.error(this);\n620                             tb.popStackToClose(name);\n621                         }\n622                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n623                         if (!tb.inScope(name)) {\n624                             tb.error(this);\n625                             return false;\n626                         } else {\n627                             tb.generateImpliedEndTags(name);\n628                             if (!tb.currentElement().nodeName().equals(name))\n629                                 tb.error(this);\n630                             tb.popStackToClose(name);\n631                         }\n632                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n633                         if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n634                             tb.error(this);\n635                             return false;\n636                         } else {\n637                             tb.generateImpliedEndTags(name);\n638                             if (!tb.currentElement().nodeName().equals(name))\n639                                 tb.error(this);\n640                             tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n641                         }\n642                     } else if (name.equals(\"sarcasm\")) {\n643                         // *sigh*\n644                         return anyOtherEndTag(t, tb);\n645                     } else if (StringUtil.in(name,\n646                             \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n647                         // Adoption Agency Algorithm.\n648                         OUTER:\n649                         for (int i = 0; i < 8; i++) {\n650                             Element formatEl = tb.getActiveFormattingElement(name);\n651                             if (formatEl == null)\n652                                 return anyOtherEndTag(t, tb);\n653                             else if (!tb.onStack(formatEl)) {\n654                                 tb.error(this);\n655                                 tb.removeFromActiveFormattingElements(formatEl);\n656                                 return true;\n657                             } else if (!tb.inScope(formatEl.nodeName())) {\n658                                 tb.error(this);\n659                                 return false;\n660                             } else if (tb.currentElement() != formatEl)\n661                                 tb.error(this);\n662 \n663                             Element furthestBlock = null;\n664                             Element commonAncestor = null;\n665                             boolean seenFormattingElement = false;\n666                             LinkedList<Element> stack = tb.getStack();\n667                             for (int si = 0; si < stack.size(); si++) {\n668                                 Element el = stack.get(si);\n669                                 if (el == formatEl) {\n670                                     commonAncestor = stack.get(si - 1);\n671                                     seenFormattingElement = true;\n672                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n673                                     furthestBlock = el;\n674                                     break;\n675                                 }\n676                             }\n677                             if (furthestBlock == null) {\n678                                 tb.popStackToClose(formatEl.nodeName());\n679                                 tb.removeFromActiveFormattingElements(formatEl);\n680                                 return true;\n681                             }\n682 \n683                             // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n684                             // does that mean: int pos of format el in list?\n685                             Element node = furthestBlock;\n686                             Element lastNode = furthestBlock;\n687                             INNER:\n688                             for (int j = 0; j < 3; j++) {\n689                                 if (tb.onStack(node))\n690                                     node = tb.aboveOnStack(node);\n691                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n692                                     tb.removeFromStack(node);\n693                                     continue INNER;\n694                                 } else if (node == formatEl)\n695                                     break INNER;\n696 \n697                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n698                                 tb.replaceActiveFormattingElement(node, replacement);\n699                                 tb.replaceOnStack(node, replacement);\n700                                 node = replacement;\n701 \n702                                 if (lastNode == furthestBlock) {\n703                                     // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n704                                     // not getting how this bookmark both straddles the element above, but is inbetween here...\n705                                 }\n706                                 if (lastNode.parent() != null)\n707                                     lastNode.remove();\n708                                 node.appendChild(lastNode);\n709 \n710                                 lastNode = node;\n711                             }\n712 \n713                             if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n714                                 if (lastNode.parent() != null)\n715                                     lastNode.remove();\n716                                 tb.insertInFosterParent(lastNode);\n717                             } else {\n718                                 if (lastNode.parent() != null)\n719                                     lastNode.remove();\n720                                 commonAncestor.appendChild(lastNode);\n721                             }\n722 \n723                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n724                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n725                             for (Node childNode : childNodes) {\n726                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n727                             }\n728                             furthestBlock.appendChild(adopter);\n729                             tb.removeFromActiveFormattingElements(formatEl);\n730                             // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n731                             tb.removeFromStack(formatEl);\n732                             tb.insertOnStackAfter(furthestBlock, adopter);\n733                         }\n734                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n735                         if (!tb.inScope(\"name\")) {\n736                             if (!tb.inScope(name)) {\n737                                 tb.error(this);\n738                                 return false;\n739                             }\n740                             tb.generateImpliedEndTags();\n741                             if (!tb.currentElement().nodeName().equals(name))\n742                                 tb.error(this);\n743                             tb.popStackToClose(name);\n744                             tb.clearFormattingElementsToLastMarker();\n745                         }\n746                     } else if (name.equals(\"br\")) {\n747                         tb.error(this);\n748                         tb.process(new Token.StartTag(\"br\"));\n749                         return false;\n750                     } else {\n751                         return anyOtherEndTag(t, tb);\n752                     }\n753 \n754                     break;\n755                 case EOF:\n756                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n757                     // stop parsing\n758                     break;\n759             }\n760             return true;\n761         }", "bm_classpath": "org.jsoup.parser.TreeBuilderState"}, {"bug_name": "Jsoup_16", "report_text": "> DocumentType.outerHtmlHead missing quote\n> \n> There's just a doublequote missing from the append sequence right before the systemId.\n> For example:", "test_name": "org.jsoup.nodes.DocumentTypeTest::outerHtmlGeneration", "test_method": "    @Test public void outerHtmlGeneration() {\n        DocumentType html5 = new DocumentType(\"html\", \"\", \"\", \"\");\n\n        DocumentType publicDocType = new DocumentType(\"html\", \"-//IETF//DTD HTML//\", \"\", \"\");\n\n        DocumentType systemDocType = new DocumentType(\"html\", \"\", \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\", \"\");\n        assertEquals(\"<!DOCTYPE html \\\"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\\\">\", systemDocType.outerHtml()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<!DOCTYPE html [\"]http://www.ibm.com/d...> but was:<<!DOCTYPE html []http://www.ibm.com/d...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.DocumentTypeTest.outerHtmlGeneration(DocumentTypeTest.java:36)", "buggy_method": "18 public DocumentType(String name, String publicId, String systemId, String baseUri) {\n19         super(baseUri);\n20 \n21         attr(\"name\", name);\n22         attr(\"publicId\", publicId);\n23         attr(\"systemId\", systemId);\n24     }", "bm_classpath": "org.jsoup.nodes.DocumentType"}, {"bug_name": "Jsoup_18", "report_text": "> outerHtml method returns extra attribute when element definition has new line\n> \n> I think this is a bug.\n> Version: jsoup-1.6.0.jar\n> Source:  \n> ---------BEGIN  \n> <img alt=\"\"\n> ```\n>          src=\"/imagelibraries/homepagebanners/british_10k_2010.jpg\" />\n> ```\n> ---------END  \n> Steps to reproduce: element.outerHtml() ->\n> Expected result: two attributes alt and src  \n> Observed result output  \n> ----------BEGIN  \n> <img alt=\"\" =\"\" src=\"/imagelibraries/homepagebanners/british\\_10k\\_2010.jpg\" />  \n> ----------END", "test_name": "org.jsoup.parser.CharacterReaderTest::handleCarriageReturnAsLineFeed", "test_method": "    @Test public void handleCarriageReturnAsLineFeed() {\n        String in = \"one \\r two \\r\\n three\";\n        CharacterReader r = new CharacterReader(in);\n\n        String first = r.consumeTo('\\n');\n        assertEquals(\"one \", first); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<one []> but was:<one [\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.CharacterReaderTest.handleCarriageReturnAsLineFeed(CharacterReaderTest.java:69)", "buggy_method": "16 CharacterReader(String input) {\n17         Validate.notNull(input);\n18 \n19         this.input = input;\n20         this.length = input.length();\n21     }", "bm_classpath": "org.jsoup.parser.CharacterReader"}, {"bug_name": "Jsoup_19", "report_text": "> Cleaning html containing the cid identifier breaks images\n> \n> Ok, so in mail type HTML the following is common\n> ![]()\n> The item after CID: can be almost anything (US-ASCII I think) and of any length. It corresponds to an image linked elsewhere in MIME say like this\n> --mimebounday  \n> Content-ID:  \n> Content-Type: image/jpeg.....  \n> (snip)\n> So, to mark a long story somewhat shorter, I use Jsoup's sanitizer extensively. However, I need these CID references to be preserved post sanitization. addProtocols does not work because the items are not valid URLs. As a result  \n> the above becomes ![](). Which for my purposes is not good :)", "test_name": "org.jsoup.safety.CleanerTest::handlesCustomProtocols", "test_method": "    @Test public void handlesCustomProtocols() {\n        String html = \"<img src='cid:12345' /> <img src='data:gzzt' />\";\n        String dropped = Jsoup.clean(html, Whitelist.basicWithImages());\n\n        String preserved = Jsoup.clean(html, Whitelist.basicWithImages().addProtocols(\"img\", \"src\", \"cid\", \"data\"));\n        assertEquals(\"<img src=\\\"cid:12345\\\" /> \\n<img src=\\\"data:gzzt\\\" />\", preserved); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<img [src=\"cid:12345\" />\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.safety.CleanerTest.handlesCustomProtocols(CleanerTest.java:123)", "buggy_method": "338 private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n339         // try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n340         // rels without a baseuri get removed\n341         String value = el.absUrl(attr.getKey());\n342         if (!preserveRelativeLinks)\n343             attr.setValue(value);\n344         \n345         for (Protocol protocol : protocols) {\n346             String prot = protocol.toString() + \":\";\n347             if (value.toLowerCase().startsWith(prot)) {\n348                 return true;\n349             }\n350         }\n351         return false;\n352     }", "bm_classpath": "org.jsoup.safety.Whitelist"}, {"bug_name": "Jsoup_20", "report_text": "> Some html file's head element will be empty\n> \n> Hello, Jonathan\n> I love Jsoup, and handling many html files.\n> But today, I'm under the problem.  \n> When parse with Jsoup, some html file's head element will be empty.\n> Sample html is here -> <http://dl.dropbox.com/u/972460/test.html>\n> Please help me.", "test_name": "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMark", "test_method": "    @Test public void discardsSpuriousByteOrderMark() {\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n        Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n        assertEquals(\"One\", doc.head().text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[One]> but was:<[]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.DataUtilTest.discardsSpuriousByteOrderMark(DataUtilTest.java:32)", "buggy_method": "73 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n74         String docData;\n75         Document doc = null;\n76         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n77             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n78             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n79             doc = parser.parseInput(docData, baseUri);\n80             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n81             if (meta != null) { // if not found, will keep utf-8 as best attempt\n82                 String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n83                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n84                     charsetName = foundCharset;\n85                     byteData.rewind();\n86                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n87                     doc = null;\n88                 }\n89             }\n90         } else { // specified by content type header (or by user on file load)\n91             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n92             docData = Charset.forName(charsetName).decode(byteData).toString();\n93         }\n94         if (doc == null) {\n95             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n96             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n97             // into head mode\n98 \n99             doc = parser.parseInput(docData, baseUri);\n100             doc.outputSettings().charset(charsetName);\n101         }\n102         return doc;\n103     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_22", "report_text": "> siblingElements in Element throws Null Pointer Exception\n> \n> Hi,\n> I have noticed that the sibling methods (nextSibling, previousSibling, siblingElements) rely on an element (underlying node) having a parent. If the node does not have a parent it throws null pointer exception.\n> Would it be possible to modify the code so that it checks for parent nullness around Node.java:468?\n> In the event of nullness return null as in the javadoc?\n> Confirmed in 1.6.2", "test_name": "org.jsoup.nodes.ElementTest::elementIsNotASiblingOfItself", "test_method": "    @Test public void elementIsNotASiblingOfItself() {\n        Document doc = Jsoup.parse(\"<div><p>One<p>Two<p>Three</div>\");\n        Element p2 = doc.select(\"p\").get(1);\n\n        Elements els = p2.siblingElements();\n        assertEquals(2, els.size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2> but was:<3>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.jsoup.nodes.ElementTest.elementIsNotASiblingOfItself(ElementTest.java:538)", "buggy_method": "433 public Elements siblingElements() {\n434 \n435         return parent().children();\n436     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_24", "report_text": "> 1.6.0 dropping a ' on a particular javascript string\n> \n> Loses a single quote when the javascript contains a partial tag, exampled pared from ad section of <http://scienceblogs.com/pharyngula>. Note in the result that '</scr is missing closing ' :\n> Input:\n> ```\n> <HTML>\n> <body>\n>  <div>\n>   <script language=\"JavaScript1.1\"> \n>     document.write('</scr' + 'ipt>');\n>   </script>\n>  </div>\n> </body>\n> </HTML>\n> ```\n> Result:\n> ```\n> <html>\n>  <body> \n>   <div> \n>    <script language=\"JavaScript1.1\"> \n>     document.write('</scr + 'ipt>');\n>   \n>    </script> \n>   </div>  \n>  </body>\n> </html>\n> ```", "test_name": "org.jsoup.parser.HtmlParserTest::handlesQuotesInCommentsInScripts", "test_method": "    @Test public void handlesQuotesInCommentsInScripts() {\n        String html = \"<script>\\n\" +\n                \"  <!--\\n\" +\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n                \"  // -->\\n\" +\n                \"</script>\";\n        Document node = Jsoup.parseBodyFragment(html);\n        assertEquals(\"<script>\\n\" +\n                \"  <!--\\n\" +\n                \"    document.write('</scr' + 'ipt>');\\n\" +\n                \"  // -->\\n\" +\n                \"</script>\", node.body().html()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...ocument.write('</scr['] + 'ipt>');\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.handlesQuotesInCommentsInScripts(HtmlParserTest.java:690)", "buggy_method": "553 void read(Tokeniser t, CharacterReader r) {\n554             if (r.matchesLetter()) {\n555                 String name = r.consumeLetterSequence();\n556                 t.tagPending.appendTagName(name.toLowerCase());\n557                 t.dataBuffer.append(name);\n558                 r.advance();\n559                 return;\n560             }\n561 \n562             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n563                 char c = r.consume();\n564                 switch (c) {\n565                     case '\\t':\n566                     case '\\n':\n567                     case '\\f':\n568                     case ' ':\n569                         t.transition(BeforeAttributeName);\n570                         break;\n571                     case '/':\n572                         t.transition(SelfClosingStartTag);\n573                         break;\n574                     case '>':\n575                         t.emitTagPending();\n576                         t.transition(Data);\n577                         break;\n578                     default:\n579                         t.dataBuffer.append(c);\n580                         anythingElse(t, r);\n581                         break;\n582                 }\n583             } else {\n584                 anythingElse(t, r);\n585             }\n586         }", "bm_classpath": "org.jsoup.parser.TokeniserState"}, {"bug_name": "Jsoup_26", "report_text": "> NullpointerException when applying Cleaner to a frameset\n> \n> To reproduce:\n> 1. Create/find a html document of a frameset.\n> 2. Parse the html.\n> 3. Create a Cleaner instance and call the clean method with the document from step 2.\n> 4. NullPointerException\n> Cause:  \n> In Cleaner.clean(Document) (<https://github.com/jhy/jsoup/blob/master/src/main/java/org/jsoup/safety/Cleaner.java#L43>) the copySafeNodes is called with the document.body(). However, this is null when handling a frameset document.\n> Expected:  \n> An empty document or perhaps null returned. But not a nullpointerException.", "test_name": "org.jsoup.safety.CleanerTest::handlesFramesets", "test_method": "    @Test public void handlesFramesets() {\n        String dirty = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\";\n        String clean = Jsoup.clean(dirty, Whitelist.basic());\n\n        Document dirtyDoc = Jsoup.parse(dirty);\n        Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:73)\n\torg.jsoup.safety.Cleaner.clean(Cleaner.java:43)\n\torg.jsoup.safety.CleanerTest.handlesFramesets(CleanerTest.java:176)", "buggy_method": "39 public Document clean(Document dirtyDocument) {\n40         Validate.notNull(dirtyDocument);\n41 \n42         Document clean = Document.createShell(dirtyDocument.baseUri());\n43             copySafeNodes(dirtyDocument.body(), clean.body());\n44 \n45         return clean;\n46     }", "bm_classpath": "org.jsoup.safety.Cleaner"}, {"bug_name": "Jsoup_27", "report_text": "> Invalid HTTP-Response header leads to exception\n> \n> In particular case a HTTP-Webpage responses with a invalid HTTP-Charset field (delivered UFT8 instead of UTF8).  \n> This leads to an UnsupportedCharsetException in org.jsoup.helper.DataUtil at around Line 93(?) where :\n> ```\n>   Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n>   docData = Charset.forName(charsetName).decode(byteData).toString();\n> ```\n> I fixed it by wrapping a try catch statement around these two lines such that:\n> ```\n> try{\n>   Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n>   docData = Charset.forName(charsetName).decode(byteData).toString();\n> } catch(UnsupportedCharsetException e){\n>   return parseByteData(byteData,(String)null,baseUri,parser);\n> }\n> ```\n> It now falls back to the none charset argument assigned clause, and tries to detect the character set via HTML.", "test_name": "org.jsoup.helper.DataUtilTest::testCharset", "test_method": "    @Test\n    public void testCharset() {\n        assertEquals(\"utf-8\", DataUtil.getCharsetFromContentType(\"text/html;charset=utf-8 \")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[utf]-8> but was:<[UTF]-8>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.DataUtilTest.testCharset(DataUtilTest.java:15)", "buggy_method": "127 static String getCharsetFromContentType(String contentType) {\n128         if (contentType == null) return null;\n129         Matcher m = charsetPattern.matcher(contentType);\n130         if (m.find()) {\n131             String charset = m.group(1).trim();\n132             charset = charset.toUpperCase(Locale.ENGLISH);\n133             return charset;\n134         }\n135         return null;\n136     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_28", "report_text": "> Jsoup.parse unescapes query params in plain text URL's\n> \n> I'm trying to clean the HTML snippet below, but unfortunately the URL parameter names have been mistaken for HTML entities and unescaped to HTML.\n> ```\n>     <a href=\"http://www.foo.com?a=1&num\\_rooms=1&children=0&int=VA&b=2\">\n>         http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2\n>     </a>\n> ```\n> Cleaned HTML: [http://www.foo.com?a=1#\\_rooms=1\u03c7ldren=0\u222b=VA&amp;b=2](http://www.foo.com?a=1#_rooms=1%CF%87ldren=0%E2%88%AB=VA&amp;b=2)  \n> Expected HTML: <http://www.foo.com?a=1&num_rooms=1&children=0&int=VA&b=2>\n> Unit tests...\n> ```\n>     private static final String URL = \"http://www.foo.com?a=1&num\\_rooms=1&children=0&int=VA&b=2\";\n>     /\\*\\*\n>  \\* Passes\n>  \\*/\n>     @Test\n>     public void testStringEscapeUtilsUnescapeHtml() throws Exception {\n>         // org.apache.commons.lang.StringEscapeUtils;\n>         assertEquals(URL, StringEscapeUtils.unescapeHtml(URL));\n>     }\n>     /\\*\\*\n>  \\* Fails: unescapes &num, &chi, and &int to #, \u03c7, and \u222b respectively\n>  \\* Expected :http://www.foo.com?a=1&num\\_rooms=1&children=0&int=VA&b=2\n>  \\* Actual :http://www.foo.com?a=1#\\_rooms=1\u03c7ldren=0\u222b=VA&amp;b=2\n>  \\*/\n>     @Test\n>     public void testJsoupClean() throws Exception {\n>         String html = \"<a href=\\\"\" + URL + \"\\\">\" + URL + \"</a>\";\n>         assertEquals(URL, Jsoup.clean(html, Whitelist.none()));\n>     }\n>     /\\*\\*\n>  \\* Fails: unescapes &num, &chi, and &int to #, \u03c7, and \u222b respectively\n>  \\* Expected :http://www.foo.com?a=1&num\\_rooms=1&children=0&int=VA&b=2\n>  \\* Actual :http://www.foo.com?a=1#\\_rooms=1&children=0\u222b=VA&b=2\n>  \\*/\n>     @Test\n>     public void testJsoupTextNodeCreateFromEncoded() throws Exception {\n>         assertEquals(URL, TextNode.createFromEncoded(URL, null).text());\n>     }\n> ```", "test_name": "org.jsoup.nodes.EntitiesTest::unescape", "test_method": "    @Test public void unescape() {\n        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Hello &<> \u00ae \u00c5 [&angst] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...> but was:<Hello &<> \u00ae \u00c5 [\u00c5] \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 ...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.EntitiesTest.unescape(EntitiesTest.java:27)", "buggy_method": "102 static String unescape(String string, boolean strict) {\n103         if (!string.contains(\"&\"))\n104             return string;\n105         Matcher m = strict? strictUnescapePattern.matcher(string) : unescapePattern.matcher(string);\n106         StringBuffer accum = new StringBuffer(string.length());\n107         while (m.find()) {\n108             int charval = -1;\n109             String num = m.group(3);\n110             if (num != null) {\n111                 try {\n112                     int base = m.group(2) != null ? 16 : 10;\n113                     charval = Integer.valueOf(num, base);\n114                 } catch (NumberFormatException e) {\n115                 }\n116             } else {\n117                 String name = m.group(1);\n118                 if (full.containsKey(name))\n119                     charval = full.get(name);\n120             }\n121             if (charval != -1 || charval > 0xFFFF) {\n122                 String c = Character.toString((char) charval);\n123                 m.appendReplacement(accum, Matcher.quoteReplacement(c));\n124             } else {\n125                 m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n126             }\n127         }\n128         m.appendTail(accum);\n129         return accum.toString();\n130     }", "bm_classpath": "org.jsoup.nodes.Entities"}, {"bug_name": "Jsoup_29", "report_text": "> '\\n' and redundant space char is not needed from title\n> \n> We assume that we just need 1 line title string from below uri.  \n> <http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/nimbus.html>\n> we can see title like as below by viewing page source code in that page (of course, It is real situation.)\n> ```\n> <title>Nimbus Look and Feel (The Java\u2122 Tutorials >        \n>             Creating a GUI With JFC/Swing > Modifying the Look and Feel)\n> </title>\n> ```\n> maybe some another page has multiline title, but browser will shows ordinarily.  \n> in the other words, Browser shows one line title without CR/LF and redundant space character  \n> whether string has newline character or many redundant space or tab, or not.\n> But,  \n> When we execute Jsoup.connect(uri).get().title(); after we assign  \n> \"<http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/nimbus.html>\" into uri variable as String,  \n> it gives two lines like below,\n> \"Nimbus Look and Feel (The Java\u2122 Tutorials > \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"  \n> \"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Creating a GUI With JFC/Swing > Modifying the Look and Feel)\"\n> \"Nimbus Look and Feel (The Java\u2122 Tutorials > Creating a GUI With JFC/Swing > Modifying the Look and Feel)\"  \n> is better, I think.\n> Humm ... do you have another idea?", "test_name": "org.jsoup.nodes.DocumentTest::testTitles", "test_method": "    @Test public void testTitles() {\n        Document noTitle = Jsoup.parse(\"<p>Hello</p>\");\n        Document withTitle = Jsoup.parse(\"<title>First</title><title>Ignore</title><p>Hello</p>\");\n        \n        noTitle.title(\"Hello\");\n        \n        withTitle.title(\"Hello\");\n\n        Document normaliseTitle = Jsoup.parse(\"<title>   Hello\\nthere   \\n   now   \\n\");\n        assertEquals(\"Hello there now\", normaliseTitle.title()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Hello[ there] now> but was:<Hello[\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.DocumentTest.testTitles(DocumentTest.java:37)", "buggy_method": "66 public String title() {\n67         // title is a preserve whitespace tag (for document output), but normalised here\n68         Element titleEl = getElementsByTag(\"title\").first();\n69         return titleEl != null ? titleEl.text().trim() : \"\";\n70     }", "bm_classpath": "org.jsoup.nodes.Document"}, {"bug_name": "Jsoup_30", "report_text": "> Jsoup.clean sometimes will throw execution exception:java.lang.StackOverflowError\n> \n> [ ERROR ] throw execution exception:java.lang.StackOverflowError  \n> java.util.concurrent.ExecutionException: java.lang.StackOverflowError  \n> Caused by: java.lang.StackOverflowError  \n> at org.jsoup.safety.Whitelist.isSafeTag(Whitelist.java:323)  \n> at org.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:115)  \n> at org.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:127)  \n> at org.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:127)  \n> at org.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:127)  \n> at org.jsoup.safety.Cleaner.copySafeNodes(Cleaner.java:127)\n> clean the url:<http://blog.sina.com.cn/s/blog_501a5b1f0102dx6z.html>\n> It's have to much **wbr** tags,when i search the page source ,found 24205.\n> i look at org.jsoup.safety.Cleaner source code and add code like this\n> ```\n> private int num = 1;\n>     /\\*\\*\n>  \\* Iterates the input and copies trusted nodes (tags, attributes, text) into\n>  \\* the destination.\n>  \\* \n>  \\* @param source\n>  \\* source of HTML\n>  \\* @param dest\n>  \\* destination element to copy into\n>  \\* @return number of discarded elements (that were considered unsafe)\n>  \\*/\n>     private int copySafeNodes(Element source, Element dest) {\n>         List<Node> sourceChildren = source.childNodes();\n>         int numDiscarded = 0;\n>         for (Node sourceChild : sourceChildren) {\n>             num++;\n>             logger.info(num);\n>             if (num > 2000) {\n>                 //break this tag.\n>                 break;\n>             }\n>             if (sourceChild instanceof Element) {\n>                 Element sourceEl = (Element) sourceChild;\n>                 if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone\n>                                                                 // and copy safe\n>                                                                 // attrs\n>                     ElementMeta meta = createSafeElement(sourceEl);\n>                     Element destChild = meta.el;\n>                     dest.appendChild(destChild);\n>                     numDiscarded += meta.numAttribsDiscarded;\n>                     numDiscarded += copySafeNodes(sourceEl, destChild); // recurs\n>                 } else { // not a safe tag, but it may have children (els or\n>                             // text) that are, so recurse\n>                     numDiscarded++;\n>                     numDiscarded += copySafeNodes(sourceEl, dest);\n>                 }\n>             } else if (sourceChild instanceof TextNode) {\n>                 TextNode sourceText = (TextNode) sourceChild;\n>                 TextNode destText = new TextNode(sourceText.getWholeText(),\n>                         sourceChild.baseUri());\n>                 dest.appendChild(destText);\n>             } // else, we don't care about comments, xml proc instructions, etc\n>         }\n>         return numDiscarded;\n>     }\n> ```\n> but the clean result will be wrong and The layout will be chaos.\n> How can I solve this problem?", "test_name": "org.jsoup.safety.CleanerTest::testIsValid", "test_method": "    @Test public void testIsValid() {\n        String ok = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\";\n        String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n        String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n        String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n        assertFalse(Jsoup.isValid(nok3, Whitelist.basic())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertFalse(Assert.java:64)\n\torg.junit.Assert.assertFalse(Assert.java:74)\n\torg.jsoup.safety.CleanerTest.testIsValid(CleanerTest.java:99)", "buggy_method": "70 private int copySafeNodes(Element root, Element destination) {\n71         List<Node> sourceChildren = root.childNodes();\n72         int numDiscarded = 0;\n73 \n74         for (Node source : sourceChildren) {\n75             if (source instanceof Element) {\n76                 Element sourceEl = (Element) source;\n77 \n78                 if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs\n79                     ElementMeta meta = createSafeElement(sourceEl);\n80                     Element destChild = meta.el;\n81                     destination.appendChild(destChild);\n82 \n83                     numDiscarded += meta.numAttribsDiscarded;\n84                     numDiscarded += copySafeNodes(sourceEl, destChild);\n85                 } else {\n86                     numDiscarded++;\n87                     numDiscarded += copySafeNodes(sourceEl, destination);\n88                 }\n89             } else if (source instanceof TextNode) {\n90                 TextNode sourceText = (TextNode) source;\n91                 TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n92                 destination.appendChild(destText);\n93             }\n94         }\n95         return numDiscarded;\n96 \n97 \n98     }", "bm_classpath": "org.jsoup.safety.Cleaner"}, {"bug_name": "Jsoup_32", "report_text": "> Element.clone() wrongly shared a same classNames Set instance\n> \n> In the clone() method of Node, the Object.clone() is called, if the original element's classNames Set had been initialized before clone, the original classNames Set will be set to the new cloned Element instance due to the JDK's clone mechanism. Thus, the old element and the newly cloned Element will share a same classNames Set instance.", "test_name": "org.jsoup.nodes.ElementTest::testClonesClassnames", "test_method": "    @Test public void testClonesClassnames() {\n        Document doc = Jsoup.parse(\"<div class='one two'></div>\");\n        Element div = doc.select(\"div\").first();\n        Set<String> classes = div.classNames();\n\n        Element copy = div.clone();\n        Set<String> copyClasses = copy.classNames();\n        copyClasses.add(\"three\");\n        copyClasses.remove(\"one\");\n\n        assertTrue(classes.contains(\"one\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.nodes.ElementTest.testClonesClassnames(ElementTest.java:493)", "buggy_method": "1135 @Override\n1136     public Element clone() {\n1137         Element clone = (Element) super.clone();\n1138         clone.classNames();\n1139         return clone;\n1140     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_33", "report_text": "> Self-closing script tag causes remainder of document to be html-escaped.\n> \n> When a self-closing script block is encountered it appears that the state transitions do not account for the closing tag, so the rest of the document is considered to be in the body of the script tag, and so is escaped.\n> The unit test HtmlParserTest.handlesKnownEmptyBlocks() will fail if a self-closing script tag is included in the String h.", "test_name": "org.jsoup.parser.HtmlParserTest::handlesKnownEmptyBlocks", "test_method": "    @Test public void handlesKnownEmptyBlocks() {\n        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n        String h = \"<div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<div id=\\\"1\\\"></div><script src=\\\"/foo\\\"></script><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...src=\"/foo\"></script>[<div id=\"2\"><img /><img /></div><a id=\"3\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr />] hr text two> but was:<...src=\"/foo\"></script>[&lt;div id=2&gt;&lt;img /&gt;&lt;img&gt;&lt;/div&gt;&lt;a id=3 /&gt;&lt;i /&gt;&lt;foo /&gt;&lt;foo&gt;One&lt;/foo&gt; &lt;hr /&gt; hr text &lt;hr&gt;] hr text two>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.handlesKnownEmptyBlocks(HtmlParserTest.java:331)", "buggy_method": "156 Element insert(Token.StartTag startTag) {\n157         // handle empty unknown tags\n158         // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n159         if (startTag.isSelfClosing()) {\n160             Element el = insertEmpty(startTag);\n161             stack.add(el);\n162             tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n163             return el;\n164         }\n165         \n166         Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n167         insert(el);\n168         return el;\n169     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_34", "report_text": "> Parser error on commented CDATA\n> \n> Jsoup gives the following error when trying to parse this HTML: <https://gist.github.com/felipehummel/6122799>\n> ```\n> java.lang.ArrayIndexOutOfBoundsException: 8666\n>     at org.jsoup.parser.CharacterReader.nextIndexOf(CharacterReader.java:92)\n>     at org.jsoup.parser.CharacterReader.consumeTo(CharacterReader.java:112)\n>     at org.jsoup.parser.TokeniserState$67.read(TokeniserState.java:1789)\n>     at org.jsoup.parser.Tokeniser.read(Tokeniser.java:42)\n>     at org.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:47)\n>     at org.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:41)\n>     at org.jsoup.parser.HtmlTreeBuilder.parse(HtmlTreeBuilder.java:37)\n>     at org.jsoup.parser.Parser.parse(Parser.java:90)\n>     at org.jsoup.Jsoup.parse(Jsoup.java:58)\n> ...\n> ```\n> The HTML is from a entry in a RSS feed. If I remove the line:\n> ```\n> // ]]\n> ```\n> or just the  \n> ]]\n> Then it parses the HTML nicely.\n> Does this syntax error should really throw an exception or it should be silently ignored?", "test_name": "org.jsoup.parser.CharacterReaderTest::nextIndexOfUnmatched", "test_method": "    @Test public void nextIndexOfUnmatched() {\n        CharacterReader r = new CharacterReader(\"<[[one]]\");\n        assertEquals(-1, r.nextIndexOf(\"]]>\")); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 8\n\torg.jsoup.parser.CharacterReader.nextIndexOf(CharacterReader.java:92)\n\torg.jsoup.parser.CharacterReaderTest.nextIndexOfUnmatched(CharacterReaderTest.java:100)", "buggy_method": "82 int nextIndexOf(CharSequence seq) {\n83         // doesn't handle scanning for surrogates\n84         char startChar = seq.charAt(0);\n85         for (int offset = pos; offset < length; offset++) {\n86             // scan to first instance of startchar:\n87             if (startChar != input[offset])\n88                 while(++offset < length && startChar != input[offset]);\n89             int i = offset + 1;\n90             int last = i + seq.length()-1;\n91             if (offset < length) {\n92                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n93                 if (i == last) // found full sequence\n94                     return offset - pos;\n95             }\n96         }\n97         return -1;\n98     }", "bm_classpath": "org.jsoup.parser.CharacterReader"}, {"bug_name": "Jsoup_35", "report_text": "> JSoup parsing unclosed tags\n> \n> Using JSoup inclusive the last release 1.7.2 there is a bug parsing HTML with unclosed tags.\n> Example:\n> ```\n> String tmp = \"<a href='www.google.com'>Link<p>Error link</a>\";\n> Jsoup.parse(tmp);\n> ```\n> The Document that generate is:\n> ```\n> <html>\n>  <head></head>\n>  <body>\n>   <a href=\"www.google.com\">Link</a>\n>   <p><a>Error link</a></p>\n>  </body>\n> </html>\n> ```\n> The browsers would generate something as:\n> ```\n> <html>\n>  <head></head>\n>  <body>\n>   <a href=\"www.google.com\">Link</a>\n>   <p><a href=\"www.google.com\">Error link</a></p>\n>  </body>\n> </html>\n> ```\n> Jsoup should works as browsers or as source code.\n> Also there is a question on stackoverflow:  \n> <http://stackoverflow.com/questions/15813821/jsoup-parsing-unclosed-tags>", "test_name": "org.jsoup.parser.HtmlParserTest::handlesUnclosedAnchors", "test_method": "    @Test public void handlesUnclosedAnchors() {\n        String h = \"<a href='http://example.com/'>Link<p>Error link</a>\";\n        Document doc = Jsoup.parse(h);\n        String want = \"<a href=\\\"http://example.com/\\\">Link</a>\\n<p><a href=\\\"http://example.com/\\\">Error link</a></p>\";\n        assertEquals(want, doc.body().html()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...com/\">Link</a>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.handlesUnclosedAnchors(HtmlParserTest.java:529)", "buggy_method": "247 boolean process(Token t, HtmlTreeBuilder tb) {\n248             switch (t.type) {\n249                 case Character: {\n250                     Token.Character c = t.asCharacter();\n251                     if (c.getData().equals(nullString)) {\n252                         // todo confirm that check\n253                         tb.error(this);\n254                         return false;\n255                     } else if (isWhitespace(c)) {\n256                         tb.reconstructFormattingElements();\n257                         tb.insert(c);\n258                     } else {\n259                         tb.reconstructFormattingElements();\n260                         tb.insert(c);\n261                         tb.framesetOk(false);\n262                     }\n263                     break;\n264                 }\n265                 case Comment: {\n266                     tb.insert(t.asComment());\n267                     break;\n268                 }\n269                 case Doctype: {\n270                     tb.error(this);\n271                     return false;\n272                 }\n273                 case StartTag:\n274                     Token.StartTag startTag = t.asStartTag();\n275                     String name = startTag.name();\n276                     if (name.equals(\"html\")) {\n277                         tb.error(this);\n278                         // merge attributes onto real html\n279                         Element html = tb.getStack().getFirst();\n280                         for (Attribute attribute : startTag.getAttributes()) {\n281                             if (!html.hasAttr(attribute.getKey()))\n282                                 html.attributes().put(attribute);\n283                         }\n284                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n285                         return tb.process(t, InHead);\n286                     } else if (name.equals(\"body\")) {\n287                         tb.error(this);\n288                         LinkedList<Element> stack = tb.getStack();\n289                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n290                             // only in fragment case\n291                             return false; // ignore\n292                         } else {\n293                             tb.framesetOk(false);\n294                             Element body = stack.get(1);\n295                             for (Attribute attribute : startTag.getAttributes()) {\n296                                 if (!body.hasAttr(attribute.getKey()))\n297                                     body.attributes().put(attribute);\n298                             }\n299                         }\n300                     } else if (name.equals(\"frameset\")) {\n301                         tb.error(this);\n302                         LinkedList<Element> stack = tb.getStack();\n303                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n304                             // only in fragment case\n305                             return false; // ignore\n306                         } else if (!tb.framesetOk()) {\n307                             return false; // ignore frameset\n308                         } else {\n309                             Element second = stack.get(1);\n310                             if (second.parent() != null)\n311                                 second.remove();\n312                             // pop up to html element\n313                             while (stack.size() > 1)\n314                                 stack.removeLast();\n315                             tb.insert(startTag);\n316                             tb.transition(InFrameset);\n317                         }\n318                     } else if (StringUtil.in(name,\n319                             \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n320                             \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n321                             \"p\", \"section\", \"summary\", \"ul\")) {\n322                         if (tb.inButtonScope(\"p\")) {\n323                             tb.process(new Token.EndTag(\"p\"));\n324                         }\n325                         tb.insert(startTag);\n326                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n327                         if (tb.inButtonScope(\"p\")) {\n328                             tb.process(new Token.EndTag(\"p\"));\n329                         }\n330                         if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n331                             tb.error(this);\n332                             tb.pop();\n333                         }\n334                         tb.insert(startTag);\n335                     } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n336                         if (tb.inButtonScope(\"p\")) {\n337                             tb.process(new Token.EndTag(\"p\"));\n338                         }\n339                         tb.insert(startTag);\n340                         // todo: ignore LF if next token\n341                         tb.framesetOk(false);\n342                     } else if (name.equals(\"form\")) {\n343                         if (tb.getFormElement() != null) {\n344                             tb.error(this);\n345                             return false;\n346                         }\n347                         if (tb.inButtonScope(\"p\")) {\n348                             tb.process(new Token.EndTag(\"p\"));\n349                         }\n350                         tb.insertForm(startTag, true);\n351                     } else if (name.equals(\"li\")) {\n352                         tb.framesetOk(false);\n353                         LinkedList<Element> stack = tb.getStack();\n354                         for (int i = stack.size() - 1; i > 0; i--) {\n355                             Element el = stack.get(i);\n356                             if (el.nodeName().equals(\"li\")) {\n357                                 tb.process(new Token.EndTag(\"li\"));\n358                                 break;\n359                             }\n360                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n361                                 break;\n362                         }\n363                         if (tb.inButtonScope(\"p\")) {\n364                             tb.process(new Token.EndTag(\"p\"));\n365                         }\n366                         tb.insert(startTag);\n367                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n368                         tb.framesetOk(false);\n369                         LinkedList<Element> stack = tb.getStack();\n370                         for (int i = stack.size() - 1; i > 0; i--) {\n371                             Element el = stack.get(i);\n372                             if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n373                                 tb.process(new Token.EndTag(el.nodeName()));\n374                                 break;\n375                             }\n376                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n377                                 break;\n378                         }\n379                         if (tb.inButtonScope(\"p\")) {\n380                             tb.process(new Token.EndTag(\"p\"));\n381                         }\n382                         tb.insert(startTag);\n383                     } else if (name.equals(\"plaintext\")) {\n384                         if (tb.inButtonScope(\"p\")) {\n385                             tb.process(new Token.EndTag(\"p\"));\n386                         }\n387                         tb.insert(startTag);\n388                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n389                     } else if (name.equals(\"button\")) {\n390                         if (tb.inButtonScope(\"button\")) {\n391                             // close and reprocess\n392                             tb.error(this);\n393                             tb.process(new Token.EndTag(\"button\"));\n394                             tb.process(startTag);\n395                         } else {\n396                             tb.reconstructFormattingElements();\n397                             tb.insert(startTag);\n398                             tb.framesetOk(false);\n399                         }\n400                     } else if (name.equals(\"a\")) {\n401                         if (tb.getActiveFormattingElement(\"a\") != null) {\n402                             tb.error(this);\n403                             tb.process(new Token.EndTag(\"a\"));\n404 \n405                             // still on stack?\n406                             Element remainingA = tb.getFromStack(\"a\");\n407                             if (remainingA != null) {\n408                                 tb.removeFromActiveFormattingElements(remainingA);\n409                                 tb.removeFromStack(remainingA);\n410                             }\n411                         }\n412                         tb.reconstructFormattingElements();\n413                         Element a = tb.insert(startTag);\n414                         tb.pushActiveFormattingElements(a);\n415                     } else if (StringUtil.in(name,\n416                             \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n417                         tb.reconstructFormattingElements();\n418                         Element el = tb.insert(startTag);\n419                         tb.pushActiveFormattingElements(el);\n420                     } else if (name.equals(\"nobr\")) {\n421                         tb.reconstructFormattingElements();\n422                         if (tb.inScope(\"nobr\")) {\n423                             tb.error(this);\n424                             tb.process(new Token.EndTag(\"nobr\"));\n425                             tb.reconstructFormattingElements();\n426                         }\n427                         Element el = tb.insert(startTag);\n428                         tb.pushActiveFormattingElements(el);\n429                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n430                         tb.reconstructFormattingElements();\n431                         tb.insert(startTag);\n432                         tb.insertMarkerToFormattingElements();\n433                         tb.framesetOk(false);\n434                     } else if (name.equals(\"table\")) {\n435                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n436                             tb.process(new Token.EndTag(\"p\"));\n437                         }\n438                         tb.insert(startTag);\n439                         tb.framesetOk(false);\n440                         tb.transition(InTable);\n441                     } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n442                         tb.reconstructFormattingElements();\n443                         tb.insertEmpty(startTag);\n444                         tb.framesetOk(false);\n445                     } else if (name.equals(\"input\")) {\n446                         tb.reconstructFormattingElements();\n447                         Element el = tb.insertEmpty(startTag);\n448                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n449                             tb.framesetOk(false);\n450                     } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n451                         tb.insertEmpty(startTag);\n452                     } else if (name.equals(\"hr\")) {\n453                         if (tb.inButtonScope(\"p\")) {\n454                             tb.process(new Token.EndTag(\"p\"));\n455                         }\n456                         tb.insertEmpty(startTag);\n457                         tb.framesetOk(false);\n458                     } else if (name.equals(\"image\")) {\n459                         // we're not supposed to ask.\n460                         startTag.name(\"img\");\n461                         return tb.process(startTag);\n462                     } else if (name.equals(\"isindex\")) {\n463                         // how much do we care about the early 90s?\n464                         tb.error(this);\n465                         if (tb.getFormElement() != null)\n466                             return false;\n467 \n468                         tb.tokeniser.acknowledgeSelfClosingFlag();\n469                         tb.process(new Token.StartTag(\"form\"));\n470                         if (startTag.attributes.hasKey(\"action\")) {\n471                             Element form = tb.getFormElement();\n472                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n473                         }\n474                         tb.process(new Token.StartTag(\"hr\"));\n475                         tb.process(new Token.StartTag(\"label\"));\n476                         // hope you like english.\n477                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n478                                 startTag.attributes.get(\"prompt\") :\n479                                 \"This is a searchable index. Enter search keywords: \";\n480 \n481                         tb.process(new Token.Character(prompt));\n482 \n483                         // input\n484                         Attributes inputAttribs = new Attributes();\n485                         for (Attribute attr : startTag.attributes) {\n486                             if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n487                                 inputAttribs.put(attr);\n488                         }\n489                         inputAttribs.put(\"name\", \"isindex\");\n490                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n491                         tb.process(new Token.EndTag(\"label\"));\n492                         tb.process(new Token.StartTag(\"hr\"));\n493                         tb.process(new Token.EndTag(\"form\"));\n494                     } else if (name.equals(\"textarea\")) {\n495                         tb.insert(startTag);\n496                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n497                         tb.tokeniser.transition(TokeniserState.Rcdata);\n498                         tb.markInsertionMode();\n499                         tb.framesetOk(false);\n500                         tb.transition(Text);\n501                     } else if (name.equals(\"xmp\")) {\n502                         if (tb.inButtonScope(\"p\")) {\n503                             tb.process(new Token.EndTag(\"p\"));\n504                         }\n505                         tb.reconstructFormattingElements();\n506                         tb.framesetOk(false);\n507                         handleRawtext(startTag, tb);\n508                     } else if (name.equals(\"iframe\")) {\n509                         tb.framesetOk(false);\n510                         handleRawtext(startTag, tb);\n511                     } else if (name.equals(\"noembed\")) {\n512                         // also handle noscript if script enabled\n513                         handleRawtext(startTag, tb);\n514                     } else if (name.equals(\"select\")) {\n515                         tb.reconstructFormattingElements();\n516                         tb.insert(startTag);\n517                         tb.framesetOk(false);\n518 \n519                         HtmlTreeBuilderState state = tb.state();\n520                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n521                             tb.transition(InSelectInTable);\n522                         else\n523                             tb.transition(InSelect);\n524                     } else if (StringUtil.in(\"optgroup\", \"option\")) {\n525                         if (tb.currentElement().nodeName().equals(\"option\"))\n526                             tb.process(new Token.EndTag(\"option\"));\n527                         tb.reconstructFormattingElements();\n528                         tb.insert(startTag);\n529                     } else if (StringUtil.in(\"rp\", \"rt\")) {\n530                         if (tb.inScope(\"ruby\")) {\n531                             tb.generateImpliedEndTags();\n532                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n533                                 tb.error(this);\n534                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n535                             }\n536                             tb.insert(startTag);\n537                         }\n538                     } else if (name.equals(\"math\")) {\n539                         tb.reconstructFormattingElements();\n540                         // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n541                         tb.insert(startTag);\n542                         tb.tokeniser.acknowledgeSelfClosingFlag();\n543                     } else if (name.equals(\"svg\")) {\n544                         tb.reconstructFormattingElements();\n545                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n546                         tb.insert(startTag);\n547                         tb.tokeniser.acknowledgeSelfClosingFlag();\n548                     } else if (StringUtil.in(name,\n549                             \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n550                         tb.error(this);\n551                         return false;\n552                     } else {\n553                         tb.reconstructFormattingElements();\n554                         tb.insert(startTag);\n555                     }\n556                     break;\n557 \n558                 case EndTag:\n559                     Token.EndTag endTag = t.asEndTag();\n560                     name = endTag.name();\n561                     if (name.equals(\"body\")) {\n562                         if (!tb.inScope(\"body\")) {\n563                             tb.error(this);\n564                             return false;\n565                         } else {\n566                             // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n567                             tb.transition(AfterBody);\n568                         }\n569                     } else if (name.equals(\"html\")) {\n570                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n571                         if (notIgnored)\n572                             return tb.process(endTag);\n573                     } else if (StringUtil.in(name,\n574                             \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n575                             \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n576                             \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n577                         // todo: refactor these lookups\n578                         if (!tb.inScope(name)) {\n579                             // nothing to close\n580                             tb.error(this);\n581                             return false;\n582                         } else {\n583                             tb.generateImpliedEndTags();\n584                             if (!tb.currentElement().nodeName().equals(name))\n585                                 tb.error(this);\n586                             tb.popStackToClose(name);\n587                         }\n588                     } else if (name.equals(\"form\")) {\n589                         Element currentForm = tb.getFormElement();\n590                         tb.setFormElement(null);\n591                         if (currentForm == null || !tb.inScope(name)) {\n592                             tb.error(this);\n593                             return false;\n594                         } else {\n595                             tb.generateImpliedEndTags();\n596                             if (!tb.currentElement().nodeName().equals(name))\n597                                 tb.error(this);\n598                             // remove currentForm from stack. will shift anything under up.\n599                             tb.removeFromStack(currentForm);\n600                         }\n601                     } else if (name.equals(\"p\")) {\n602                         if (!tb.inButtonScope(name)) {\n603                             tb.error(this);\n604                             tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n605                             return tb.process(endTag);\n606                         } else {\n607                             tb.generateImpliedEndTags(name);\n608                             if (!tb.currentElement().nodeName().equals(name))\n609                                 tb.error(this);\n610                             tb.popStackToClose(name);\n611                         }\n612                     } else if (name.equals(\"li\")) {\n613                         if (!tb.inListItemScope(name)) {\n614                             tb.error(this);\n615                             return false;\n616                         } else {\n617                             tb.generateImpliedEndTags(name);\n618                             if (!tb.currentElement().nodeName().equals(name))\n619                                 tb.error(this);\n620                             tb.popStackToClose(name);\n621                         }\n622                     } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n623                         if (!tb.inScope(name)) {\n624                             tb.error(this);\n625                             return false;\n626                         } else {\n627                             tb.generateImpliedEndTags(name);\n628                             if (!tb.currentElement().nodeName().equals(name))\n629                                 tb.error(this);\n630                             tb.popStackToClose(name);\n631                         }\n632                     } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n633                         if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n634                             tb.error(this);\n635                             return false;\n636                         } else {\n637                             tb.generateImpliedEndTags(name);\n638                             if (!tb.currentElement().nodeName().equals(name))\n639                                 tb.error(this);\n640                             tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n641                         }\n642                     } else if (name.equals(\"sarcasm\")) {\n643                         // *sigh*\n644                         return anyOtherEndTag(t, tb);\n645                     } else if (StringUtil.in(name,\n646                             \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n647                         // Adoption Agency Algorithm.\n648                         OUTER:\n649                         for (int i = 0; i < 8; i++) {\n650                             Element formatEl = tb.getActiveFormattingElement(name);\n651                             if (formatEl == null)\n652                                 return anyOtherEndTag(t, tb);\n653                             else if (!tb.onStack(formatEl)) {\n654                                 tb.error(this);\n655                                 tb.removeFromActiveFormattingElements(formatEl);\n656                                 return true;\n657                             } else if (!tb.inScope(formatEl.nodeName())) {\n658                                 tb.error(this);\n659                                 return false;\n660                             } else if (tb.currentElement() != formatEl)\n661                                 tb.error(this);\n662 \n663                             Element furthestBlock = null;\n664                             Element commonAncestor = null;\n665                             boolean seenFormattingElement = false;\n666                             LinkedList<Element> stack = tb.getStack();\n667                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n668                             // run-aways\n669                             for (int si = 0; si < stack.size() && si < 64; si++) {\n670                                 Element el = stack.get(si);\n671                                 if (el == formatEl) {\n672                                     commonAncestor = stack.get(si - 1);\n673                                     seenFormattingElement = true;\n674                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n675                                     furthestBlock = el;\n676                                     break;\n677                                 }\n678                             }\n679                             if (furthestBlock == null) {\n680                                 tb.popStackToClose(formatEl.nodeName());\n681                                 tb.removeFromActiveFormattingElements(formatEl);\n682                                 return true;\n683                             }\n684 \n685                             // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n686                             // does that mean: int pos of format el in list?\n687                             Element node = furthestBlock;\n688                             Element lastNode = furthestBlock;\n689                             INNER:\n690                             for (int j = 0; j < 3; j++) {\n691                                 if (tb.onStack(node))\n692                                     node = tb.aboveOnStack(node);\n693                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n694                                     tb.removeFromStack(node);\n695                                     continue INNER;\n696                                 } else if (node == formatEl)\n697                                     break INNER;\n698 \n699                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n700                                 tb.replaceActiveFormattingElement(node, replacement);\n701                                 tb.replaceOnStack(node, replacement);\n702                                 node = replacement;\n703 \n704                                 if (lastNode == furthestBlock) {\n705                                     // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n706                                     // not getting how this bookmark both straddles the element above, but is inbetween here...\n707                                 }\n708                                 if (lastNode.parent() != null)\n709                                     lastNode.remove();\n710                                 node.appendChild(lastNode);\n711 \n712                                 lastNode = node;\n713                             }\n714 \n715                             if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n716                                 if (lastNode.parent() != null)\n717                                     lastNode.remove();\n718                                 tb.insertInFosterParent(lastNode);\n719                             } else {\n720                                 if (lastNode.parent() != null)\n721                                     lastNode.remove();\n722                                 commonAncestor.appendChild(lastNode);\n723                             }\n724 \n725                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n726                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n727                             for (Node childNode : childNodes) {\n728                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n729                             }\n730                             furthestBlock.appendChild(adopter);\n731                             tb.removeFromActiveFormattingElements(formatEl);\n732                             // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n733                             tb.removeFromStack(formatEl);\n734                             tb.insertOnStackAfter(furthestBlock, adopter);\n735                         }\n736                     } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n737                         if (!tb.inScope(\"name\")) {\n738                             if (!tb.inScope(name)) {\n739                                 tb.error(this);\n740                                 return false;\n741                             }\n742                             tb.generateImpliedEndTags();\n743                             if (!tb.currentElement().nodeName().equals(name))\n744                                 tb.error(this);\n745                             tb.popStackToClose(name);\n746                             tb.clearFormattingElementsToLastMarker();\n747                         }\n748                     } else if (name.equals(\"br\")) {\n749                         tb.error(this);\n750                         tb.process(new Token.StartTag(\"br\"));\n751                         return false;\n752                     } else {\n753                         return anyOtherEndTag(t, tb);\n754                     }\n755 \n756                     break;\n757                 case EOF:\n758                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n759                     // stop parsing\n760                     break;\n761             }\n762             return true;\n763         }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilderState"}, {"bug_name": "Jsoup_36", "report_text": "> More robust charset detection code\n> \n> With the following HTML:\n> ```\n> <html lang=\"en-US\">\n> <head>\n>     <meta charset=\"UTF-8\">\n>     <meta http-equiv=\"Content-Type\" content=\"text/html; \" />\n> </head>\n> ```\n> jsoup fails to parse the page with a IllegalCharsetNameException. I see that http-equiv=\"Content-Type\" has an invalid content-type but it would be possible to still parse it correctly by using the html5 , i.e. jsoup could be more robust on this one.\n> other domains which are not working but could be:  \n> 9kuhkep.net  \n> [www.a-bright.org](http://www.a-bright.org)\n> I use this code to parse the sites:\n> ```\n> Jsoup.connect(url).execute()\n> ```", "test_name": "org.jsoup.helper.DataUtilTest::shouldCorrectCharsetForDuplicateCharsetString", "test_method": "    @Test\n    public void shouldCorrectCharsetForDuplicateCharsetString() {\n        assertEquals(\"iso-8859-1\", DataUtil.getCharsetFromContentType(\"text/html; charset=charset=iso-8859-1\")); // <-- fails here\n    }", "error_message": "java.nio.charset.IllegalCharsetNameException: charset=iso-8859-1\n\tjava.nio.charset.Charset.checkName(Charset.java:315)\n\tjava.nio.charset.Charset.lookup2(Charset.java:484)\n\tjava.nio.charset.Charset.lookup(Charset.java:464)\n\tjava.nio.charset.Charset.isSupported(Charset.java:505)\n\torg.jsoup.helper.DataUtil.getCharsetFromContentType(DataUtil.java:161)\n\torg.jsoup.helper.DataUtilTest.shouldCorrectCharsetForDuplicateCharsetString(DataUtilTest.java:51)", "buggy_method": "74 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n75         String docData;\n76         Document doc = null;\n77         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n78             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n79             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n80             doc = parser.parseInput(docData, baseUri);\n81             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n82             if (meta != null) { // if not found, will keep utf-8 as best attempt\n83 \n84                 String foundCharset;\n85                 if (meta.hasAttr(\"http-equiv\")) {\n86                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n87                 } else {\n88                     foundCharset = meta.attr(\"charset\");\n89                 }\n90 \n91                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n92                     charsetName = foundCharset;\n93                     byteData.rewind();\n94                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n95                     doc = null;\n96                 }\n97             }\n98         } else { // specified by content type header (or by user on file load)\n99             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n100             docData = Charset.forName(charsetName).decode(byteData).toString();\n101         }\n102         if (doc == null) {\n103             // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n104             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n105             // into head mode\n106             if (docData.length() > 0 && docData.charAt(0) == 65279)\n107                 docData = docData.substring(1);\n108 \n109             doc = parser.parseInput(docData, baseUri);\n110             doc.outputSettings().charset(charsetName);\n111         }\n112         return doc;\n113     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_37", "report_text": "> Whitespaces are discared in Element.html() method\n> \n> Hi,  \n> I'm trying to make an exact copy of a document (changing just a couple of attributes and appending a few nodes) and the trim() inside the Element.html() is killing me.  \n> I'm using Parsers.xml() and no prettyPrint.\n> I think this trim should be enabled for prettyPrint only.", "test_name": "org.jsoup.nodes.ElementTest::testNotPretty", "test_method": "    @Test public void testNotPretty() {\n        Document doc = Jsoup.parse(\"<div>   \\n<p>Hello\\n there\\n</p></div>\");\n        doc.outputSettings().prettyPrint(false);\n\n        Element div = doc.select(\"div\").first();\n        assertEquals(\"   \\n<p>Hello\\n there\\n</p>\", div.html()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.testNotPretty(ElementTest.java:247)", "buggy_method": "1098 public String html() {\n1099         StringBuilder accum = new StringBuilder();\n1100         html(accum);\n1101         return accum.toString().trim();\n1102     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_38", "report_text": "> Jsoup converts \"svg image\" to \"svg img\"\n> \n> Hi,  \n> when I parse a html page with a svg element, which contains an image element, the \"image\" element is replaced by \"img\". But this is not correct. The \"image\" must be \"image\".\n> Example:  \n> Input:\n> ```\n> <svg width=\"560\" height=\"150\">\n> <image xlink:href=\"myimage.jpg\"\n>    y=\"5\" x=\"100\"  \n>    height=\"140\" width=\"230\" />\n> </svg>\n> ```\n> Output:\n> ```\n> <svg width=\"560\" height=\"150\">\n> <img xlink:href=\"myimage.jpg\"\n>    y=\"5\" x=\"100\"  \n>    height=\"140\" width=\"230\" />\n> </svg>\n> ```\n> The problem seems to be in line 457 of HtmlTreeBuilderState.java.", "test_name": "org.jsoup.parser.HtmlParserTest::convertsImageToImg", "test_method": "    @Test public void convertsImageToImg() {\n        // image to img, unless in a svg. old html cruft.\n        String h = \"<body><image><svg><image /></svg></body>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<img />\\n<svg>\\n <image />\\n</svg>\", doc.body().html()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<img />\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.convertsImageToImg(HtmlParserTest.java:807)", "buggy_method": "247 boolean process(Token t, HtmlTreeBuilder tb) {\n248             switch (t.type) {\n249                 case Character: {\n250                     Token.Character c = t.asCharacter();\n251                     if (c.getData().equals(nullString)) {\n252                         // todo confirm that check\n253                         tb.error(this);\n254                         return false;\n255                     } else if (isWhitespace(c)) {\n256                         tb.reconstructFormattingElements();\n257                         tb.insert(c);\n258                     } else {\n259                         tb.reconstructFormattingElements();\n260                         tb.insert(c);\n261                         tb.framesetOk(false);\n262                     }\n263                     break;\n264                 }\n265                 case Comment: {\n266                     tb.insert(t.asComment());\n267                     break;\n268                 }\n269                 case Doctype: {\n270                     tb.error(this);\n271                     return false;\n272                 }\n273                 case StartTag:\n274                     Token.StartTag startTag = t.asStartTag();\n275                     String name = startTag.name();\n276                     if (name.equals(\"html\")) {\n277                         tb.error(this);\n278                         // merge attributes onto real html\n279                         Element html = tb.getStack().getFirst();\n280                         for (Attribute attribute : startTag.getAttributes()) {\n281                             if (!html.hasAttr(attribute.getKey()))\n282                                 html.attributes().put(attribute);\n283                         }\n284                     } else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n285                         return tb.process(t, InHead);\n286                     } else if (name.equals(\"body\")) {\n287                         tb.error(this);\n288                         LinkedList<Element> stack = tb.getStack();\n289                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n290                             // only in fragment case\n291                             return false; // ignore\n292                         } else {\n293                             tb.framesetOk(false);\n294                             Element body = stack.get(1);\n295                             for (Attribute attribute : startTag.getAttributes()) {\n296                                 if (!body.hasAttr(attribute.getKey()))\n297                                     body.attributes().put(attribute);\n298                             }\n299                         }\n300                     } else if (name.equals(\"frameset\")) {\n301                         tb.error(this);\n302                         LinkedList<Element> stack = tb.getStack();\n303                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n304                             // only in fragment case\n305                             return false; // ignore\n306                         } else if (!tb.framesetOk()) {\n307                             return false; // ignore frameset\n308                         } else {\n309                             Element second = stack.get(1);\n310                             if (second.parent() != null)\n311                                 second.remove();\n312                             // pop up to html element\n313                             while (stack.size() > 1)\n314                                 stack.removeLast();\n315                             tb.insert(startTag);\n316                             tb.transition(InFrameset);\n317                         }\n318                     } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n319                         if (tb.inButtonScope(\"p\")) {\n320                             tb.process(new Token.EndTag(\"p\"));\n321                         }\n322                         tb.insert(startTag);\n323                     } else if (StringUtil.in(name, Constants.Headings)) {\n324                         if (tb.inButtonScope(\"p\")) {\n325                             tb.process(new Token.EndTag(\"p\"));\n326                         }\n327                         if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n328                             tb.error(this);\n329                             tb.pop();\n330                         }\n331                         tb.insert(startTag);\n332                     } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n333                         if (tb.inButtonScope(\"p\")) {\n334                             tb.process(new Token.EndTag(\"p\"));\n335                         }\n336                         tb.insert(startTag);\n337                         // todo: ignore LF if next token\n338                         tb.framesetOk(false);\n339                     } else if (name.equals(\"form\")) {\n340                         if (tb.getFormElement() != null) {\n341                             tb.error(this);\n342                             return false;\n343                         }\n344                         if (tb.inButtonScope(\"p\")) {\n345                             tb.process(new Token.EndTag(\"p\"));\n346                         }\n347                         tb.insertForm(startTag, true);\n348                     } else if (name.equals(\"li\")) {\n349                         tb.framesetOk(false);\n350                         LinkedList<Element> stack = tb.getStack();\n351                         for (int i = stack.size() - 1; i > 0; i--) {\n352                             Element el = stack.get(i);\n353                             if (el.nodeName().equals(\"li\")) {\n354                                 tb.process(new Token.EndTag(\"li\"));\n355                                 break;\n356                             }\n357                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n358                                 break;\n359                         }\n360                         if (tb.inButtonScope(\"p\")) {\n361                             tb.process(new Token.EndTag(\"p\"));\n362                         }\n363                         tb.insert(startTag);\n364                     } else if (StringUtil.in(name, Constants.DdDt)) {\n365                         tb.framesetOk(false);\n366                         LinkedList<Element> stack = tb.getStack();\n367                         for (int i = stack.size() - 1; i > 0; i--) {\n368                             Element el = stack.get(i);\n369                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n370                                 tb.process(new Token.EndTag(el.nodeName()));\n371                                 break;\n372                             }\n373                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n374                                 break;\n375                         }\n376                         if (tb.inButtonScope(\"p\")) {\n377                             tb.process(new Token.EndTag(\"p\"));\n378                         }\n379                         tb.insert(startTag);\n380                     } else if (name.equals(\"plaintext\")) {\n381                         if (tb.inButtonScope(\"p\")) {\n382                             tb.process(new Token.EndTag(\"p\"));\n383                         }\n384                         tb.insert(startTag);\n385                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n386                     } else if (name.equals(\"button\")) {\n387                         if (tb.inButtonScope(\"button\")) {\n388                             // close and reprocess\n389                             tb.error(this);\n390                             tb.process(new Token.EndTag(\"button\"));\n391                             tb.process(startTag);\n392                         } else {\n393                             tb.reconstructFormattingElements();\n394                             tb.insert(startTag);\n395                             tb.framesetOk(false);\n396                         }\n397                     } else if (name.equals(\"a\")) {\n398                         if (tb.getActiveFormattingElement(\"a\") != null) {\n399                             tb.error(this);\n400                             tb.process(new Token.EndTag(\"a\"));\n401 \n402                             // still on stack?\n403                             Element remainingA = tb.getFromStack(\"a\");\n404                             if (remainingA != null) {\n405                                 tb.removeFromActiveFormattingElements(remainingA);\n406                                 tb.removeFromStack(remainingA);\n407                             }\n408                         }\n409                         tb.reconstructFormattingElements();\n410                         Element a = tb.insert(startTag);\n411                         tb.pushActiveFormattingElements(a);\n412                     } else if (StringUtil.in(name, Constants.Formatters)) {\n413                         tb.reconstructFormattingElements();\n414                         Element el = tb.insert(startTag);\n415                         tb.pushActiveFormattingElements(el);\n416                     } else if (name.equals(\"nobr\")) {\n417                         tb.reconstructFormattingElements();\n418                         if (tb.inScope(\"nobr\")) {\n419                             tb.error(this);\n420                             tb.process(new Token.EndTag(\"nobr\"));\n421                             tb.reconstructFormattingElements();\n422                         }\n423                         Element el = tb.insert(startTag);\n424                         tb.pushActiveFormattingElements(el);\n425                     } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n426                         tb.reconstructFormattingElements();\n427                         tb.insert(startTag);\n428                         tb.insertMarkerToFormattingElements();\n429                         tb.framesetOk(false);\n430                     } else if (name.equals(\"table\")) {\n431                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n432                             tb.process(new Token.EndTag(\"p\"));\n433                         }\n434                         tb.insert(startTag);\n435                         tb.framesetOk(false);\n436                         tb.transition(InTable);\n437                     } else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n438                         tb.reconstructFormattingElements();\n439                         tb.insertEmpty(startTag);\n440                         tb.framesetOk(false);\n441                     } else if (name.equals(\"input\")) {\n442                         tb.reconstructFormattingElements();\n443                         Element el = tb.insertEmpty(startTag);\n444                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n445                             tb.framesetOk(false);\n446                     } else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n447                         tb.insertEmpty(startTag);\n448                     } else if (name.equals(\"hr\")) {\n449                         if (tb.inButtonScope(\"p\")) {\n450                             tb.process(new Token.EndTag(\"p\"));\n451                         }\n452                         tb.insertEmpty(startTag);\n453                         tb.framesetOk(false);\n454                     } else if (name.equals(\"image\")) {\n455                             return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n456                     } else if (name.equals(\"isindex\")) {\n457                         // how much do we care about the early 90s?\n458                         tb.error(this);\n459                         if (tb.getFormElement() != null)\n460                             return false;\n461 \n462                         tb.tokeniser.acknowledgeSelfClosingFlag();\n463                         tb.process(new Token.StartTag(\"form\"));\n464                         if (startTag.attributes.hasKey(\"action\")) {\n465                             Element form = tb.getFormElement();\n466                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n467                         }\n468                         tb.process(new Token.StartTag(\"hr\"));\n469                         tb.process(new Token.StartTag(\"label\"));\n470                         // hope you like english.\n471                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n472                                 startTag.attributes.get(\"prompt\") :\n473                                 \"This is a searchable index. Enter search keywords: \";\n474 \n475                         tb.process(new Token.Character(prompt));\n476 \n477                         // input\n478                         Attributes inputAttribs = new Attributes();\n479                         for (Attribute attr : startTag.attributes) {\n480                             if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n481                                 inputAttribs.put(attr);\n482                         }\n483                         inputAttribs.put(\"name\", \"isindex\");\n484                         tb.process(new Token.StartTag(\"input\", inputAttribs));\n485                         tb.process(new Token.EndTag(\"label\"));\n486                         tb.process(new Token.StartTag(\"hr\"));\n487                         tb.process(new Token.EndTag(\"form\"));\n488                     } else if (name.equals(\"textarea\")) {\n489                         tb.insert(startTag);\n490                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n491                         tb.tokeniser.transition(TokeniserState.Rcdata);\n492                         tb.markInsertionMode();\n493                         tb.framesetOk(false);\n494                         tb.transition(Text);\n495                     } else if (name.equals(\"xmp\")) {\n496                         if (tb.inButtonScope(\"p\")) {\n497                             tb.process(new Token.EndTag(\"p\"));\n498                         }\n499                         tb.reconstructFormattingElements();\n500                         tb.framesetOk(false);\n501                         handleRawtext(startTag, tb);\n502                     } else if (name.equals(\"iframe\")) {\n503                         tb.framesetOk(false);\n504                         handleRawtext(startTag, tb);\n505                     } else if (name.equals(\"noembed\")) {\n506                         // also handle noscript if script enabled\n507                         handleRawtext(startTag, tb);\n508                     } else if (name.equals(\"select\")) {\n509                         tb.reconstructFormattingElements();\n510                         tb.insert(startTag);\n511                         tb.framesetOk(false);\n512 \n513                         HtmlTreeBuilderState state = tb.state();\n514                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n515                             tb.transition(InSelectInTable);\n516                         else\n517                             tb.transition(InSelect);\n518                     } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n519                         if (tb.currentElement().nodeName().equals(\"option\"))\n520                             tb.process(new Token.EndTag(\"option\"));\n521                         tb.reconstructFormattingElements();\n522                         tb.insert(startTag);\n523                     } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n524                         if (tb.inScope(\"ruby\")) {\n525                             tb.generateImpliedEndTags();\n526                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n527                                 tb.error(this);\n528                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n529                             }\n530                             tb.insert(startTag);\n531                         }\n532                     } else if (name.equals(\"math\")) {\n533                         tb.reconstructFormattingElements();\n534                         // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n535                         tb.insert(startTag);\n536                         tb.tokeniser.acknowledgeSelfClosingFlag();\n537                     } else if (name.equals(\"svg\")) {\n538                         tb.reconstructFormattingElements();\n539                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n540                         tb.insert(startTag);\n541                         tb.tokeniser.acknowledgeSelfClosingFlag();\n542                     } else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n543                         tb.error(this);\n544                         return false;\n545                     } else {\n546                         tb.reconstructFormattingElements();\n547                         tb.insert(startTag);\n548                     }\n549                     break;\n550 \n551                 case EndTag:\n552                     Token.EndTag endTag = t.asEndTag();\n553                     name = endTag.name();\n554                     if (name.equals(\"body\")) {\n555                         if (!tb.inScope(\"body\")) {\n556                             tb.error(this);\n557                             return false;\n558                         } else {\n559                             // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n560                             tb.transition(AfterBody);\n561                         }\n562                     } else if (name.equals(\"html\")) {\n563                         boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n564                         if (notIgnored)\n565                             return tb.process(endTag);\n566                     } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n567                         if (!tb.inScope(name)) {\n568                             // nothing to close\n569                             tb.error(this);\n570                             return false;\n571                         } else {\n572                             tb.generateImpliedEndTags();\n573                             if (!tb.currentElement().nodeName().equals(name))\n574                                 tb.error(this);\n575                             tb.popStackToClose(name);\n576                         }\n577                     } else if (name.equals(\"form\")) {\n578                         Element currentForm = tb.getFormElement();\n579                         tb.setFormElement(null);\n580                         if (currentForm == null || !tb.inScope(name)) {\n581                             tb.error(this);\n582                             return false;\n583                         } else {\n584                             tb.generateImpliedEndTags();\n585                             if (!tb.currentElement().nodeName().equals(name))\n586                                 tb.error(this);\n587                             // remove currentForm from stack. will shift anything under up.\n588                             tb.removeFromStack(currentForm);\n589                         }\n590                     } else if (name.equals(\"p\")) {\n591                         if (!tb.inButtonScope(name)) {\n592                             tb.error(this);\n593                             tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n594                             return tb.process(endTag);\n595                         } else {\n596                             tb.generateImpliedEndTags(name);\n597                             if (!tb.currentElement().nodeName().equals(name))\n598                                 tb.error(this);\n599                             tb.popStackToClose(name);\n600                         }\n601                     } else if (name.equals(\"li\")) {\n602                         if (!tb.inListItemScope(name)) {\n603                             tb.error(this);\n604                             return false;\n605                         } else {\n606                             tb.generateImpliedEndTags(name);\n607                             if (!tb.currentElement().nodeName().equals(name))\n608                                 tb.error(this);\n609                             tb.popStackToClose(name);\n610                         }\n611                     } else if (StringUtil.in(name, Constants.DdDt)) {\n612                         if (!tb.inScope(name)) {\n613                             tb.error(this);\n614                             return false;\n615                         } else {\n616                             tb.generateImpliedEndTags(name);\n617                             if (!tb.currentElement().nodeName().equals(name))\n618                                 tb.error(this);\n619                             tb.popStackToClose(name);\n620                         }\n621                     } else if (StringUtil.in(name, Constants.Headings)) {\n622                         if (!tb.inScope(Constants.Headings)) {\n623                             tb.error(this);\n624                             return false;\n625                         } else {\n626                             tb.generateImpliedEndTags(name);\n627                             if (!tb.currentElement().nodeName().equals(name))\n628                                 tb.error(this);\n629                             tb.popStackToClose(Constants.Headings);\n630                         }\n631                     } else if (name.equals(\"sarcasm\")) {\n632                         // *sigh*\n633                         return anyOtherEndTag(t, tb);\n634                     } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n635                         // Adoption Agency Algorithm.\n636                         OUTER:\n637                         for (int i = 0; i < 8; i++) {\n638                             Element formatEl = tb.getActiveFormattingElement(name);\n639                             if (formatEl == null)\n640                                 return anyOtherEndTag(t, tb);\n641                             else if (!tb.onStack(formatEl)) {\n642                                 tb.error(this);\n643                                 tb.removeFromActiveFormattingElements(formatEl);\n644                                 return true;\n645                             } else if (!tb.inScope(formatEl.nodeName())) {\n646                                 tb.error(this);\n647                                 return false;\n648                             } else if (tb.currentElement() != formatEl)\n649                                 tb.error(this);\n650 \n651                             Element furthestBlock = null;\n652                             Element commonAncestor = null;\n653                             boolean seenFormattingElement = false;\n654                             LinkedList<Element> stack = tb.getStack();\n655                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n656                             // run-aways\n657                             final int stackSize = stack.size();\n658                             for (int si = 0; si < stackSize && si < 64; si++) {\n659                                 Element el = stack.get(si);\n660                                 if (el == formatEl) {\n661                                     commonAncestor = stack.get(si - 1);\n662                                     seenFormattingElement = true;\n663                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n664                                     furthestBlock = el;\n665                                     break;\n666                                 }\n667                             }\n668                             if (furthestBlock == null) {\n669                                 tb.popStackToClose(formatEl.nodeName());\n670                                 tb.removeFromActiveFormattingElements(formatEl);\n671                                 return true;\n672                             }\n673 \n674                             // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n675                             // does that mean: int pos of format el in list?\n676                             Element node = furthestBlock;\n677                             Element lastNode = furthestBlock;\n678                             INNER:\n679                             for (int j = 0; j < 3; j++) {\n680                                 if (tb.onStack(node))\n681                                     node = tb.aboveOnStack(node);\n682                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n683                                     tb.removeFromStack(node);\n684                                     continue INNER;\n685                                 } else if (node == formatEl)\n686                                     break INNER;\n687 \n688                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n689                                 tb.replaceActiveFormattingElement(node, replacement);\n690                                 tb.replaceOnStack(node, replacement);\n691                                 node = replacement;\n692 \n693                                 if (lastNode == furthestBlock) {\n694                                     // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n695                                     // not getting how this bookmark both straddles the element above, but is inbetween here...\n696                                 }\n697                                 if (lastNode.parent() != null)\n698                                     lastNode.remove();\n699                                 node.appendChild(lastNode);\n700 \n701                                 lastNode = node;\n702                             }\n703 \n704                             if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n705                                 if (lastNode.parent() != null)\n706                                     lastNode.remove();\n707                                 tb.insertInFosterParent(lastNode);\n708                             } else {\n709                                 if (lastNode.parent() != null)\n710                                     lastNode.remove();\n711                                 commonAncestor.appendChild(lastNode);\n712                             }\n713 \n714                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n715                             adopter.attributes().addAll(formatEl.attributes());\n716                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n717                             for (Node childNode : childNodes) {\n718                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n719                             }\n720                             furthestBlock.appendChild(adopter);\n721                             tb.removeFromActiveFormattingElements(formatEl);\n722                             // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n723                             tb.removeFromStack(formatEl);\n724                             tb.insertOnStackAfter(furthestBlock, adopter);\n725                         }\n726                     } else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n727                         if (!tb.inScope(\"name\")) {\n728                             if (!tb.inScope(name)) {\n729                                 tb.error(this);\n730                                 return false;\n731                             }\n732                             tb.generateImpliedEndTags();\n733                             if (!tb.currentElement().nodeName().equals(name))\n734                                 tb.error(this);\n735                             tb.popStackToClose(name);\n736                             tb.clearFormattingElementsToLastMarker();\n737                         }\n738                     } else if (name.equals(\"br\")) {\n739                         tb.error(this);\n740                         tb.process(new Token.StartTag(\"br\"));\n741                         return false;\n742                     } else {\n743                         return anyOtherEndTag(t, tb);\n744                     }\n745 \n746                     break;\n747                 case EOF:\n748                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n749                     // stop parsing\n750                     break;\n751             }\n752             return true;\n753         }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilderState"}, {"bug_name": "Jsoup_39", "report_text": "> JSoup incorrectly moves content from the <head> section into <body> for sample URL\n> \n> If you load the following URL:\n> ```\n> http://jornutzon.sydneyoperahouse.com/home.htm\n> ```\n> into:\n> ```\n> http://try.jsoup.org/\n> ```\n> then it will move the content from the \"head\" section into the \"body\" section. The URL  \n> being parsed validates using the W3C validator:\n> <http://validator.w3.org/check?uri=http%3A%2F%2Fjornutzon.sydneyoperahouse.com%2Fhome.htm&charset=%28detect+automatically%29&doctype=Inline&ss=1&group=0&user-agent=W3C_Validator%2F1.3+http%3A%2F%2Fvalidator.w3.org%2Fservices>\n> We are using JSoup 1.7.2", "test_name": "org.jsoup.helper.DataUtilTest::discardsSpuriousByteOrderMarkWhenNoCharsetSet", "test_method": "    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() {\n        String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n        Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());\n        assertEquals(\"One\", doc.head().text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[One]> but was:<[]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.DataUtilTest.discardsSpuriousByteOrderMarkWhenNoCharsetSet(DataUtilTest.java:42)", "buggy_method": "76 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n77         String docData;\n78         Document doc = null;\n79         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n80             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n81             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n82             doc = parser.parseInput(docData, baseUri);\n83             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n84             if (meta != null) { // if not found, will keep utf-8 as best attempt\n85                 String foundCharset;\n86                 if (meta.hasAttr(\"http-equiv\")) {\n87                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n88                     if (foundCharset == null && meta.hasAttr(\"charset\")) {\n89                         try {\n90                             if (Charset.isSupported(meta.attr(\"charset\"))) {\n91                                 foundCharset = meta.attr(\"charset\");\n92                             }\n93                         } catch (IllegalCharsetNameException e) {\n94                             foundCharset = null;\n95                         }\n96                     }\n97                 } else {\n98                     foundCharset = meta.attr(\"charset\");\n99                 }\n100 \n101                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n102                     foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n103                     charsetName = foundCharset;\n104                     byteData.rewind();\n105                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n106                     doc = null;\n107                 }\n108             }\n109         } else { // specified by content type header (or by user on file load)\n110             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n111             docData = Charset.forName(charsetName).decode(byteData).toString();\n112         }\n113         // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n114         if (docData.length() > 0 && docData.charAt(0) == 65279) {\n115             byteData.rewind();\n116             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n117             docData = docData.substring(1);\n118             charsetName = defaultCharset;\n119         }\n120         if (doc == null) {\n121             doc = parser.parseInput(docData, baseUri);\n122             doc.outputSettings().charset(charsetName);\n123         }\n124         return doc;\n125     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_40", "report_text": "> \"<!DOCTYPE>\" IllegalArgumentException: String must not be empty\n> \n> While this may be a contrived example, Jsoup.parse(\"<!DOCTYPE>\") throws an exception, this was unexpected. Possibly related, a proper document with <!DOCTYPE> (no name) is generating corrupt html e.g. \"<!DOCTYPE <html> ...\" (missing right angle bracket on DOCTYPE.)\n> Spec says \"When a DOCTYPE token is created, its name, public identifier, and system identifier must be marked as missing (which is a distinct state from the empty string), [...]\"", "test_name": "org.jsoup.nodes.DocumentTypeTest::constructorValidationOkWithBlankName", "test_method": "    @Test\n    public void constructorValidationOkWithBlankName() {\n        DocumentType fail = new DocumentType(\"\",\"\", \"\", \"\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: String must not be empty\n\torg.jsoup.helper.Validate.notEmpty(Validate.java:92)\n\torg.jsoup.nodes.DocumentType.<init>(DocumentType.java:22)\n\torg.jsoup.nodes.DocumentTypeTest.constructorValidationOkWithBlankName(DocumentTypeTest.java:15)", "buggy_method": "19 public DocumentType(String name, String publicId, String systemId, String baseUri) {\n20         super(baseUri);\n21 \n22         Validate.notEmpty(name);\n23         attr(\"name\", name);\n24         attr(\"publicId\", publicId);\n25         attr(\"systemId\", systemId);\n26     }", "bm_classpath": "org.jsoup.nodes.DocumentType"}, {"bug_name": "Jsoup_41", "report_text": "> Element.hashCode() ignores the content text of the element.\n> \n> Found [this question](http://stackoverflow.com/questions/28970732/jsoup-node-hash-code-collision-when-traversing-dom-tree/28971463) on SO, OP was using `Element.hashCode()` and it wasn't woring right.\n> The problem is that when jsoup generates the hashCode of an Element, the content text of the element will be ignored, and the hashCode is generated only based on the attributes, and the hashCode of the parent Element.\n> ---\n> Using the following HTML:\n> ```\n> <html>\n>     <head>\n>     </head>\n>     <body>\n>         <div style=\"blah\">TODO: write content</div>\n>         <div style=\"blah\">Nothing here</div>\n>         <p style=\"test\">Empty</p>\n>         <p style=\"nothing\">Empty</p>\n>     </body>\n> </html>\n> ```\n> And the following code:\n> ```\n> String html = //HTML posted above\n> Document doc = Jsoup.parse(html);\n> Elements elements = doc.select(\"[style]\");\n> for (Element e : elements) {\n>    System.out.println(e.hashCode());\n> }\n> ```\n> It gives:\n> ```\n> -148184373\n> -148184373\n> -1050420242\n> 2013043377\n> ```\n> I believe the hashCode should be different for the first two Elements, since the content is text is different. Or is this intended behaviour?", "test_name": "org.jsoup.nodes.ElementTest::testHashAndEquals", "test_method": "    @Test\n    public void testHashAndEquals() {\n        String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n                \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n\n        Document doc = Jsoup.parse(doc1);\n        Elements els = doc.select(\"p\");\n\n        /*\n        for (Element el : els) {\n            System.out.println(el.hashCode() + \" - \" + el.outerHtml());\n        }\n\n        0 1534787905 - <p class=\"one\">One</p>\n        1 1534787905 - <p class=\"one\">One</p>\n        2 1539683239 - <p class=\"one\">Two</p>\n        3 1535455211 - <p class=\"two\">One</p>\n        4 1534787905 - <p class=\"one\">One</p>\n        5 1534787905 - <p class=\"one\">One</p>\n        6 1539683239 - <p class=\"one\">Two</p>\n        7 1535455211 - <p class=\"two\">One</p>\n        */\n        Element e0 = els.get(0);\n        Element e1 = els.get(1);\n        Element e2 = els.get(2);\n        Element e3 = els.get(3);\n        Element e4 = els.get(4);\n        Element e5 = els.get(5);\n        Element e6 = els.get(6);\n        Element e7 = els.get(7);\n\n        assertEquals(e0, e1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected: org.jsoup.nodes.Element<<p class=\"one\">One</p>> but was: org.jsoup.nodes.Element<<p class=\"one\">One</p>>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.testHashAndEquals(ElementTest.java:785)", "buggy_method": "1167 @Override\n1168     public boolean equals(Object o) {\n1169         if (this == o) return true;\n1170         if (o == null || getClass() != o.getClass()) return false;\n1171         if (!super.equals(o)) return false;\n1172 \n1173         Element element = (Element) o;\n1174 \n1175         return this == o;\n1176     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_42", "report_text": "> FormElement's formData ignores input checkbox checked without value.\n> \n> When there is input:\n> ```\n> <input type=\"checkbox\" name=\"testCheckBox\" checked=\"checked\" />\n> ```\n> The \"formData()\" of FormElement's ignores that default value which should be \"on\" as submitted by browsers.\n> HTML fragment:\n> ```\n> <html>\n>     <head>\n>         <title>Test</title>\n>     </head>\n>     <body>\n>     <form name=\"myForm\" method=\"POST\">\n>         <input type=\"checkbox\" name=\"testCheckBox\" checked=\"checked\" /> Something<br/>\n>         <input type=\"submit\" value=\"Submit\" />\n>     </form>\n>     </body>\n> </html>\n> ```\n> When submiting from Firefox it sends to sever: testCheckBox=on\n> Java code:\n> ```\n>     public static void main(String[] args)\n>     {\n>         final String html = \"<html>\\n\"\n>                             + \"    <head>\\n\"\n>                             + \"        <title>Test</title>\\n\"\n>                             + \"    </head>\\n\"\n>                             + \"    \\n\"\n>                             + \"    <body>\\n\"\n>                             + \"\\n\"\n>                             + \"    <form name=\\\"myForm\\\" method=\\\"POST\\\">\\n\"\n>                             + \"        <input type=\\\"checkbox\\\" name=\\\"testCheckBox\\\" checked=\\\"checked\\\" /> Something<br/>\\n\"\n>                             + \"\\n\"\n>                             + \"        <input type=\\\"submit\\\" value=\\\"Submit\\\" />\\n\"\n>                             + \"    </form>\\n\"\n>                             + \"\\n\"\n>                             + \"    </body>\\n\"\n>                             + \"</html>\";\n>         final Document document = Jsoup.parse(html);\n>         final FormElement formElement = (FormElement) document.select(\"form[name=myForm]\").first();\n>         for (Connection.KeyVal keyVal : formElement.formData())\n>         {\n>             System.out.println(keyVal.key() + \"=\" + keyVal.value());\n>         }\n>     }\n> ```\n> Output: testCheckBox=\n> Expected output: testCheckBox=on\n> Seems like Jsoup doesn't add default value which is sent by browsers. The \"submit()\" method from FormElement also uses \"formData()\" method to get form's submission parameters. By sending the empty String for checkbox the server acts as it's not checked when in fact it was checked.\n> Also while testing noticed that it doesn't check the checkbox'es at all. If there is checkbox with value, but not checked, it will get the value no matter what, for example:\n> ```\n>         <input type=\"checkbox\" name=\"textCheckBox2\" value=\"testVal\" /> \n> ```\n> This affects radio buttons as well. Not selected radion buttons should not be sent to server, but formData() add their values anyway.\n> I'm not sure if that's done on purpose, but submit() method will get wrong parameters for submission since not checked input value is not sent to server at all.\n> Moreover type button value and \"disabled\" inputs are not sent to server as well (by browsers).\n> Looked at the source, one extra else if before the final else in \"formData()\" method could solve this:\n> ```\n> else if (\"input\".equals(el.tagName())) {\n>                 // Not disabled? Ignore disabled inputs.\n>                 if(!el.hasAttr(\"disabled\")) {\n>                     // Deal with checkbox and radio (not checked should not be added to avoid sending to server)\n>                     if(\"checkbox\".equals(el.attr(\"type\")) || \"radio\".equals(el.attr(\"type\"))) {\n>                         // Checked, but no value? Default should be \"on\".\n>                         if(el.hasAttr(\"checked\") && !el.hasAttr(\"value\")) {\n>                             data.add(HttpConnection.KeyVal.create(name, \"on\"));\n>                         } \n>                         // Checked? Add it's value\n>                         else if(el.hasAttr(\"checked\")) {\n>                             data.add(HttpConnection.KeyVal.create(name, el.val()));\n>                         }\n>                     } \n>                     // Buttons should be ignored.\n>                     else if(!\"button\".equals(el.attr(\"type\"))){\n>                         data.add(HttpConnection.KeyVal.create(name, el.val()));\n>                     }\n>                 }\n>             }\n> ```\n> One more thing. If form has multiple type submit inputs, only the clicked input's value should be sent to server, but I have no idea how this could be implemented. Sending all submit input's values can change the server's logic and be bad (result not as expected).", "test_name": "org.jsoup.nodes.FormElementTest::createsFormData", "test_method": "    @Test public void createsFormData() {\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n                \"<input name='ten' value='text' disabled>\" +\n                \"</form>\";\n        Document doc = Jsoup.parse(html);\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(6, data.size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<6> but was:<7>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.jsoup.nodes.FormElementTest.createsFormData(FormElementTest.java:38)", "buggy_method": "74 public List<Connection.KeyVal> formData() {\n75         ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n76 \n77         // iterate the form control elements and accumulate their values\n78         for (Element el: elements) {\n79             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n80             String name = el.attr(\"name\");\n81             if (name.length() == 0) continue;\n82             String type = el.attr(\"type\");\n83 \n84             if (\"select\".equals(el.tagName())) {\n85                 Elements options = el.select(\"option[selected]\");\n86                 boolean set = false;\n87                 for (Element option: options) {\n88                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n89                     set = true;\n90                 }\n91                 if (!set) {\n92                     Element option = el.select(\"option\").first();\n93                     if (option != null)\n94                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n95                 }\n96             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n97                 // only add checkbox or radio if they have the checked attribute\n98                 if (el.hasAttr(\"checked\")) {\n99                     final String val = el.val();\n100                     data.add(HttpConnection.KeyVal.create(name, val));\n101                 }\n102             } else {\n103                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n104             }\n105         }\n106         return data;\n107     }", "bm_classpath": "org.jsoup.nodes.FormElement"}, {"bug_name": "Jsoup_43", "report_text": "> Unexpected behavior in elementSiblingIndex\n> \n> The documentation for elementSiblingIndex states \"Get the list index of this element in its element sibling list. I.e. if this is the first element sibling, returns 0\".\n> This would imply that if\n> ```\n> n=myElem.elementSiblingIndex();\n> ```\n> then\n> ```\n> myElem.parent().children().get(n)==myElem.  \n> ```\n> However, this is not how elementSiblingIndex behaves. What is guaranteed is that\n> ```\n> myElem.parent().children().get(n).equals(myElem).  \n> ```\n> For example, if both row 2 and row 5 of a table are\n> ```\n> <tr><td>Cell1</td><td>Cell2</td></tr>\n> ```\n> then the Element object associated with both rows will have the same `elementSiblingIndex()`.", "test_name": "org.jsoup.nodes.ElementTest::testElementSiblingIndexSameContent", "test_method": "    @Test public void testElementSiblingIndexSameContent() {\n        Document doc = Jsoup.parse(\"<div><p>One</p>...<p>One</p>...<p>One</p>\");\n        Elements ps = doc.select(\"p\");\n        assertTrue(1 == ps.get(1).elementSiblingIndex()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.nodes.ElementTest.testElementSiblingIndexSameContent(ElementTest.java:156)", "buggy_method": "568 private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n569         Validate.notNull(search);\n570         Validate.notNull(elements);\n571 \n572         for (int i = 0; i < elements.size(); i++) {\n573             E element = elements.get(i);\n574             if (element.equals(search))\n575                 return i;\n576         }\n577         return null;\n578     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_44", "report_text": "> Unexpected elements inside table are moved to wrong location\n> \n> This commit [e991936](https://github.com/jhy/jsoup/commit/e99193605b688e923d20054c13db897cff751607) introduced a bug where handling of unexpected elements inside a table element changed, resulting in the unexpected elements being pushed further up the document than before.\n> I have constructed a minimal repro. Before the commit in question, the unexpected p tag would continue to be positioned after the comment (with some elements being closed early etc. to support this). After the commit, the p tag and its contents are moved up more than one table level, and now appear after the comment tag.\n> Obviously this input HTML is very broken and bad, but it seems that the change in behaviour was unintended.\n> copying [@jaredstehler](https://github.com/jaredstehler)\n> ```\n> @Test\n> public void testInvalidTableContents() throws IOException {\n>     File in = getFile(\"/htmltests/table-invalid-elements.html\");\n>     Document doc = Jsoup.parse(in, \"UTF-8\");\n>     doc.outputSettings().prettyPrint(true);\n>     String rendered = doc.toString();\n>     int endOfEmail = rendered.indexOf(\"Comment\");\n>     int guarantee = rendered.indexOf(\"Why am I here?\");\n>     assertTrue(\"Comment not found\", endOfEmail > -1);\n>     assertTrue(\"Search text not found\", guarantee > -1);\n>     assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail);\n> }\n> ```\n> Uses the following fixture:\n> ```\n> <html>\n>     <body>\n>         <table>\n>             <tr>\n>                 <td>\n>                     <table>\n>                         <tr>\n>                             <!--Comment-->\n>                             <table>\n>                                 <p>Why am I here?</p>\n>                         </tr>\n>                     </table>\n>                 </td>\n>             </tr>\n>         </table>\n>     </body>\n> </html>\n> ```", "test_name": "org.jsoup.parser.HtmlParserTest::testInvalidTableContents", "test_method": "    @Test\n    public void testInvalidTableContents() throws IOException {\n        File in = ParseTest.getFile(\"/htmltests/table-invalid-elements.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\");\n        doc.outputSettings().prettyPrint(true);\n        String rendered = doc.toString();\n        int endOfEmail = rendered.indexOf(\"Comment\");\n        int guarantee = rendered.indexOf(\"Why am I here?\");\n        assertTrue(\"Search text did not come after comment\", guarantee > endOfEmail); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Search text did not come after comment\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.jsoup.parser.HtmlParserTest.testInvalidTableContents(HtmlParserTest.java:864)", "buggy_method": "60 protected boolean processStartTag(String name) {\n61         return process(start.reset().name(name));\n62     }", "bm_classpath": "org.jsoup.parser.TreeBuilder"}, {"bug_name": "Jsoup_45", "report_text": "> [There is no report available for this bug.]", "test_name": "org.jsoup.parser.HtmlParserTest::testReinsertionModeForThCelss", "test_method": "    @Test public void testReinsertionModeForThCelss() {\n        String body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\n        Document doc = Jsoup.parse(body);\n        assertEquals(1, doc.body().children().size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<5>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.jsoup.parser.HtmlParserTest.testReinsertionModeForThCelss(HtmlParserTest.java:877)", "buggy_method": "382 void resetInsertionMode() {\n383         boolean last = false;\n384         for (int pos = stack.size() -1; pos >= 0; pos--) {\n385             Element node = stack.get(pos);\n386             if (pos == 0) {\n387                 last = true;\n388                 node = contextElement;\n389             }\n390             String name = node.nodeName();\n391             if (\"select\".equals(name)) {\n392                 transition(HtmlTreeBuilderState.InSelect);\n393                 break; // frag\n394             } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n395                 transition(HtmlTreeBuilderState.InCell);\n396                 break;\n397             } else if (\"tr\".equals(name)) {\n398                 transition(HtmlTreeBuilderState.InRow);\n399                 break;\n400             } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n401                 transition(HtmlTreeBuilderState.InTableBody);\n402                 break;\n403             } else if (\"caption\".equals(name)) {\n404                 transition(HtmlTreeBuilderState.InCaption);\n405                 break;\n406             } else if (\"colgroup\".equals(name)) {\n407                 transition(HtmlTreeBuilderState.InColumnGroup);\n408                 break; // frag\n409             } else if (\"table\".equals(name)) {\n410                 transition(HtmlTreeBuilderState.InTable);\n411                 break;\n412             } else if (\"head\".equals(name)) {\n413                 transition(HtmlTreeBuilderState.InBody);\n414                 break; // frag\n415             } else if (\"body\".equals(name)) {\n416                 transition(HtmlTreeBuilderState.InBody);\n417                 break;\n418             } else if (\"frameset\".equals(name)) {\n419                 transition(HtmlTreeBuilderState.InFrameset);\n420                 break; // frag\n421             } else if (\"html\".equals(name)) {\n422                 transition(HtmlTreeBuilderState.BeforeHead);\n423                 break; // frag\n424             } else if (last) {\n425                 transition(HtmlTreeBuilderState.InBody);\n426                 break; // frag\n427             }\n428         }\n429     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_46", "report_text": "> EscapeMode.xhtml no longer falls back to numeric escapes - Can cause '?' replacement in output\n> \n> I've been using EscapeMode.xhtml with JSoup to avoid encoding things which don't (from my perspective) need to be encoded, like egrave in a UTF-8 document for example.\n> While upgrading from JSoup 1.7.2 to 1.8.1 however, I've noticed a problem with a shift-jis related test I have. Here's a simplified/reduced version.\n> ```\n> package test;\n> import java.io.ByteArrayInputStream;\n> import java.io.InputStream;\n> import java.nio.charset.Charset;\n> import org.jsoup.Jsoup;\n> import org.jsoup.nodes.Document;\n> import org.jsoup.nodes.Entities.EscapeMode;\n> import org.junit.Assert;\n> import org.junit.Test;\n> public class ShiftJisTest {\n>     @Test\n>     public void testShiftJisRoundtrip() throws Exception {\n>         String input = \n>             \"<html>\"\n>           +   \"<head>\"\n>           +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n>           +   \"</head>\"\n>           +   \"<body>\"\n>           +     \"before&nbsp;after\"\n>           +   \"</body>\"\n>           + \"</html>\";\n>         InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n>         Document doc = Jsoup.parse(is, null, \"http://example.com\");\n>         doc.outputSettings().escapeMode(EscapeMode.xhtml);\n>         String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n>         System.out.println(output);\n>         Assert.assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\"));\n>         Assert.assertTrue(\"Should have contained a '&#xa0;' or a '&nbsp;'.\", \n>             output.contains(\"&#xa0;\") || output.contains(\"&nbsp;\"));\n>     }\n> }\n> ```\n> Under JSoup 1.7.2, the body of the output in this test is \"before\u00a0after\" (which looks as expected when rendered in Firefox), where as under 1.8.1 it is \"before?after\".\n> I assume the issue here is that I've asked JSoup to escape only XHTML characters (i.e. not nbsp), and it's producing a charset where (I assume) there's no character to represent 'non-breaking space'.\n> The upshot of this is that, as a result of upgrading JSoup, I end up with '?' replaced in for what used to be shown as a non breaking space.\n> It seems like the old behaviour was to fall back to providing an escaped numeric character (odd if there's no valid character for that in Shift\\_JIS, but it still rendered correctly). From my perspective, the old behaviour was better - Is there any way it can be reinstated (or an escape mode provided for it)?\n> Obviously using EscapeMode.base instead of EscapeMode.xhtml is a possible workaround, however I would really prefer not to have characters unnecessarily escaped if possible.", "test_name": "org.jsoup.nodes.DocumentTest::testShiftJisRoundtrip", "test_method": "    @Test\n    public void testShiftJisRoundtrip() throws Exception {\n        String input =\n                \"<html>\"\n                        +   \"<head>\"\n                        +     \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=Shift_JIS\\\" />\"\n                        +   \"</head>\"\n                        +   \"<body>\"\n                        +     \"before&nbsp;after\"\n                        +   \"</body>\"\n                        + \"</html>\";\n        InputStream is = new ByteArrayInputStream(input.getBytes(Charset.forName(\"ASCII\")));\n\n        Document doc = Jsoup.parse(is, null, \"http://example.com\");\n        doc.outputSettings().escapeMode(Entities.EscapeMode.xhtml);\n\n        String output = new String(doc.html().getBytes(doc.outputSettings().charset()), doc.outputSettings().charset());\n\n        assertFalse(\"Should not have contained a '?'.\", output.contains(\"?\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Should not have contained a '?'.\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertFalse(Assert.java:64)\n\torg.jsoup.nodes.DocumentTest.testShiftJisRoundtrip(DocumentTest.java:406)", "buggy_method": "79 static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n80                        boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n81 \n82         boolean lastWasWhite = false;\n83         boolean reachedNonWhite = false;\n84         final EscapeMode escapeMode = out.escapeMode();\n85         final CharsetEncoder encoder = out.encoder();\n86         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n87         final Map<Character, String> map = escapeMode.getMap();\n88         final int length = string.length();\n89 \n90         int codePoint;\n91         for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n92             codePoint = string.codePointAt(offset);\n93 \n94             if (normaliseWhite) {\n95                 if (StringUtil.isWhitespace(codePoint)) {\n96                     if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n97                         continue;\n98                     accum.append(' ');\n99                     lastWasWhite = true;\n100                     continue;\n101                 } else {\n102                     lastWasWhite = false;\n103                     reachedNonWhite = true;\n104                 }\n105             }\n106             // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n107             if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n108                 final char c = (char) codePoint;\n109                 // html specific and required escapes:\n110                 switch (c) {\n111                     case '&':\n112                         accum.append(\"&amp;\");\n113                         break;\n114                     case 0xA0:\n115                         if (escapeMode != EscapeMode.xhtml)\n116                             accum.append(\"&nbsp;\");\n117                         else\n118                             accum.append(c);\n119                         break;\n120                     case '<':\n121                         if (!inAttribute)\n122                             accum.append(\"&lt;\");\n123                         else\n124                             accum.append(c);\n125                         break;\n126                     case '>':\n127                         if (!inAttribute)\n128                             accum.append(\"&gt;\");\n129                         else\n130                             accum.append(c);\n131                         break;\n132                     case '\"':\n133                         if (inAttribute)\n134                             accum.append(\"&quot;\");\n135                         else\n136                             accum.append(c);\n137                         break;\n138                     default:\n139                         if (canEncode(coreCharset, c, encoder))\n140                             accum.append(c);\n141                         else if (map.containsKey(c))\n142                             accum.append('&').append(map.get(c)).append(';');\n143                         else\n144                             accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n145                 }\n146             } else {\n147                 final String c = new String(Character.toChars(codePoint));\n148                 if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n149                     accum.append(c);\n150                 else\n151                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n152             }\n153         }\n154     }", "bm_classpath": "org.jsoup.nodes.Entities"}, {"bug_name": "Jsoup_47", "report_text": "> Jsoup not retaining &lt in data attributes\n> \n> Jsoup not retaining &lt in data attributes value if there is <\n> In the example below &lt; is converted to < in the output after parsing.  \n> Please let me know how to retain it.  \n> Example:  \n> <http://notes.io/Gww>  \n> [@uggedal](https://github.com/uggedal)  \n> @krystiangor  \n> [@tc](https://github.com/tc)  \n> [@bbeck](https://github.com/bbeck)", "test_name": "org.jsoup.nodes.EntitiesTest::escapesGtInXmlAttributesButNotInHtml", "test_method": "    @Test public void escapesGtInXmlAttributesButNotInHtml() {\n        // https://github.com/jhy/jsoup/issues/528 - < is OK in HTML attribute values, but not in XML\n\n\n        String docHtml = \"<a title='<p>One</p>'>One</a>\";\n        Document doc = Jsoup.parse(docHtml);\n        Element element = doc.select(\"a\").first();\n\n        doc.outputSettings().escapeMode(base);\n\n        doc.outputSettings().escapeMode(xhtml);\n        assertEquals(\"<a title=\\\"&lt;p>One&lt;/p>\\\">One</a>\", element.outerHtml()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<a title=\"[&lt;p>One&lt;]/p>\">One</a>> but was:<<a title=\"[<p>One<]/p>\">One</a>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.EntitiesTest.escapesGtInXmlAttributesButNotInHtml(EntitiesTest.java:102)", "buggy_method": "79 static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n80                        boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n81 \n82         boolean lastWasWhite = false;\n83         boolean reachedNonWhite = false;\n84         final EscapeMode escapeMode = out.escapeMode();\n85         final CharsetEncoder encoder = out.encoder();\n86         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n87         final Map<Character, String> map = escapeMode.getMap();\n88         final int length = string.length();\n89 \n90         int codePoint;\n91         for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n92             codePoint = string.codePointAt(offset);\n93 \n94             if (normaliseWhite) {\n95                 if (StringUtil.isWhitespace(codePoint)) {\n96                     if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n97                         continue;\n98                     accum.append(' ');\n99                     lastWasWhite = true;\n100                     continue;\n101                 } else {\n102                     lastWasWhite = false;\n103                     reachedNonWhite = true;\n104                 }\n105             }\n106             // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n107             if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n108                 final char c = (char) codePoint;\n109                 // html specific and required escapes:\n110                 switch (c) {\n111                     case '&':\n112                         accum.append(\"&amp;\");\n113                         break;\n114                     case 0xA0:\n115                         if (escapeMode != EscapeMode.xhtml)\n116                             accum.append(\"&nbsp;\");\n117                         else\n118                             accum.append(\"&#xa0;\");\n119                         break;\n120                     case '<':\n121                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n122                         if (!inAttribute)\n123                             accum.append(\"&lt;\");\n124                         else\n125                             accum.append(c);\n126                         break;\n127                     case '>':\n128                         if (!inAttribute)\n129                             accum.append(\"&gt;\");\n130                         else\n131                             accum.append(c);\n132                         break;\n133                     case '\"':\n134                         if (inAttribute)\n135                             accum.append(\"&quot;\");\n136                         else\n137                             accum.append(c);\n138                         break;\n139                     default:\n140                         if (canEncode(coreCharset, c, encoder))\n141                             accum.append(c);\n142                         else if (map.containsKey(c))\n143                             accum.append('&').append(map.get(c)).append(';');\n144                         else\n145                             accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n146                 }\n147             } else {\n148                 final String c = new String(Character.toChars(codePoint));\n149                 if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n150                     accum.append(c);\n151                 else\n152                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n153             }\n154         }\n155     }", "bm_classpath": "org.jsoup.nodes.Entities"}, {"bug_name": "Jsoup_48", "report_text": "> A small bug for duplicate tuple in response header\n> \n> for response headers have duplicate tuple\uff0c  \n> in this case  \n> X-Powered-By:PHP/5.2.8  \n> X-Powered-By:ASP.NET\n> Jsoup can only get the second one  \n> if I run header\uff08\u201cX-powered-by\u201d\uff09  \n> I got Asp.NET\n> URL\uff1a<http://01pt.com/>\n> Cache-Control:no-store, no-cache, must-revalidate, post-check=0, pre-check=0  \n> Content-Encoding:gzip  \n> Content-Length:16224  \n> Content-Type:text/html;charset=gb2312  \n> Date:Thu, 27 Aug 2015 09:22:40 GMT  \n> Expires:Thu, 19 Nov 1981 08:52:00 GMT  \n> Pragma:no-cache  \n> Server:Microsoft-IIS/7.5  \n> Vary:Accept-Encoding  \n> X-Powered-By:PHP/5.2.8  \n> X-Powered-By:ASP.NET\n> The bug is because  \n> if (!values.isEmpty()) header(name, values.get(0));\n> I change it to  \n> if (!values.isEmpty()) {  \n> String val = \"\";  \n> for(String str: values) {  \n> val = val.concat(str).concat(\" \");\n> ```\n>                     }\n>                     header(name, val);\n>               }\n> ```\n> then I am able to get \u201cPHP/5.2.8 ASP.NET\u201d when I run header\uff08\u201cX-powered-by\u201d\uff09\n> void processResponseHeaders(Map<String, List> resHeaders) {  \n> for (Map.Entry<String, List> entry : resHeaders.entrySet()) {  \n> String name = entry.getKey();  \n> if (name == null)  \n> continue; // http/1.1 line\n> ```\n>             List<String> values = entry.getValue();\n>             if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n>                 for (String value : values) {\n>                     if (value == null)\n>                         continue;\n>                     TokenQueue cd = new TokenQueue(value);\n>                     String cookieName = cd.chompTo(\"=\").trim();\n>                     String cookieVal = cd.consumeTo(\";\").trim();\n>                     // ignores path, date, domain, validateTLSCertificates et al. req'd?\n>                     // name not blank, value not null\n>                     if (cookieName.length() > 0)\n>                         cookie(cookieName, cookieVal);\n>                 }\n>             } else { // only take the first instance of each header\n>                 if (!values.isEmpty())\n>                     header(name, values.get(0));\n>             }\n>         }\n>     }\n> ```", "test_name": "org.jsoup.helper.HttpConnectionTest::sameHeadersCombineWithComma", "test_method": "    @Test public void sameHeadersCombineWithComma() {\n        Map<String, List<String>> headers = new HashMap<String, List<String>>();\n        List<String> values = new ArrayList<String>();\n        values.add(\"no-cache\");\n        values.add(\"no-store\");\n        headers.put(\"Cache-Control\", values);\n        HttpConnection.Response res = new HttpConnection.Response();\n        res.processResponseHeaders(headers);\n        assertEquals(\"no-cache, no-store\", res.header(\"Cache-Control\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<no-cache[, no-store]> but was:<no-cache[]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.HttpConnectionTest.sameHeadersCombineWithComma(HttpConnectionTest.java:63)", "buggy_method": "753 void processResponseHeaders(Map<String, List<String>> resHeaders) {\n754             for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n755                 String name = entry.getKey();\n756                 if (name == null)\n757                     continue; // http/1.1 line\n758 \n759                 List<String> values = entry.getValue();\n760                 if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n761                     for (String value : values) {\n762                         if (value == null)\n763                             continue;\n764                         TokenQueue cd = new TokenQueue(value);\n765                         String cookieName = cd.chompTo(\"=\").trim();\n766                         String cookieVal = cd.consumeTo(\";\").trim();\n767                         // ignores path, date, domain, validateTLSCertificates et al. req'd?\n768                         // name not blank, value not null\n769                         if (cookieName.length() > 0)\n770                             cookie(cookieName, cookieVal);\n771                     }\n772                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n773                     if (!values.isEmpty())\n774                         header(name, values.get(0));\n775                 }\n776             }\n777         }", "bm_classpath": "org.jsoup.helper.HttpConnection$Response"}, {"bug_name": "Jsoup_49", "report_text": "> Bug in Element.insertChildren()\n> \n> When using org.jsoup.nodes.Element.insertChildren(int, Collection<? extends Node>) to move (more than one!) child-elements from one parent-element to the same parent, but different index then it produces wrong results.\n> The problem is that the first Element's 'move' leaves the siblingIndex unchanged and then the second 'move' removes a wrong element and produces some crap. Maybe calling reindexChildren() inside the loop in addChildren() fixes this.  \n> Version 1.8.3.  \n> Workaround: call remove() on the elements before passing them to insertChildren()\n> Easy Test Case:\n> ```\n>     @Test\n>     public void mustCorrectlyMoveChildrenInsideOneParentElement() {\n>         Document doc = new Document( \"\" );\n>         Element body = doc.appendElement( \"body\" );\n>         body.appendElement( \"div1\" );\n>         body.appendElement( \"div2\" );\n>         Element div3 = body.appendElement( \"div3\" );\n>         Element div4 = body.appendElement( \"div4\" );\n>         ArrayList<Element> toMove = new ArrayList<Element>() {\n>             {\n>                 add( div3 );\n>                 add( div4 );\n>             }\n>         };\n>         body.insertChildren( 0, toMove );\n>         String result = doc.toString().replaceAll( \"\\\\s+\", \"\" );\n>         assertEquals( \"<body><div3></div3><div4></div4><div1></div1><div2></div2></body>\", result );\n>     }\n> ```", "test_name": "org.jsoup.nodes.ElementTest::appendMustCorrectlyMoveChildrenInsideOneParentElement", "test_method": "    @Test\n    public void appendMustCorrectlyMoveChildrenInsideOneParentElement() {\n        Document doc = new Document(\"\");\n        Element body = doc.appendElement(\"body\");\n        body.appendElement(\"div1\");\n        body.appendElement(\"div2\");\n        final Element div3 = body.appendElement(\"div3\");\n        div3.text(\"Check\");\n        final Element div4 = body.appendElement(\"div4\");\n\n        ArrayList<Element> toMove = new ArrayList<Element>();\n        toMove.add(div3);\n        toMove.add(div4);\n\n        body.insertChildren(0, toMove);\n\n        String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n        assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...><div3>Check</div3><[div4></div4><div1></div1><div2></div2><]/body>> but was:<...><div3>Check</div3><[]/body>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.appendMustCorrectlyMoveChildrenInsideOneParentElement(ElementTest.java:878)", "buggy_method": "438 protected void addChildren(int index, Node... children) {\n439         Validate.noNullElements(children);\n440         ensureChildNodes();\n441         for (int i = children.length - 1; i >= 0; i--) {\n442             Node in = children[i];\n443             reparentChild(in);\n444             childNodes.add(index, in);\n445         }\n446         reindexChildren(index);\n447     }", "bm_classpath": "org.jsoup.nodes.Node"}, {"bug_name": "Jsoup_50", "report_text": "> UTF16 streams with BOM are processed as UTF-8\n> \n> The handling of the character encoding in org.jsoup.helper.DataUtil.parseByteData(...) is bugged when the input is an UTF16 stream with unicode BOM. This method does a check for presence of a BOM and, if it finds one, incorrectly assumes that this was a UTF-8 BOM. To fix this, the code would have to check the raw BOM bytes as the distinction between the various BOMs is lost after conversion to characters. See also: <http://unicode.org/faq/utf_bom.html#bom4>", "test_name": "org.jsoup.helper.DataUtilTest::supportsBOMinFiles", "test_method": "    @Test\n    public void supportsBOMinFiles() throws IOException {\n        // test files from http://www.i18nl10n.com/korean/utftest/\n        File in = getFile(\"/bomtests/bom_utf16be.html\");\n        Document doc = Jsoup.parse(in, null, \"http://example.com\");\n        assertTrue(doc.title().contains(\"UTF-16BE\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.helper.DataUtilTest.supportsBOMinFiles(DataUtilTest.java:109)", "buggy_method": "88 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n89         String docData;\n90         Document doc = null;\n91 \n92         // look for BOM - overrides any other header or input\n93 \n94         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n95             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n96             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n97             doc = parser.parseInput(docData, baseUri);\n98             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n99             if (meta != null) { // if not found, will keep utf-8 as best attempt\n100                 String foundCharset = null;\n101                 if (meta.hasAttr(\"http-equiv\")) {\n102                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n103                 }\n104                 if (foundCharset == null && meta.hasAttr(\"charset\")) {\n105                     try {\n106                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n107                             foundCharset = meta.attr(\"charset\");\n108                         }\n109                     } catch (IllegalCharsetNameException e) {\n110                         foundCharset = null;\n111                     }\n112                 }\n113 \n114                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n115                     foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n116                     charsetName = foundCharset;\n117                     byteData.rewind();\n118                     docData = Charset.forName(foundCharset).decode(byteData).toString();\n119                     doc = null;\n120                 }\n121             }\n122         } else { // specified by content type header (or by user on file load)\n123             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n124             docData = Charset.forName(charsetName).decode(byteData).toString();\n125         }\n126         if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n127             byteData.rewind();\n128             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n129             docData = docData.substring(1);\n130             charsetName = defaultCharset;\n131             doc = null;\n132         }\n133         if (doc == null) {\n134             doc = parser.parseInput(docData, baseUri);\n135             doc.outputSettings().charset(charsetName);\n136         }\n137         return doc;\n138     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_51", "report_text": "> Problem in reading XML file containing Japanese tag names\n> \n> Hello,  \n> I have XML file containing Japanese tag names and values.  \n> JSOUP is not parsing this Japanese tags.  \n> I am using JSOUP library (version: 1.8.3).  \n> Please help me to solve this issue.\n> ---\n> e.g. ( XML File to reproduce problem )\n> <\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>  \n> <\u958b\u59cb\u4e88\u5b9a\u51e1\u4f8b\u540d \u8868\u793a\u72b6\u614b=\"0\" \u7dda\u8272=\"00CED1\">&#9312;&#35373;&#35336; &#38283;&#22987;&#20104;&#23450;</\u958b\u59cb\u4e88\u5b9a\u51e1\u4f8b\u540d>\n> </\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>\n> ----------\n> //// \\*\\*\\*\\* Source Code \\*\\*\\*\\*\\*\\*  \n> Document doc = Jsoup.parse(XMLString.toString(),\"UTF-8\",Parser.xmlParser());  \n> Elements objElementCollection = doc.getAllElements();\n> int iElementsSize=objElementCollection.size();\n> for(Element objCurrent : objElementCollection)  \n> {  \n> String szTag=objCurrent.tagName();\n> ```\n>     for (TextNode tnTextNode : objCurrent.textNodes()) \n>     {\n>         String szVal=tnTextNode.text();\n>     }\n> ```\n> }", "test_name": "org.jsoup.parser.HtmlParserTest::testSupportsNonAsciiTags", "test_method": "    @Test public void testSupportsNonAsciiTags() {\n        String body = \"<\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>Yes</\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5>\";\n        Document doc = Jsoup.parse(body);\n        Elements els = doc.select(\"\u9032\u6357\u63a8\u79fb\u30b0\u30e9\u30d5\");\n        assertEquals(\"Yes\", els.text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[Yes]> but was:<[]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.testSupportsNonAsciiTags(HtmlParserTest.java:891)", "buggy_method": "296 boolean matchesLetter() {\n297         if (isEmpty())\n298             return false;\n299         char c = input[pos];\n300         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n301     }", "bm_classpath": "org.jsoup.parser.CharacterReader"}, {"bug_name": "Jsoup_52", "report_text": "> Should detect ?xml encoding charset\n> \n> Hi,\n> For example this is target URL: <http://www.elacontecer.com.uy/rss/hoy.xml>, its charset is `ISO-8859-1`.\n> I use Jsoup like this:\n> ```\n> final Document doc = Jsoup.connect(\"http://...\").parser(Parser.xmlParser()).get();\n> System.out.println(\"charset=\" + doc.charset());\n> ```\n> The result is: `java.nio.charset.CharsetICU[UTF-8]`\n> Would you please check to see if it's a bug?\n> Thanks,", "test_name": "org.jsoup.nodes.DocumentTest::testMetaCharsetUpdateXmlNoCharset", "test_method": "    @Test\n    public void testMetaCharsetUpdateXmlNoCharset() {\n        final Document doc = createXmlDocument(\"1.0\", \"none\", false);\n        doc.updateMetaCharsetElement(true);\n        doc.charset(Charset.forName(charsetUtf8));\n        \n        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\"?>\\n\" +\n                                        \"<root>\\n\" +\n                                        \" node\\n\" +\n                                        \"</root>\";\n        assertEquals(xmlCharsetUTF8, doc.toString()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<....0\" encoding=\"UTF-8\"[?]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.DocumentTest.testMetaCharsetUpdateXmlNoCharset(DocumentTest.java:355)", "buggy_method": "94 static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n95         String docData;\n96         Document doc = null;\n97 \n98         // look for BOM - overrides any other header or input\n99         charsetName = detectCharsetFromBom(byteData, charsetName);\n100 \n101         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n102             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n103             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n104             doc = parser.parseInput(docData, baseUri);\n105             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n106             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n107             if (meta != null) {\n108                 if (meta.hasAttr(\"http-equiv\")) {\n109                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n110                 }\n111                 if (foundCharset == null && meta.hasAttr(\"charset\")) {\n112                     try {\n113                         if (Charset.isSupported(meta.attr(\"charset\"))) {\n114                     foundCharset = meta.attr(\"charset\");\n115                         }\n116                     } catch (IllegalCharsetNameException e) {\n117                         foundCharset = null;\n118                     }\n119                 }\n120             }\n121             // look for <?xml encoding='ISO-8859-1'?>\n122             if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n123                 XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n124                 if (prolog.name().equals(\"xml\")) {\n125                     foundCharset = prolog.attr(\"encoding\");\n126                 }\n127             }\n128             foundCharset = validateCharset(foundCharset);\n129 \n130             if (foundCharset != null && !foundCharset.equals(defaultCharset)) { // need to re-decode\n131                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n132                 charsetName = foundCharset;\n133                 byteData.rewind();\n134                 docData = Charset.forName(foundCharset).decode(byteData).toString();\n135                 doc = null;\n136             }\n137         } else { // specified by content type header (or by user on file load)\n138             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n139             docData = Charset.forName(charsetName).decode(byteData).toString();\n140         }\n141         if (doc == null) {\n142             doc = parser.parseInput(docData, baseUri);\n143             doc.outputSettings().charset(charsetName);\n144         }\n145         return doc;\n146     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_53", "report_text": "> Parse failed with org.jsoup.select.Selector$SelectorParseException when selector has unbalanced '(' or '[' or ')' or ']'\n> \n> Selector I am having as following div.card-content2:has(a.subtitle[title= MySubTitle:)]) OR a.title[title=MyTitle :] ]", "test_name": "org.jsoup.select.SelectorTest::attributeWithBrackets", "test_method": "    @Test public void attributeWithBrackets() {\n        String html = \"<div data='End]'>One</div> <div data='[Another)]]'>Two</div>\";\n        Document doc = Jsoup.parse(html);\n        assertEquals(\"One\", doc.select(\"div[data='End]'\").first().text()); // <-- fails here\n    }", "error_message": "org.jsoup.select.Selector$SelectorParseException: Could not parse query 'div[data='End]'': unexpected token at '''\n\torg.jsoup.select.QueryParser.findElements(QueryParser.java:196)\n\torg.jsoup.select.QueryParser.parse(QueryParser.java:65)\n\torg.jsoup.select.QueryParser.parse(QueryParser.java:39)\n\torg.jsoup.select.Selector.<init>(Selector.java:84)\n\torg.jsoup.select.Selector.select(Selector.java:106)\n\torg.jsoup.nodes.Element.select(Element.java:286)\n\torg.jsoup.select.SelectorTest.attributeWithBrackets(SelectorTest.java:668)", "buggy_method": "260 public String chompBalanced(char open, char close) {\n261         int start = -1;\n262         int end = -1;\n263         int depth = 0;\n264         char last = 0;\n265 \n266         do {\n267             if (isEmpty()) break;\n268             Character c = consume();\n269             if (last == 0 || last != ESC) {\n270                 if (c.equals(open)) {\n271                     depth++;\n272                     if (start == -1)\n273                         start = pos;\n274                 }\n275                 else if (c.equals(close))\n276                     depth--;\n277             }\n278 \n279             if (depth > 0 && last != 0)\n280                 end = pos; // don't include the outer match pair in the return\n281             last = c;\n282         } while (depth > 0);\n283         return (end >= 0) ? queue.substring(start, end) : \"\";\n284     }", "bm_classpath": "org.jsoup.parser.TokenQueue"}, {"bug_name": "Jsoup_54", "report_text": "> INVALID_CHARACTER_ERR when converting Document to W3C\n> \n> A recent ClearQuest version has an HTML generation bug, which is ignored by both Chrome and Internet Explorer. Jsoup.parse is also successful:\n> `org.jsoup.nodes.Document doc = Jsoup.parse(\"<html><head></head><body style=\\\"color: red\\\" \\\"></body></html>\");`\n> (Please note the single quotation mark at the end of the body start tag.)\n> But trying to convert this to a W3C document fails:\n> `new W3CDom().fromJsoup(doc);`\n> ```\n> Exception in thread \"main\" org.w3c.dom.DOMException: INVALID_CHARACTER_ERR: An invalid or illegal XML character is specified. \n>     at org.apache.xerces.dom.CoreDocumentImpl.createAttribute(Unknown Source)\n>     at org.apache.xerces.dom.ElementImpl.setAttribute(Unknown Source)\n>     at org.jsoup.helper.W3CDom$W3CBuilder.copyAttributes(W3CDom.java:124)\n>     at org.jsoup.helper.W3CDom$W3CBuilder.head(W3CDom.java:92)\n>     at org.jsoup.select.NodeTraversor.traverse(NodeTraversor.java:31)\n>     at org.jsoup.helper.W3CDom.convert(W3CDom.java:66)\n>     at org.jsoup.helper.W3CDom.fromJsoup(W3CDom.java:46)\n> ```\n> Perhaps copyAttributes() should ignore invalid attributes, or catch exactly this error, and ignore it, or W3CDom could have flags to ignore such errors...", "test_name": "org.jsoup.helper.W3CDomTest::handlesInvalidAttributeNames", "test_method": "    @Test\n    public void handlesInvalidAttributeNames() {\n        String html = \"<html><head></head><body style=\\\"color: red\\\" \\\" name\\\"></body></html>\";\n        org.jsoup.nodes.Document jsoupDoc;\n        jsoupDoc = Jsoup.parse(html);\n        Element body = jsoupDoc.select(\"body\").first();\n\n        Document w3Doc = new W3CDom().fromJsoup(jsoupDoc); // <-- fails here\n    }", "error_message": "org.w3c.dom.DOMException: INVALID_CHARACTER_ERR: An invalid or illegal XML character is specified.\n\tcom.sun.org.apache.xerces.internal.dom.CoreDocumentImpl.createAttribute(CoreDocumentImpl.java:611)\n\tcom.sun.org.apache.xerces.internal.dom.ElementImpl.setAttribute(ElementImpl.java:498)\n\torg.jsoup.helper.W3CDom$W3CBuilder.copyAttributes(W3CDom.java:126)\n\torg.jsoup.helper.W3CDom$W3CBuilder.head(W3CDom.java:92)\n\torg.jsoup.select.NodeTraversor.traverse(NodeTraversor.java:31)\n\torg.jsoup.helper.W3CDom.convert(W3CDom.java:66)\n\torg.jsoup.helper.W3CDom.fromJsoup(W3CDom.java:46)\n\torg.jsoup.helper.W3CDomTest.handlesInvalidAttributeNames(W3CDomTest.java:93)", "buggy_method": "122 private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n123             for (Attribute attribute : source.attributes()) {\n124                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n125                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n126                     el.setAttribute(key, attribute.getValue());\n127             }\n128         }", "bm_classpath": "org.jsoup.helper.W3CDom$W3CBuilder"}, {"bug_name": "Jsoup_55", "report_text": "> Parse slash in attibutes\n> \n> Hello,  \n> I don't know if it is a bug or not, but when I'm parsing:  \n> `<img /onerror=\"a()\"/>`\n> The result of the parsers is:  \n> `<img nerror=\"a()\"/>`  \n> Is it OK? can I change the parser behavior for those types of tags?", "test_name": "org.jsoup.parser.AttributeParseTest::dropsSlashFromAttributeName", "test_method": "    @Test public void dropsSlashFromAttributeName() {\n        String html = \"<img /onerror='doMyJob'/>\";\n        Document doc = Jsoup.parse(html);\n        assertTrue(\"SelfClosingStartTag ignores last character\", doc.select(\"img[onerror]\").size() != 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: SelfClosingStartTag ignores last character\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.jsoup.parser.AttributeParseTest.dropsSlashFromAttributeName(AttributeParseTest.java:97)", "buggy_method": "869 void read(Tokeniser t, CharacterReader r) {\n870             char c = r.consume();\n871             switch (c) {\n872                 case '>':\n873                     t.tagPending.selfClosing = true;\n874                     t.emitTagPending();\n875                     t.transition(Data);\n876                     break;\n877                 case eof:\n878                     t.eofError(this);\n879                     t.transition(Data);\n880                     break;\n881                 default:\n882                     t.error(this);\n883                     t.transition(BeforeAttributeName);\n884             }\n885         }", "bm_classpath": "org.jsoup.parser.TokeniserState"}, {"bug_name": "Jsoup_56", "report_text": "> Jsoup.parse seems to remove system identifier in DOCTYPE\n> \n> Specifically when I call:\n> ```\n> Document doc = Jsoup.parse(xhtml, \"\", Parser.xmlParser());\n> ```\n> on a xhtml document that has the following doctype:\n> ```\n> <!DOCTYPE html SYSTEM \"exampledtdfile.dtd\">\n> ```\n> I end up with the following result in the document (SYSTEM is now missing):\n> ```\n> <!DOCTYPE html \"exampledtdfile.dtd\"> \n> ```\n> But this works fine on a document with:\n> ```\n>  <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> \n> ```\n> Since SYSTEM is a proper way of declaring a DTD, I believe this is an issue with Jsoup.", "test_name": "org.jsoup.nodes.DocumentTypeTest::testRoundTrip", "test_method": "    @Test public void testRoundTrip() {\n        String base = \"<!DOCTYPE html>\";\n\n        String publicDoc = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\";\n\n        String systemDoc = \"<!DOCTYPE html SYSTEM \\\"exampledtdfile.dtd\\\">\";\n        assertEquals(systemDoc, htmlOutput(systemDoc)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<!DOCTYPE html [SYSTEM ]\"exampledtdfile.dtd\"...> but was:<<!DOCTYPE html []\"exampledtdfile.dtd\"...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.DocumentTypeTest.testRoundTrip(DocumentTypeTest.java:54)", "buggy_method": "26 public DocumentType(String name, String publicId, String systemId, String baseUri) {\n27         super(baseUri);\n28 \n29         attr(NAME, name);\n30         attr(PUBLIC_ID, publicId);\n31         attr(SYSTEM_ID, systemId);\n32     }", "bm_classpath": "org.jsoup.nodes.DocumentType"}, {"bug_name": "Jsoup_57", "report_text": "> removeIgnoreCase ConcurrentModificationException\n> \n> When testing out the removeIgnoreCase method, I'm now seeing a ConcurrentModificationException with code like: element.select(\"abc\").first().removeAttr(\"attr1\").removeAttr(\"attr2\");\n> It appears to be due to using a foreach loop over the LinkedHashMap to do the removal. Changing to do the removal directly with an iterator fixes this issue.  \n> Like so:\n> ```\n> for (Iterator<Map.Entry<String, Attribute>> iter = attributes.entrySet().iterator(); iter.hasNext();) {\n>             Map.Entry<String, Attribute> entry = iter.next();\n>             if (entry.getKey().equalsIgnoreCase(\"key1\")) {\n>                 iter.remove();\n>             }\n>         }\n> ```", "test_name": "org.jsoup.nodes.ElementTest::testChainedRemoveAttributes", "test_method": "    @Test\n    public void testChainedRemoveAttributes() {\n        String html = \"<a one two three four>Text</a>\";\n        Document doc = Jsoup.parse(html);\n        Element a = doc.select(\"a\").first();\n        a\n            .removeAttr(\"zero\")\n            .removeAttr(\"one\")\n            .removeAttr(\"two\")\n            .removeAttr(\"three\")\n            .removeAttr(\"four\")\n            .removeAttr(\"five\"); // <-- fails here\n    }", "error_message": "java.util.ConcurrentModificationException\n\tjava.util.LinkedHashMap$LinkedHashIterator.nextNode(LinkedHashMap.java:719)\n\tjava.util.LinkedHashMap$LinkedKeyIterator.next(LinkedHashMap.java:742)\n\torg.jsoup.nodes.Attributes.removeIgnoreCase(Attributes.java:123)\n\torg.jsoup.nodes.Node.removeAttr(Node.java:128)\n\torg.jsoup.nodes.ElementTest.testChainedRemoveAttributes(ElementTest.java:966)", "buggy_method": "118 public void removeIgnoreCase(String key) {\n119         Validate.notEmpty(key);\n120         if (attributes == null)\n121             return;\n122         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n123             String attrKey = it.next();\n124             if (attrKey.equalsIgnoreCase(key))\n125                 attributes.remove(attrKey);\n126         }\n127     }", "bm_classpath": "org.jsoup.nodes.Attributes"}, {"bug_name": "Jsoup_58", "report_text": "> Jsoup.isValid returns true even when htmlFragment includes tags not on whitelist\n> \n> Caused by Jsoup.isValid performing a destructive parse before testing for validity. The html returned from parseBodyFragment is not what was passed in.\n> According to documentation, html, head tags etc. should be specifically added to whitelist if they should be allowed.\n> Test cases below.\n> ```\n> package jsoup;\n> import junit.framework.Assert;\n> import org.jsoup.Jsoup;\n> import org.jsoup.nodes.Document;\n> import org.jsoup.parser.Parser;\n> import org.jsoup.safety.Cleaner;\n> import org.jsoup.safety.Whitelist;\n> import org.junit.Test;\n> import org.junit.runner.RunWith;\n> import org.junit.runners.Parameterized;\n> import java.util.Arrays;\n> import java.util.Collection;\n> @RunWith(Parameterized.class)\n> public class JsoupTest\n> {\n>     private String htmlFragment;\n>     public JsoupTest(String htmlFragment)\n>     {\n>         this.htmlFragment = htmlFragment;\n>     }\n>     @Parameterized.Parameters\n>     public static Collection<String[]> dirtyHtml()\n>     {\n>         String[][] htmlFragments = new String[][] { {\"<html></html>\"},\n>                                                     {\"<head></head>\"},\n>                                                     {\"<body></body>\"}\n>         };\n>         return Arrays.asList(htmlFragments);\n>     }\n>     @Test\n>     public void emptyWhitelistReturnsFalseForAllTags()\n>     {\n>         Assert.assertEquals(false, Jsoup.isValid(htmlFragment, new Whitelist()));\n>     }\n>     @Test\n>     public void whitelistNoneReturnsFalseForAllTags()\n>     {\n>         Assert.assertEquals(false, Jsoup.isValid(htmlFragment, Whitelist.none()));\n>     }\n>     @Test\n>     public void typicalWhitelistReturnsFalseForNonIncludedTags()\n>     {\n>         Whitelist whitelist = new Whitelist();\n>         whitelist.addTags(\"p\");\n>         Assert.assertEquals(false, Jsoup.isValid(htmlFragment, whitelist));\n>     }\n>     @Test\n>     public void codeFromSource()\n>     {\n>         Document dirty = Parser.parseBodyFragment(htmlFragment, \"\");\n>         Cleaner cleaner = new Cleaner(Whitelist.none());\n>         Assert.assertEquals(false, cleaner.isValid(dirty));\n>     }\n> }\n> ```", "test_name": "org.jsoup.safety.CleanerTest::testIsValidBodyHtml", "test_method": "    @Test public void testIsValidBodyHtml() {\n        String ok = \"<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>\";\n        String ok1 = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\"; // missing enforced is OK because still needs run thru cleaner\n        String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n        String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n        String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n        String nok4 = \"<html><head>Foo</head><body><b>OK</b></body></html>\"; // not body html\n        String nok5 = \"<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>\";\n        String nok6 = \"<p>Test <b><a href='http://example.com/'>OK</b></p>\"; // missing close tag\n        String nok7 = \"</div>What\";\n        assertFalse(Jsoup.isValid(nok4, Whitelist.basic())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertFalse(Assert.java:64)\n\torg.junit.Assert.assertFalse(Assert.java:74)\n\torg.jsoup.safety.CleanerTest.testIsValidBodyHtml(CleanerTest.java:160)", "buggy_method": "249 public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n250         return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n251     }", "bm_classpath": "org.jsoup.Jsoup"}, {"bug_name": "Jsoup_59", "report_text": "> Jsoup.clean control characters throws: IllegalArgumentException: String must not be empty\n> \n> I found that when running Jsoup.clean() on a string that contains the format below, Jsoup throws: `IllegalArgumentException: String must not be empty`.  \n> The problematic string format:  \n> `'<a/*>'`, (where \\* is a control char).  \n> i.e. `<` char followed by a letter (a-z), then any chars, `/` and any control char (ASCII 0-31) except 0, 9-10, 12-13, any chars, and a `>` char.", "test_name": "org.jsoup.parser.HtmlParserTest::handlesControlCodeInAttributeName", "test_method": "    @Test public void handlesControlCodeInAttributeName() {\n        Document doc = Jsoup.parse(\"<p><a \\06=foo>One</a><a/\\06=bar><a foo\\06=bar>Two</a></p>\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: String must not be empty\n\torg.jsoup.helper.Validate.notEmpty(Validate.java:92)\n\torg.jsoup.nodes.Attribute.<init>(Attribute.java:35)\n\torg.jsoup.parser.Token$Tag.newAttribute(Token.java:109)\n\torg.jsoup.parser.Token$Tag.finaliseTag(Token.java:128)\n\torg.jsoup.parser.Tokeniser.emitTagPending(Tokeniser.java:206)\n\torg.jsoup.parser.TokeniserState$40.read(TokeniserState.java:815)\n\torg.jsoup.parser.Tokeniser.read(Tokeniser.java:50)\n\torg.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:49)\n\torg.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:43)\n\torg.jsoup.parser.HtmlTreeBuilder.parse(HtmlTreeBuilder.java:56)\n\torg.jsoup.parser.Parser.parse(Parser.java:100)\n\torg.jsoup.Jsoup.parse(Jsoup.java:58)\n\torg.jsoup.parser.HtmlParserTest.handlesControlCodeInAttributeName(HtmlParserTest.java:946)", "buggy_method": "100 final void newAttribute() {\n101             if (attributes == null)\n102                 attributes = new Attributes();\n103 \n104             if (pendingAttributeName != null) {\n105                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n106                 pendingAttributeName = pendingAttributeName.trim();\n107                     Attribute attribute;\n108                     if (hasPendingAttributeValue)\n109                         attribute = new Attribute(pendingAttributeName,\n110                             pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n111                     else if (hasEmptyAttributeValue)\n112                         attribute = new Attribute(pendingAttributeName, \"\");\n113                     else\n114                         attribute = new BooleanAttribute(pendingAttributeName);\n115                     attributes.put(attribute);\n116             }\n117             pendingAttributeName = null;\n118             hasEmptyAttributeValue = false;\n119             hasPendingAttributeValue = false;\n120             reset(pendingAttributeValue);\n121             pendingAttributeValueS = null;\n122         }", "bm_classpath": "org.jsoup.parser.Token$Tag"}, {"bug_name": "Jsoup_60", "report_text": "> 1.10.1 failed a test while 1.8.3 passed for a contains query\n> \n> Today I tried to upgrade jsoup from 1.8.3 to 1.10.1, however, one of my unit test failed like this:\n> \"div.a-row.a-spacing-medium span.a-size-base:contains(I'll Ship & Pay)\"  \n> \"div.a-row.a-spacing-medium span.a-size-base:contains(I'll Send & Pay)\"  \n> \"div.a-row.a-spacing-medium span.a-color-price:contains(Varies)\"\n> Above are 3 css selectors and in a webpage that no such element exists, Jsoup selector find 9 elements, which broke my unit test. It seems like that the **contains** logic broke. I'm not sure whether **'** or **&** processing changed in newer version.\n> Can you have a look at this? For your reference I've attached the html page as a zip file.\n> [AmazonReturn.zip](https://github.com/jhy/jsoup/files/676839/AmazonReturn.zip)", "test_name": "org.jsoup.select.QueryParserTest::testParsesSingleQuoteInContains", "test_method": "@Test(expected = Selector.SelectorParseException.class)  public void testParsesSingleQuoteInContains() {\n        Evaluator parse = QueryParser.parse(\"p:contains(One \\\" One)\");\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.jsoup.select.Selector$SelectorParseException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "260 public String chompBalanced(char open, char close) {\n261         int start = -1;\n262         int end = -1;\n263         int depth = 0;\n264         char last = 0;\n265         boolean inQuote = false;\n266 \n267         do {\n268             if (isEmpty()) break;\n269             Character c = consume();\n270             if (last == 0 || last != ESC) {\n271                 if ((c.equals('\\'') || c.equals('\"')) && c != open)\n272                     inQuote = !inQuote;\n273                 if (inQuote)\n274                     continue;\n275                 if (c.equals(open)) {\n276                     depth++;\n277                     if (start == -1)\n278                         start = pos;\n279                 }\n280                 else if (c.equals(close))\n281                     depth--;\n282             }\n283 \n284             if (depth > 0 && last != 0)\n285                 end = pos; // don't include the outer match pair in the return\n286             last = c;\n287         } while (depth > 0);\n288         final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n289         return out;\n290     }", "bm_classpath": "org.jsoup.parser.TokenQueue"}, {"bug_name": "Jsoup_61", "report_text": "> Unexpected case sensitivity for CSS class selector\n> \n> Hi,  \n> i use JSoup version 1.10.2 and noticed an unexpected case sensitivity for a CSS class selector. I tried to parse the following HTML document with capitalized class attributes:\n> ```\n> <!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>\n> <HTML>\n>   <HEAD>\n>     <FORM Method='POST' name='Form' Action='Action'>\n>       <TABLE Class='Lst'>\n>         <TR Class='Lst'>\n>           <TH Class='Lst'>Header 1</TH>\n>           <TH Class='Lst'>Header 2</TH>\n>           <TH Class='Lst'>Header 3</TH>\n>         </TR>\n>         <TR Class='Lst1'>\n>           <TD Class='Lst'>Cell 1</TD>\n>           <TD Class='Lst'>Cell 2</TD>\n>           <TD Class='Lst'>Cell 3</TD>\n>         </TR>\n>       </TABLE>\n>     </FORM>\n>   </BODY>\n> </HTML>\n> ```\n> I wanted to select the table using the selector *\"html > body > form table.Lst\"* because I expected it to choose the table with the class attribute \"Lst\", but that did not work. The selector *\"html > body > form table[class=Lst]\"* works. Is this a bug?\n> Here is the parser code:\n> ```\n> try {\n>   final String htmlStr = \"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN' 'http://www.w3.org/TR/html4/loose.dtd'>\\n\"\n>       + \"<HTML>\\n\"\n>       + \" <HEAD>\\n\"\n>       + \" <FORM Method='POST' name='Form' Action='Action'>\\n\"\n>       + \" <TABLE Class='Lst'>\\n\"\n>       + \" <TR Class='Lst'>\\n\"\n>       + \" <TH Class='Lst'>Header 1</TH>\\n\"\n>       + \" <TH Class='Lst'>Header 2</TH>\\n\"\n>       + \" <TH Class='Lst'>Header 3</TH>\\n\"\n>       + \" </TR>\\n\"\n>       + \" <TR Class='Lst1'>\\n\"\n>       + \" <TD Class='Lst'>Cell 1</TD>\\n\"\n>       + \" <TD Class='Lst'>Cell 2</TD>\\n\"\n>       + \" <TD Class='Lst'>Cell 3</TD>\\n\"\n>       + \" </TR>\\n\"\n>       + \" </TABLE>\\n\"\n>       + \" </FORM>\\n\"\n>       + \" </BODY>\\n\"\n>       + \"</HTML>\";\n>   final Document htmlDoc = Jsoup.parse(htmlStr,\n>       \"\");\n>   final Element tableNotOk = htmlDoc.select(\"html > body > form table.Lst\")\n>       .first();\n>   final Element tableOk = htmlDoc.select(\"html > body > form table[class=Lst]\")\n>       .first();\n>   Logger.getLogger(this.getClass().getName())\n>       .log(Level.INFO,\n>           \"tableNotOk found: ''{0}'', tableOk found: ''{1}''\",\n>           new Object[]{(tableNotOk != null), (tableOk != null)});\n> } catch (UnsupportedCharsetException | ParseException | Selector.SelectorParseException ex) {\n>   Logger.getLogger(this.getClass().getName())\n>       .log(Level.SEVERE,\n>           null,\n>           ex);\n> }\n> ```", "test_name": "org.jsoup.select.ElementsTest::hasClassCaseInsensitive", "test_method": "    @Test public void hasClassCaseInsensitive() {\n        Elements els = Jsoup.parse(\"<p Class=One>One <p class=Two>Two <p CLASS=THREE>THREE\").select(\"p\");\n        Element one = els.get(0);\n        Element two = els.get(1);\n        Element thr = els.get(2);\n\n        assertTrue(one.hasClass(\"One\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.select.ElementsTest.hasClassCaseInsensitive(ElementsTest.java:104)", "buggy_method": "1091 public boolean hasClass(String className) {\n1092         final String classAttr = attributes.get(\"class\");\n1093         final int len = classAttr.length();\n1094         final int wantLen = className.length();\n1095 \n1096         if (len == 0 || len < wantLen) {\n1097             return false;\n1098         }\n1099 \n1100         // if both lengths are equal, only need compare the className with the attribute\n1101         if (len == wantLen) {\n1102             return className.equalsIgnoreCase(classAttr);\n1103         }\n1104 \n1105         // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n1106         boolean inClass = false;\n1107         int start = 0;\n1108         for (int i = 0; i < len; i++) {\n1109             if (Character.isWhitespace(classAttr.charAt(i))) {\n1110                 if (inClass) {\n1111                     // white space ends a class name, compare it with the requested one, ignore case\n1112                     if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n1113                         return true;\n1114                     }\n1115                     inClass = false;\n1116                 }\n1117             } else {\n1118                 if (!inClass) {\n1119                     // we're in a class name : keep the start of the substring\n1120                     inClass = true;\n1121                     start = i;\n1122                 }\n1123             }\n1124         }\n1125 \n1126         // check the last entry\n1127         if (inClass && len - start == wantLen) {\n1128             return classAttr.regionMatches(true, start, className, 0, wantLen);\n1129         }\n1130 \n1131         return false;\n1132     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_62", "report_text": "> Wrong parsing of case sensitive HTML\n> \n> Executing :\n> ```\n>         String xml=\"<r><X>A</X><y>B</y></r>\";\n> \tParser parser = Parser.htmlParser();\n> \tparser.settings(ParseSettings.preserveCase);\n> \torg.jsoup.nodes.Document _doc = parser.parseInput(xml, \"/\");\n> ```\n> Results in :  \n> <html>  \n> <head></head>  \n> <body>  \n> <r>  \n> <X>  \n> A  \n> <y>  \n> B  \n> </y>  \n> </X>  \n> </r>  \n> </body>  \n> </html>\n> Manual hacking : remove all .toLowerCase() invocations from Token.java (normalName=...)", "test_name": "org.jsoup.parser.HtmlParserTest::caseSensitiveParseTree", "test_method": "    @Test public void caseSensitiveParseTree() {\n        String html = \"<r><X>A</X><y>B</y></r>\";\n        Parser parser = Parser.htmlParser();\n        parser.settings(ParseSettings.preserveCase);\n        Document doc = parser.parseInput(html, \"\");\n        assertEquals(\"<r> <X> A </X> <y> B </y> </r>\", StringUtil.normaliseWhitespace(doc.body().html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<r> <X> A <[/X> <y> B </y]> </r>> but was:<<r> <X> A <[y> B </y> </X]> </r>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.caseSensitiveParseTree(HtmlParserTest.java:955)", "buggy_method": "763 boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n764             String name = t.asEndTag().normalName();\n765             ArrayList<Element> stack = tb.getStack();\n766             for (int pos = stack.size() -1; pos >= 0; pos--) {\n767                 Element node = stack.get(pos);\n768                 if (node.nodeName().equals(name)) {\n769                     tb.generateImpliedEndTags(name);\n770                     if (!name.equals(tb.currentElement().nodeName()))\n771                         tb.error(this);\n772                     tb.popStackToClose(name);\n773                     break;\n774                 } else {\n775                     if (tb.isSpecial(node)) {\n776                         tb.error(this);\n777                         return false;\n778                     }\n779                 }\n780             }\n781             return true;\n782         }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilderState"}, {"bug_name": "Jsoup_63", "report_text": "> Error: \"Self closing flag not acknowledged\" for self closing break\n> \n> This code snippet returns invalid html with the message: \"Self closing flag not acknowledged\"\n> ```\n> Jsoup.isValid(\"<p>test<br/>test</p>\")\n> ```\n> Why breaks could not be self closing?", "test_name": "org.jsoup.parser.HtmlParserTest::selfClosingOnNonvoidIsError", "test_method": "    @Test public void selfClosingOnNonvoidIsError() {\n        String html = \"<p>test</p><div /><div>Two</div>\";\n        Parser parser = Parser.htmlParser().setTrackErrors(5);\n        parser.parseInput(html, \"\");\n        assertEquals(\"18: Tag cannot be self closing; not a void tag\", parser.getErrors().get(0).toString()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<18: [Tag cannot be self closing; not a void tag]> but was:<18: [Self closing flag not acknowledged]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.selfClosingOnNonvoidIsError(HtmlParserTest.java:983)", "buggy_method": "221 Element insertEmpty(Token.StartTag startTag) {\n222         Tag tag = Tag.valueOf(startTag.name(), settings);\n223         Element el = new Element(tag, baseUri, startTag.attributes);\n224         insertNode(el);\n225         if (startTag.isSelfClosing()) {\n226             if (tag.isKnownTag()) {\n227                 if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag();\n228             }\n229             else {\n230                 tag.setSelfClosing();\n231                 tokeniser.acknowledgeSelfClosingFlag();\n232             }\n233         }\n234         return el;\n235     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_64", "report_text": "> Incorrect handling of self-closing tags noframes, style and title cause remainder of document to be html-escaped\n> \n> Given the input:\n> ```\n> <html>\n> <head>\n> \t<style />   <!-- < - - this is the culprit -->\n> </head>\n> <body>\n> \t<p>Whatever</p>\n> </body>\n> </html>\n> ```\n> JSoup 1.8.2 and also <http://try.jsoup.org/~lJwWpjXYUSTBeBZhdEnS3Mt56g4> will produce:\n> ```\n>     <html>\n>      <head> \n>       <style></style>\n>      </head>\n>      <body>\n>        &lt;/head&gt; &lt;body&gt; &lt;p&gt;Whatever&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;\n>      </body>\n>     </html>\n> ```\n> With `<title/>` instead of `<style/>`, the result is different but still wrong (<http://try.jsoup.org/~BZ3uoMki-r904fZxUOWJgLJO7r8> ):\n> ```\n> <html>\n>  <head> \n>   <title></title>\n>  </head>\n>  <body>\n>    &lt;/head&gt;  \n>   <p>Whatever</p>  \n>  </body>\n> </html>\n> ```\n> That weirdness was fixed for `<script>` with Issue [#305](https://github.com/jhy/jsoup/issues/305): <http://try.jsoup.org/~3Ms6TQCrrdaA_uPgxgURYYvwFAg>\n> ```\n> <html>\n>  <head> \n>   <script></script> \n>  </head> \n>  <body> \n>   <p>Whatever</p>  \n>  </body>\n> </html>\n> ```\n> Looking [at the source](https://github.com/jhy/jsoup/blob/master/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java#L106), it seems only the HtmlTreeBuilderState handling for `<noframes>`, `<style>` and `<title>` in the methods `handleRawText` and `handleRcData` doesn't get along with the self-closing tags.  \n> Any other tagname I've checked (and I tried to cover all branches of that `case StartTag` switch) results in a good parse similar to the `<script>` case, which is what I'd expect.\n> Thanks for looking into this!", "test_name": "org.jsoup.parser.HtmlParserTest::handlesKnownEmptyStyle", "test_method": "    @Test public void handlesKnownEmptyStyle() {\n        String h = \"<html><head><style /><meta name=foo></head><body>One</body></html>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"<html><head><style></style><meta name=\\\"foo\\\"></head><body>One</body></html>\", TextUtil.stripNewlines(doc.html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...ead><style></style><[meta name=\"foo\"></head><body>One]</body></html>> but was:<...ead><style></style><[/head><body>&lt;meta name=foo&gt;&lt;/head&gt;&lt;body&gt;One&lt;/body&gt;&lt;/html&gt;]</body></html>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.handlesKnownEmptyStyle(HtmlParserTest.java:376)", "buggy_method": "1488 private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n1489         tb.insert(startTag);\n1490         tb.tokeniser.transition(TokeniserState.Rawtext);\n1491         tb.markInsertionMode();\n1492         tb.transition(Text);\n1493     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilderState"}, {"bug_name": "Jsoup_65", "report_text": "> Parser error on <template> inside <tr>\n> \n> I've been experimenting with jsoup as a validator for TensorBoard code and I encountered a bug.\n> If I have code like this:\n> ```\n>           <tr>\n>             <th></th>\n>             <th>Name</th>\n>             <template is=\"dom-if\" if=\"{{smoothingEnabled}}\">\n>               <th>Smoothed</th>\n>             </template>   \n>             <th>Value</th>\n>             <th>Step</th>\n>             <th>Time</th>\n>             <th>Relative</th>\n>           </tr>\n> ```\n> I get errors like this:\n> ERROR: tensorflow/tensorboard/components/vz\\_line\\_chart/vz-line-chart.html (offset 1282): Unexpected token [StartTag] when in state [InTable]  \n> ERROR: tensorflow/tensorboard/components/vz\\_line\\_chart/vz-line-chart.html (offset 1338): Unexpected token [EndTag] when in state [InTable]  \n> ERROR: tensorflow/tensorboard/components/vz\\_line\\_chart/vz-line-chart.html (offset 1338): Unexpected token [EndTag] when in state [InBody]\n> Please note that those offset numbers point to the `<template>` tags.\n> Template tag is legal here because <https://www.w3.org/TR/html5/tabular-data.html#the-tr-element> says content model for `tr` is \"Zero or more td, th, and script-supporting elements\" and `template` is a script supporting element.", "test_name": "org.jsoup.parser.HtmlParserTest::testTemplateInsideTable", "test_method": "  @Test public void testTemplateInsideTable() throws IOException {\n        File in = ParseTest.getFile(\"/htmltests/table-polymer-template.html\");\n        Document doc = Jsoup.parse(in, \"UTF-8\");\n        doc.outputSettings().prettyPrint(true);\n\n        Elements templates = doc.body().getElementsByTag(\"template\");\n        for (Element template : templates) {\n            assertTrue(template.childNodes().size() > 1);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.parser.HtmlParserTest.testTemplateInsideTable(HtmlParserTest.java:1045)", "buggy_method": "359 void clearStackToTableBodyContext() {\n360         clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n361     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_66", "report_text": "> Method nextElementSibling() returns null after adding an element to a document that was cloned\n> \n> If I clone a document, and add an element by the method `after()`, and try to get the new element by the method `nextElementSibling()` I get null. In the same time the method `nextSibling()` successfully returns this element.  \n> If I do the same with the original document everything is fine.\n> Code:\n> ```\n> String html = \"<!DOCTYPE html><html lang=\\\"en\\\"><head></head><body><div>Initial element</div></body></html>\";\n> Document original = Jsoup.parse(html);\n> Document clone = original.clone();\n> Element originalElement = original.body().child(0);\n> originalElement.after(\"<div>New element</div>\");\n> Element originalNextElementSibling = originalElement.nextElementSibling();\n> Element originalNextSibling = (Element) originalElement.nextSibling();\n> System.out.println(\"originalNextElementSibling:\\n\" + originalNextElementSibling);\n> System.out.println(\"originalNextSibling:\\n\" + originalNextSibling);\n> System.out.println();\n> Element cloneElement = clone.body().child(0);\n> cloneElement.after(\"<div>New element</div>\");\n> Element cloneNextElementSibling = cloneElement.nextElementSibling();\n> Element cloneNextSibling = (Element) cloneElement.nextSibling();\n> System.out.println(\"cloneNextElementSibling:\\n\" + cloneNextElementSibling);\n> System.out.println(\"cloneNextSibling:\\n\" + cloneNextSibling);\n> ```\n> Output:\n> ```\n> originalNextElementSibling:\n> <div>\n>  New element\n> </div>\n> originalNextSibling:\n> <div>\n>  New element\n> </div>\n> cloneNextElementSibling:\n> null\n> cloneNextSibling:\n> <div>\n> New element\n> </div>\n> ```", "test_name": "org.jsoup.nodes.ElementTest::testNextElementSiblingAfterClone", "test_method": "\t@Test\n    public void testNextElementSiblingAfterClone() {\n        // via https://github.com/jhy/jsoup/issues/951\n        String html = \"<!DOCTYPE html><html lang=\\\"en\\\"><head></head><body><div>Initial element</div></body></html>\";\n        String expectedText = \"New element\";\n        String cloneExpect = \"New element in clone\";\n\n        Document original = Jsoup.parse(html);\n        Document clone = original.clone();\n\n        Element originalElement = original.body().child(0);\n        originalElement.after(\"<div>\" + expectedText + \"</div>\");\n        Element originalNextElementSibling = originalElement.nextElementSibling();\n        Element originalNextSibling = (Element) originalElement.nextSibling();\n\n        Element cloneElement = clone.body().child(0);\n        cloneElement.after(\"<div>\" + cloneExpect + \"</div>\");\n        Element cloneNextElementSibling = cloneElement.nextElementSibling();\n        Element cloneNextSibling = (Element) cloneElement.nextSibling();\n        assertEquals(cloneExpect, cloneNextElementSibling.text()); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jsoup.nodes.ElementTest.testNextElementSiblingAfterClone(ElementTest.java:1235)", "buggy_method": "87 protected List<Node> ensureChildNodes() {\n88         if (childNodes == EMPTY_NODES) {\n89             childNodes = new NodeList(4);\n90         }\n91         return childNodes;\n92     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_67", "report_text": "> Quadratic behaviour on deeply nested pages\n> \n> On pages with very deep sequence of elements (like this one sv.stargate.wikia.com/wiki/M2J), Jsoup gets very slow and spends too much time in this function:  \n> <https://github.com/jhy/jsoup/blob/master/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java#L462>\n> Is there any way to remove this quadratic behaviour? Either by using better data structures or by having option to limit stack size (and throw exception when it is too deep).", "test_name": "org.jsoup.parser.HtmlParserTest::handlesDeepStack", "test_method": "    @Test public void handlesDeepStack() {\n        // inspired by http://sv.stargate.wikia.com/wiki/M2J and https://github.com/jhy/jsoup/issues/955\n        // I didn't put it in the integration tests, because explorer and intellij kept dieing trying to preview/index it\n\n        // Arrange\n        StringBuilder longBody = new StringBuilder(500000);\n        for (int i = 0; i < 25000; i++) {\n            longBody.append(i).append(\"<dl><dd>\");\n        }\n        for (int i = 0; i < 25000; i++) {\n            longBody.append(i).append(\"</dd></dl>\");\n        }\n\n        // Act\n        long start = System.currentTimeMillis();\n        Document doc = Parser.parseBodyFragment(longBody.toString(), \"\");\n\n        // Assert\n        assertTrue(System.currentTimeMillis() - start < 1000); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.jsoup.parser.HtmlParserTest.handlesDeepStack(HtmlParserTest.java:924)", "buggy_method": "466 private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n467         int depth = stack.size() -1;\n468         for (int pos = depth; pos >= 0; pos--) {\n469             Element el = stack.get(pos);\n470             String elName = el.nodeName();\n471             if (inSorted(elName, targetNames))\n472                 return true;\n473             if (inSorted(elName, baseTypes))\n474                 return false;\n475             if (extraTypes != null && inSorted(elName, extraTypes))\n476                 return false;\n477         }\n478         Validate.fail(\"Should not be reachable\");\n479         return false;\n480     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_68", "report_text": "> version 1.11.1 java.lang.StackOverflowError\n> \n> version 1.10.3 no problem  \n> version 1.11.1 java.lang.StackOverflowError  \n> Example URL\uff1a  \n> <http://szshb.nxszs.gov.cn/>  \n> <http://www.lnfsfda.gov.cn/>  \n> <http://www.beihai.gov.cn/>  \n> <http://www.fsepb.gov.cn/>  \n> <http://www.bhem.gov.cn>", "test_name": "org.jsoup.parser.HtmlParserTest::testHandlesDeepSpans", "test_method": "@Test public void testHandlesDeepSpans() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 200; i++) {\n            sb.append(\"<span>\");\n        }\n\n        sb.append(\"<p>One</p>\");\n\n        Document doc = Jsoup.parse(sb.toString());\n        assertEquals(200, doc.select(\"span\").size());\n        assertEquals(1, doc.select(\"p\").size());\n  }", "error_message": "java.lang.StackOverflowError\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:282)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.TreeBuilder.processStartTag(TreeBuilder.java:66)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:707)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)\n\torg.jsoup.parser.HtmlTreeBuilder.process(HtmlTreeBuilder.java:137)\n\torg.jsoup.parser.HtmlTreeBuilderState$7.process(HtmlTreeBuilderState.java:708)", "buggy_method": "466 private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n467         // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n468         int bottom = stack.size() -1;\n469         if (bottom > MaxScopeSearchDepth) {\n470             bottom = MaxScopeSearchDepth;\n471         }\n472         final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n473         // don't walk too far up the tree\n474 \n475         for (int pos = bottom; pos >= top; pos--) {\n476             final String elName = stack.get(pos).nodeName();\n477             if (inSorted(elName, targetNames))\n478                 return true;\n479             if (inSorted(elName, baseTypes))\n480                 return false;\n481             if (extraTypes != null && inSorted(elName, extraTypes))\n482                 return false;\n483         }\n484         //Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n485         return false;\n486     }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilder"}, {"bug_name": "Jsoup_70", "report_text": "> Whitespaces not properly handled in <pre> tag\n> \n> If a \"pre\" tag contains deep nested tags, whitespaces in nested tags are not preserved.\n> Example:\n> --------\n> ```\n> String s = \"<pre><code>\\n\"\n>         + \"  message <span style=\\\"color:red\\\"> other   \\n    message  with \\n\"\n>         + \"   whitespaces      </span>\\n\"\n>         + \"</code></pre>\";\n>     Document doc = Jsoup.parse(s);\n>     System.out.println(doc.select(\"pre\").first().outerHtml());\n> ```\n> Will output:  \n> <pre><code>  \n> \u00a0\u00a0message <span style=\"color:red\"> other message with whiptespaces </span>  \n> </pre></code>\n> ---\n> Output is OK if we omit the \"code\" tag", "test_name": "org.jsoup.nodes.ElementTest::testKeepsPreTextAtDepth", "test_method": "    @Test public void testKeepsPreTextAtDepth() {\n        String h = \"<pre><code><span><b>code\\n\\ncode</b></span></code></pre>\";\n        Document doc = Jsoup.parse(h);\n        assertEquals(\"code\\n\\ncode\", doc.text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<code[\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.testKeepsPreTextAtDepth(ElementTest.java:110)", "buggy_method": "1087 static boolean preserveWhitespace(Node node) {\n1088         // looks only at this element and five levels up, to prevent recursion & needless stack searches\n1089         if (node != null && node instanceof Element) {\n1090             Element el = (Element) node;\n1091                 if (el.tag.preserveWhitespace())\n1092                     return true;\n1093                 else\n1094                     return el.parent() != null && el.parent().tag.preserveWhitespace();\n1095         }\n1096         return false;\n1097     }", "bm_classpath": "org.jsoup.nodes.Element"}, {"bug_name": "Jsoup_72", "report_text": "> StringIndexOutOfBoundsException as of jsoup 1.11.1\n> \n> Example:\n> ```\n> Jsoup.parse(new URL(\"https://gist.githubusercontent.com/valodzka/91ed27043628e9023009e503d41f1aad/raw/a15f68671e6f0517e48fdac812983b85fea27c16/test.html\"), 10_000);\n> ```", "test_name": "org.jsoup.parser.CharacterReaderTest::consumeToNonexistentEndWhenAtAnd", "test_method": "    @Test\n    public void consumeToNonexistentEndWhenAtAnd() {\n        CharacterReader r = new CharacterReader(\"<!\");\n\n        String after = r.consumeTo('>'); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\tjava.lang.String.<init>(String.java:196)\n\torg.jsoup.parser.CharacterReader.cacheString(CharacterReader.java:440)\n\torg.jsoup.parser.CharacterReader.consumeToEnd(CharacterReader.java:255)\n\torg.jsoup.parser.CharacterReader.consumeTo(CharacterReader.java:167)\n\torg.jsoup.parser.CharacterReaderTest.consumeToNonexistentEndWhenAtAnd(CharacterReaderTest.java:265)", "buggy_method": "423 private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n424         // limit (no cache):\n425         if (count > maxStringCacheLen)\n426             return new String(charBuf, start, count);\n427 \n428         // calculate hash:\n429         int hash = 0;\n430         int offset = start;\n431         for (int i = 0; i < count; i++) {\n432             hash = 31 * hash + charBuf[offset++];\n433         }\n434 \n435         // get from cache\n436         final int index = hash & stringCache.length - 1;\n437         String cached = stringCache[index];\n438 \n439         if (cached == null) { // miss, add\n440             cached = new String(charBuf, start, count);\n441             stringCache[index] = cached;\n442         } else { // hashcode hit, check equality\n443             if (rangeEquals(charBuf, start, count, cached)) { // hit\n444                 return cached;\n445             } else { // hashcode conflict\n446                 cached = new String(charBuf, start, count);\n447                 stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n448             }\n449         }\n450         return cached;\n451     }", "bm_classpath": "org.jsoup.parser.CharacterReader"}, {"bug_name": "Jsoup_73", "report_text": "> In w3c dom, siblings are incorrectly inheriting namespaces\n> \n> I am not sure if this is a bug or I am missing something that is defined in specification.\n> When I am parsing (W3C DOM) html file without namespace that have some element(s) with defined namespace, elements that are following will inherit that namespace.\n> Small test case and test html are included.\n> [test.zip](https://github.com/jhy/jsoup/files/1478508/test.zip)", "test_name": "org.jsoup.helper.W3CDomTest::namespacePreservation", "test_method": "    @Test\n    public void namespacePreservation() throws IOException {\n        File in = ParseTest.getFile(\"/htmltests/namespaces.xhtml\");\n        org.jsoup.nodes.Document jsoupDoc;\n        jsoupDoc = Jsoup.parse(in, \"UTF-8\");\n\n        Document doc;\n        org.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();\n        doc = jDom.fromJsoup(jsoupDoc);\n\n        Node htmlEl = doc.getChildNodes().item(0);\n\n        // inherits default namespace\n        Node head = htmlEl.getFirstChild();\n\n        Node epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);\n\n        Node xSection = epubTitle.getNextSibling().getNextSibling();\n\n        // https://github.com/jhy/jsoup/issues/977\n        // does not keep last set namespace\n        Node svg = xSection.getNextSibling().getNextSibling();\n\n        Node path = svg.getChildNodes().item(1);\n\n        Node clip = path.getChildNodes().item(1);\n\n        Node picture = svg.getNextSibling().getNextSibling();\n        assertEquals(\"http://www.w3.org/1999/xhtml\", picture.getNamespaceURI()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<http://[www.w3.org/1999/xhtml]> but was:<http://[example.com/clip]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.W3CDomTest.namespacePreservation(W3CDomTest.java:116)", "buggy_method": "112 public void tail(org.jsoup.nodes.Node source, int depth) {\n113             if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n114                 dest = (Element) dest.getParentNode(); // undescend. cromulent.\n115             }\n116         }", "bm_classpath": "org.jsoup.helper.W3CDom$W3CBuilder"}, {"bug_name": "Jsoup_74", "report_text": "> &shy; renders as '-' when Node.text() is called\n> \n> Consider the following JUnit4 test\n> ```\n> @Test\n> public void testIfShyIsStripped(){\n>         String htmlwithSHY = \"<html><body>quite&shy;a&shy;long&shy;word</body></html>\";\n>         Document parse = Jsoup.parse(htmlwithSHY);\n>         String text = parse.body().text();\n>         assertEquals(\"quitealongword\", text);\n> }\n> ```\n> This test fails as text is parsed as `quite-a-long-word` rather then it's actual textual representation that would have been `quitealongword` in any browser.\n> Perhaps this is working as intended, but it would be interesting to understand the reasoning behind it.", "test_name": "org.jsoup.nodes.ElementTest::testNormalizesInvisiblesInText", "test_method": "    @Test public void testNormalizesInvisiblesInText() {\n        // return Character.getType(c) == 16 && (c == 8203 || c == 8204 || c == 8205 || c == 173);\n        String escaped = \"This&shy;is&#x200b;one&#x200c;long&#x200d;word\";\n        String decoded = \"This\\u00ADis\\u200Bone\\u200Clong\\u200Dword\"; // browser would not display those soft hyphens / other chars, so we don't want them in the text\n\n        Document doc = Jsoup.parse(\"<p>\" + escaped);\n        Element p = doc.select(\"p\").first();\n        doc.outputSettings().charset(\"ascii\"); // so that the outer html is easier to see with escaped invisibles\n        assertEquals(\"Thisisonelongword\", p.text()); // text is normalized // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<This[isonelong]word> but was:<This[\u00adis\u200bone\u200clong\u200d]word>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.testNormalizesInvisiblesInText(ElementTest.java:1212)", "buggy_method": "151 public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n152         boolean lastWasWhite = false;\n153         boolean reachedNonWhite = false;\n154 \n155         int len = string.length();\n156         int c;\n157         for (int i = 0; i < len; i+= Character.charCount(c)) {\n158             c = string.codePointAt(i);\n159             if (isActuallyWhitespace(c)) {\n160                 if ((stripLeading && !reachedNonWhite) || lastWasWhite)\n161                     continue;\n162                 accum.append(' ');\n163                 lastWasWhite = true;\n164             }\n165             else {\n166                 accum.appendCodePoint(c);\n167                 lastWasWhite = false;\n168                 reachedNonWhite = true;\n169             }\n170         }\n171     }", "bm_classpath": "org.jsoup.helper.StringUtil"}, {"bug_name": "Jsoup_75", "report_text": "> Regression - Boolean attributes not collapsed when using HTML syntax\n> \n> Hello,\n> First off, thanks for a really useful library.\n> So, upgrading from 1.10.2 to 1.11.2 we see that boolean attributes are no longer collapsed when using html syntax. Example test case:\n> ```\n>     @Test\n>     public void test() {\n>         Document document = Jsoup.parse(\n>                 \"<html><head></head><body><hr size=\\\"1\\\" noshade=\\\"\\\"></body></html>\");\n>         assertEquals(\"<html>\\n\" +\n>                      \" <head></head>\\n\" +\n>                      \" <body>\\n\" +\n>                      \"  <hr size=\\\"1\\\" noshade>\\n\" +\n>                      \" </body>\\n\" +\n>                      \"</html>\",\n>                      document.outerHtml());\n>     }\n> ```\n> Tracked it down to commit \"Refactored Attributes to be an array pair vs LinkedHashSet \" [ea1fb65](https://github.com/jhy/jsoup/commit/ea1fb65e9ff8eee82c4e379dc3236d09a5ab02e1). The `Attibutes.html(final Appendable accum, final Document.OutputSettings out)` method no longer uses `Attribute` and **fails** to check the value of the attribute for an *empty string*(line 320).\n> If I may also suggest to use `Attribute.shouldCollapseAttribute(String key, String val, Document.OutputSettings out)` instead as a single source of truth as the boolean expression is complex enough and easy to make a mistake. Not sure if this would have an impact in performance though but I am guessing that optimizer will inline the call at some point anyways?", "test_name": "org.jsoup.nodes.ElementTest::booleanAttributeOutput", "test_method": "    @Test\n    public void booleanAttributeOutput() {\n        Document doc = Jsoup.parse(\"<img src=foo noshade='' nohref async=async autofocus=false>\");\n        Element img = doc.selectFirst(\"img\");\n\n        assertEquals(\"<img src=\\\"foo\\\" noshade nohref async autofocus=\\\"false\\\">\", img.outerHtml()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<...mg src=\"foo\" noshade[] nohref async autofo...> but was:<...mg src=\"foo\" noshade[=\"\"] nohref async autofo...>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.ElementTest.booleanAttributeOutput(ElementTest.java:1318)", "buggy_method": "310 final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n311         final int sz = size;\n312         for (int i = 0; i < sz; i++) {\n313             // inlined from Attribute.html()\n314             final String key = keys[i];\n315             final String val = vals[i];\n316             accum.append(' ').append(key);\n317 \n318             // collapse checked=null, checked=\"\", checked=checked; write out others\n319             if (!(out.syntax() == Document.OutputSettings.Syntax.html\n320                 && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n321                 accum.append(\"=\\\"\");\n322                 Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\n323                 accum.append('\"');\n324             }\n325         }\n326     }", "bm_classpath": "org.jsoup.nodes.Attributes"}, {"bug_name": "Jsoup_76", "report_text": "> Newline after pre and textarea not handled properly\n> \n> The WHATWG spec for HTML syntax indicates that if there is a newline directly after an opening `<pre>` or `<textarea>`, it should be removed.\n> <https://html.spec.whatwg.org/multipage/syntax.html#element-restrictions>\n> jsoup currently does not do this:\n> ```\n> Jsoup.parse(\"<pre>\\nabc  def</pre>\").select(\"pre\").get(0).childNodes().get(0).text();\n> // Outputs  \" abc def\"\n> // Expected \"abc def\"\n> ```\n> Arguably, jsoup is also wrong for the value of `getWholeText()`, although I guess this depends on one's interpretation of what `getWholeText()` is supposed to do. I am hoping that it intends to correspond to the value of [Node.nodeValue](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeValue), in which case:\n> ```\n> Jsoup.parse(\"<pre>\\nabc  def</pre>\").select(\"pre\").get(0).childNodes().get(0).getWholeText();\n> // Outputs  \"\\nabc  def\"\n> // Expected \"abc  def\" \n> Jsoup.parse(\"<pre>\\n\\nabc  def</pre>\").select(\"pre\").get(0).childNodes().get(0).getWholeText();\n> // Outputs  \"\\n\\nabc  def\"\n> // Expected \"\\nabc  def\"\n> ```", "test_name": "org.jsoup.parser.HtmlParserTest::preSkipsFirstNewline", "test_method": "  @Test public void preSkipsFirstNewline() {\n        Document doc = Jsoup.parse(\"<pre>\\n\\nOne\\nTwo\\n</pre>\");\n        Element pre = doc.selectFirst(\"pre\");\n        assertEquals(\"\\nOne\\nTwo\\n\", pre.wholeText()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.preSkipsFirstNewline(HtmlParserTest.java:1164)", "buggy_method": "252 boolean process(Token t, HtmlTreeBuilder tb) {\n253             switch (t.type) {\n254                 case Character: {\n255                     Token.Character c = t.asCharacter();\n256                     if (c.getData().equals(nullString)) {\n257                         // todo confirm that check\n258                         tb.error(this);\n259                         return false;\n260                     } else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n261                         tb.reconstructFormattingElements();\n262                         tb.insert(c);\n263                     } else {\n264                         tb.reconstructFormattingElements();\n265                         tb.insert(c);\n266                         tb.framesetOk(false);\n267                     }\n268                     break;\n269                 }\n270                 case Comment: {\n271                     tb.insert(t.asComment());\n272                     break;\n273                 }\n274                 case Doctype: {\n275                     tb.error(this);\n276                     return false;\n277                 }\n278                 case StartTag:\n279                     Token.StartTag startTag = t.asStartTag();\n280                     // todo - refactor to a switch statement\n281                     String name = startTag.normalName();\n282                     if (name.equals(\"a\")) {\n283                         if (tb.getActiveFormattingElement(\"a\") != null) {\n284                             tb.error(this);\n285                             tb.processEndTag(\"a\");\n286 \n287                             // still on stack?\n288                             Element remainingA = tb.getFromStack(\"a\");\n289                             if (remainingA != null) {\n290                                 tb.removeFromActiveFormattingElements(remainingA);\n291                                 tb.removeFromStack(remainingA);\n292                             }\n293                         }\n294                         tb.reconstructFormattingElements();\n295                         Element a = tb.insert(startTag);\n296                         tb.pushActiveFormattingElements(a);\n297                     } else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n298                         tb.reconstructFormattingElements();\n299                         tb.insertEmpty(startTag);\n300                         tb.framesetOk(false);\n301                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n302                         if (tb.inButtonScope(\"p\")) {\n303                             tb.processEndTag(\"p\");\n304                         }\n305                         tb.insert(startTag);\n306                     } else if (name.equals(\"span\")) {\n307                         // same as final else, but short circuits lots of checks\n308                         tb.reconstructFormattingElements();\n309                         tb.insert(startTag);\n310                     } else if (name.equals(\"li\")) {\n311                         tb.framesetOk(false);\n312                         ArrayList<Element> stack = tb.getStack();\n313                         for (int i = stack.size() - 1; i > 0; i--) {\n314                             Element el = stack.get(i);\n315                             if (el.nodeName().equals(\"li\")) {\n316                                 tb.processEndTag(\"li\");\n317                                 break;\n318                             }\n319                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n320                                 break;\n321                         }\n322                         if (tb.inButtonScope(\"p\")) {\n323                             tb.processEndTag(\"p\");\n324                         }\n325                         tb.insert(startTag);\n326                     } else if (name.equals(\"html\")) {\n327                         tb.error(this);\n328                         // merge attributes onto real html\n329                         Element html = tb.getStack().get(0);\n330                         for (Attribute attribute : startTag.getAttributes()) {\n331                             if (!html.hasAttr(attribute.getKey()))\n332                                 html.attributes().put(attribute);\n333                         }\n334                     } else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n335                         return tb.process(t, InHead);\n336                     } else if (name.equals(\"body\")) {\n337                         tb.error(this);\n338                         ArrayList<Element> stack = tb.getStack();\n339                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n340                             // only in fragment case\n341                             return false; // ignore\n342                         } else {\n343                             tb.framesetOk(false);\n344                             Element body = stack.get(1);\n345                             for (Attribute attribute : startTag.getAttributes()) {\n346                                 if (!body.hasAttr(attribute.getKey()))\n347                                     body.attributes().put(attribute);\n348                             }\n349                         }\n350                     } else if (name.equals(\"frameset\")) {\n351                         tb.error(this);\n352                         ArrayList<Element> stack = tb.getStack();\n353                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n354                             // only in fragment case\n355                             return false; // ignore\n356                         } else if (!tb.framesetOk()) {\n357                             return false; // ignore frameset\n358                         } else {\n359                             Element second = stack.get(1);\n360                             if (second.parent() != null)\n361                                 second.remove();\n362                             // pop up to html element\n363                             while (stack.size() > 1)\n364                                 stack.remove(stack.size()-1);\n365                             tb.insert(startTag);\n366                             tb.transition(InFrameset);\n367                         }\n368                     } else if (StringUtil.inSorted(name, Constants.Headings)) {\n369                         if (tb.inButtonScope(\"p\")) {\n370                             tb.processEndTag(\"p\");\n371                         }\n372                         if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n373                             tb.error(this);\n374                             tb.pop();\n375                         }\n376                         tb.insert(startTag);\n377                     } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n378                         if (tb.inButtonScope(\"p\")) {\n379                             tb.processEndTag(\"p\");\n380                         }\n381                         tb.insert(startTag);\n382                         tb.framesetOk(false);\n383                     } else if (name.equals(\"form\")) {\n384                         if (tb.getFormElement() != null) {\n385                             tb.error(this);\n386                             return false;\n387                         }\n388                         if (tb.inButtonScope(\"p\")) {\n389                             tb.processEndTag(\"p\");\n390                         }\n391                         tb.insertForm(startTag, true);\n392                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n393                         tb.framesetOk(false);\n394                         ArrayList<Element> stack = tb.getStack();\n395                         for (int i = stack.size() - 1; i > 0; i--) {\n396                             Element el = stack.get(i);\n397                             if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n398                                 tb.processEndTag(el.nodeName());\n399                                 break;\n400                             }\n401                             if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n402                                 break;\n403                         }\n404                         if (tb.inButtonScope(\"p\")) {\n405                             tb.processEndTag(\"p\");\n406                         }\n407                         tb.insert(startTag);\n408                     } else if (name.equals(\"plaintext\")) {\n409                         if (tb.inButtonScope(\"p\")) {\n410                             tb.processEndTag(\"p\");\n411                         }\n412                         tb.insert(startTag);\n413                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n414                     } else if (name.equals(\"button\")) {\n415                         if (tb.inButtonScope(\"button\")) {\n416                             // close and reprocess\n417                             tb.error(this);\n418                             tb.processEndTag(\"button\");\n419                             tb.process(startTag);\n420                         } else {\n421                             tb.reconstructFormattingElements();\n422                             tb.insert(startTag);\n423                             tb.framesetOk(false);\n424                         }\n425                     } else if (StringUtil.inSorted(name, Constants.Formatters)) {\n426                         tb.reconstructFormattingElements();\n427                         Element el = tb.insert(startTag);\n428                         tb.pushActiveFormattingElements(el);\n429                     } else if (name.equals(\"nobr\")) {\n430                         tb.reconstructFormattingElements();\n431                         if (tb.inScope(\"nobr\")) {\n432                             tb.error(this);\n433                             tb.processEndTag(\"nobr\");\n434                             tb.reconstructFormattingElements();\n435                         }\n436                         Element el = tb.insert(startTag);\n437                         tb.pushActiveFormattingElements(el);\n438                     } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n439                         tb.reconstructFormattingElements();\n440                         tb.insert(startTag);\n441                         tb.insertMarkerToFormattingElements();\n442                         tb.framesetOk(false);\n443                     } else if (name.equals(\"table\")) {\n444                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n445                             tb.processEndTag(\"p\");\n446                         }\n447                         tb.insert(startTag);\n448                         tb.framesetOk(false);\n449                         tb.transition(InTable);\n450                     } else if (name.equals(\"input\")) {\n451                         tb.reconstructFormattingElements();\n452                         Element el = tb.insertEmpty(startTag);\n453                         if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n454                             tb.framesetOk(false);\n455                     } else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n456                         tb.insertEmpty(startTag);\n457                     } else if (name.equals(\"hr\")) {\n458                         if (tb.inButtonScope(\"p\")) {\n459                             tb.processEndTag(\"p\");\n460                         }\n461                         tb.insertEmpty(startTag);\n462                         tb.framesetOk(false);\n463                     } else if (name.equals(\"image\")) {\n464                         if (tb.getFromStack(\"svg\") == null)\n465                             return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n466                         else\n467                             tb.insert(startTag);\n468                     } else if (name.equals(\"isindex\")) {\n469                         // how much do we care about the early 90s?\n470                         tb.error(this);\n471                         if (tb.getFormElement() != null)\n472                             return false;\n473 \n474                         tb.processStartTag(\"form\");\n475                         if (startTag.attributes.hasKey(\"action\")) {\n476                             Element form = tb.getFormElement();\n477                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n478                         }\n479                         tb.processStartTag(\"hr\");\n480                         tb.processStartTag(\"label\");\n481                         // hope you like english.\n482                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n483                                 startTag.attributes.get(\"prompt\") :\n484                                 \"This is a searchable index. Enter search keywords: \";\n485 \n486                         tb.process(new Token.Character().data(prompt));\n487 \n488                         // input\n489                         Attributes inputAttribs = new Attributes();\n490                         for (Attribute attr : startTag.attributes) {\n491                             if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n492                                 inputAttribs.put(attr);\n493                         }\n494                         inputAttribs.put(\"name\", \"isindex\");\n495                         tb.processStartTag(\"input\", inputAttribs);\n496                         tb.processEndTag(\"label\");\n497                         tb.processStartTag(\"hr\");\n498                         tb.processEndTag(\"form\");\n499                     } else if (name.equals(\"textarea\")) {\n500                         tb.insert(startTag);\n501                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n502                         tb.tokeniser.transition(TokeniserState.Rcdata);\n503                         tb.markInsertionMode();\n504                         tb.framesetOk(false);\n505                         tb.transition(Text);\n506                     } else if (name.equals(\"xmp\")) {\n507                         if (tb.inButtonScope(\"p\")) {\n508                             tb.processEndTag(\"p\");\n509                         }\n510                         tb.reconstructFormattingElements();\n511                         tb.framesetOk(false);\n512                         handleRawtext(startTag, tb);\n513                     } else if (name.equals(\"iframe\")) {\n514                         tb.framesetOk(false);\n515                         handleRawtext(startTag, tb);\n516                     } else if (name.equals(\"noembed\")) {\n517                         // also handle noscript if script enabled\n518                         handleRawtext(startTag, tb);\n519                     } else if (name.equals(\"select\")) {\n520                         tb.reconstructFormattingElements();\n521                         tb.insert(startTag);\n522                         tb.framesetOk(false);\n523 \n524                         HtmlTreeBuilderState state = tb.state();\n525                         if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n526                             tb.transition(InSelectInTable);\n527                         else\n528                             tb.transition(InSelect);\n529                     } else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n530                         if (tb.currentElement().nodeName().equals(\"option\"))\n531                             tb.processEndTag(\"option\");\n532                         tb.reconstructFormattingElements();\n533                         tb.insert(startTag);\n534                     } else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n535                         if (tb.inScope(\"ruby\")) {\n536                             tb.generateImpliedEndTags();\n537                             if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n538                                 tb.error(this);\n539                                 tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n540                             }\n541                             tb.insert(startTag);\n542                         }\n543                     } else if (name.equals(\"math\")) {\n544                         tb.reconstructFormattingElements();\n545                         // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n546                         tb.insert(startTag);\n547                     } else if (name.equals(\"svg\")) {\n548                         tb.reconstructFormattingElements();\n549                         // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n550                         tb.insert(startTag);\n551                     } else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n552                         tb.error(this);\n553                         return false;\n554                     } else {\n555                         tb.reconstructFormattingElements();\n556                         tb.insert(startTag);\n557                     }\n558                     break;\n559 \n560                 case EndTag:\n561                     Token.EndTag endTag = t.asEndTag();\n562                     name = endTag.normalName();\n563                     if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n564                         // Adoption Agency Algorithm.\n565                         for (int i = 0; i < 8; i++) {\n566                             Element formatEl = tb.getActiveFormattingElement(name);\n567                             if (formatEl == null)\n568                                 return anyOtherEndTag(t, tb);\n569                             else if (!tb.onStack(formatEl)) {\n570                                 tb.error(this);\n571                                 tb.removeFromActiveFormattingElements(formatEl);\n572                                 return true;\n573                             } else if (!tb.inScope(formatEl.nodeName())) {\n574                                 tb.error(this);\n575                                 return false;\n576                             } else if (tb.currentElement() != formatEl)\n577                                 tb.error(this);\n578 \n579                             Element furthestBlock = null;\n580                             Element commonAncestor = null;\n581                             boolean seenFormattingElement = false;\n582                             ArrayList<Element> stack = tb.getStack();\n583                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n584                             // run-aways\n585                             final int stackSize = stack.size();\n586                             for (int si = 0; si < stackSize && si < 64; si++) {\n587                                 Element el = stack.get(si);\n588                                 if (el == formatEl) {\n589                                     commonAncestor = stack.get(si - 1);\n590                                     seenFormattingElement = true;\n591                                 } else if (seenFormattingElement && tb.isSpecial(el)) {\n592                                     furthestBlock = el;\n593                                     break;\n594                                 }\n595                             }\n596                             if (furthestBlock == null) {\n597                                 tb.popStackToClose(formatEl.nodeName());\n598                                 tb.removeFromActiveFormattingElements(formatEl);\n599                                 return true;\n600                             }\n601 \n602                             // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n603                             // does that mean: int pos of format el in list?\n604                             Element node = furthestBlock;\n605                             Element lastNode = furthestBlock;\n606                             for (int j = 0; j < 3; j++) {\n607                                 if (tb.onStack(node))\n608                                     node = tb.aboveOnStack(node);\n609                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n610                                     tb.removeFromStack(node);\n611                                     continue;\n612                                 } else if (node == formatEl)\n613                                     break;\n614 \n615                                 Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n616                                 // case will follow the original node (so honours ParseSettings)\n617                                 tb.replaceActiveFormattingElement(node, replacement);\n618                                 tb.replaceOnStack(node, replacement);\n619                                 node = replacement;\n620 \n621                                 if (lastNode == furthestBlock) {\n622                                     // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n623                                     // not getting how this bookmark both straddles the element above, but is inbetween here...\n624                                 }\n625                                 if (lastNode.parent() != null)\n626                                     lastNode.remove();\n627                                 node.appendChild(lastNode);\n628 \n629                                 lastNode = node;\n630                             }\n631 \n632                             if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n633                                 if (lastNode.parent() != null)\n634                                     lastNode.remove();\n635                                 tb.insertInFosterParent(lastNode);\n636                             } else {\n637                                 if (lastNode.parent() != null)\n638                                     lastNode.remove();\n639                                 commonAncestor.appendChild(lastNode);\n640                             }\n641 \n642                             Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n643                             adopter.attributes().addAll(formatEl.attributes());\n644                             Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n645                             for (Node childNode : childNodes) {\n646                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n647                             }\n648                             furthestBlock.appendChild(adopter);\n649                             tb.removeFromActiveFormattingElements(formatEl);\n650                             // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n651                             tb.removeFromStack(formatEl);\n652                             tb.insertOnStackAfter(furthestBlock, adopter);\n653                         }\n654                     } else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n655                         if (!tb.inScope(name)) {\n656                             // nothing to close\n657                             tb.error(this);\n658                             return false;\n659                         } else {\n660                             tb.generateImpliedEndTags();\n661                             if (!tb.currentElement().nodeName().equals(name))\n662                                 tb.error(this);\n663                             tb.popStackToClose(name);\n664                         }\n665                     } else if (name.equals(\"span\")) {\n666                         // same as final fall through, but saves short circuit\n667                         return anyOtherEndTag(t, tb);\n668                     } else if (name.equals(\"li\")) {\n669                         if (!tb.inListItemScope(name)) {\n670                             tb.error(this);\n671                             return false;\n672                         } else {\n673                             tb.generateImpliedEndTags(name);\n674                             if (!tb.currentElement().nodeName().equals(name))\n675                                 tb.error(this);\n676                             tb.popStackToClose(name);\n677                         }\n678                     } else if (name.equals(\"body\")) {\n679                         if (!tb.inScope(\"body\")) {\n680                             tb.error(this);\n681                             return false;\n682                         } else {\n683                             // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n684                             tb.transition(AfterBody);\n685                         }\n686                     } else if (name.equals(\"html\")) {\n687                         boolean notIgnored = tb.processEndTag(\"body\");\n688                         if (notIgnored)\n689                             return tb.process(endTag);\n690                     } else if (name.equals(\"form\")) {\n691                         Element currentForm = tb.getFormElement();\n692                         tb.setFormElement(null);\n693                         if (currentForm == null || !tb.inScope(name)) {\n694                             tb.error(this);\n695                             return false;\n696                         } else {\n697                             tb.generateImpliedEndTags();\n698                             if (!tb.currentElement().nodeName().equals(name))\n699                                 tb.error(this);\n700                             // remove currentForm from stack. will shift anything under up.\n701                             tb.removeFromStack(currentForm);\n702                         }\n703                     } else if (name.equals(\"p\")) {\n704                         if (!tb.inButtonScope(name)) {\n705                             tb.error(this);\n706                             tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n707                             return tb.process(endTag);\n708                         } else {\n709                             tb.generateImpliedEndTags(name);\n710                             if (!tb.currentElement().nodeName().equals(name))\n711                                 tb.error(this);\n712                             tb.popStackToClose(name);\n713                         }\n714                     } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n715                         if (!tb.inScope(name)) {\n716                             tb.error(this);\n717                             return false;\n718                         } else {\n719                             tb.generateImpliedEndTags(name);\n720                             if (!tb.currentElement().nodeName().equals(name))\n721                                 tb.error(this);\n722                             tb.popStackToClose(name);\n723                         }\n724                     } else if (StringUtil.inSorted(name, Constants.Headings)) {\n725                         if (!tb.inScope(Constants.Headings)) {\n726                             tb.error(this);\n727                             return false;\n728                         } else {\n729                             tb.generateImpliedEndTags(name);\n730                             if (!tb.currentElement().nodeName().equals(name))\n731                                 tb.error(this);\n732                             tb.popStackToClose(Constants.Headings);\n733                         }\n734                     } else if (name.equals(\"sarcasm\")) {\n735                         // *sigh*\n736                         return anyOtherEndTag(t, tb);\n737                     } else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n738                         if (!tb.inScope(\"name\")) {\n739                             if (!tb.inScope(name)) {\n740                                 tb.error(this);\n741                                 return false;\n742                             }\n743                             tb.generateImpliedEndTags();\n744                             if (!tb.currentElement().nodeName().equals(name))\n745                                 tb.error(this);\n746                             tb.popStackToClose(name);\n747                             tb.clearFormattingElementsToLastMarker();\n748                         }\n749                     } else if (name.equals(\"br\")) {\n750                         tb.error(this);\n751                         tb.processStartTag(\"br\");\n752                         return false;\n753                     } else {\n754                         return anyOtherEndTag(t, tb);\n755                     }\n756 \n757                     break;\n758                 case EOF:\n759                     // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n760                     // stop parsing\n761                     break;\n762             }\n763             return true;\n764         }", "bm_classpath": "org.jsoup.parser.HtmlTreeBuilderState"}, {"bug_name": "Jsoup_77", "report_text": "> xmlParser() with ParseSettings.htmlDefault does not put end tag to lower case\n> \n> ```\n> @Test public void test() {\n>     Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n>     Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\n>     assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.toString()); // fail -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\"\n> }\n> @Test public void test1() {\n>     Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n>     Document document = Jsoup.parse(\"<DIV>test</div><p></p>\", \"\", parser);\n>     assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.toString()); // pass\n> }\n> ```", "test_name": "org.jsoup.parser.XmlTreeBuilderTest::normalizesDiscordantTags", "test_method": "    @Test public void normalizesDiscordantTags() {\n        Parser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\n        Document document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\n        assertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<div>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.XmlTreeBuilderTest.normalizesDiscordantTags(XmlTreeBuilderTest.java:197)", "buggy_method": "116 private void popStackToClose(Token.EndTag endTag) {\n117         String elName = endTag.name();\n118         Element firstFound = null;\n119 \n120         for (int pos = stack.size() -1; pos >= 0; pos--) {\n121             Element next = stack.get(pos);\n122             if (next.nodeName().equals(elName)) {\n123                 firstFound = next;\n124                 break;\n125             }\n126         }\n127         if (firstFound == null)\n128             return; // not found, skip\n129 \n130         for (int pos = stack.size() -1; pos >= 0; pos--) {\n131             Element next = stack.get(pos);\n132             stack.remove(pos);\n133             if (next == firstFound)\n134                 break;\n135         }\n136     }", "bm_classpath": "org.jsoup.parser.XmlTreeBuilder"}, {"bug_name": "Jsoup_78", "report_text": "> Underlying input stream returned zero bytes\n> \n> ```\n> Caused by org.jsoup.c: java.io.IOException: Underlying input stream returned zero bytes\n>        at org.jsoup.parser.CharacterReader.bufferUp(CharacterReader.java:60)\n>        at org.jsoup.parser.CharacterReader.(CharacterReader.java)\n>        at org.jsoup.parser.CharacterReader.(CharacterReader.java)\n>        at org.jsoup.parser.TreeBuilder.defaultSettings(TreeBuilder.java:35)\n>        at org.jsoup.parser.HtmlTreeBuilder.initialiseParse(HtmlTreeBuilder.java:66)\n>        at org.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:44)\n>        at org.jsoup.parser.Parser.parseInput(Parser.java:39)\n>        at org.jsoup.helper.DataUtil.parseInputStream(DataUtil.java:151)\n>        at org.jsoup.helper.HttpConnection$Response.parse(HttpConnection.java:832)\n>        at org.jsoup.helper.HttpConnection.get(HttpConnection.java:289)\n> ```\n> There isn't much information I can offer here.  \n> This is with JSoup 1.11.1, with an attempt of parsing for a user's name.\n> My assumption is that the call is executing the following:\n> ```\n> var result = \"\"\n> try {\n> \tresult = frostJsoup(cookie, FbItem.PROFILE.url).title()\n> \tL.d(\"Fetch username found\", result)\n> } catch (e: Exception) {\n> \tif (e !is UnknownHostException)\n> \t\te.logFrostAnswers(\"Fetch username failed\")\n> } finally {\n> \tif (result.isBlank() && (name?.isNotBlank() == true)) {\n> \t\tcallback(name!!)\n> \t\treturn@subscribe\n> \t}\n> \tif (name != result) {\n> \t\tname = result\n> \t\tsaveFbCookie(this@fetchUsername)\n> \t}\n> \tcallback(result)\n> }\n> ```\n> where cookie is the user's cooke, and the url is touch.facebook.com/me\n> I'm not sure why this is a seemlingly fatal error though.\n> As usual, the full log and thread info can be found [here](http://crashes.to/s/92e0e5d0b69)", "test_name": "org.jsoup.integration.ConnectTest::handlesEmptyStreamDuringParseRead", "test_method": "    @Test\n    public void handlesEmptyStreamDuringParseRead() throws IOException {\n        // this handles situations where the remote server sets a content length greater than it actually writes\n\n        Connection.Response res = Jsoup.connect(InterruptedServlet.Url)\n            .timeout(200)\n            .execute();\n\n        boolean threw = false;\n        try {\n            Document document = res.parse();\n            assertEquals(\"Something\", document.title());\n        } catch (IOException e) {\n            threw = true;\n        } // <-- fails here\n    }", "error_message": "org.jsoup.UncheckedIOException: java.io.IOException: Underlying input stream returned zero bytes\n\torg.jsoup.parser.CharacterReader.bufferUp(CharacterReader.java:63)\n\torg.jsoup.parser.CharacterReader.current(CharacterReader.java:93)\n\torg.jsoup.parser.TokeniserState$1.read(TokeniserState.java:12)\n\torg.jsoup.parser.Tokeniser.read(Tokeniser.java:45)\n\torg.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:51)\n\torg.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:45)\n\torg.jsoup.parser.Parser.parseInput(Parser.java:39)\n\torg.jsoup.helper.DataUtil.parseInputStream(DataUtil.java:151)\n\torg.jsoup.helper.HttpConnection$Response.parse(HttpConnection.java:837)\n\torg.jsoup.integration.ConnectTest.handlesEmptyStreamDuringParseRead(ConnectTest.java:400)", "buggy_method": "93 static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n94         if (input == null) // empty body\n95             return new Document(baseUri);\n96         input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n97 \n98         Document doc = null;\n99         boolean fullyRead = false;\n100 \n101         // read the start of the stream and look for a BOM or meta charset\n102         input.mark(bufferSize);\n103         ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n104         fullyRead = input.read() == -1;\n105         input.reset();\n106 \n107         // look for BOM - overrides any other header or input\n108         BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n109         if (bomCharset != null) {\n110             charsetName = bomCharset.charset;\n111             input.skip(bomCharset.offset);\n112         }\n113 \n114         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n115             String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n116             doc = parser.parseInput(docData, baseUri);\n117 \n118             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n119             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n120             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n121             for (Element meta : metaElements) {\n122                 if (meta.hasAttr(\"http-equiv\"))\n123                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n124                 if (foundCharset == null && meta.hasAttr(\"charset\"))\n125                     foundCharset = meta.attr(\"charset\");\n126                 if (foundCharset != null)\n127                     break;\n128             }\n129 \n130             // look for <?xml encoding='ISO-8859-1'?>\n131             if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n132                 XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n133                 if (prolog.name().equals(\"xml\"))\n134                     foundCharset = prolog.attr(\"encoding\");\n135             }\n136             foundCharset = validateCharset(foundCharset);\n137             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n138                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n139                 charsetName = foundCharset;\n140                 doc = null;\n141             } else if (!fullyRead) {\n142                 doc = null;\n143             }\n144         } else { // specified by content type header (or by user on file load)\n145             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n146         }\n147         if (doc == null) {\n148             if (charsetName == null)\n149                 charsetName = defaultCharset;\n150             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n151                 doc = parser.parseInput(reader, baseUri);\n152                 // io exception when parsing (not seen before because reading the stream as we go)\n153             doc.outputSettings().charset(charsetName);\n154         }\n155         input.close();\n156         return doc;\n157     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_79", "report_text": "> LeafNode.childNodes() throws UnsupportedOperationException.\n> \n> `LeafNode.childNodes()` throws `UnsupportedOperationException` since this commit:  \n> [f71712b#diff-605d28890f72a0f43298f842d0a3414f](https://github.com/jhy/jsoup/commit/f71712ba5d28df09c9a5b6e3c8a37f05f5e3372d#diff-605d28890f72a0f43298f842d0a3414f)\n> The javadoc of `Node.childNodes()` says this:  \n> `@return list of children. If no children, returns an empty list.`\n> But in the case of a LeafNode, which has no children, it throws `UnsupportedOperationException`. This is because `childNodes()` calls `ensureChildNodes()`, which throws an exception when called on a `LeafNode`.\n> The result is that the calling application needs to guard against this case. But the application should not need to know if the `Node` it has is a `LeafNode` or not.\n> `LeafNode.childNodes()` should simply return an empty list as it used to do, and as per the javadoc.", "test_name": "org.jsoup.nodes.TextNodeTest::testLeadNodesHaveNoChildren", "test_method": "    @Test public void testLeadNodesHaveNoChildren() {\n        Document doc = Jsoup.parse(\"<div>Hello there</div>\");\n        Element div = doc.select(\"div\").first();\n        TextNode tn = (TextNode) div.childNode(0);\n        List<Node> nodes = tn.childNodes(); // <-- fails here\n    }", "error_message": "java.lang.UnsupportedOperationException: Leaf Nodes do not have child nodes.\n\torg.jsoup.nodes.LeafNode.ensureChildNodes(LeafNode.java:94)\n\torg.jsoup.nodes.Node.childNodes(Node.java:209)\n\torg.jsoup.nodes.TextNodeTest.testLeadNodesHaveNoChildren(TextNodeTest.java:82)", "buggy_method": "92 @Override\n93     protected List<Node> ensureChildNodes() {\n94         throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n95     }", "bm_classpath": "org.jsoup.nodes.LeafNode"}, {"bug_name": "Jsoup_80", "report_text": "> Faulty Xml Causes IndexOutOfBoundsException\n> \n> ```\n> @Test\n> public void parseFaultyXml() {\n>     String xml = \"<?xml version='1.0'><val>One</val>\";\n>     Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n> }\n> ```\n> Results in:\n> ```\n> java.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n> \tat java.util.ArrayList.rangeCheck(ArrayList.java:657)\n> \tat java.util.ArrayList.get(ArrayList.java:433)\n> \tat org.jsoup.nodes.Element.child(Element.java:254)\n> \tat org.jsoup.parser.XmlTreeBuilder.insert(XmlTreeBuilder.java:91)\n> \tat org.jsoup.parser.XmlTreeBuilder.process(XmlTreeBuilder.java:49)\n> \tat org.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:52)\n> \tat org.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:45)\n> \tat org.jsoup.parser.Parser.parseInput(Parser.java:34)\n> \tat org.jsoup.Jsoup.parse(Jsoup.java:45)\n> ```", "test_name": "org.jsoup.parser.XmlTreeBuilderTest::handlesDodgyXmlDecl", "test_method": "    @Test\n    public void handlesDodgyXmlDecl() {\n        String xml = \"<?xml version='1.0'><val>One</val>\";\n        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser()); // <-- fails here\n    }", "error_message": "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n\tjava.util.ArrayList.rangeCheck(ArrayList.java:659)\n\tjava.util.ArrayList.get(ArrayList.java:435)\n\torg.jsoup.nodes.Element.child(Element.java:254)\n\torg.jsoup.parser.XmlTreeBuilder.insert(XmlTreeBuilder.java:91)\n\torg.jsoup.parser.XmlTreeBuilder.process(XmlTreeBuilder.java:49)\n\torg.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:52)\n\torg.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:45)\n\torg.jsoup.parser.Parser.parseInput(Parser.java:34)\n\torg.jsoup.Jsoup.parse(Jsoup.java:45)\n\torg.jsoup.parser.XmlTreeBuilderTest.handlesDodgyXmlDecl(XmlTreeBuilderTest.java:227)", "buggy_method": "83 void insert(Token.Comment commentToken) {\n84         Comment comment = new Comment(commentToken.getData());\n85         Node insert = comment;\n86         if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n87             // so we do a bit of a hack and parse the data as an element to pull the attributes out\n88             String data = comment.getData();\n89             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n90                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n91                     Element el = doc.child(0);\n92                     insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n93                     insert.attributes().addAll(el.attributes());\n94             }\n95         }\n96         insertNode(insert);\n97     }", "bm_classpath": "org.jsoup.parser.XmlTreeBuilder"}, {"bug_name": "Jsoup_81", "report_text": "> Failure to guess correct XHTML encoding even when explicitly declared\n> \n> ```\n> String encoding = \"iso-8859-1\";\n> InputStream soup = new ByteArrayInputStream((\n>     \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + encoding + \"\\\"?>\" +\n>     \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" +\n>     \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">Hell\u00f6 W\u00f6rld!</html>\"\n>     ).getBytes(encoding));\n> System.out.println(Jsoup.parse(soup, null, \"\"));\n> ```\n> prints:\n> ```\n> <!--?xml version=\"1.0\" encoding=\"iso-8859-1\"?--><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n> <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n>  <head></head>\n>  <body>\n>   Hell\ufffd W\ufffdrld!\n>  </body>\n> </html>\n> ```\n> instead of expected output:\n> ```\n> <!--?xml version=\"1.0\" encoding=\"iso-8859-1\"?--><!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n> <html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"en\" xml:lang=\"en\">\n>  <head></head>\n>  <body>\n>   Hell\u00f6 W\u00f6rld!\n>  </body>\n> </html>\n> ```", "test_name": "org.jsoup.helper.DataUtilTest::supportsXmlCharsetDeclaration", "test_method": "    @Test\n    public void supportsXmlCharsetDeclaration() throws IOException {\n        String encoding = \"iso-8859-1\";\n        InputStream soup = new ByteArrayInputStream((\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"iso-8859-1\\\"?>\" +\n                \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" +\n                \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\" xml:lang=\\\"en\\\">Hell\u00f6 W\u00f6rld!</html>\"\n        ).getBytes(encoding));\n\n        Document doc = Jsoup.parse(soup, null, \"\");\n        assertEquals(\"Hell\u00f6 W\u00f6rld!\", doc.body().text()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<Hell[\u00f6 W\u00f6]rld!> but was:<Hell[\ufffd W\ufffd]rld!>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.helper.DataUtilTest.supportsXmlCharsetDeclaration(DataUtilTest.java:178)", "buggy_method": "95 static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n96         if (input == null) // empty body\n97             return new Document(baseUri);\n98         input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n99 \n100         Document doc = null;\n101         boolean fullyRead = false;\n102 \n103         // read the start of the stream and look for a BOM or meta charset\n104         input.mark(bufferSize);\n105         ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n106         fullyRead = input.read() == -1;\n107         input.reset();\n108 \n109         // look for BOM - overrides any other header or input\n110         BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n111         if (bomCharset != null)\n112             charsetName = bomCharset.charset;\n113 \n114         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n115             String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n116             doc = parser.parseInput(docData, baseUri);\n117 \n118             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n119             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n120             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n121             for (Element meta : metaElements) {\n122                 if (meta.hasAttr(\"http-equiv\"))\n123                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n124                 if (foundCharset == null && meta.hasAttr(\"charset\"))\n125                     foundCharset = meta.attr(\"charset\");\n126                 if (foundCharset != null)\n127                     break;\n128             }\n129 \n130             // look for <?xml encoding='ISO-8859-1'?>\n131             if (foundCharset == null && doc.childNodeSize() > 0) {\n132                 Node first = doc.childNode(0);\n133                 XmlDeclaration decl = null;\n134                 if (first instanceof XmlDeclaration)\n135                     decl = (XmlDeclaration) first;\n136                 if (decl != null) {\n137                     if (decl.name().equalsIgnoreCase(\"xml\"))\n138                         foundCharset = decl.attr(\"encoding\");\n139                 }\n140             }\n141             foundCharset = validateCharset(foundCharset);\n142             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n143                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n144                 charsetName = foundCharset;\n145                 doc = null;\n146             } else if (!fullyRead) {\n147                 doc = null;\n148             }\n149         } else { // specified by content type header (or by user on file load)\n150             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n151         }\n152         if (doc == null) {\n153             if (charsetName == null)\n154                 charsetName = defaultCharset;\n155             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n156             if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n157                 reader.skip(1);\n158             try {\n159                 doc = parser.parseInput(reader, baseUri);\n160             } catch (UncheckedIOException e) {\n161                 // io exception when parsing (not seen before because reading the stream as we go)\n162                 throw e.ioException();\n163             }\n164             doc.outputSettings().charset(charsetName);\n165         }\n166         input.close();\n167         return doc;\n168     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_82", "report_text": "> UnsupportedOperationException thrown for charsets that don't support encoding\n> \n> ```\n> public static void main(String[] args) throws IOException {\n>     String html = \"<html><meta charset=\\\"ISO-2022-CN\\\"/></html>\";\n>     System.out.println(\n>         Jsoup.parse(new ByteArrayInputStream(html.getBytes()), null, \"\")\n>     );  \n> }\n> ```\n> throws\n> ```\n> Exception in thread \"main\" java.lang.UnsupportedOperationException\n> \tat sun.nio.cs.ext.ISO2022_CN.newEncoder(ISO2022_CN.java:76)\n> \tat org.jsoup.nodes.Document$OutputSettings.prepareEncoder(Document.java:443)\n> \tat org.jsoup.nodes.Node$OuterHtmlVisitor.(Node.java:704)\n> \tat org.jsoup.nodes.Node.outerHtml(Node.java:573)\n> \tat org.jsoup.nodes.Element.html(Element.java:1395)\n> \tat org.jsoup.nodes.Element.html(Element.java:1389)\n> \tat org.jsoup.nodes.Document.outerHtml(Document.java:195)\n> \tat org.jsoup.nodes.Element.toString(Element.java:1422)\n> \tat java.lang.String.valueOf(String.java:2982)\n> \tat java.io.PrintStream.println(PrintStream.java:821)\n> ```", "test_name": "org.jsoup.parser.HtmlParserTest::fallbackToUtfIfCantEncode", "test_method": "    @Test public void fallbackToUtfIfCantEncode() throws IOException {\n        // that charset can't be encoded, so make sure we flip to utf\n\n        String in = \"<html><meta charset=\\\"ISO-2022-CN\\\"/>One</html>\";\n        Document doc = Jsoup.parse(new ByteArrayInputStream(in.getBytes()), null, \"\");\n\n        assertEquals(\"UTF-8\", doc.charset().name()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[UTF-8]> but was:<[ISO-2022-CN]>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.fallbackToUtfIfCantEncode(HtmlParserTest.java:1207)", "buggy_method": "95 static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n96         if (input == null) // empty body\n97             return new Document(baseUri);\n98         input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n99 \n100         Document doc = null;\n101         boolean fullyRead = false;\n102 \n103         // read the start of the stream and look for a BOM or meta charset\n104         input.mark(bufferSize);\n105         ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n106         fullyRead = input.read() == -1;\n107         input.reset();\n108 \n109         // look for BOM - overrides any other header or input\n110         BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n111         if (bomCharset != null)\n112             charsetName = bomCharset.charset;\n113 \n114         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n115             String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n116             doc = parser.parseInput(docData, baseUri);\n117 \n118             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n119             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n120             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n121             for (Element meta : metaElements) {\n122                 if (meta.hasAttr(\"http-equiv\"))\n123                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n124                 if (foundCharset == null && meta.hasAttr(\"charset\"))\n125                     foundCharset = meta.attr(\"charset\");\n126                 if (foundCharset != null)\n127                     break;\n128             }\n129 \n130             // look for <?xml encoding='ISO-8859-1'?>\n131             if (foundCharset == null && doc.childNodeSize() > 0) {\n132                 Node first = doc.childNode(0);\n133                 XmlDeclaration decl = null;\n134                 if (first instanceof XmlDeclaration)\n135                     decl = (XmlDeclaration) first;\n136                 else if (first instanceof Comment) {\n137                     Comment comment = (Comment) first;\n138                     if (comment.isXmlDeclaration())\n139                         decl = comment.asXmlDeclaration();\n140                 }\n141                 if (decl != null) {\n142                     if (decl.name().equalsIgnoreCase(\"xml\"))\n143                         foundCharset = decl.attr(\"encoding\");\n144                 }\n145             }\n146             foundCharset = validateCharset(foundCharset);\n147             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n148                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n149                 charsetName = foundCharset;\n150                 doc = null;\n151             } else if (!fullyRead) {\n152                 doc = null;\n153             }\n154         } else { // specified by content type header (or by user on file load)\n155             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n156         }\n157         if (doc == null) {\n158             if (charsetName == null)\n159                 charsetName = defaultCharset;\n160             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n161             if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n162                 reader.skip(1);\n163             try {\n164                 doc = parser.parseInput(reader, baseUri);\n165             } catch (UncheckedIOException e) {\n166                 // io exception when parsing (not seen before because reading the stream as we go)\n167                 throw e.ioException();\n168             }\n169             Charset charset = Charset.forName(charsetName);\n170             doc.outputSettings().charset(charset);\n171                 // some charsets can read but not encode; switch to an encodable charset and update the meta el\n172         }\n173         input.close();\n174         return doc;\n175     }", "bm_classpath": "org.jsoup.helper.DataUtil"}, {"bug_name": "Jsoup_83", "report_text": "> Could handle missing tag ends (>) better\n> \n> We are using Jsoup to parse HTML documents from some external websites, which are not under our control. A few days ago, one of these sites updated their website, and introduced a bug, causing our crawling to fail spectacularly. The HTML which was broken looked a bit like this:\n> ```\n> <td class=\"my-cell\"\n>    <div class=\"great-formatting\">100</div>\n> </td>\n> ```\n> As you can see, the TD is missing a closing `>`, while we did a `document.select(\"div.great-formatting\")`. This failed, because Jsoup couldn't parse the document correctly anymore.\n> I understand it's a very edge case, and maybe very hard to fix. However, for us it was a production issue, and caused us quite a few headaches. Right now, we have a sort of preprocessor running over the HTML to close all elements which should be closed, but it would be much nicer if Jsoup would handle this out of the box.", "test_name": "org.jsoup.parser.HtmlParserTest::parsesQuiteRoughAttributes", "test_method": "    @Test public void parsesQuiteRoughAttributes() {\n        String html = \"<p =a>One<a <p>Something</p>Else\";\n        // this (used to; now gets cleaner) gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n        Document doc = Jsoup.parse(html);\n\n        // NOTE: per spec this should be the test case. but impacts too many ppl\n        // assertEquals(\"<p =a>One<a <p>Something</a></p>\\n<a <p>Else</a>\", doc.body().html());\n\n        assertEquals(\"<p =a>One<a></a></p><p><a>Something</a></p><a>Else</a>\", TextUtil.stripNewlines(doc.body().html())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<p =a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>> but was:<<p =a>One<a[ <p>Something</a></p><a <p]>Else</a>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.parsesQuiteRoughAttributes(HtmlParserTest.java:66)", "buggy_method": "244 String consumeTagName() {\n245         // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n246         // NOTE: out of spec, added '<' to fix common author bugs\n247         bufferUp();\n248         final int start = bufPos;\n249         final int remaining = bufLength;\n250         final char[] val = charBuf;\n251 \n252         while (bufPos < remaining) {\n253             final char c = val[bufPos];\n254             if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n255                 break;\n256             bufPos++;\n257         }\n258 \n259         return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n260     }", "bm_classpath": "org.jsoup.parser.CharacterReader"}, {"bug_name": "Jsoup_84", "report_text": "> W3CDom Helper fails to convert whenever some namespace declarations are missing\n> \n> Hello\n> I've been running into an issue where if I convert my Jsoup parsed document into a org.w3c.dom.Document with the W3CDom helper and that document happens to be missing namespace declarations we get the following exception:\n> ```\n> NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.\n> ```\n> I've looked into this a bit and first thing I tried was using a locally forked version of the W3CDom helper that simply turned this flag off:\n> ```\n> factory.setNamespaceAware(false);\n> ```\n> However the issue continued, so instead I simply hacked the code to completely ignore namespaces\n> ```\n> // (csueiras): We purposely remove any namespace because we get malformed HTML that might not be\n> // declaring all of it's namespaces!\n> Element el = doc.createElementNS(\"\", sourceEl.tagName());\n> ```\n> I am not completely sure if this will have any side effects, but it resolved the issues with the document I'm interacting with. I would be glad to provide a pull request if I have some guidance regarding how to properly handle this issue if it can be handled by Jsoup.\n> The document I'm having issues is simply making use of the Facebook like buttons using tags like this:\n> ```\n> <fb:like ...\n> ```\n> But there's no namespace declaration for \"fb\".", "test_name": "org.jsoup.helper.W3CDomTest::treatsUndeclaredNamespaceAsLocalName", "test_method": "    @Test public void treatsUndeclaredNamespaceAsLocalName() {\n        String html = \"<fb:like>One</fb:like>\";\n        org.jsoup.nodes.Document doc = Jsoup.parse(html);\n\n        Document w3Doc = new W3CDom().fromJsoup(doc); // <-- fails here\n    }", "error_message": "org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.\n\tcom.sun.org.apache.xerces.internal.dom.ElementNSImpl.setName(ElementNSImpl.java:153)\n\tcom.sun.org.apache.xerces.internal.dom.ElementNSImpl.<init>(ElementNSImpl.java:84)\n\tcom.sun.org.apache.xerces.internal.dom.CoreDocumentImpl.createElementNS(CoreDocumentImpl.java:2121)\n\torg.jsoup.helper.W3CDom$W3CBuilder.head(W3CDom.java:91)\n\torg.jsoup.select.NodeTraversor.traverse(NodeTraversor.java:45)\n\torg.jsoup.helper.W3CDom.convert(W3CDom.java:63)\n\torg.jsoup.helper.W3CDom.fromJsoup(W3CDom.java:44)\n\torg.jsoup.helper.W3CDomTest.treatsUndeclaredNamespaceAsLocalName(W3CDomTest.java:144)", "buggy_method": "82 public void head(org.jsoup.nodes.Node source, int depth) {\n83             namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n84             if (source instanceof org.jsoup.nodes.Element) {\n85                 org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n86 \n87                 String prefix = updateNamespaces(sourceEl);\n88                 String namespace = namespacesStack.peek().get(prefix);\n89                 String tagName = sourceEl.tagName();\n90 \n91                 Element el = \n92                     doc.createElementNS(namespace, tagName);\n93                 copyAttributes(sourceEl, el);\n94                 if (dest == null) { // sets up the root\n95                     doc.appendChild(el);\n96                 } else {\n97                     dest.appendChild(el);\n98                 }\n99                 dest = el; // descend\n100             } else if (source instanceof org.jsoup.nodes.TextNode) {\n101                 org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n102                 Text text = doc.createTextNode(sourceText.getWholeText());\n103                 dest.appendChild(text);\n104             } else if (source instanceof org.jsoup.nodes.Comment) {\n105                 org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n106                 Comment comment = doc.createComment(sourceComment.getData());\n107                 dest.appendChild(comment);\n108             } else if (source instanceof org.jsoup.nodes.DataNode) {\n109                 org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n110                 Text node = doc.createTextNode(sourceData.getWholeData());\n111                 dest.appendChild(node);\n112             } else {\n113                 // unhandled\n114             }\n115         }", "bm_classpath": "org.jsoup.helper.W3CDom$W3CBuilder"}, {"bug_name": "Jsoup_85", "report_text": "> Attribute.java line 45 variable key scope error, it seems should be \"this.key\"\n> \n> [![image](https://user-images.githubusercontent.com/41705526/49982508-ca65db80-ff11-11e8-9833-1775ddcc8871.png)](https://user-images.githubusercontent.com/41705526/49982508-ca65db80-ff11-11e8-9833-1775ddcc8871.png)\n> Attribute.java Line 45, it should be:\n> ```\n> Validate.notEmpty(this.key);\n> ```\n> rather than\n> ```\n> Validate.notEmpty(key);\n> ```\n> This issue only happens when **key** is blank or empty, in reality this would rarely happen, but in the syntax context it is still an issue, so better fix this.", "test_name": "org.jsoup.nodes.AttributeTest::validatesKeysNotEmpty", "test_method": "@Test(expected = IllegalArgumentException.class) public void validatesKeysNotEmpty() {\n        Attribute attr = new Attribute(\" \", \"Check\");\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: java.lang.IllegalArgumentException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "42 public Attribute(String key, String val, Attributes parent) {\n43         Validate.notNull(key);\n44         this.key = key.trim();\n45         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n46         this.val = val;\n47         this.parent = parent;\n48     }", "bm_classpath": "org.jsoup.nodes.Attribute"}, {"bug_name": "Jsoup_86", "report_text": "> Jsoup 1.11.3: IndexOutOfBoundsException\n> \n> Hi, I am using Jsoup 1.11.3. While trying to parse HTML content, I'm getting IndexOutOfBoundsException.\n> I am using such Jsoup call as this is the only way to parse iframe content.\n> Jsoup call:\n> `Jsoup.parse(html, \"\", Parser.xmlParser())`\n> HTML is here: <https://files.fm/u/v43yemgb>. I can't add it to the body as it's huge.", "test_name": "org.jsoup.parser.XmlTreeBuilderTest::handlesLTinScript", "test_method": "    @Test\n    public void handlesLTinScript() {\n        // https://github.com/jhy/jsoup/issues/1139\n        String html = \"<script> var a=\\\"<?\\\"; var b=\\\"?>\\\"; </script>\";\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser()); // <-- fails here\n    }", "error_message": "java.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n\tjava.util.ArrayList.rangeCheck(ArrayList.java:659)\n\tjava.util.ArrayList.get(ArrayList.java:435)\n\torg.jsoup.nodes.Element.child(Element.java:253)\n\torg.jsoup.nodes.Comment.asXmlDeclaration(Comment.java:79)\n\torg.jsoup.parser.XmlTreeBuilder.insert(XmlTreeBuilder.java:95)\n\torg.jsoup.parser.XmlTreeBuilder.process(XmlTreeBuilder.java:55)\n\torg.jsoup.parser.TreeBuilder.runParser(TreeBuilder.java:56)\n\torg.jsoup.parser.TreeBuilder.parse(TreeBuilder.java:47)\n\torg.jsoup.parser.Parser.parseInput(Parser.java:31)\n\torg.jsoup.Jsoup.parse(Jsoup.java:45)\n\torg.jsoup.parser.XmlTreeBuilderTest.handlesLTinScript(XmlTreeBuilderTest.java:245)", "buggy_method": "74 public XmlDeclaration asXmlDeclaration() {\n75         String data = getData();\n76         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n77         XmlDeclaration decl = null;\n78         if (doc.childNodeSize() > 0) {\n79             Element el = doc.child(0);\n80             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n81             decl.attributes().addAll(el.attributes());\n82         }\n83         return decl;\n84     }", "bm_classpath": "org.jsoup.nodes.Comment"}, {"bug_name": "Jsoup_88", "report_text": "> Attribute.getValue() broken for empty attributes since 1.11.1\n> \n> ```\n>         Document doc = Jsoup.parse(\"<div hidden>\");\n>         Attributes attributes = doc.body().child(0).attributes();\n>         System.out.println(String.format(\"Attr: '%s', value: '%s'\", \"hidden\",\n>                 attributes.get(\"hidden\")));\n>         Attribute first = attributes.iterator().next();\n>         System.out.println(String.format(\"Attr: '%s', value: '%s'\",\n>                 first.getKey(), first.getValue()));\n> ```\n> Expected output, as in 1.10.x\n> ```\n> Attr: 'hidden', value: ''\n> Attr: 'hidden', value: ''\n> ```\n> Output in 1.11.1-1.11.3:\n> ```\n> Attr: 'hidden', value: ''\n> Attr: 'hidden', value: 'null'\n> ```", "test_name": "org.jsoup.nodes.AttributeTest::booleanAttributesAreEmptyStringValues", "test_method": "    @Test public void booleanAttributesAreEmptyStringValues() {\n        Document doc = Jsoup.parse(\"<div hidden>\");\n        Attributes attributes = doc.body().child(0).attributes();\n\n        Attribute first = attributes.iterator().next();\n        assertEquals(\"\", first.getValue()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<> but was:<null>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.nodes.AttributeTest.booleanAttributesAreEmptyStringValues(AttributeTest.java:38)", "buggy_method": "79 public String getValue() {\n80         return val;\n81     }", "bm_classpath": "org.jsoup.nodes.Attribute"}, {"bug_name": "Jsoup_89", "report_text": "> NPE in Attribute.setValue() for attribute without parent\n> \n> ```\n>     public String setValue(String val) {\n>         String oldVal = parent.get(this.key);\n>         if (parent != null) {\n>             int i = parent.indexOfKey(this.key);\n>             if (i != Attributes.NotFound)\n>                 parent.vals[i] = val;\n>         }\n>         this.val = val;\n>         return oldVal;\n>     }\n> ```\n> Its useless to check `parent` for `null` after it has been dereferenced. I guess this is a copy-paste-bug:\n> ```\n>     public void setKey(String key) {\n>         Validate.notNull(key);\n>         key = key.trim();\n>         Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n>         if (parent != null) {\n>             int i = parent.indexOfKey(this.key);\n>             if (i != Attributes.NotFound)\n>                 parent.keys[i] = key;\n>         }\n>         this.key = key;\n>     }\n> ```", "test_name": "org.jsoup.nodes.AttributeTest::settersOnOrphanAttribute", "test_method": "    @Test public void settersOnOrphanAttribute() {\n        Attribute attr = new Attribute(\"one\", \"two\");\n        attr.setKey(\"three\");\n        String oldVal = attr.setValue(\"four\"); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.jsoup.nodes.Attribute.setValue(Attribute.java:88)\n\torg.jsoup.nodes.AttributeTest.settersOnOrphanAttribute(AttributeTest.java:44)", "buggy_method": "87 public String setValue(String val) {\n88         String oldVal = parent.get(this.key);\n89         if (parent != null) {\n90             int i = parent.indexOfKey(this.key);\n91             if (i != Attributes.NotFound)\n92                 parent.vals[i] = val;\n93         }\n94         this.val = val;\n95         return Attributes.checkNotNull(oldVal);\n96     }", "bm_classpath": "org.jsoup.nodes.Attribute"}, {"bug_name": "Jsoup_90", "report_text": "> ArrayIndexOutOfBoundsException when parsing with some URL\n> \n> ### error\n> ```\n> Caused by: java.lang.ArrayIndexOutOfBoundsException: 11\n> \tat org.jsoup.helper.HttpConnection$Base.looksLikeUtf8(HttpConnection.java:437)\n> \tat org.jsoup.helper.HttpConnection$Base.fixHeaderEncoding(HttpConnection.java:400)\n> \tat org.jsoup.helper.HttpConnection$Base.addHeader(HttpConnection.java:386)\n> \tat org.jsoup.helper.HttpConnection$Response.processResponseHeaders(HttpConnection.java:1075)\n> \tat org.jsoup.helper.HttpConnection$Response.setupFromConnection(HttpConnection.java:1019)\n> \tat org.jsoup.helper.HttpConnection$Response.execute(HttpConnection.java:752)\n> \tat org.jsoup.helper.HttpConnection$Response.execute(HttpConnection.java:722)\n> \tat org.jsoup.helper.HttpConnection.execute(HttpConnection.java:306)\n> ```\n> ### code\n> ```\n> try {\n>             String url = \"https://www.colisprive.com/moncolis/pages/detailColis.aspx?numColis=P4000000037777930\";\n>             Connection connection = Jsoup.connect(url).referrer(url).\n>                     userAgent(\"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\")\n>                     .ignoreContentType(true).timeout(20000);\n>            \n>             connection.method(Method.GET);\n>             return connection.execute().parse();\n>         } catch (Exception e) {\n>             throw new RuntimeException(e);\n>         }\n> ```", "test_name": "org.jsoup.helper.HttpConnectionTest::handlesHeaderEncodingOnRequest", "test_method": "    @Test public void handlesHeaderEncodingOnRequest() {\n        Connection.Request req = new HttpConnection.Request();\n        req.addHeader(\"xxx\", \"\u00e9\"); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 1\n\torg.jsoup.helper.HttpConnection$Base.looksLikeUtf8(HttpConnection.java:427)\n\torg.jsoup.helper.HttpConnection$Base.fixHeaderEncoding(HttpConnection.java:389)\n\torg.jsoup.helper.HttpConnection$Base.addHeader(HttpConnection.java:375)\n\torg.jsoup.helper.HttpConnectionTest.handlesHeaderEncodingOnRequest(HttpConnectionTest.java:256)", "buggy_method": "398 private static boolean looksLikeUtf8(byte[] input) {\n399             int i = 0;\n400             // BOM:\n401             if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n402                 && (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n403                 i = 3;\n404             }\n405 \n406             int end;\n407             for (int j = input.length; i < j; ++i) {\n408                 int o = input[i];\n409                 if ((o & 0x80) == 0) {\n410                     continue; // ASCII\n411                 }\n412 \n413                 // UTF-8 leading:\n414                 if ((o & 0xE0) == 0xC0) {\n415                     end = i + 1;\n416                 } else if ((o & 0xF0) == 0xE0) {\n417                     end = i + 2;\n418                 } else if ((o & 0xF8) == 0xF0) {\n419                     end = i + 3;\n420                 } else {\n421                     return false;\n422                 }\n423 \n424 \n425                 while (i < end) {\n426                     i++;\n427                     o = input[i];\n428                     if ((o & 0xC0) != 0x80) {\n429                         return false;\n430                     }\n431                 }\n432             }\n433             return true;\n434         }", "bm_classpath": "org.jsoup.helper.HttpConnection$Base"}, {"bug_name": "Jsoup_92", "report_text": "> Duplicated attribute parsing problem\n> \n> In case there is duplicated tag attribute Jsoup parses the last one, but Chrome browser takes the first one.", "test_name": "org.jsoup.parser.HtmlParserTest::retainsAttributesOfDifferentCaseIfSensitive", "test_method": "    @Test public void retainsAttributesOfDifferentCaseIfSensitive() {\n        String html = \"<p One=One One=Two one=Three two=Four two=Five Two=Six>Text</p>\";\n        Parser parser = Parser.htmlParser().settings(ParseSettings.preserveCase);\n        Document doc = parser.parseInput(html, \"\");\n        assertEquals(\"<p One=\\\"One\\\" one=\\\"Three\\\" two=\\\"Four\\\" Two=\\\"Six\\\">Text</p>\", doc.selectFirst(\"p\").outerHtml()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<<p One=\"[One\" one=\"Three\" two=\"Four]\" Two=\"Six\">Text</p>> but was:<<p One=\"[Two\" one=\"Three\" two=\"Five]\" Two=\"Six\">Text</p>>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.jsoup.parser.HtmlParserTest.retainsAttributesOfDifferentCaseIfSensitive(HtmlParserTest.java:74)", "buggy_method": "118 private void add(String key, String value) {\n119         checkCapacity(size + 1);\n120         keys[size] = key;\n121         vals[size] = value;\n122         size++;\n123     }", "bm_classpath": "org.jsoup.nodes.Attributes"}, {"bug_name": "Jsoup_93", "report_text": "> <input type=\"image\"> is not special cased in formData method\n> \n> The following code:\n> ```\n> import org.jsoup.Jsoup;\n> import org.jsoup.nodes.FormElement;\n> class Scratch {\n>     public static void main(String[] args) {\n>         System.out.println(((FormElement) Jsoup.parse(\"<form id=f><input type=image name=x></form>\").getElementById(\"f\")).formData());\n>     }\n> }\n> ```\n> Returns the following output:\n> ```\n> [x=]\n> ```\n> When either `[]` or `[x.x=0, x.y=0]` is expected (not sure which, but `[x=]` is definitely wrong).", "test_name": "org.jsoup.nodes.FormElementTest::createsFormData", "test_method": "    @Test public void createsFormData() {\n        String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n                \"<input name='ten' value='text' disabled>\" +\n                \"<input name='eleven' value='text' type='button'>\" +\n                \"</form>\";\n        Document doc = Jsoup.parse(html);\n        FormElement form = (FormElement) doc.select(\"form\").first();\n        List<Connection.KeyVal> data = form.formData();\n\n        assertEquals(6, data.size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<6> but was:<7>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.jsoup.nodes.FormElementTest.createsFormData(FormElementTest.java:39)", "buggy_method": "78 public List<Connection.KeyVal> formData() {\n79         ArrayList<Connection.KeyVal> data = new ArrayList<>();\n80 \n81         // iterate the form control elements and accumulate their values\n82         for (Element el: elements) {\n83             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n84             if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n85             String name = el.attr(\"name\");\n86             if (name.length() == 0) continue;\n87             String type = el.attr(\"type\");\n88 \n89 \n90             if (\"select\".equals(el.normalName())) {\n91                 Elements options = el.select(\"option[selected]\");\n92                 boolean set = false;\n93                 for (Element option: options) {\n94                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n95                     set = true;\n96                 }\n97                 if (!set) {\n98                     Element option = el.select(\"option\").first();\n99                     if (option != null)\n100                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n101                 }\n102             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n103                 // only add checkbox or radio if they have the checked attribute\n104                 if (el.hasAttr(\"checked\")) {\n105                     final String val = el.val().length() >  0 ? el.val() : \"on\";\n106                     data.add(HttpConnection.KeyVal.create(name, val));\n107                 }\n108             } else {\n109                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n110             }\n111         }\n112         return data;\n113     }", "bm_classpath": "org.jsoup.nodes.FormElement"}, {"bug_name": "JxPath_1", "report_text": "> Descendant or self axis does not work correctly at root node\n> \n> Given the following XML document: <root id=\"1234\"/>  \n> and the XPath: //root/@id/text().\n> JXPath returns null instead of \"1234\".\n> JXPathContext context = JXPathContext.newContext(doc);  \n> assertEquals(value, context.selectSingleNode(\"//root/@id/text()\"));\n> The attached JUnit test highlights the problem. It seems that JXPath does not  \n> find the root node if it is accessed with the axis descendant-or-self.", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testGetNode", "test_method": "    public void testGetNode() {\n        assertXPathNodeType(context, \"//vendor\", Element.class); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathNodeType(JXPathTestCase.java:224)\n\torg.apache.commons.jxpath.ri.model.dom.DOMModelTest.testGetNode(DOMModelTest.java:68)", "buggy_method": "87 public static boolean testNode(Node node, NodeTest test) {\n88         if (test == null) {\n89             return true;\n90         }\n91         else if (test instanceof NodeNameTest) {\n92             if (node.getNodeType() != Node.ELEMENT_NODE) {\n93                 return false;\n94             }\n95 \n96             NodeNameTest nodeNameTest = (NodeNameTest) test;\n97             QName testName = nodeNameTest.getNodeName();\n98             String namespaceURI = nodeNameTest.getNamespaceURI();\n99             boolean wildcard = nodeNameTest.isWildcard();\n100             String testPrefix = testName.getPrefix();\n101             if (wildcard && testPrefix == null) {\n102                 return true;\n103             }\n104 \n105             if (wildcard\n106                 || testName.getName()\n107                         .equals(DOMNodePointer.getLocalName(node))) {\n108                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n109                 return equalStrings(namespaceURI, nodeNS);\n110             }\n111         }\n112         else if (test instanceof NodeTypeTest) {\n113             int nodeType = node.getNodeType();\n114             switch (((NodeTypeTest) test).getNodeType()) {\n115                 case Compiler.NODE_TYPE_NODE :\n116                     return nodeType == Node.ELEMENT_NODE;\n117                 case Compiler.NODE_TYPE_TEXT :\n118                     return nodeType == Node.CDATA_SECTION_NODE\n119                         || nodeType == Node.TEXT_NODE;\n120                 case Compiler.NODE_TYPE_COMMENT :\n121                     return nodeType == Node.COMMENT_NODE;\n122                 case Compiler.NODE_TYPE_PI :\n123                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n124             }\n125             return false;\n126         }\n127         else if (test instanceof ProcessingInstructionTest) {\n128             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n129                 String testPI = ((ProcessingInstructionTest) test).getTarget();\n130                 String nodePI = ((ProcessingInstruction) node).getTarget();\n131                 return testPI.equals(nodePI);\n132             }\n133         }\n134         return false;\n135     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "JxPath_2", "report_text": "> does not properly handle NodeSet returned by extension function\n> \n> Per the documentation, my function is returning a BasicNodeSet containing zero  \n> or more pointers:\n>  public static NodeSet observations(ExpressionContext context) {  \n>  // the cast below shouldn't break, as this is the only pointer type that  \n>  // makes sense in this context  \n>  List<NodePointer> ptrs = extractObservations(  \n>  (NodePointer)context.getContextNodePointer(),   \n>  new ArrayList<NodePointer>());  \n>  BasicNodeSet result = new BasicNodeSet();  \n>  for (NodePointer ptr : ptrs) \n> {\n>  result.add(ptr);\n>  }\n>  return result;  \n>  }\n> However, if I call JXPathContext.selectNodes(\"ems:observations()\"), I'm getting  \n> a single node containing the BasicNodeSet. I notice that there is a testcase for  \n> functions that return NodeSets, but that it uses expressions that actually  \n> return the children of the NodeSet (\"test:nodeSet()/name\").\n> There appear to be two problems. First, Expression.iterate() and  \n> Expression.iteratePointers() do not correctly recognize a NodeSet as something  \n> iterable. I've resolved this by reaching into the NodeSet and getting an  \n> iterator over its pointers.\n> Second, Expression.PointerIterator doesn't recognize when it already has a  \n> pointer, and instead tries to wrap it in a new pointer. This ends up treating  \n> the pointer as a bean.\n> I've made these changes, and written a testcase that uses an unadorned NodeSet  \n> function. I also found a class that used a variable named \"enum\", and changed  \n> this so that it would compile under 1.5.\n> The patch is attached. It's relative to \"commons-jxpath-1.2\" (root of extract  \n> directory).", "test_name": "org.apache.commons.jxpath.ri.compiler.ExtensionFunctionTest::testNodeSetReturn", "test_method": "    public void testNodeSetReturn() {\n\n        assertXPathValueIterator(\n            context,\n            \"test:nodeSet()\",\n            list(testBean.getBeans()[0], testBean.getBeans()[1])); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating value iterator <test:nodeSet()> expected:<[Nested: Name 1, Nested: Name 2]> but was:<[[/beans[1], /beans[2]]]>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValueIterator(JXPathTestCase.java:158)\n\torg.apache.commons.jxpath.ri.compiler.ExtensionFunctionTest.testNodeSetReturn(ExtensionFunctionTest.java:342)", "buggy_method": "72 public Iterator iterate(EvalContext context) {\n73         Object result = compute(context);\n74         if (result instanceof EvalContext) {\n75             return new ValueIterator((EvalContext) result);\n76         }\n77         return ValueUtils.iterate(result);\n78     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.Expression"}, {"bug_name": "JxPath_3", "report_text": "> StackOverflow error on a call to 'JXPathContext.createPath()'\n> \n> I'm running into a StackOverflow error on a call to  \n> 'JXPathContext.createPath()' whenever I have a path that looks like  \n> 'a/b[1]/c'. I took a quick look at the code and it appears JXPath, when  \n> trying to create its parent pointer, simply recreates an equivalent  \n> pointer(???).\n> Here is code to reproduce the problem.\n>  Map map = new HashMap();  \n>  map.put(\"a\", null);\n>  JXPathContext pathContext = JXPathContext.newContext(map);  \n>  pathContext.setFactory(new AbstractFactory() {  \n>  public boolean createObject(  \n>  JXPathContext context, Pointer pointer, Object parent, String  \n> name, int index) {\n>  Map parentMap = (Map)parent;  \n>  System.out.println(parent + \":\" + name + \":\" + index);  \n>  if (index > -1) {  \n>  List list = (List)parentMap.get(name);  \n>  if (list == null) \n> {\n>  list = new ArrayList();\n>  }  \n>  int size = list.size();  \n>  for (int i = size; i <= index; i++) {\n>  list.add(i, null);\n>  }  \n>  parentMap.put(name, list);  \n>  } else {\n>  parentMap.put(name, new HashMap());\n>  }  \n>  return true;  \n>  }  \n>   \n>  });  \n>  pathContext.createPath(\"a/b[1]/c\");  \n>   \n> \\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*  \n>   \n> I have continued looking into this, and found that the problem is that, if  \n> the List is created with a 'null' element, JXPath gets stuck in infinite  \n> recursion.  \n>   \n> To discover this, I changed my Factory to implement the following method:  \n>   \n>  public boolean createObject(  \n>  JXPathContext context, Pointer pointer, Object parent,   \n>  String name, int index) {  \n>   \n>  if (pointer instanceof NodePointer) {\n>  index = ((NodePointer)pointer).getIndex();\n>  }  \n>  System.out.println(parent + \":\" + name + \":\" + index);  \n>  Map parentMap = (Map)parent;  \n>  if (index > -1) {  \n>  List list = (List)parentMap.get(name);  \n>  if (list == null) { list = new ArrayList(); }\n>  int size = list.size();  \n>  for (int i = size; i <= index; i++) \n> {\n>  list.add(i, new HashMap()); // !!!!!! Don't set to 'null'\n>  }\n>  parentMap.put(name, list);  \n>  } else \n> {\n>  parentMap.put(name, new HashMap());\n>  }\n>  return true;  \n>  }\n> Then I ran the following code:\n>  pathContext.createPath(\"a/b[1]/c\");  \n>  pathContext.createPath(\"a/b[2]/c\"); // STACK OVERFLOW HERE\n> Here is the stack trace at the beginning, where  \n> 'ValueUtils.expandCollection()' is called. It puts 'null' into the list,  \n> thus causing the stack overflow as we cycle between createPath() &  \n> createChild().\n> Thread [main] (Suspended (breakpoint at line 227 in DynamicPropertyPointer))  \n>  DynamicPropertyPointer.createPath(JXPathContext) line: 227  \n>  DynamicPropertyPointer(PropertyPointer).createChild(JXPathContext,  \n> QName, int) line: 188  \n>  NullElementPointer.createPath(JXPathContext) line: 82  \n>  NullPointer.createPath(JXPathContext) line: 86  \n>  NullPropertyPointer.createPath(JXPathContext) line: 103  \n>  NullPointer.createPath(JXPathContext) line: 86  \n>  NullPropertyPointer.createPath(JXPathContext) line: 103  \n>  JXPathContextReferenceImpl.createPath(String, Expression) line: 447  \n>  JXPathContextReferenceImpl.createPath(String) line: 427  \n>  Test.test4() line: 75  \n>  Test.main(String[]) line: 38", "test_name": "org.apache.commons.jxpath.ri.model.beans.BadlyImplementedFactoryTest::testBadFactoryImplementation", "test_method": "    public void testBadFactoryImplementation() {\n        try {\n            context.createPath(\"foo/bar\");\n            fail(\"should fail with JXPathException caused by JXPathAbstractFactoryException\");\n        } catch (JXPathException e) {\n            assertTrue(e.getCause() instanceof JXPathAbstractFactoryException);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.jxpath.ri.model.beans.BadlyImplementedFactoryTest.testBadFactoryImplementation(BadlyImplementedFactoryTest.java:64)", "buggy_method": "130 public NodePointer createPath(JXPathContext context, Object value) {\n131         NodePointer newParent = parent.createPath(context);\n132         if (isAttribute()) {\n133             NodePointer pointer = newParent.createAttribute(context, getName());\n134             pointer.setValue(value);\n135             return pointer;\n136         }\n137         else {\n138             if (newParent instanceof PropertyOwnerPointer) {\n139                 PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n140                 newParent = pop.getPropertyPointer();\n141             }\n142             return newParent.createChild(context, getName(), index, value);\n143         }\n144     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer"}, {"bug_name": "JxPath_4", "report_text": "> JXpath automatically trims string values\n> \n> When an xml contains a value with leading or trailing spaces, JXPath trims this value.  \n> example: <value> 12324 56</value> is retrieved by JXPath as : '1234 56' while I expect ' 1234 56'.", "test_name": "org.apache.commons.jxpath.ri.model.XMLSpaceTest::testPreserveDOM", "test_method": "    public void testPreserveDOM() {\n        doTest(\"preserve\", DocumentContainer.MODEL_DOM, \" foo \"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<foo> but was:< foo >\n\torg.apache.commons.jxpath.ri.model.XMLSpaceTest.doTest(XMLSpaceTest.java:55)\n\torg.apache.commons.jxpath.ri.model.XMLSpaceTest.testPreserveDOM(XMLSpaceTest.java:67)", "buggy_method": "296 protected String getLanguage() {\n297         Node n = node;\n298         while (n != null) {\n299             if (n.getNodeType() == Node.ELEMENT_NODE) {\n300                 Element e = (Element) n;\n301                 String attr = e.getAttribute(\"xml:lang\");\n302                 if (attr != null && !attr.equals(\"\")) {\n303                     return attr;\n304                 }\n305             }\n306             n = n.getParentNode();\n307         }\n308         return null;\n309     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "JxPath_5", "report_text": "> Cannot compare pointers that do not belong to the same tree\n> \n> For XPath \"$var | /MAIN/A\" exception is thrown:\n> org.apache.commons.jxpath.JXPathException: Cannot compare pointers that do not belong to the same tree: '$var' and ''  \n>  at org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:665)  \n>  at org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)  \n>  at org.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:649)  \n>  at org.apache.commons.jxpath.ri.model.NodePointer.compareTo(NodePointer.java:639)  \n>  at java.util.Arrays.mergeSort(Arrays.java:1152)  \n>  at java.util.Arrays.sort(Arrays.java:1079)  \n>  at java.util.Collections.sort(Collections.java:113)  \n>  at org.apache.commons.jxpath.ri.EvalContext.constructIterator(EvalContext.java:176)  \n>  at org.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:100)  \n>  at org.apache.commons.jxpath.JXPathContext.selectNodes(JXPathContext.java:648)  \n>  at org.apache.commons.jxpath.ri.model.VariablePointerTestCase.testUnionOfVariableAndNode(VariablePointerTestCase.java:76)", "test_name": "org.apache.commons.jxpath.ri.compiler.VariableTest::testUnionOfVariableAndNode", "test_method": "    public void testUnionOfVariableAndNode() throws Exception {\n        Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder().parse(\n                        new InputSource(new StringReader(\n                                \"<MAIN><A/><A/></MAIN>\")));\n\n        JXPathContext context = JXPathContext.newContext(doc);\n        context.getVariables().declareVariable(\"var\", \"varValue\");\n        int sz = 0;\n        for (Iterator ptrs = context.iteratePointers(\"$var | /MAIN/A\"); ptrs.hasNext(); sz++) {\n            ptrs.next();\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.jxpath.JXPathException: Cannot compare pointers that do not belong to the same tree: '' and '$var'\n\torg.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:665)\n\torg.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:653)\n\torg.apache.commons.jxpath.ri.model.NodePointer.compareNodePointers(NodePointer.java:653)\n\torg.apache.commons.jxpath.ri.model.NodePointer.compareTo(NodePointer.java:639)\n\tjava.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)\n\tjava.util.ComparableTimSort.sort(ComparableTimSort.java:188)\n\tjava.util.Arrays.sort(Arrays.java:1312)\n\tjava.util.Arrays.sort(Arrays.java:1506)\n\tjava.util.ArrayList.sort(ArrayList.java:1464)\n\tjava.util.Collections.sort(Collections.java:143)\n\torg.apache.commons.jxpath.ri.EvalContext.constructIterator(EvalContext.java:176)\n\torg.apache.commons.jxpath.ri.EvalContext.hasNext(EvalContext.java:100)\n\torg.apache.commons.jxpath.ri.compiler.VariableTest.testUnionOfVariableAndNode(VariableTest.java:286)", "buggy_method": "642 private int compareNodePointers(\n643         NodePointer p1,\n644         int depth1,\n645         NodePointer p2,\n646         int depth2) \n647     {\n648         if (depth1 < depth2) {\n649             int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n650             return r == 0 ? -1 : r;\n651         }\n652         if (depth1 > depth2) {\n653             int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n654             return r == 0 ? 1 : r;\n655         }\n656         if (p1 == null && p2 == null) {\n657             return 0;\n658         }\n659 \n660         if (p1 != null && p1.equals(p2)) {\n661             return 0;\n662         }\n663 \n664         if (depth1 == 1) {\n665             throw new JXPathException(\n666                     \"Cannot compare pointers that do not belong to the same tree: '\"\n667                             + p1 + \"' and '\" + p2 + \"'\");\n668         }\n669         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n670         if (r != 0) {\n671             return r;\n672         }\n673 \n674         return p1.parent.compareChildNodePointers(p1, p2);\n675     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.NodePointer"}, {"bug_name": "JxPath_6", "report_text": "> equality test for multi-valued variables does not conform to spec\n> \n> given e.g. variable d=\n> {\"a\", \"b\"}\n> , the spec implies that \"$d = 'a'\" and that \"$d = 'b'\". Instead of iterating the variable's components its immediate content (here, the String[]) is compared, causing the aforementioned assertions to fail.", "test_name": "org.apache.commons.jxpath.ri.compiler.VariableTest::testIterateVariable", "test_method": "    public void testIterateVariable() throws Exception {\n        assertXPathValue(context, \"$d = 'a'\", Boolean.TRUE); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <$d = 'a'> expected:<true> but was:<false>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:55)\n\torg.apache.commons.jxpath.ri.compiler.VariableTest.testIterateVariable(VariableTest.java:278)", "buggy_method": "45 protected boolean equal(\n46         EvalContext context,\n47         Expression left,\n48         Expression right) \n49     {\n50         Object l = left.compute(context);\n51         Object r = right.compute(context);\n52 \n53 //        System.err.println(\"COMPARING: \" +\n54 //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n55 //            (r == null ? \"null\" : r.getClass().getName()));\n56 \n57         if (l instanceof InitialContext || l instanceof SelfContext) {\n58             l = ((EvalContext) l).getSingleNodePointer();\n59         }\n60 \n61         if (r instanceof InitialContext || r instanceof SelfContext) {\n62             r = ((EvalContext) r).getSingleNodePointer();\n63         }\n64 \n65         if (l instanceof Collection) {\n66             l = ((Collection) l).iterator();\n67         }\n68 \n69         if (r instanceof Collection) {\n70             r = ((Collection) r).iterator();\n71         }\n72 \n73         if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n74             return contains((Iterator) l, r);\n75         }\n76         if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n77             return contains((Iterator) r, l);\n78         }\n79         if (l instanceof Iterator && r instanceof Iterator) {\n80             return findMatch((Iterator) l, (Iterator) r);\n81         }\n82         return equal(l, r);\n83     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare"}, {"bug_name": "JxPath_7", "report_text": "> Binary operators behaviour involving node-sets is incorrect\n> \n> According to XPath specification:  \n> \"If both objects to be compared are node-sets, then the comparison will be true if and only if there is a node in the first node-set and a node in the second node-set such that the result of performing the comparison on the string-values of the two nodes is true. If one object to be compared is a node-set and the other is a number, then the comparison will be true if and only if there is a node in the node-set such that the result of performing the comparison on the number to be compared and on the result of converting the string-value of that node to a number using the number function is true.\"\n> But following example illustrates, that this is not a JXPath behaviour:\n>  JXPathContext pathContext = JXPathContext  \n>  .newContext(DocumentBuilderFactory.newInstance()  \n>  .newDocumentBuilder().parse(  \n>  new InputSource(new StringReader(  \n>  \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\"  \n>  + \"<doc/>\"))));  \n>  Boolean result = (Boolean) pathContext.getValue(\"2.0 > child1\",  \n>  Boolean.class);  \n>  assertFalse(result.booleanValue());\n> \"child1\" is not found - right operand node set is empty, but result is TRUE, instead of FALSE.\n> Please, check greaterThan(), lesserThan(), etc methods of org.apache.xpath.objects.XObject for possible solution ![](/jira/images/icons/emoticons/smile.png)", "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNodeSetOperations", "test_method": "    public void testNodeSetOperations() {\n        assertXPathValue(context, \"$array > 0\", Boolean.TRUE, Boolean.class); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <$array > 0> expected:<true> but was:<false>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:63)\n\torg.apache.commons.jxpath.ri.compiler.CoreOperationTest.testNodeSetOperations(CoreOperationTest.java:100)", "buggy_method": "33 public Object computeValue(EvalContext context) {\n34         double l = InfoSetUtil.doubleValue(args[0].computeValue(context));\n35         double r = InfoSetUtil.doubleValue(args[1].computeValue(context));\n36         return l > r ? Boolean.TRUE : Boolean.FALSE;\n37     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan"}, {"bug_name": "JxPath_8", "report_text": "> Comparing with NaN is incorrect\n> \n> 'NaN' > 'NaN' is true, but should be FALSE", "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNan", "test_method": "    public void testNan() {\n        assertXPathValue(context, \"$nan > $nan\", Boolean.FALSE, Boolean.class); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <$nan > $nan> expected:<false> but was:<true>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:63)\n\torg.apache.commons.jxpath.ri.compiler.CoreOperationTest.testNan(CoreOperationTest.java:116)", "buggy_method": "56 private boolean compute(Object left, Object right) {\n57         left = reduce(left);\n58         right = reduce(right);\n59 \n60         if (left instanceof InitialContext) {\n61             ((InitialContext) left).reset();\n62         }\n63         if (right instanceof InitialContext) {\n64             ((InitialContext) right).reset();\n65         }\n66         if (left instanceof Iterator && right instanceof Iterator) {\n67             return findMatch((Iterator) left, (Iterator) right);\n68         }\n69         if (left instanceof Iterator) {\n70             return containsMatch((Iterator) left, right);\n71         }\n72         if (right instanceof Iterator) {\n73             return containsMatch((Iterator) right, left);\n74         }\n75         double ld = InfoSetUtil.doubleValue(left);\n76         double rd = InfoSetUtil.doubleValue(right);\n77         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n78     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression"}, {"bug_name": "JxPath_9", "report_text": "> Comparing with NaN is incorrect\n> \n> 'NaN' > 'NaN' is true, but should be FALSE", "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testNan", "test_method": "    public void testNan() {\n        assertXPathValue(context, \"$nan = $nan\", Boolean.FALSE, Boolean.class); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <$nan = $nan> expected:<false> but was:<true>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:63)\n\torg.apache.commons.jxpath.ri.compiler.CoreOperationTest.testNan(CoreOperationTest.java:121)", "buggy_method": "120 protected boolean equal(Object l, Object r) {\n121         if (l instanceof Pointer && r instanceof Pointer) {\n122             if (l.equals(r)) {\n123                 return true;\n124             }\n125         }\n126         if (l instanceof Pointer) {\n127             l = ((Pointer) l).getValue();\n128         }\n129 \n130         if (r instanceof Pointer) {\n131             r = ((Pointer) r).getValue();\n132         }\n133 \n134         if (l == r) {\n135             return true;\n136         }\n137         if (l instanceof Boolean || r instanceof Boolean) {\n138             return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n139             }\n140             //if either side is NaN, no comparison returns true:\n141         if (l instanceof Number || r instanceof Number) {\n142             return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n143             }\n144             if (l instanceof String || r instanceof String) {\n145             return (\n146                 InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n147         }\n148         return l != null && l.equals(r);\n149     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationCompare"}, {"bug_name": "JxPath_10", "report_text": "> Binary operators behaviour involving node-sets is incorrect\n> \n> According to XPath specification:  \n> \"If both objects to be compared are node-sets, then the comparison will be true if and only if there is a node in the first node-set and a node in the second node-set such that the result of performing the comparison on the string-values of the two nodes is true. If one object to be compared is a node-set and the other is a number, then the comparison will be true if and only if there is a node in the node-set such that the result of performing the comparison on the number to be compared and on the result of converting the string-value of that node to a number using the number function is true.\"\n> But following example illustrates, that this is not a JXPath behaviour:\n>  JXPathContext pathContext = JXPathContext  \n>  .newContext(DocumentBuilderFactory.newInstance()  \n>  .newDocumentBuilder().parse(  \n>  new InputSource(new StringReader(  \n>  \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\r\\n\"  \n>  + \"<doc/>\"))));  \n>  Boolean result = (Boolean) pathContext.getValue(\"2.0 > child1\",  \n>  Boolean.class);  \n>  assertFalse(result.booleanValue());\n> \"child1\" is not found - right operand node set is empty, but result is TRUE, instead of FALSE.\n> Please, check greaterThan(), lesserThan(), etc methods of org.apache.xpath.objects.XObject for possible solution ![](/jira/images/icons/emoticons/smile.png)", "test_name": "org.apache.commons.jxpath.ri.compiler.CoreOperationTest::testEmptyNodeSetOperations", "test_method": "    public void testEmptyNodeSetOperations() {\n        assertXPathValue(context, \"/idonotexist >= 0\", Boolean.FALSE, Boolean.class); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating </idonotexist >= 0> expected:<false> but was:<true>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:63)\n\torg.apache.commons.jxpath.ri.compiler.CoreOperationTest.testEmptyNodeSetOperations(CoreOperationTest.java:120)", "buggy_method": "41 public final Object computeValue(EvalContext context) {\n42         return compute(args[0].computeValue(context), args[1].computeValue(context)) \n43                 ? Boolean.TRUE : Boolean.FALSE;\n44     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression"}, {"bug_name": "JxPath_11", "report_text": "> Incomplete handling of undefined namespaces\n> \n> Mcduffey, Joe <jdmcduf@nsa.gov>\n> Can someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: xsi\n> For example the following  \n> <ElementA A:myAttr=\"Mytype\">  \n>  <B:ElementB>MY VALUE</B:ElementB>  \n> </ElementA>\n> Would result in the following exception:  \n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: A\n> FYI: In this example there was a namespace decaration in the file and I also manually called the  \n> registerNamespace(A,\"/http...\");  \n> registerNamespace(B,\"/http...\");\n> There was no problem encountered for elements. Only attributes. Can someone help? Thanks.", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testNamespaceMapping", "test_method": "public void testNamespaceMapping() {\n        context.registerNamespace(\"rate\", \"priceNS\");\n        context.registerNamespace(\"goods\", \"productNS\");\n\n        assertEquals(\"Context node namespace resolution\", \n                \"priceNS\", \n                context.getNamespaceURI(\"price\"));        \n        \n        assertEquals(\"Registered namespace resolution\", \n                \"priceNS\", \n                context.getNamespaceURI(\"rate\"));\n\n        // child:: with a namespace and wildcard\n        assertXPathValue(context, \n                \"count(vendor/product/rate:*)\", \n                new Double(2));\n\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/rate:amount[1]/@rate:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/rate:amount[1]/@price:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/price:amount[1]/@rate:discount\", \"10%\");\n        assertXPathValue(context,\n                \"vendor[1]/product[1]/price:amount[1]/@price:discount\", \"10%\");\n\n        // Preference for externally registered namespace prefix\n        assertXPathValueAndPointer(context,\n                \"//product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n        \n        // Same, but with a child context        \n        JXPathContext childCtx = \n            JXPathContext.newContext(context, context.getContextBean());\n        assertXPathValueAndPointer(childCtx,\n                \"//product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n        \n        // Same, but with a relative context        \n        JXPathContext relativeCtx = \n            context.getRelativeContext(context.getPointer(\"/vendor\"));\n        assertXPathValueAndPointer(relativeCtx,\n                \"product/product:name\",\n                \"Box of oranges\",\n                \"/vendor[1]/product[1]/goods:name[1]\");\n    }\n}", "error_message": "junit.framework.AssertionFailedError: Evaluating <vendor[1]/product[1]/rate:amount[1]/@rate:discount> expected:<10%> but was:<20%>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:55)\n\torg.apache.commons.jxpath.ri.model.XMLModelTestCase.testNamespaceMapping(XMLModelTestCase.java:800)", "buggy_method": "106 private Attr getAttribute(Element element, QName name) {\n107         String testPrefix = name.getPrefix();\n108         String testNS = null;\n109 \n110         if (testPrefix != null) {\n111             testNS = parent.getNamespaceURI(testPrefix);\n112         }\n113 \n114         if (testNS != null) {\n115             Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n116             if (attr != null) {\n117                 return attr;\n118             }\n119 \n120             // This may mean that the parser does not support NS for\n121             // attributes, example - the version of Crimson bundled\n122             // with JDK 1.4.0\n123             NamedNodeMap nnm = element.getAttributes();\n124             for (int i = 0; i < nnm.getLength(); i++) {\n125                 attr = (Attr) nnm.item(i);\n126                 if (testAttr(attr, name)) {\n127                     return attr;\n128                 }\n129             }\n130             return null;\n131         }\n132         return element.getAttributeNode(name.getName());\n133     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator"}, {"bug_name": "JxPath_12", "report_text": "> Incomplete handling of undefined namespaces\n> \n> Mcduffey, Joe <jdmcduf@nsa.gov>\n> Can someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: xsi\n> For example the following  \n> <ElementA A:myAttr=\"Mytype\">  \n>  <B:ElementB>MY VALUE</B:ElementB>  \n> </ElementA>\n> Would result in the following exception:  \n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: A\n> FYI: In this example there was a namespace decaration in the file and I also manually called the  \n> registerNamespace(A,\"/http...\");  \n> registerNamespace(B,\"/http...\");\n> There was no problem encountered for elements. Only attributes. Can someone help? Thanks.", "test_name": "org.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest::testElementDOM", "test_method": "    public void testElementDOM() {\n        doTestElement(DocumentContainer.MODEL_DOM); // <-- fails here\n    }", "error_message": "org.apache.commons.jxpath.JXPathNotFoundException: No value for xpath: /ElementA/B:ElementB\n\torg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:355)\n\torg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue(JXPathContextReferenceImpl.java:289)\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:54)\n\torg.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest.doTest(ExternalXMLNamespaceTest.java:54)\n\torg.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest.doTestElement(ExternalXMLNamespaceTest.java:62)\n\torg.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest.testElementDOM(ExternalXMLNamespaceTest.java:70)", "buggy_method": "87 public static boolean testNode(Node node, NodeTest test) {\n88         if (test == null) {\n89             return true;\n90         }\n91         if (test instanceof NodeNameTest) {\n92             if (node.getNodeType() != Node.ELEMENT_NODE) {\n93                 return false;\n94             }\n95 \n96             NodeNameTest nodeNameTest = (NodeNameTest) test;\n97             QName testName = nodeNameTest.getNodeName();\n98             String namespaceURI = nodeNameTest.getNamespaceURI();\n99             boolean wildcard = nodeNameTest.isWildcard();\n100             String testPrefix = testName.getPrefix();\n101             if (wildcard && testPrefix == null) {\n102                 return true;\n103             }\n104             if (wildcard\n105                 || testName.getName()\n106                         .equals(DOMNodePointer.getLocalName(node))) {\n107                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n108                 return equalStrings(namespaceURI, nodeNS);\n109             }\n110             return false;\n111         }\n112         if (test instanceof NodeTypeTest) {\n113             int nodeType = node.getNodeType();\n114             switch (((NodeTypeTest) test).getNodeType()) {\n115                 case Compiler.NODE_TYPE_NODE :\n116                     return nodeType == Node.ELEMENT_NODE\n117                             || nodeType == Node.DOCUMENT_NODE;\n118                 case Compiler.NODE_TYPE_TEXT :\n119                     return nodeType == Node.CDATA_SECTION_NODE\n120                         || nodeType == Node.TEXT_NODE;\n121                 case Compiler.NODE_TYPE_COMMENT :\n122                     return nodeType == Node.COMMENT_NODE;\n123                 case Compiler.NODE_TYPE_PI :\n124                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n125             }\n126             return false;\n127         }\n128         if (test instanceof ProcessingInstructionTest) {\n129             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n130                 String testPI = ((ProcessingInstructionTest) test).getTarget();\n131                 String nodePI = ((ProcessingInstruction) node).getTarget();\n132                 return testPI.equals(nodePI);\n133             }\n134         }\n135         return false;\n136     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "JxPath_13", "report_text": "> Incomplete handling of undefined namespaces\n> \n> Mcduffey, Joe <jdmcduf@nsa.gov>\n> Can someone tell me how to register namespaces so that attributes with namespaces does not cause the exception\n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: xsi\n> For example the following  \n> <ElementA A:myAttr=\"Mytype\">  \n>  <B:ElementB>MY VALUE</B:ElementB>  \n> </ElementA>\n> Would result in the following exception:  \n> org.apache.common.ri.model.dom.DOMNodePointer.createAttribute  \n> unknown namespace prefix: A\n> FYI: In this example there was a namespace decaration in the file and I also manually called the  \n> registerNamespace(A,\"/http...\");  \n> registerNamespace(B,\"/http...\");\n> There was no problem encountered for elements. Only attributes. Can someone help? Thanks.", "test_name": "org.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest::testCreateAndSetAttributeDOM", "test_method": "    public void testCreateAndSetAttributeDOM() {\n        doTestCreateAndSetAttribute(DocumentContainer.MODEL_DOM); // <-- fails here\n    }", "error_message": "org.apache.commons.jxpath.JXPathException: Unknown namespace prefix: A\n\torg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(JXPathContextReferenceImpl.java:479)\n\torg.apache.commons.jxpath.ri.JXPathContextReferenceImpl.createPathAndSetValue(JXPathContextReferenceImpl.java:467)\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathCreatePathAndSetValue(JXPathTestCase.java:108)\n\torg.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest.doTestCreateAndSetAttribute(ExternalXMLNamespaceTest.java:70)\n\torg.apache.commons.jxpath.ri.model.ExternalXMLNamespaceTest.testCreateAndSetAttributeDOM(ExternalXMLNamespaceTest.java:83)", "buggy_method": "107 public synchronized String getNamespaceURI(String prefix) {\n108 \n109     /**\n110      * Given a prefix, returns an externally registered namespace URI.\n111      * \n112      * @param prefix The namespace prefix to look up\n113      * @return namespace URI or null if the prefix is undefined.\n114      * @since JXPath 1.3\n115      */\n116         String uri = (String) namespaceMap.get(prefix);\n117         if (uri == null && pointer != null) {\n118             uri = pointer.getNamespaceURI(prefix);\n119         }\n120         if (uri == null && parent != null) {\n121             return parent.getNamespaceURI(prefix);\n122         }\n123         return uri;\n124     }", "bm_classpath": "org.apache.commons.jxpath.ri.NamespaceResolver"}, {"bug_name": "JxPath_14", "report_text": "> Core rounding functions don't handle NaN or infinite values correctly\n> \n>  assertXPathValue(context, \"floor('NaN')\", new Double(Double.NaN));  \n>  assertXPathValue(context, \"floor(-2 div 0)\", new Double(Double.NEGATIVE\\_INFINITY));  \n>  assertXPathValue(context, \"floor(2 div 0)\", new Double(Double.POSITIVE\\_INFINITY));\n>  assertXPathValue(context, \"ceiling('NaN')\", new Double(Double.NaN));  \n>  assertXPathValue(context, \"ceiling(-2 div 0)\", new Double(Double.NEGATIVE\\_INFINITY));  \n>  assertXPathValue(context, \"ceiling(2 div 0)\", new Double(Double.POSITIVE\\_INFINITY));\n>  assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN));  \n>  assertXPathValue(context, \"round(-2 div 0)\", new Double(Double.NEGATIVE\\_INFINITY));  \n>  assertXPathValue(context, \"round(2 div 0)\", new Double(Double.POSITIVE\\_INFINITY));", "test_name": "org.apache.commons.jxpath.ri.compiler.CoreFunctionTest::testCoreFunctions", "test_method": "    public void testCoreFunctions() {\n\n\n        assertXPathValue(context, \"round('NaN')\", new Double(Double.NaN)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <round('NaN')> expected:<NaN> but was:<0.0>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:55)\n\torg.apache.commons.jxpath.ri.compiler.CoreFunctionTest.testCoreFunctions(CoreFunctionTest.java:126)", "buggy_method": "653 protected Object functionFloor(EvalContext context) {\n654         assertArgCount(1);\n655         double v = InfoSetUtil.doubleValue(getArg1().computeValue(context));\n656         return new Double(Math.floor(v));\n657     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreFunction"}, {"bug_name": "JxPath_15", "report_text": "> Core union operation does not sort result nodes according to document order\n> \n> Source document:  \n> <MAIN><A>avalue</A><B>bvalue</B></MAIN>\n> According to string() function defintion:  \n> \"A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned.\"\n> Following XPath calculated incorrectly:  \n>  string(/MAIN/B | /MAIN/A)\n> Expected result: \"avalue\"  \n> Actual value: \"bvalue\"\n> Reason:  \n> sorting of result nodes is missing from CoreOperationUnion", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testUnion", "test_method": "public void testUnion() {\n        assertXPathValue(context, \"/vendor[1]/contact[1] | /vendor[1]/contact[4]\", \"John\");\n        assertXPathValue(context, \"/vendor[1]/contact[4] | /vendor[1]/contact[1]\", \"John\");\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating </vendor[1]/contact[4] | /vendor[1]/contact[1]> expected:<John> but was:<Jack Black>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:55)\n\torg.apache.commons.jxpath.ri.model.XMLModelTestCase.testUnion(XMLModelTestCase.java:834)", "buggy_method": "45 public boolean setPosition(int position) {\n46         if (!prepared) {\n47             prepared = true;\n48             BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet();\n49             ArrayList pointers = new ArrayList();\n50             for (int i = 0; i < contexts.length; i++) {\n51                 EvalContext ctx = (EvalContext) contexts[i];\n52                 while (ctx.nextSet()) {\n53                     while (ctx.nextNode()) {\n54                         NodePointer ptr = ctx.getCurrentNodePointer();\n55                         if (!pointers.contains(ptr)) {\n56                             nodeSet.add(ptr);\n57                             pointers.add(ptr);\n58                         }\n59                     }\n60                 }\n61             }\n62         }\n63         return super.setPosition(position);\n64     }", "bm_classpath": "org.apache.commons.jxpath.ri.axes.UnionContext"}, {"bug_name": "JxPath_16", "report_text": "> node() implementation in DOM and JDOM model\n> \n> I think that the code in DOMNodePointer.java, line 120 is wrong because considers only element and document to be matched by node().  \n> while instead it matches any node that pass from there.\n> case Compiler.NODE\\_TYPE\\_NODE :  \n>  return nodeType == Node.ELEMENT\\_NODE\n> |  nodeType == Node.DOCUMENT\\_NODE; |\n> | --- |\n> should be changed to \n> case Compiler.NODE\\_TYPE\\_NODE :  \n>  return true;\n> Same in JDOMNodePointer, line 391\n>  return true;//(node instanceof Element) || (node instanceof Document);", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisFollowing", "test_method": "public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }", "error_message": "junit.framework.ComparisonFailure: Evaluating pointer <//location[2]/following::node()[2]> expected:<...vendor[1]/product[1][]> but was:<...vendor[1]/product[1][/product:name[1]]>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathPointer(JXPathTestCase.java:125)\n\torg.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisFollowing(XMLModelTestCase.java:644)", "buggy_method": "117 public static boolean testNode(Node node, NodeTest test) {\n118         if (test == null) {\n119             return true;\n120         }\n121         if (test instanceof NodeNameTest) {\n122             if (node.getNodeType() != Node.ELEMENT_NODE) {\n123                 return false;\n124             }\n125 \n126             NodeNameTest nodeNameTest = (NodeNameTest) test;\n127             QName testName = nodeNameTest.getNodeName();\n128             String namespaceURI = nodeNameTest.getNamespaceURI();\n129             boolean wildcard = nodeNameTest.isWildcard();\n130             String testPrefix = testName.getPrefix();\n131             if (wildcard && testPrefix == null) {\n132                 return true;\n133             }\n134             if (wildcard\n135                 || testName.getName()\n136                         .equals(DOMNodePointer.getLocalName(node))) {\n137                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n138                 return equalStrings(namespaceURI, nodeNS) || nodeNS == null\n139                         && equalStrings(testPrefix, getPrefix(node));\n140             }\n141             return false;\n142         }\n143         if (test instanceof NodeTypeTest) {\n144             int nodeType = node.getNodeType();\n145             switch (((NodeTypeTest) test).getNodeType()) {\n146                 case Compiler.NODE_TYPE_NODE :\n147                     return nodeType == Node.ELEMENT_NODE\n148                             || nodeType == Node.DOCUMENT_NODE;\n149                 case Compiler.NODE_TYPE_TEXT :\n150                     return nodeType == Node.CDATA_SECTION_NODE\n151                         || nodeType == Node.TEXT_NODE;\n152                 case Compiler.NODE_TYPE_COMMENT :\n153                     return nodeType == Node.COMMENT_NODE;\n154                 case Compiler.NODE_TYPE_PI :\n155                     return nodeType == Node.PROCESSING_INSTRUCTION_NODE;\n156             }\n157             return false;\n158         }\n159         if (test instanceof ProcessingInstructionTest) {\n160             if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) {\n161                 String testPI = ((ProcessingInstructionTest) test).getTarget();\n162                 String nodePI = ((ProcessingInstruction) node).getTarget();\n163                 return testPI.equals(nodePI);\n164             }\n165         }\n166         return false;\n167     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "JxPath_17", "report_text": "> Namespaced attribute not selected with wildcard\n> \n> With expression:\n> xml/@\\*\n> On xml:\n> <xml xmlns:x='foo' x:pop='a'/>\n> selectSingleNode returns null, @x:\\* works fine.\n> Possible Fix:\n> In DOMAttributeIterator, line 84\n> if (equalStrings(testPrefix, nodePrefix)) \n> {\n>  return true;\n>  }  \n>   \n> should probably be changed to  \n>   \n> if (testPrefix==null || equalStrings(testPrefix, nodePrefix)) { return true; }\n>  ", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute", "test_method": "public void testAxisAttribute() {\n        // attribute::\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n        // attribute:: produces the correct pointer\n        assertXPathPointer(\n            context,\n            \"vendor/location/@id\",\n            \"/vendor[1]/location[1]/@id\");\n\n        // iterate over attributes\n        assertXPathValueIterator(\n            context,\n            \"vendor/location/@id\",\n            list(\"100\", \"101\"));\n\n        // Using different prefixes for the same namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@price:discount\",\n            \"10%\");\n        \n        // namespace uri for an attribute\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n            \"priceNS\");\n\n        // local name of an attribute\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n            \"discount\");\n\n        // name for an attribute\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@price:discount)\",\n            \"price:discount\");\n\n        // attribute:: with the default namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@discount\",\n            \"20%\");\n\n        // namespace uri of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n            \"\");\n\n        // local name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // attribute:: with a namespace and wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@price:*\",\n            list(\"10%\"));\n\n        // attribute:: with a wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/location[1]/@*\",\n            set(\"100\", \"\", \"local\"));\n\n        // attribute:: with default namespace and wildcard\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/@*\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n\n        // attribute:: select non-ns'd attributes only\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n            list(\"20%\"));\n\n        // Empty attribute\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n        // Missing attribute\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n        // Missing attribute with namespace\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n        // Using attribute in a predicate\n        assertXPathValue(\n            context,\n            \"vendor/location[@id='101']//street\",\n            \"Tangerine Drive\");\n        \n        assertXPathValueIterator(\n            context,\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n            \"local\"));\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating value iterator <vendor/product/price:amount/@*> expected:<[10%, 20%]> but was:<[20%]>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValueIterator(JXPathTestCase.java:158)\n\torg.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisAttribute(XMLModelTestCase.java:555)", "buggy_method": "68 private boolean testAttr(Attr attr) {\n69         String nodePrefix = DOMNodePointer.getPrefix(attr);\n70         String nodeLocalName = DOMNodePointer.getLocalName(attr);\n71 \n72         if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n73             return false;\n74         }\n75 \n76         if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n77             return false;\n78         }\n79 \n80         String testLocalName = name.getName();\n81         if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n82             String testPrefix = name.getPrefix();\n83 \n84             if (equalStrings(testPrefix, nodePrefix)) {\n85                 return true;\n86             }\n87             String testNS = null;\n88             if (testPrefix != null) {\n89                 testNS = parent.getNamespaceURI(testPrefix);\n90             }\n91             String nodeNS = null;\n92             if (nodePrefix != null) {\n93                 nodeNS = parent.getNamespaceURI(nodePrefix);\n94             }\n95             return equalStrings(testNS, nodeNS);\n96         }\n97         return false;\n98     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMAttributeIterator"}, {"bug_name": "JxPath_18", "report_text": "> Issue with attribute::\n> \n> Checking test (Issue172\\_CountAttributeNode) I came with the following fix for the code in AttributeContext line 72  \n> from \n> ---\n> if (!(nodeTest instanceof NodeNameTest)) \n> {\n>  return false;\n>  }\n>  QName name = ((NodeNameTest) nodeTest).getNodeName();\n> ------  \n> '  \n> to   \n> \u2014 (outside method)  \n> private static final QName WILDCARD = new QName(\"\", \"\\*\");  \n> \u2014 (in method)\n> final QName name ;  \n> if (nodeTest instanceof NodeTypeTest)  \n> {  \n>  if (((NodeTypeTest) nodeTest).getNodeType() == Compiler.NODE\\_TYPE\\_NODE)  \n>  name = WILDCARD;  \n>  else return false;  \n> }  \n> else if (nodeTest instanceof NodeNameTest) {  \n>  name = ((NodeNameTest) nodeTest).getNodeName();  \n> }  \n> else  \n> {  \n>  return false;  \n> }", "test_name": "org.apache.commons.jxpath.ri.model.dom.DOMModelTest::testAxisAttribute", "test_method": "public void testAxisAttribute() {\n        // attribute::\n        assertXPathValue(context, \"vendor/location/@id\", \"100\");\n\n        // attribute:: produces the correct pointer\n        assertXPathPointer(\n            context,\n            \"vendor/location/@id\",\n            \"/vendor[1]/location[1]/@id\");\n\n        // iterate over attributes\n        assertXPathValueIterator(\n            context,\n            \"vendor/location/@id\",\n            list(\"100\", \"101\"));\n\n        // Using different prefixes for the same namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@price:discount\",\n            \"10%\");\n        \n        // namespace uri for an attribute\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@price:discount)\",\n            \"priceNS\");\n\n        // local name of an attribute\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@price:discount)\",\n            \"discount\");\n\n        // name for an attribute\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@price:discount)\",\n            \"price:discount\");\n\n        // attribute:: with the default namespace\n        assertXPathValue(\n            context,\n            \"vendor/product/price:amount/@discount\",\n            \"20%\");\n\n        // namespace uri of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"namespace-uri(vendor/product/price:amount/@discount)\",\n            \"\");\n\n        // local name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // name of an attribute with the default namespace\n        assertXPathValue(\n            context,\n            \"name(vendor/product/price:amount/@discount)\",\n            \"discount\");\n\n        // attribute:: with a namespace and wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@price:*\",\n            list(\"10%\"));\n\n        // attribute:: with a wildcard\n        assertXPathValueIterator(\n            context,\n            \"vendor/location[1]/@*\",\n            set(\"100\", \"\", \"local\"));\n\n        // attribute:: with default namespace and wildcard\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/@*\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n\n        // attribute::node()\n        assertXPathValueIterator(\n                context,\n                \"vendor/product/price:amount/attribute::node()\",\n                //use a set because DOM returns attrs sorted by name, JDOM by occurrence order:\n                set(\"10%\", \"20%\"));\n        \n        // attribute:: select non-ns'd attributes only\n        assertXPathValueIterator(\n            context,\n            \"vendor/product/price:amount/@*[namespace-uri() = '']\",\n            list(\"20%\"));\n\n        // Empty attribute\n        assertXPathValue(context, \"vendor/location/@manager\", \"\");\n\n        // Missing attribute\n        assertXPathValueLenient(context, \"vendor/location/@missing\", null);\n\n        // Missing attribute with namespace\n        assertXPathValueLenient(context, \"vendor/location/@miss:missing\", null);\n\n        // Using attribute in a predicate\n        assertXPathValue(\n            context,\n            \"vendor/location[@id='101']//street\",\n            \"Tangerine Drive\");\n        \n        assertXPathValueIterator(\n            context,\n            \"/vendor/location[1]/@*[name()!= 'manager']\", list(\"100\",\n            \"local\"));\n    }\n\n    public void testAxisNamespace() {\n        // namespace::\n        assertXPathValueAndPointer(\n            context,\n            \"vendor/product/prix/namespace::price\",\n            \"priceNS\",\n            \"/vendor[1]/product[1]/prix[1]/namespace::price\");\n\n        // namespace::*\n        assertXPathValue(\n            context,\n            \"count(vendor/product/namespace::*)\",\n            new Double(3));\n\n        // name of namespace\n        assertXPathValue(\n            context,\n            \"name(vendor/product/prix/namespace::price)\",\n            \"price\");\n\n        // local name of namespace\n        assertXPathValue(\n            context,\n            \"local-name(vendor/product/prix/namespace::price)\",\n            \"price\");\n    }\n\n    public void testAxisAncestor() {\n        // ancestor::\n        assertXPathValue(\n            context,\n            \"vendor/product/price:sale/saleEnds/\"\n                + \"ancestor::price:sale/saleEnds\",\n            \"never\");\n\n        // ancestor:: with a wildcard\n        assertXPathValue(\n            context,\n            \"vendor/product/price:sale/saleEnds/ancestor::price:*\"\n                + \"/saleEnds\",\n            \"never\");\n    }\n\n    public void testAxisAncestorOrSelf() {\n        // ancestor-or-self::\n        assertXPathValue(\n            context,\n            \"vendor/product/price:sale/\"\n                + \"ancestor-or-self::price:sale/saleEnds\",\n            \"never\");\n    }\n\n    public void testAxisFollowing() {\n        assertXPathValueIterator(\n            context,\n            \"vendor/contact/following::location//street\",\n            list(\"Orchard Road\", \"Tangerine Drive\"));\n\n        // following:: with a namespace\n        assertXPathValue(\n            context,\n            \"//location/following::price:sale/saleEnds\",\n            \"never\");\n        assertXPathPointer(context, \"//location[2]/following::node()[2]\", \"/vendor[1]/product[1]\");\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating value iterator <vendor/product/price:amount/attribute::node()> expected:<[10%, 20%]> but was:<[]>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValueIterator(JXPathTestCase.java:158)\n\torg.apache.commons.jxpath.ri.model.XMLModelTestCase.testAxisAttribute(XMLModelTestCase.java:562)", "buggy_method": "71 public boolean nextNode() {\n72         super.setPosition(getCurrentPosition() + 1);\n73         if (!setStarted) {\n74             setStarted = true;\n75             if (!(nodeTest instanceof NodeNameTest)) {\n76                 return false;\n77             }\n78             QName name = ((NodeNameTest) nodeTest).getNodeName();\n79             iterator =\n80                 parentContext.getCurrentNodePointer().attributeIterator(name);\n81         }\n82         if (iterator == null) {\n83             return false;\n84         }\n85         if (!iterator.setPosition(iterator.getPosition() + 1)) {\n86             return false;\n87         }\n88         currentNodePointer = iterator.getNodePointer();\n89         return true;\n90     }", "bm_classpath": "org.apache.commons.jxpath.ri.axes.AttributeContext"}, {"bug_name": "JxPath_19", "report_text": "> JXPathContext.iteratePointers() does not work with multiple prefixes for a single namespace URI\n> \n> Have a look at the following document:\n> <a:doc xmlns:a=\"ns\">  \n>  <a:elem />  \n>  <b:elem xmlns:b=\"ns\" />  \n> </a:doc>\n> We have two elements 'elem' in the same namespace 'ns'.  \n> They have a different prefix, however.\n> When we use JXPathContext.iteratePointers() to iterate over them, the first element is returned two times. The second element is not returned.\n> This is because  \n> in class org.apache.commons.jxpath.ri.model.dom.DOMNodePointer  \n> in method getRelativePositionByName() (line 546)  \n> we have:\n> if (nm.equals(node.getNodeName()))\n> In the example, we have  \n> nm == \"a:elem\" and node == \"b:elem\"\n> Thus, equals() returns false. But since 'a' and 'b' are just different prefixes for the same namespace URI, we should have 'true'.\n> I attached a testcase which reproduces the bug.", "test_name": "org.apache.commons.jxpath.ri.model.AliasedNamespaceIterationTest::testIterateJDOM", "test_method": "    public void testIterateJDOM() {\n        doTestIterate(DocumentContainer.MODEL_JDOM); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating pointer iterator </a:doc/a:elem> expected:<[/a:doc[1]/a:elem[1], /a:doc[1]/a:elem[2]]> but was:<[/a:doc[1]/a:elem[1], /a:doc[1]/a:elem[1]]>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathPointerIterator(JXPathTestCase.java:176)\n\torg.apache.commons.jxpath.ri.model.AliasedNamespaceIterationTest.doTestIterate(AliasedNamespaceIterationTest.java:50)\n\torg.apache.commons.jxpath.ri.model.AliasedNamespaceIterationTest.testIterateJDOM(AliasedNamespaceIterationTest.java:58)", "buggy_method": "556 private int getRelativePositionByQName() {\n557         int count = 1;\n558         Node n = node.getPreviousSibling();\n559         while (n != null) {\n560             if (n.getNodeType() == Node.ELEMENT_NODE) {\n561                 String nm = n.getNodeName();\n562                 if (nm.equals(node.getNodeName())) {\n563                 count++;\n564                 }\n565             }\n566             n = n.getPreviousSibling();\n567         }\n568         return count;\n569     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "JxPath_20", "report_text": "> relational operations do not function properly when comparing a non-Iterator LHS to an Iterator RHS\n> \n> I have a simple JXpathContext, with the following variables: var1=0, var2=0, var3=1. When I try to evaluate the following expression - \"$var1 + $var2 <= $var3\", it returns false.", "test_name": "org.apache.commons.jxpath.ri.compiler.JXPath149Test::testComplexOperationWithVariables", "test_method": "    public void testComplexOperationWithVariables() {\n        JXPathContext context = JXPathContext.newContext(null);\n        context.getVariables().declareVariable(\"a\", Integer.valueOf(0));\n        context.getVariables().declareVariable(\"b\", Integer.valueOf(0));\n        context.getVariables().declareVariable(\"c\", Integer.valueOf(1));\n        assertXPathValue(context, \"$a + $b <= $c\", Boolean.TRUE); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <$a + $b <= $c> expected:<true> but was:<false>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:52)\n\torg.apache.commons.jxpath.ri.compiler.JXPath149Test.testComplexOperationWithVariables(JXPath149Test.java:29)", "buggy_method": "71 private boolean compute(Object left, Object right) {\n72         left = reduce(left);\n73         right = reduce(right);\n74 \n75         if (left instanceof InitialContext) {\n76             ((InitialContext) left).reset();\n77         }\n78         if (right instanceof InitialContext) {\n79             ((InitialContext) right).reset();\n80         }\n81         if (left instanceof Iterator && right instanceof Iterator) {\n82             return findMatch((Iterator) left, (Iterator) right);\n83         }\n84         if (left instanceof Iterator) {\n85             return containsMatch((Iterator) left, right);\n86         }\n87         if (right instanceof Iterator) {\n88             return containsMatch((Iterator) right, left);\n89         }\n90         double ld = InfoSetUtil.doubleValue(left);\n91         if (Double.isNaN(ld)) {\n92             return false;\n93         }\n94         double rd = InfoSetUtil.doubleValue(right);\n95         if (Double.isNaN(rd)) {\n96             return false;\n97         }\n98         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n99     }", "bm_classpath": "org.apache.commons.jxpath.ri.compiler.CoreOperationRelationalExpression"}, {"bug_name": "JxPath_21", "report_text": "> null handling is inconsistent\n> \n> Comparing a vaule to null using unequals (!=) yields false!\n> ```\n>         Map<String, Integer> m = new HashMap<String, Integer>();\n>         m.put(\"a\", 1);\n>         m.put(\"b\", null);\n>         m.put(\"c\", 1);\n>         JXPathContext c = JXPathContext.newContext(m);\n>         System.out.println(c.getValue(\"a != b\") + \" should be true\");\n>         System.out.println(c.getValue(\"a != c\") + \" should be false\");\n>         System.out.println(c.getValue(\"a = b\") + \" should be false\");\n>         System.out.println(c.getValue(\"a = c\") + \" should be true\");\n>         System.out.println(c.getValue(\"not(a = b)\") + \" should be true\");\n>         System.out.println(c.getValue(\"not(a = c)\") + \" should be false\");\n> ```\n> Output using 1.3:  \n>  false should be true  \n> false should be false  \n> false should be false  \n> true should be true  \n> true should be true  \n> false should be false\n> In 1.2 it works correctly!", "test_name": "org.apache.commons.jxpath.ri.model.JXPath151Test::testMapValueEquality", "test_method": "    public void testMapValueEquality() {\n        assertXPathValue(context, \"map/b != map/a\", Boolean.TRUE); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Evaluating <map/b != map/a> expected:<true> but was:<false>\n\torg.apache.commons.jxpath.JXPathTestCase.assertXPathValue(JXPathTestCase.java:52)\n\torg.apache.commons.jxpath.ri.model.JXPath151Test.testMapValueEquality(JXPath151Test.java:43)", "buggy_method": "151 public int getLength() {\n152         return ValueUtils.getLength(getBaseValue());\n153     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.beans.PropertyPointer"}, {"bug_name": "JxPath_22", "report_text": "> Resetting the default namespace causes a serious endless loop when requesting .asPath() on a node.\n> \n> sample smaller case:\n> ```\n> <...>\n>  <b:foo xmlns:b=\"bla\" xmlns=\"test111\">    <!--  No nodes are placed in the tree within ns \"test111\" but the attribute is still there.-->\n>   <b:bar>a</b:bar>                         <!-- is in ns 'bla' -->\n>   <test xmlns=\"\"></test>                   <!-- does not have a namespace -->\n>  </b:foo>\n> </...>\n> ```\n> when requesting .asPath() on the 'test' node, it loops in org.apache.commons.jxpath.ri.NamespaceResolver.getPrefix(NodePointer, String),   \n> and if it didn't loop it would create a wrong xpath '//b:fo/null:test' DOMNodePointer.asPath().\n> So I think that the fix should be in org.apache.commons.jxpath.ri.model.dom.DOMNodePointer.asPath()\n> ```\n> ....\n>                     String ln = DOMNodePointer.getLocalName(node);\n>                     String nsURI = getNamespaceURI();\n>                     if (nsURI == null) {\n>                         buffer.append(ln);\n>                         buffer.append('[');\n>                         buffer.append(getRelativePositionByName()).append(']');\n>                     }\n>                     else {\n>                         String prefix = getNamespaceResolver().getPrefix(nsURI);\n>                         if (prefix != null) {\n> ...\n> ```\n> should become\n> ```\n> ...\n>                     String ln = DOMNodePointer.getLocalName(node);\n>                     String nsURI = getNamespaceURI();\n>                     if (nsURI == null || nsURI.length() == 0) { // check for empty string which means that the node doesn't have a namespace.\n>                         buffer.append(ln);\n>                         buffer.append('[');\n>                         buffer.append(getRelativePositionByName()).append(']');\n>                     }\n>                     else {\n>                         String prefix = getNamespaceResolver().getPrefix(nsURI);\n>                         if (prefix != null) {\n> ...\n> ```", "test_name": "org.apache.commons.jxpath.ri.model.JXPath154Test::testInnerEmptyNamespaceDOM", "test_method": "    public void testInnerEmptyNamespaceDOM() {\n        doTest(\"b:foo/test\", DocumentContainer.MODEL_DOM, \"/b:foo[1]/test[1]\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:</b:foo[1]/[test[1]]> but was:</b:foo[1]/[node()[2]]>\n\torg.apache.commons.jxpath.ri.model.JXPath154Test.doTest(JXPath154Test.java:17)\n\torg.apache.commons.jxpath.ri.model.JXPath154Test.testInnerEmptyNamespaceDOM(JXPath154Test.java:21)", "buggy_method": "672 public static String getNamespaceURI(Node node) {\n673         if (node instanceof Document) {\n674             node = ((Document) node).getDocumentElement();\n675         }\n676 \n677         Element element = (Element) node;\n678 \n679         String uri = element.getNamespaceURI();\n680         if (uri == null) {\n681             String prefix = getPrefix(node);\n682             String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n683     \n684             Node aNode = node;\n685             while (aNode != null) {\n686                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n687                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n688                     if (attr != null) {\n689                         return attr.getValue();\n690                     }\n691                 }\n692                 aNode = aNode.getParentNode();\n693             }\n694             return null;\n695         }\n696         return uri;\n697     }", "bm_classpath": "org.apache.commons.jxpath.ri.model.dom.DOMNodePointer"}, {"bug_name": "Lang_1", "report_text": "> NumberUtils does not handle Long Hex numbers\n> \n> NumberUtils.createLong() does not handle hex numbers, but createInteger() handles hex and octal.  \n> This seems odd.\n> NumberUtils.createNumber() assumes that hex numbers can only be Integer.  \n> Again, why not handle bigger Hex numbers?\n> ==\n> It is trivial to fix createLong() - just use Long.decode() instead of valueOf().  \n> It's not clear why this was not done originally - the decode() method was added to both Integer and Long in Java 1.2.\n> Fixing createNumber() is also fairly easy - if the hex string has more than 8 digits, use Long.\n> Should we allow for leading zeros in an Integer?   \n> If not, the length check is trivial.", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::TestLang747", "test_method": "    @Test\n    public void TestLang747() {\n        assertEquals(Long.valueOf(0x80000000L),    NumberUtils.createNumber(\"0x80000000\")); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: For input string: \"80000000\"\n\tjava.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tjava.lang.Integer.parseInt(Integer.java:583)\n\tjava.lang.Integer.valueOf(Integer.java:740)\n\tjava.lang.Integer.decode(Integer.java:1197)\n\torg.apache.commons.lang3.math.NumberUtils.createInteger(NumberUtils.java:684)\n\torg.apache.commons.lang3.math.NumberUtils.createNumber(NumberUtils.java:474)\n\torg.apache.commons.lang3.math.NumberUtilsTest.TestLang747(NumberUtilsTest.java:256)", "buggy_method": "450 public static Number createNumber(final String str) throws NumberFormatException {\n451         if (str == null) {\n452             return null;\n453         }\n454         if (StringUtils.isBlank(str)) {\n455             throw new NumberFormatException(\"A blank string is not a valid number\");\n456         }\n457         // Need to deal with all possible hex prefixes here\n458         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n459         int pfxLen = 0;\n460         for(final String pfx : hex_prefixes) {\n461             if (str.startsWith(pfx)) {\n462                 pfxLen += pfx.length();\n463                 break;\n464             }\n465         }\n466         if (pfxLen > 0) { // we have a hex number\n467             final int hexDigits = str.length() - pfxLen;\n468             if (hexDigits > 16) { // too many for Long\n469                 return createBigInteger(str);\n470             }\n471             if (hexDigits > 8) { // too many for an int\n472                 return createLong(str);\n473             }\n474             return createInteger(str);\n475         }\n476         final char lastChar = str.charAt(str.length() - 1);\n477         String mant;\n478         String dec;\n479         String exp;\n480         final int decPos = str.indexOf('.');\n481         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n482         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n483         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n484 \n485         int numDecimals = 0; // Check required precision (LANG-693)\n486         if (decPos > -1) { // there is a decimal point\n487 \n488             if (expPos > -1) { // there is an exponent\n489                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n490                     throw new NumberFormatException(str + \" is not a valid number.\");\n491                 }\n492                 dec = str.substring(decPos + 1, expPos);\n493             } else {\n494                 dec = str.substring(decPos + 1);\n495             }\n496             mant = str.substring(0, decPos);\n497             numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n498         } else {\n499             if (expPos > -1) {\n500                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n501                     throw new NumberFormatException(str + \" is not a valid number.\");\n502                 }\n503                 mant = str.substring(0, expPos);\n504             } else {\n505                 mant = str;\n506             }\n507             dec = null;\n508         }\n509         if (!Character.isDigit(lastChar) && lastChar != '.') {\n510             if (expPos > -1 && expPos < str.length() - 1) {\n511                 exp = str.substring(expPos + 1, str.length() - 1);\n512             } else {\n513                 exp = null;\n514             }\n515             //Requesting a specific type..\n516             final String numeric = str.substring(0, str.length() - 1);\n517             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n518             switch (lastChar) {\n519                 case 'l' :\n520                 case 'L' :\n521                     if (dec == null\n522                         && exp == null\n523                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n524                         try {\n525                             return createLong(numeric);\n526                         } catch (final NumberFormatException nfe) { // NOPMD\n527                             // Too big for a long\n528                         }\n529                         return createBigInteger(numeric);\n530 \n531                     }\n532                     throw new NumberFormatException(str + \" is not a valid number.\");\n533                 case 'f' :\n534                 case 'F' :\n535                     try {\n536                         final Float f = NumberUtils.createFloat(numeric);\n537                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n538                             //If it's too big for a float or the float value = 0 and the string\n539                             //has non-zeros in it, then float does not have the precision we want\n540                             return f;\n541                         }\n542 \n543                     } catch (final NumberFormatException nfe) { // NOPMD\n544                         // ignore the bad number\n545                     }\n546                     //$FALL-THROUGH$\n547                 case 'd' :\n548                 case 'D' :\n549                     try {\n550                         final Double d = NumberUtils.createDouble(numeric);\n551                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n552                             return d;\n553                         }\n554                     } catch (final NumberFormatException nfe) { // NOPMD\n555                         // ignore the bad number\n556                     }\n557                     try {\n558                         return createBigDecimal(numeric);\n559                     } catch (final NumberFormatException e) { // NOPMD\n560                         // ignore the bad number\n561                     }\n562                     //$FALL-THROUGH$\n563                 default :\n564                     throw new NumberFormatException(str + \" is not a valid number.\");\n565 \n566             }\n567         }\n568         //User doesn't have a preference on the return type, so let's start\n569         //small and go from there...\n570         if (expPos > -1 && expPos < str.length() - 1) {\n571             exp = str.substring(expPos + 1, str.length());\n572         } else {\n573             exp = null;\n574         }\n575         if (dec == null && exp == null) { // no decimal point and no exponent\n576             //Must be an Integer, Long, Biginteger\n577             try {\n578                 return createInteger(str);\n579             } catch (final NumberFormatException nfe) { // NOPMD\n580                 // ignore the bad number\n581             }\n582             try {\n583                 return createLong(str);\n584             } catch (final NumberFormatException nfe) { // NOPMD\n585                 // ignore the bad number\n586             }\n587             return createBigInteger(str);\n588         }\n589 \n590         //Must be a Float, Double, BigDecimal\n591         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n592         try {\n593             if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n594                 final Float f = createFloat(str);\n595                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n596                     return f;\n597                 }\n598             }\n599         } catch (final NumberFormatException nfe) { // NOPMD\n600             // ignore the bad number\n601         }\n602         try {\n603             if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n604                 final Double d = createDouble(str);\n605                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n606                     return d;\n607                 }\n608             }\n609         } catch (final NumberFormatException nfe) { // NOPMD\n610             // ignore the bad number\n611         }\n612 \n613         return createBigDecimal(str);\n614     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_3", "report_text": "> Method createNumber from NumberUtils doesn't work for floating point numbers other than Float\n> \n> Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testStringCreateNumberEnsureNoPrecisionLoss", "test_method": "    @Test\n    public void testStringCreateNumberEnsureNoPrecisionLoss(){\n        String shouldBeFloat = \"1.23\";\n        String shouldBeDouble = \"3.40282354e+38\";\n        String shouldBeBigDecimal = \"1.797693134862315759e+308\";\n        \n        assertTrue(NumberUtils.createNumber(shouldBeDouble) instanceof Double); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.lang3.math.NumberUtilsTest.testStringCreateNumberEnsureNoPrecisionLoss(NumberUtilsTest.java:129)", "buggy_method": "450 public static Number createNumber(final String str) throws NumberFormatException {\n451         if (str == null) {\n452             return null;\n453         }\n454         if (StringUtils.isBlank(str)) {\n455             throw new NumberFormatException(\"A blank string is not a valid number\");\n456         }\n457         // Need to deal with all possible hex prefixes here\n458         final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n459         int pfxLen = 0;\n460         for(final String pfx : hex_prefixes) {\n461             if (str.startsWith(pfx)) {\n462                 pfxLen += pfx.length();\n463                 break;\n464             }\n465         }\n466         if (pfxLen > 0) { // we have a hex number\n467             final int hexDigits = str.length() - pfxLen;\n468             if (hexDigits > 16) { // too many for Long\n469                 return createBigInteger(str);\n470             }\n471             if (hexDigits > 8) { // too many for an int\n472                 return createLong(str);\n473             }\n474             return createInteger(str);\n475         }\n476         final char lastChar = str.charAt(str.length() - 1);\n477         String mant;\n478         String dec;\n479         String exp;\n480         final int decPos = str.indexOf('.');\n481         final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n482         // if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n483         // and the parsing which will detect if e or E appear in a number due to using the wrong offset\n484 \n485         int numDecimals = 0; // Check required precision (LANG-693)\n486         if (decPos > -1) { // there is a decimal point\n487 \n488             if (expPos > -1) { // there is an exponent\n489                 if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n490                     throw new NumberFormatException(str + \" is not a valid number.\");\n491                 }\n492                 dec = str.substring(decPos + 1, expPos);\n493             } else {\n494                 dec = str.substring(decPos + 1);\n495             }\n496             mant = str.substring(0, decPos);\n497             numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n498         } else {\n499             if (expPos > -1) {\n500                 if (expPos > str.length()) { // prevents double exponent causing IOOBE\n501                     throw new NumberFormatException(str + \" is not a valid number.\");\n502                 }\n503                 mant = str.substring(0, expPos);\n504             } else {\n505                 mant = str;\n506             }\n507             dec = null;\n508         }\n509         if (!Character.isDigit(lastChar) && lastChar != '.') {\n510             if (expPos > -1 && expPos < str.length() - 1) {\n511                 exp = str.substring(expPos + 1, str.length() - 1);\n512             } else {\n513                 exp = null;\n514             }\n515             //Requesting a specific type..\n516             final String numeric = str.substring(0, str.length() - 1);\n517             final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n518             switch (lastChar) {\n519                 case 'l' :\n520                 case 'L' :\n521                     if (dec == null\n522                         && exp == null\n523                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n524                         try {\n525                             return createLong(numeric);\n526                         } catch (final NumberFormatException nfe) { // NOPMD\n527                             // Too big for a long\n528                         }\n529                         return createBigInteger(numeric);\n530 \n531                     }\n532                     throw new NumberFormatException(str + \" is not a valid number.\");\n533                 case 'f' :\n534                 case 'F' :\n535                     try {\n536                         final Float f = NumberUtils.createFloat(numeric);\n537                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n538                             //If it's too big for a float or the float value = 0 and the string\n539                             //has non-zeros in it, then float does not have the precision we want\n540                             return f;\n541                         }\n542 \n543                     } catch (final NumberFormatException nfe) { // NOPMD\n544                         // ignore the bad number\n545                     }\n546                     //$FALL-THROUGH$\n547                 case 'd' :\n548                 case 'D' :\n549                     try {\n550                         final Double d = NumberUtils.createDouble(numeric);\n551                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n552                             return d;\n553                         }\n554                     } catch (final NumberFormatException nfe) { // NOPMD\n555                         // ignore the bad number\n556                     }\n557                     try {\n558                         return createBigDecimal(numeric);\n559                     } catch (final NumberFormatException e) { // NOPMD\n560                         // ignore the bad number\n561                     }\n562                     //$FALL-THROUGH$\n563                 default :\n564                     throw new NumberFormatException(str + \" is not a valid number.\");\n565 \n566             }\n567         }\n568         //User doesn't have a preference on the return type, so let's start\n569         //small and go from there...\n570         if (expPos > -1 && expPos < str.length() - 1) {\n571             exp = str.substring(expPos + 1, str.length());\n572         } else {\n573             exp = null;\n574         }\n575         if (dec == null && exp == null) { // no decimal point and no exponent\n576             //Must be an Integer, Long, Biginteger\n577             try {\n578                 return createInteger(str);\n579             } catch (final NumberFormatException nfe) { // NOPMD\n580                 // ignore the bad number\n581             }\n582             try {\n583                 return createLong(str);\n584             } catch (final NumberFormatException nfe) { // NOPMD\n585                 // ignore the bad number\n586             }\n587             return createBigInteger(str);\n588         }\n589 \n590         //Must be a Float, Double, BigDecimal\n591         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n592         try {\n593                 final Float f = createFloat(str);\n594                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n595                     return f;\n596                 }\n597         } catch (final NumberFormatException nfe) { // NOPMD\n598             // ignore the bad number\n599         }\n600         try {\n601                 final Double d = createDouble(str);\n602                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n603                     return d;\n604                 }\n605         } catch (final NumberFormatException nfe) { // NOPMD\n606             // ignore the bad number\n607         }\n608 \n609         return createBigDecimal(str);\n610     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_4", "report_text": "> LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String\n> \n> The core of org.apache.commons.lang3.text.translate is a HashMap<CharSequence, CharSequence> lookupMap.\n> From the Javadoc of CharSequence (emphasis mine):\n> > \n> > This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. **It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map.**\n> > \n> > \n> The current implementation causes code such as the following to not work as expected:\n> ```\n> CharSequence cs1 = \"1 < 2\";\n> CharSequence cs2 = CharBuffer.wrap(\"1 < 2\".toCharArray());\n> System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1));\n> System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));\n> ```\n> ... which gives the following results (but should be identical):\n> ```\n> 1 &lt; 2\n> 1 < 2\n> ```\n> The problem, at a minimum, is that CharBuffer.equals is even documented in the Javadoc that:\n> > \n> > A char buffer is not equal to any other type of object.\n> > \n> > \n> ... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains.\n> An obvious work-around is to instead use something along the lines of either of the following:\n> ```\n> System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString()));\n> System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));\n> ```\n> ... which forces everything back to a String. However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns. (As such, I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.)\n> Another option that I'm considering is to use a custom CharSequence wrapper around a char[] that implements hashCode() and equals() to work with those implemented on String. (However, this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)", "test_name": "org.apache.commons.lang3.text.translate.LookupTranslatorTest::testLang882", "test_method": "    @Test\n    public void testLang882() throws IOException {\n        final LookupTranslator lt = new LookupTranslator(new CharSequence[][] { { new StringBuffer(\"one\"), new StringBuffer(\"two\") } });\n        final StringWriter out = new StringWriter();\n        final int result = lt.translate(new StringBuffer(\"one\"), 0, out);\n        assertEquals(\"Incorrect codepoint consumption\", 3, result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Incorrect codepoint consumption expected:<3> but was:<0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.apache.commons.lang3.text.translate.LookupTranslatorTest.testLang882(LookupTranslatorTest.java:48)", "buggy_method": "45 public LookupTranslator(final CharSequence[]... lookup) {\n46         lookupMap = new HashMap<CharSequence, CharSequence>();\n47         int _shortest = Integer.MAX_VALUE;\n48         int _longest = 0;\n49         if (lookup != null) {\n50             for (final CharSequence[] seq : lookup) {\n51                 this.lookupMap.put(seq[0], seq[1]);\n52                 final int sz = seq[0].length();\n53                 if (sz < _shortest) {\n54                     _shortest = sz;\n55                 }\n56                 if (sz > _longest) {\n57                     _longest = sz;\n58                 }\n59             }\n60         }\n61         shortest = _shortest;\n62         longest = _longest;\n63     }", "bm_classpath": "org.apache.commons.lang3.text.translate.LookupTranslator"}, {"bug_name": "Lang_5", "report_text": "> LocaleUtils.toLocale does not parse strings starting with an underscore\n> \n> Hi,\n> Javadocs of Locale.toString() states that \"If the language is missing, the string will begin with an underbar.\". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString().\n> The fix for the ticket 328 does not handle well the case \"fr\\_\\_P\", which I found out during fixing the first bug.\n> I am attaching the patch for both problems.", "test_name": "org.apache.commons.lang3.LocaleUtilsTest::testLang865", "test_method": "    @Test\n    public void testLang865() {\n        assertValidToLocale(\"_GB\", \"\", \"GB\", \"\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid locale format: _GB\n\torg.apache.commons.lang3.LocaleUtils.toLocale(LocaleUtils.java:99)\n\torg.apache.commons.lang3.LocaleUtilsTest.assertValidToLocale(LocaleUtilsTest.java:119)\n\torg.apache.commons.lang3.LocaleUtilsTest.testLang865(LocaleUtilsTest.java:505)", "buggy_method": "88 public static Locale toLocale(final String str) {\n89         if (str == null) {\n90             return null;\n91         }\n92         final int len = str.length();\n93         if (len < 2) {\n94             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n95         }\n96         final char ch0 = str.charAt(0);\n97             final char ch1 = str.charAt(1);\n98             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n99                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n100             }\n101             if (len == 2) {\n102                 return new Locale(str);\n103             }\n104             if (len < 5) {\n105                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n106             }\n107             if (str.charAt(2) != '_') {\n108                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n109             }\n110             final char ch3 = str.charAt(3);\n111             if (ch3 == '_') {\n112                 return new Locale(str.substring(0, 2), \"\", str.substring(4));\n113             }\n114             final char ch4 = str.charAt(4);\n115             if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n116                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n117             }\n118             if (len == 5) {\n119                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n120             }\n121             if (len < 7) {\n122                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n123             }\n124             if (str.charAt(5) != '_') {\n125                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n126             }\n127             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n128     }", "bm_classpath": "org.apache.commons.lang3.LocaleUtils"}, {"bug_name": "Lang_6", "report_text": "> StringIndexOutOfBoundsException in CharSequenceTranslator\n> \n> I found that there is bad surrogate pair handling in the CharSequenceTranslator\n> This is a simple test case for this problem.  \n> \\uD83D\\uDE30 is a surrogate pair.\n> ```\n> @Test\n> public void testEscapeSurrogatePairs() throws Exception {\n>     assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\"));\n> }\n> ```\n> You'll get the exception as shown below.\n> ```\n> java.lang.StringIndexOutOfBoundsException: String index out of range: 2\n> \tat java.lang.String.charAt(String.java:658)\n> \tat java.lang.Character.codePointAt(Character.java:4668)\n> \tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)\n> \tat org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)\n> \tat org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)\n> ```\n> Patch attached, the method affected:\n> 1. public final void translate(CharSequence input, Writer out) throws IOException", "test_name": "org.apache.commons.lang3.StringUtilsTest::testEscapeSurrogatePairs", "test_method": "    @Test\n    public void testEscapeSurrogatePairs() throws Exception {\n        assertEquals(\"\\uD83D\\uDE30\", StringEscapeUtils.escapeCsv(\"\\uD83D\\uDE30\")); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 2\n\tjava.lang.String.charAt(String.java:658)\n\tjava.lang.Character.codePointAt(Character.java:4884)\n\torg.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)\n\torg.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)\n\torg.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)\n\torg.apache.commons.lang3.StringUtilsTest.testEscapeSurrogatePairs(StringUtilsTest.java:2187)", "buggy_method": "75 public final void translate(CharSequence input, Writer out) throws IOException {\n76         if (out == null) {\n77             throw new IllegalArgumentException(\"The Writer must not be null\");\n78         }\n79         if (input == null) {\n80             return;\n81         }\n82         int pos = 0;\n83         int len = input.length();\n84         while (pos < len) {\n85             int consumed = translate(input, pos, out);\n86             if (consumed == 0) {\n87                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n88                 out.write(c);\n89                 pos+= c.length;\n90                 continue;\n91             }\n92 //          // contract with translators is that they have to understand codepoints \n93 //          // and they just took care of a surrogate pair\n94             for (int pt = 0; pt < consumed; pt++) {\n95                 pos += Character.charCount(Character.codePointAt(input, pos));\n96             }\n97         }\n98     }", "bm_classpath": "org.apache.commons.lang3.text.translate.CharSequenceTranslator"}, {"bug_name": "Lang_7", "report_text": "> NumberUtils#createNumber - bad behaviour for leading \"--\"\n> \n> NumberUtils#createNumber checks for a leading \"--\" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal.\n> Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException.\n> It's not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber", "test_method": "    @Test\n    public void testCreateNumber() {\n        // a lot of things can go wrong\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n\n        // LANG-521\n\n        // LANG-638\n\n        // LANG-693\n        \n        // LANG-822\n        // ensure that the underlying negative number would create a BigDecimal\n        final Number bigNum = NumberUtils.createNumber(\"-1.1E-700F\");\n\n        // Check that the code fails to create a valid number when preceeded by -- rather than -\n        try {\n            NumberUtils.createNumber(\"--1.1E-700F\");\n            fail(\"Expected NumberFormatException\");\n        } catch (NumberFormatException nfe) {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected NumberFormatException\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber(NumberUtilsTest.java:242)", "buggy_method": "445 public static Number createNumber(String str) throws NumberFormatException {\n446         if (str == null) {\n447             return null;\n448         }\n449         if (StringUtils.isBlank(str)) {\n450             throw new NumberFormatException(\"A blank string is not a valid number\");\n451         }  \n452         if (str.startsWith(\"--\")) {\n453             return null;\n454         }\n455         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n456             int hexDigits = str.length() - 2; // drop 0x\n457             if (str.startsWith(\"-\")) { // drop -\n458                 hexDigits--;\n459             }\n460             if (hexDigits > 8) { // too many for an int\n461                 return createLong(str);\n462             }\n463             return createInteger(str);\n464         }   \n465         char lastChar = str.charAt(str.length() - 1);\n466         String mant;\n467         String dec;\n468         String exp;\n469         int decPos = str.indexOf('.');\n470         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n471 \n472         if (decPos > -1) {\n473 \n474             if (expPos > -1) {\n475                 if (expPos < decPos || expPos > str.length()) {\n476                     throw new NumberFormatException(str + \" is not a valid number.\");\n477                 }\n478                 dec = str.substring(decPos + 1, expPos);\n479             } else {\n480                 dec = str.substring(decPos + 1);\n481             }\n482             mant = str.substring(0, decPos);\n483         } else {\n484             if (expPos > -1) {\n485                 if (expPos > str.length()) {\n486                     throw new NumberFormatException(str + \" is not a valid number.\");\n487                 }\n488                 mant = str.substring(0, expPos);\n489             } else {\n490                 mant = str;\n491             }\n492             dec = null;\n493         }\n494         if (!Character.isDigit(lastChar) && lastChar != '.') {\n495             if (expPos > -1 && expPos < str.length() - 1) {\n496                 exp = str.substring(expPos + 1, str.length() - 1);\n497             } else {\n498                 exp = null;\n499             }\n500             //Requesting a specific type..\n501             String numeric = str.substring(0, str.length() - 1);\n502             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n503             switch (lastChar) {\n504                 case 'l' :\n505                 case 'L' :\n506                     if (dec == null\n507                         && exp == null\n508                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n509                         try {\n510                             return createLong(numeric);\n511                         } catch (NumberFormatException nfe) { // NOPMD\n512                             // Too big for a long\n513                         }\n514                         return createBigInteger(numeric);\n515 \n516                     }\n517                     throw new NumberFormatException(str + \" is not a valid number.\");\n518                 case 'f' :\n519                 case 'F' :\n520                     try {\n521                         Float f = NumberUtils.createFloat(numeric);\n522                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n523                             //If it's too big for a float or the float value = 0 and the string\n524                             //has non-zeros in it, then float does not have the precision we want\n525                             return f;\n526                         }\n527 \n528                     } catch (NumberFormatException nfe) { // NOPMD\n529                         // ignore the bad number\n530                     }\n531                     //$FALL-THROUGH$\n532                 case 'd' :\n533                 case 'D' :\n534                     try {\n535                         Double d = NumberUtils.createDouble(numeric);\n536                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n537                             return d;\n538                         }\n539                     } catch (NumberFormatException nfe) { // NOPMD\n540                         // ignore the bad number\n541                     }\n542                     try {\n543                         return createBigDecimal(numeric);\n544                     } catch (NumberFormatException e) { // NOPMD\n545                         // ignore the bad number\n546                     }\n547                     //$FALL-THROUGH$\n548                 default :\n549                     throw new NumberFormatException(str + \" is not a valid number.\");\n550 \n551             }\n552         } else {\n553             //User doesn't have a preference on the return type, so let's start\n554             //small and go from there...\n555             if (expPos > -1 && expPos < str.length() - 1) {\n556                 exp = str.substring(expPos + 1, str.length());\n557             } else {\n558                 exp = null;\n559             }\n560             if (dec == null && exp == null) {\n561                 //Must be an int,long,bigint\n562                 try {\n563                     return createInteger(str);\n564                 } catch (NumberFormatException nfe) { // NOPMD\n565                     // ignore the bad number\n566                 }\n567                 try {\n568                     return createLong(str);\n569                 } catch (NumberFormatException nfe) { // NOPMD\n570                     // ignore the bad number\n571                 }\n572                 return createBigInteger(str);\n573 \n574             } else {\n575                 //Must be a float,double,BigDec\n576                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n577                 try {\n578                     Float f = createFloat(str);\n579                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n580                         return f;\n581                     }\n582                 } catch (NumberFormatException nfe) { // NOPMD\n583                     // ignore the bad number\n584                 }\n585                 try {\n586                     Double d = createDouble(str);\n587                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n588                         return d;\n589                     }\n590                 } catch (NumberFormatException nfe) { // NOPMD\n591                     // ignore the bad number\n592                 }\n593 \n594                 return createBigDecimal(str);\n595 \n596             }\n597         }\n598     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_8", "report_text": "> FastDateFormat's \"z\" pattern does not respect timezone of Calendar instances passed to format()\n> \n> The work on [~~LANG-462~~](https://issues.apache.org/jira/browse/LANG-462 \"FastDateFormat supports parse\") has introduced a time zone formatting bug in FastDateFormat in commons-lang3.\n> The problem can be seen by this snippet:\n> ```\n> // Always prints timezone name of machine's default timezone, ignoring TZ\n> // set on calendar, even though the printed time itself respects calendar's TZ.\n> Calendar myCal = Calendar.getInstance(TimeZone.getTimeZone(\"US/Central\"));\n> System.out.println(FastDateFormat.getInstance(\"h:mma z\").format(myCal));\n> ```\n> If you happen to be in US/Central, this will print the right thing, but just try it with US/Eastern, US/Pacific, etc. It will print the time in the correct timezone, but the timezone name at the end (the \"z\" pattern) will always be the system default timezone. This is a regression against commons-lang 2.x.\n> Basically, when the \"forced time zone\" code was removed, the TimeZoneNameRule class stopped respecting the Calendar instance's timezone, and instead now always uses the mTimeZone of the FastDateFormat instance itself (which is only supposed to be used when formatting timezone-less objects such as Date or long).\n> The removal of the forced time zone stuff is surely the right thing to do (it was a mess). I think the fix is to change the TimeZoneNameRule inner class to not take a TimeZone instance, but rather to use the TimeZone on the Calendar instance passed into appendTo(), just like TimeZoneNumberRule does. Presumably then for efficiency, one would use the getTimeZoneDisplay() package-static method to quickly retrieve the required timezone's display name.", "test_name": "org.apache.commons.lang3.time.FastDateFormat_PrinterTest::testCalendarTimezoneRespected", "test_method": "@Test\n    public void testCalendarTimezoneRespected() {\n        String[] availableZones = TimeZone.getAvailableIDs();\n        TimeZone currentZone = TimeZone.getDefault();\n        \n        TimeZone anotherZone = null;\n        for (String zone : availableZones) {\n            if (!zone.equals(currentZone.getID())) {\n                anotherZone = TimeZone.getTimeZone(zone);\n            }\n        }\n        \n        assertNotNull(\"Cannot find another timezone\", anotherZone);\n        \n        final String pattern = \"h:mma z\";\n        final Calendar cal = Calendar.getInstance(anotherZone);\n        \n        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\n        sdf.setTimeZone(anotherZone);\n        String expectedValue = sdf.format(cal.getTime());\n        String actualValue = FastDateFormat.getInstance(pattern).format(cal);\n        assertEquals(expectedValue, actualValue);\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2:58PM [IC]T> but was:<2:58PM [PS]T>\n\torg.junit.Assert.assertEquals(Assert.java:115)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.lang3.time.FastDatePrinterTest.testCalendarTimezoneRespected(FastDatePrinterTest.java:286)", "buggy_method": "1109 TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n1110             mLocale = locale;\n1111             mStyle = style;\n1112             zone = timeZone;\n1113             \n1114             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n1115             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n1116         }", "bm_classpath": "org.apache.commons.lang3.time.FastDatePrinter$TimeZoneNameRule"}, {"bug_name": "Lang_9", "report_text": "> FastDateParser does not handle unterminated quotes correctly\n> \n> FDP does not handled unterminated quotes the same way as SimpleDateFormat\n> For example:\n> Format: 'd'd'  \n> Date: d3\n> This should fail to parse the format and date but it actually works.  \n> The format is parsed as:\n> Pattern: d(\\p\n> {IsNd}\n> ++)", "test_name": "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_832", "test_method": "@Test\n    public void testLANG_832() throws Exception {\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n    }", "error_message": "junit.framework.AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.apache.commons.lang3.time.FastDateParserTest.testSdfAndFdp(FastDateParserTest.java:393)\n\torg.apache.commons.lang3.time.FastDateParserTest.testLANG_832(FastDateParserTest.java:348)", "buggy_method": "115 private void init() {\n116         thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n117 \n118         nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n119 \n120         StringBuilder regex= new StringBuilder();\n121         List<Strategy> collector = new ArrayList<Strategy>();\n122 \n123         Matcher patternMatcher= formatPattern.matcher(pattern);\n124         if(!patternMatcher.lookingAt()) {\n125             throw new IllegalArgumentException(\"Invalid pattern\");\n126         }\n127 \n128         currentFormatField= patternMatcher.group();\n129         Strategy currentStrategy= getStrategy(currentFormatField);\n130         for(;;) {\n131             patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n132             if(!patternMatcher.lookingAt()) {\n133                 nextStrategy = null;\n134                 break;\n135             }\n136             String nextFormatField= patternMatcher.group();\n137             nextStrategy = getStrategy(nextFormatField);\n138             if(currentStrategy.addRegex(this, regex)) {\n139                 collector.add(currentStrategy);\n140             }\n141             currentFormatField= nextFormatField;\n142             currentStrategy= nextStrategy;\n143         }\n144         if(currentStrategy.addRegex(this, regex)) {\n145             collector.add(currentStrategy);\n146         }\n147         currentFormatField= null;\n148         strategies= collector.toArray(new Strategy[collector.size()]);\n149         parsePattern= Pattern.compile(regex.toString());\n150     }", "bm_classpath": "org.apache.commons.lang3.time.FastDateParser"}, {"bug_name": "Lang_10", "report_text": "> FastDateParser does not handle white-space properly\n> \n> The SimpleDateFormat Javadoc does not treat white-space specially, however FastDateParser treats a single white-space as being any number of white-space characters.\n> This means that FDP will parse dates that fail when parsed by SDP.", "test_name": "org.apache.commons.lang3.time.FastDateFormat_ParserTest::testLANG_831", "test_method": "@Test\n    public void testLANG_831() throws Exception {\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n    }", "error_message": "junit.framework.AssertionFailedError: Parsed dates should be equal expected:<null> but was:<Mon Mar 02 21:00:00 PST 1970>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.apache.commons.lang3.time.FastDateParserTest.testSdfAndFdp(FastDateParserTest.java:388)\n\torg.apache.commons.lang3.time.FastDateParserTest.testLANG_831(FastDateParserTest.java:348)", "buggy_method": "303 private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n304         boolean wasWhite= false;\n305         for(int i= 0; i<value.length(); ++i) {\n306             char c= value.charAt(i);\n307             if(Character.isWhitespace(c)) {\n308                 if(!wasWhite) {\n309                     wasWhite= true;\n310                     regex.append(\"\\\\s*+\");\n311                 }\n312                 continue;\n313             }\n314             wasWhite= false;\n315             switch(c) {\n316             case '\\'':\n317                 if(unquote) {\n318                     if(++i==value.length()) {\n319                         return regex;\n320                     }\n321                     c= value.charAt(i);\n322                 }\n323                 break;\n324             case '?':\n325             case '[':\n326             case ']':\n327             case '(':\n328             case ')':\n329             case '{':\n330             case '}':\n331             case '\\\\':\n332             case '|':\n333             case '*':\n334             case '+':\n335             case '^':\n336             case '$':\n337             case '.':\n338                 regex.append('\\\\');\n339             }\n340             regex.append(c);\n341         }\n342         return regex;\n343     }", "bm_classpath": "org.apache.commons.lang3.time.FastDateParser"}, {"bug_name": "Lang_11", "report_text": "> RandomStringUtils throws confusing IAE when end <= start\n> \n> RandomUtils invokes Random#nextInt![](/jira/images/icons/emoticons/thumbs_down.png) where n = end - start.\n> If end <= start, then Random throws:\n> java.lang.IllegalArgumentException: n must be positive\n> This is confusing, and does not identify the source of the problem.", "test_name": "org.apache.commons.lang3.RandomStringUtilsTest::testLANG807", "test_method": "    public void testLANG807() {\n        try {\n            RandomStringUtils.random(3,5,5,false,false);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) { // distinguish from Random#nextInt message\n            final String msg = ex.getMessage();\n            assertTrue(\"Message (\" + msg + \") must contain 'start'\", msg.contains(\"start\"));\n            assertTrue(\"Message (\" + msg + \") must contain 'end'\", msg.contains(\"end\"));\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Message (bound must be positive) must contain 'start'\n\torg.apache.commons.lang3.RandomStringUtilsTest.testLANG807(RandomStringUtilsTest.java:139)", "buggy_method": "223 public static String random(int count, int start, int end, boolean letters, boolean numbers,\n224                                 char[] chars, Random random) {\n225         if (count == 0) {\n226             return \"\";\n227         } else if (count < 0) {\n228             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n229         }\n230         if (chars != null && chars.length == 0) {\n231             throw new IllegalArgumentException(\"The chars array must not be empty\");\n232         }\n233 \n234         if (start == 0 && end == 0) {\n235             if (chars != null) {\n236                 end = chars.length;\n237             } else {\n238                 if (!letters && !numbers) {\n239                     end = Integer.MAX_VALUE;\n240                 } else {\n241                     end = 'z' + 1;\n242                     start = ' ';                \n243                 }\n244             }\n245         }\n246 \n247         char[] buffer = new char[count];\n248         int gap = end - start;\n249 \n250         while (count-- != 0) {\n251             char ch;\n252             if (chars == null) {\n253                 ch = (char) (random.nextInt(gap) + start);\n254             } else {\n255                 ch = chars[random.nextInt(gap) + start];\n256             }\n257             if (letters && Character.isLetter(ch)\n258                     || numbers && Character.isDigit(ch)\n259                     || !letters && !numbers) {\n260                 if(ch >= 56320 && ch <= 57343) {\n261                     if(count == 0) {\n262                         count++;\n263                     } else {\n264                         // low surrogate, insert high surrogate after putting it in\n265                         buffer[count] = ch;\n266                         count--;\n267                         buffer[count] = (char) (55296 + random.nextInt(128));\n268                     }\n269                 } else if(ch >= 55296 && ch <= 56191) {\n270                     if(count == 0) {\n271                         count++;\n272                     } else {\n273                         // high surrogate, insert low surrogate before putting it in\n274                         buffer[count] = (char) (56320 + random.nextInt(128));\n275                         count--;\n276                         buffer[count] = ch;\n277                     }\n278                 } else if(ch >= 56192 && ch <= 56319) {\n279                     // private high surrogate, no effing clue, so skip it\n280                     count++;\n281                 } else {\n282                     buffer[count] = ch;\n283                 }\n284             } else {\n285                 count++;\n286             }\n287         }\n288         return new String(buffer);\n289     }", "bm_classpath": "org.apache.commons.lang3.RandomStringUtils"}, {"bug_name": "Lang_12", "report_text": "> RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException\n> \n> In commons-lang 2.6 line 250 :\n> ```\n> ch = chars[random.nextInt(gap) + start];\n> ```\n> ~~This line of code takes a random int to fetch a char in the *chars* array regardless of its size.~~  \n> ~~(Besides *start* is useless here)~~\n> ~~Fixed version would be :~~\n> ```\n> //ch = chars[random.nextInt(gap)%chars.length];\n> ```\n> When user pass 0 as *end* or when the array is not null but empty this line ends up with an exception", "test_name": "org.apache.commons.lang3.RandomStringUtilsTest::testExceptions", "test_method": "    public void testExceptions() {\n        final char[] DUMMY = new char[]{'a'}; // valid char array\n        try {\n            RandomStringUtils.random(-1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, true, true);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(-1, DUMMY);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            RandomStringUtils.random(1, new char[0]); // must not provide empty array => IAE\n            fail();\n        } catch (IllegalArgumentException ex) {} // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 1362891502\n\torg.apache.commons.lang3.RandomStringUtils.random(RandomStringUtils.java:248)\n\torg.apache.commons.lang3.RandomStringUtils.random(RandomStringUtils.java:321)\n\torg.apache.commons.lang3.RandomStringUtilsTest.testExceptions(RandomStringUtilsTest.java:148)", "buggy_method": "223 public static String random(int count, int start, int end, boolean letters, boolean numbers,\n224                                 char[] chars, Random random) {\n225         if (count == 0) {\n226             return \"\";\n227         } else if (count < 0) {\n228             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n229         }\n230 \n231         if (start == 0 && end == 0) {\n232                 if (!letters && !numbers) {\n233                     end = Integer.MAX_VALUE;\n234                 } else {\n235                     end = 'z' + 1;\n236                     start = ' ';                \n237                 }\n238         }\n239 \n240         char[] buffer = new char[count];\n241         int gap = end - start;\n242 \n243         while (count-- != 0) {\n244             char ch;\n245             if (chars == null) {\n246                 ch = (char) (random.nextInt(gap) + start);\n247             } else {\n248                 ch = chars[random.nextInt(gap) + start];\n249             }\n250             if (letters && Character.isLetter(ch)\n251                     || numbers && Character.isDigit(ch)\n252                     || !letters && !numbers) {\n253                 if(ch >= 56320 && ch <= 57343) {\n254                     if(count == 0) {\n255                         count++;\n256                     } else {\n257                         // low surrogate, insert high surrogate after putting it in\n258                         buffer[count] = ch;\n259                         count--;\n260                         buffer[count] = (char) (55296 + random.nextInt(128));\n261                     }\n262                 } else if(ch >= 55296 && ch <= 56191) {\n263                     if(count == 0) {\n264                         count++;\n265                     } else {\n266                         // high surrogate, insert low surrogate before putting it in\n267                         buffer[count] = (char) (56320 + random.nextInt(128));\n268                         count--;\n269                         buffer[count] = ch;\n270                     }\n271                 } else if(ch >= 56192 && ch <= 56319) {\n272                     // private high surrogate, no effing clue, so skip it\n273                     count++;\n274                 } else {\n275                     buffer[count] = ch;\n276                 }\n277             } else {\n278                 count++;\n279             }\n280         }\n281         return new String(buffer);\n282     }", "bm_classpath": "org.apache.commons.lang3.RandomStringUtils"}, {"bug_name": "Lang_13", "report_text": "> SerializationUtils throws ClassNotFoundException when cloning primitive classes\n> \n> If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.\n> ```\n> import org.apache.commons.lang3.SerializationUtils;\n> import org.junit.Test;\n> public class SerializationUtilsTest {\n> \t\n> \t@Test\n> \tpublic void primitiveTypeClassSerialization(){\n> \t\tClass<?> primitiveType = int.class;\n> \t\t\n> \t\tClass<?> clone = SerializationUtils.clone(primitiveType);\n> \t\tassertEquals(primitiveType, clone);\n> \t}\n> }\n> ```\n> The problem was already reported as a java bug <http://bugs.sun.com/view_bug.do?bug_id=4171142> and ObjectInputStream is fixed since java version 1.4.  \n> The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream's  \n> resoleClass method without delegating to the super method in case of a ClassNotFoundException.\n> I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.\n> For example:\n> ```\n>         protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n>             String name = desc.getName();\n>             try {\n>                 return Class.forName(name, false, classLoader);\n>             } catch (ClassNotFoundException ex) {\n>             \ttry {\n>             \t     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n>             \t} catch (Exception e) {\n> \t\t     return super.resolveClass(desc);\n> \t\t}\n>             }\n>         }\n> ```\n> Here is the code in ObjectInputStream that fixed the java bug.\n> ```\n>     protected Class<?> resolveClass(ObjectStreamClass desc)\n> \tthrows IOException, ClassNotFoundException\n>     {\n> \tString name = desc.getName();\n> \ttry {\n> \t    return Class.forName(name, false, latestUserDefinedLoader());\n> \t} catch (ClassNotFoundException ex) {\n> \t    Class cl = (Class) primClasses.get(name);\n> \t    if (cl != null) {\n> \t\treturn cl;\n> \t    } else {\n> \t\tthrow ex;\n> \t    }\n> \t}\n>     }\n> ```", "test_name": "org.apache.commons.lang3.SerializationUtilsTest::testPrimitiveTypeClassSerialization", "test_method": "    public void testPrimitiveTypeClassSerialization() {\n        Class<?>[] primitiveTypes = { byte.class, short.class, int.class, long.class, float.class, double.class,\n                boolean.class, char.class, void.class };\n\n        for (Class<?> primitiveType : primitiveTypes) {\n            Class<?> clone = SerializationUtils.clone(primitiveType);\n            assertEquals(primitiveType, clone);\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.lang3.SerializationException: ClassNotFoundException while reading cloned object data\n\torg.apache.commons.lang3.SerializationUtils.clone(SerializationUtils.java:99)\n\torg.apache.commons.lang3.SerializationUtilsTest.testPrimitiveTypeClassSerialization(SerializationUtilsTest.java:373)", "buggy_method": "248 public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n249             super(in);\n250             this.classLoader = classLoader;\n251 \n252         }", "bm_classpath": "org.apache.commons.lang3.SerializationUtils$ClassLoaderAwareObjectInputStream"}, {"bug_name": "Lang_14", "report_text": "> StringUtils equals() relies on undefined behavior\n> \n> Since the java.lang.CharSequence class was first introduced in 1.4, the JavaDoc block has contained the following note:\n> > \n> > This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other.\n> > \n> > \n> When the signature of the StringUtils equals() method was changed from equals(String, String) to equals(CharSequence, CharSequence) in R920543, the implementation still relied on calling CharSequence#equals(Object) even though, in general, the result is undefined.\n> One example where equals(Object) returns false even though, as CharSequences, two objects represent equal sequences is when one object is an instance of javax.lang.model.element.Name and the other object is a String.", "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testEquals", "test_method": "    public void testEquals() {\n        final CharSequence fooCs = FOO, barCs = BAR, foobarCs = FOOBAR;\n        assertTrue(StringUtils.equals(fooCs, (CharSequence) new StringBuilder(FOO))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testEquals(StringUtilsEqualsIndexOfTest.java:490)", "buggy_method": "781 public static boolean equals(CharSequence cs1, CharSequence cs2) {\n782         if (cs1 == cs2) {\n783             return true;\n784         }\n785         if (cs1 == null || cs2 == null) {\n786             return false;\n787         }\n788             return cs1.equals(cs2);\n789     }", "bm_classpath": "org.apache.commons.lang3.StringUtils"}, {"bug_name": "Lang_15", "report_text": "> TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes\n> \n> failing test code to add to TypeUtilsTest.testGetTypeArguments():\n> ```\n> typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\n> Assert.assertEquals(2, typeVarAssigns.size());\n> Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\n> Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n> ```\n> These should pass based on:\n> ```\n> public interface This<K, V> {\n> }\n> public class Other<T> implements This<String, T> {\n> }\n> ```\n> This case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect. This report is extrapolated from an offline report received by Hen.", "test_name": "org.apache.commons.lang3.reflect.TypeUtilsTest::testGetTypeArguments", "test_method": "    @Test\n    public void testGetTypeArguments() {\n        Map<TypeVariable<?>, Type> typeVarAssigns;\n        TypeVariable<?> treeSetTypeVar;\n        Type typeArg;\n\n        typeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n        typeArg = typeVarAssigns.get(treeSetTypeVar);\n\n        typeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n        typeArg = typeVarAssigns.get(treeSetTypeVar);\n\n        Collection<Integer> col = Arrays.asList(new Integer[0]);\n        typeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\n        treeSetTypeVar = Comparable.class.getTypeParameters()[0];\n\n        typeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);\n\n        typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\n        Assert.assertEquals(2, typeVarAssigns.size()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2> but was:<0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.junit.Assert.assertEquals(Assert.java:542)\n\torg.apache.commons.lang3.reflect.TypeUtilsTest.testGetTypeArguments(TypeUtilsTest.java:505)", "buggy_method": "179 private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,\n180             Map<TypeVariable<?>, Type> typeVarAssigns) {\n181         if (type == null) {\n182             return true;\n183         }\n184 \n185         // only a null type can be assigned to null type which\n186         // would have cause the previous to return true\n187         if (toParameterizedType == null) {\n188             return false;\n189         }\n190 \n191         // all types are assignable to themselves\n192         if (toParameterizedType.equals(type)) {\n193             return true;\n194         }\n195 \n196         // get the target type's raw type\n197         Class<?> toClass = getRawType(toParameterizedType);\n198         // get the subject type's type arguments including owner type arguments\n199         // and supertype arguments up to and including the target class.\n200         Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n201 \n202         // null means the two types are not compatible\n203         if (fromTypeVarAssigns == null) {\n204             return false;\n205         }\n206 \n207         // compatible types, but there's no type arguments. this is equivalent\n208         // to comparing Map< ?, ? > to Map, and raw types are always assignable\n209         // to parameterized types.\n210         if (fromTypeVarAssigns.isEmpty()) {\n211             return true;\n212         }\n213 \n214         // get the target type's type arguments including owner type arguments\n215         Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n216                 toClass, typeVarAssigns);\n217 \n218         // now to check each type argument\n219         for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n220             Type toTypeArg = entry.getValue();\n221             Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n222 \n223             // parameters must either be absent from the subject type, within\n224             // the bounds of the wildcard type, or be an exact match to the\n225             // parameters of the target type.\n226             if (fromTypeArg != null\n227                     && !toTypeArg.equals(fromTypeArg)\n228                     && !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n229                             typeVarAssigns))) {\n230                 return false;\n231             }\n232         }\n233 \n234         return true;\n235     }", "bm_classpath": "org.apache.commons.lang3.reflect.TypeUtils"}, {"bug_name": "Lang_16", "report_text": "> NumberUtils does not handle upper-case hex: 0X and -0X\n> \n> NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException\n> Integer.decode() handles both upper and lower case hex.", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber", "test_method": "    @Test\n    public void testCreateNumber() {\n        // a lot of things can go wrong\n        assertTrue(\"createNumber(String) 9b failed\", 0xFADE == NumberUtils.createNumber(\"0Xfade\").intValue()); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: 0Xfade is not a valid number.\n\torg.apache.commons.lang3.math.NumberUtils.createNumber(NumberUtils.java:545)\n\torg.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber(NumberUtilsTest.java:197)", "buggy_method": "444 public static Number createNumber(String str) throws NumberFormatException {\n445         if (str == null) {\n446             return null;\n447         }\n448         if (StringUtils.isBlank(str)) {\n449             throw new NumberFormatException(\"A blank string is not a valid number\");\n450         }  \n451         if (str.startsWith(\"--\")) {\n452             // this is protection for poorness in java.lang.BigDecimal.\n453             // it accepts this as a legal value, but it does not appear \n454             // to be in specification of class. OS X Java parses it to \n455             // a wrong value.\n456             return null;\n457         }\n458         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n459             return createInteger(str);\n460         }   \n461         char lastChar = str.charAt(str.length() - 1);\n462         String mant;\n463         String dec;\n464         String exp;\n465         int decPos = str.indexOf('.');\n466         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n467 \n468         if (decPos > -1) {\n469 \n470             if (expPos > -1) {\n471                 if (expPos < decPos || expPos > str.length()) {\n472                     throw new NumberFormatException(str + \" is not a valid number.\");\n473                 }\n474                 dec = str.substring(decPos + 1, expPos);\n475             } else {\n476                 dec = str.substring(decPos + 1);\n477             }\n478             mant = str.substring(0, decPos);\n479         } else {\n480             if (expPos > -1) {\n481                 if (expPos > str.length()) {\n482                     throw new NumberFormatException(str + \" is not a valid number.\");\n483                 }\n484                 mant = str.substring(0, expPos);\n485             } else {\n486                 mant = str;\n487             }\n488             dec = null;\n489         }\n490         if (!Character.isDigit(lastChar) && lastChar != '.') {\n491             if (expPos > -1 && expPos < str.length() - 1) {\n492                 exp = str.substring(expPos + 1, str.length() - 1);\n493             } else {\n494                 exp = null;\n495             }\n496             //Requesting a specific type..\n497             String numeric = str.substring(0, str.length() - 1);\n498             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n499             switch (lastChar) {\n500                 case 'l' :\n501                 case 'L' :\n502                     if (dec == null\n503                         && exp == null\n504                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n505                         try {\n506                             return createLong(numeric);\n507                         } catch (NumberFormatException nfe) { // NOPMD\n508                             // Too big for a long\n509                         }\n510                         return createBigInteger(numeric);\n511 \n512                     }\n513                     throw new NumberFormatException(str + \" is not a valid number.\");\n514                 case 'f' :\n515                 case 'F' :\n516                     try {\n517                         Float f = NumberUtils.createFloat(numeric);\n518                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n519                             //If it's too big for a float or the float value = 0 and the string\n520                             //has non-zeros in it, then float does not have the precision we want\n521                             return f;\n522                         }\n523 \n524                     } catch (NumberFormatException nfe) { // NOPMD\n525                         // ignore the bad number\n526                     }\n527                     //$FALL-THROUGH$\n528                 case 'd' :\n529                 case 'D' :\n530                     try {\n531                         Double d = NumberUtils.createDouble(numeric);\n532                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n533                             return d;\n534                         }\n535                     } catch (NumberFormatException nfe) { // NOPMD\n536                         // ignore the bad number\n537                     }\n538                     try {\n539                         return createBigDecimal(numeric);\n540                     } catch (NumberFormatException e) { // NOPMD\n541                         // ignore the bad number\n542                     }\n543                     //$FALL-THROUGH$\n544                 default :\n545                     throw new NumberFormatException(str + \" is not a valid number.\");\n546 \n547             }\n548         } else {\n549             //User doesn't have a preference on the return type, so let's start\n550             //small and go from there...\n551             if (expPos > -1 && expPos < str.length() - 1) {\n552                 exp = str.substring(expPos + 1, str.length());\n553             } else {\n554                 exp = null;\n555             }\n556             if (dec == null && exp == null) {\n557                 //Must be an int,long,bigint\n558                 try {\n559                     return createInteger(str);\n560                 } catch (NumberFormatException nfe) { // NOPMD\n561                     // ignore the bad number\n562                 }\n563                 try {\n564                     return createLong(str);\n565                 } catch (NumberFormatException nfe) { // NOPMD\n566                     // ignore the bad number\n567                 }\n568                 return createBigInteger(str);\n569 \n570             } else {\n571                 //Must be a float,double,BigDec\n572                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n573                 try {\n574                     Float f = createFloat(str);\n575                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n576                         return f;\n577                     }\n578                 } catch (NumberFormatException nfe) { // NOPMD\n579                     // ignore the bad number\n580                 }\n581                 try {\n582                     Double d = createDouble(str);\n583                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n584                         return d;\n585                     }\n586                 } catch (NumberFormatException nfe) { // NOPMD\n587                     // ignore the bad number\n588                 }\n589 \n590                 return createBigDecimal(str);\n591 \n592             }\n593         }\n594     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_17", "report_text": "> StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.\n> \n> Hello.\n> I use StringEscapeUtils.escapeXml(input) to escape special characters for XML.  \n> This method outputs wrong results when input contains characters in Supplementary Planes.\n> String str1 = \"\\uD842\\uDFB7\" + \"A\";  \n> String str2 = StringEscapeUtils.escapeXml(str1);\n> // The value of str2 must be equal to the one of str1,  \n> // because str1 does not contain characters to be escaped.  \n> // However, str2 is diffrent from str1.\n> System.out.println(URLEncoder.encode(str1, \"UTF-16BE\")); //%D8%42%DF%B7A  \n> System.out.println(URLEncoder.encode(str2, \"UTF-16BE\")); //%D8%42%DF%B7%FF%FD\n> The cause of this problem is that the loop to translate input character by character is wrong.  \n> In CharSequenceTranslator.translate(CharSequence input, Writer out),  \n> loop counter \"i\" moves from 0 to Character.codePointCount(input, 0, input.length()),  \n> but it should move from 0 to input.length().", "test_name": "org.apache.commons.lang3.StringEscapeUtilsTest::testLang720", "test_method": "    public void testLang720() {\n        String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n        String escaped = StringEscapeUtils.escapeXml(input);\n        assertEquals(input, escaped); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<\ud842\udfb7[A]> but was:<\ud842\udfb7[?]>\n\torg.apache.commons.lang3.StringEscapeUtilsTest.testLang720(StringEscapeUtilsTest.java:431)", "buggy_method": "75 public final void translate(CharSequence input, Writer out) throws IOException {\n76         if (out == null) {\n77             throw new IllegalArgumentException(\"The Writer must not be null\");\n78         }\n79         if (input == null) {\n80             return;\n81         }\n82         int pos = 0;\n83         int len = Character.codePointCount(input, 0, input.length());\n84         while (pos < len) {\n85             int consumed = translate(input, pos, out);\n86             if (consumed == 0) {\n87                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n88                 out.write(c);\n89             }\n90             else {\n91 //          // contract with translators is that they have to understand codepoints \n92 //          // and they just took care of a surrogate pair\n93             for (int pt = 0; pt < consumed; pt++) {\n94                     if (pos < len - 2) {\n95                 pos += Character.charCount(Character.codePointAt(input, pos));\n96                     } else {\n97                         pos++;\n98                     }\n99                 }\n100                 pos--;\n101             }\n102             pos++;\n103         }\n104     }", "bm_classpath": "org.apache.commons.lang3.text.translate.CharSequenceTranslator"}, {"bug_name": "Lang_18", "report_text": "> FastDateFormat formats year differently than SimpleDateFormat in Java 7\n> \n> Starting with Java 7 does SimpleDateFormat format a year pattern of 'Y' or 'YYY' as '2003' instead of '03' as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.", "test_name": "org.apache.commons.lang3.time.FastDateFormatTest::testFormat", "test_method": "    public void testFormat() {\n        Locale realDefaultLocale = Locale.getDefault();\n        TimeZone realDefaultZone = TimeZone.getDefault();\n        try {\n            Locale.setDefault(Locale.US);\n            TimeZone.setDefault(TimeZone.getTimeZone(\"America/New_York\"));\n\n            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\n            Date date1 = cal1.getTime();\n            Date date2 = cal2.getTime();\n            long millis1 = date1.getTime();\n            long millis2 = date2.getTime();\n\n            FastDateFormat fdf = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n            assertEquals(sdf.format(date1), fdf.format(date1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n            assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n            assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n\n            fdf = FastDateFormat.getInstance(\"Z\");\n            assertEquals(\"-0500\", fdf.format(date1));\n            assertEquals(\"-0500\", fdf.format(cal1));\n            assertEquals(\"-0500\", fdf.format(millis1));\n\n            assertEquals(\"-0400\", fdf.format(date2));\n            assertEquals(\"-0400\", fdf.format(cal2));\n            assertEquals(\"-0400\", fdf.format(millis2));\n\n            fdf = FastDateFormat.getInstance(\"ZZ\");\n            assertEquals(\"-05:00\", fdf.format(date1));\n            assertEquals(\"-05:00\", fdf.format(cal1));\n            assertEquals(\"-05:00\", fdf.format(millis1));\n\n            assertEquals(\"-04:00\", fdf.format(date2));\n            assertEquals(\"-04:00\", fdf.format(cal2));\n            assertEquals(\"-04:00\", fdf.format(millis2));\n\n            String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" +\n                \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n            fdf = FastDateFormat.getInstance(pattern);\n            sdf = new SimpleDateFormat(pattern);\n            // SDF bug fix starting with Java 7\n            assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n            assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));\n        } finally {\n            Locale.setDefault(realDefaultLocale);\n            TimeZone.setDefault(realDefaultZone);\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<AD AD AD AD 2003 [2003 03 20]03 January Jan 01 1 ...> but was:<AD AD AD AD 2003 [03 03 ]03 January Jan 01 1 ...>\n\torg.apache.commons.lang3.time.FastDateFormatTest.testFormat(FastDateFormatTest.java:220)", "buggy_method": "463 protected List<Rule> parsePattern() {\n464         DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n465         List<Rule> rules = new ArrayList<Rule>();\n466 \n467         String[] ERAs = symbols.getEras();\n468         String[] months = symbols.getMonths();\n469         String[] shortMonths = symbols.getShortMonths();\n470         String[] weekdays = symbols.getWeekdays();\n471         String[] shortWeekdays = symbols.getShortWeekdays();\n472         String[] AmPmStrings = symbols.getAmPmStrings();\n473 \n474         int length = mPattern.length();\n475         int[] indexRef = new int[1];\n476 \n477         for (int i = 0; i < length; i++) {\n478             indexRef[0] = i;\n479             String token = parseToken(mPattern, indexRef);\n480             i = indexRef[0];\n481 \n482             int tokenLen = token.length();\n483             if (tokenLen == 0) {\n484                 break;\n485             }\n486 \n487             Rule rule;\n488             char c = token.charAt(0);\n489 \n490             switch (c) {\n491             case 'G': // era designator (text)\n492                 rule = new TextField(Calendar.ERA, ERAs);\n493                 break;\n494             case 'y': // year (number)\n495                 if (tokenLen >= 4) {\n496                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n497                 } else {\n498                     rule = TwoDigitYearField.INSTANCE;\n499                 }\n500                 break;\n501             case 'M': // month in year (text and number)\n502                 if (tokenLen >= 4) {\n503                     rule = new TextField(Calendar.MONTH, months);\n504                 } else if (tokenLen == 3) {\n505                     rule = new TextField(Calendar.MONTH, shortMonths);\n506                 } else if (tokenLen == 2) {\n507                     rule = TwoDigitMonthField.INSTANCE;\n508                 } else {\n509                     rule = UnpaddedMonthField.INSTANCE;\n510                 }\n511                 break;\n512             case 'd': // day in month (number)\n513                 rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n514                 break;\n515             case 'h': // hour in am/pm (number, 1..12)\n516                 rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n517                 break;\n518             case 'H': // hour in day (number, 0..23)\n519                 rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n520                 break;\n521             case 'm': // minute in hour (number)\n522                 rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n523                 break;\n524             case 's': // second in minute (number)\n525                 rule = selectNumberRule(Calendar.SECOND, tokenLen);\n526                 break;\n527             case 'S': // millisecond (number)\n528                 rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n529                 break;\n530             case 'E': // day in week (text)\n531                 rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n532                 break;\n533             case 'D': // day in year (number)\n534                 rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n535                 break;\n536             case 'F': // day of week in month (number)\n537                 rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n538                 break;\n539             case 'w': // week in year (number)\n540                 rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n541                 break;\n542             case 'W': // week in month (number)\n543                 rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n544                 break;\n545             case 'a': // am/pm marker (text)\n546                 rule = new TextField(Calendar.AM_PM, AmPmStrings);\n547                 break;\n548             case 'k': // hour in day (1..24)\n549                 rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n550                 break;\n551             case 'K': // hour in am/pm (0..11)\n552                 rule = selectNumberRule(Calendar.HOUR, tokenLen);\n553                 break;\n554             case 'z': // time zone (text)\n555                 if (tokenLen >= 4) {\n556                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n557                 } else {\n558                     rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n559                 }\n560                 break;\n561             case 'Z': // time zone (value)\n562                 if (tokenLen == 1) {\n563                     rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n564                 } else {\n565                     rule = TimeZoneNumberRule.INSTANCE_COLON;\n566                 }\n567                 break;\n568             case '\\'': // literal text\n569                 String sub = token.substring(1);\n570                 if (sub.length() == 1) {\n571                     rule = new CharacterLiteral(sub.charAt(0));\n572                 } else {\n573                     rule = new StringLiteral(sub);\n574                 }\n575                 break;\n576             default:\n577                 throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n578             }\n579 \n580             rules.add(rule);\n581         }\n582 \n583         return rules;\n584     }", "bm_classpath": "org.apache.commons.lang3.time.FastDateFormat"}, {"bug_name": "Lang_19", "report_text": "> StringIndexOutOfBoundsException when calling unescapeHtml4(\"&#03\")\n> \n> When calling unescapeHtml4() on the String \"&#03\" (or any String that contains these characters) an Exception is thrown:\n> Exception in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: 4  \n>  at java.lang.String.charAt(String.java:686)  \n>  at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49)  \n>  at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53)  \n>  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88)  \n>  at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60)  \n>  at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)", "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest::testUnfinishedEntity", "test_method": "    public void testUnfinishedEntity() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        String input = \"Test &#x30 not test\";\n        String expected = \"Test \\u0030 not test\";\n\n        String result = neu.translate(input); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 19\n\tjava.lang.String.charAt(String.java:658)\n\torg.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:54)\n\torg.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:86)\n\torg.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)\n\torg.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testUnfinishedEntity(NumericEntityUnescaperTest.java:51)", "buggy_method": "36 @Override\n37     public int translate(CharSequence input, int index, Writer out) throws IOException {\n38         int seqEnd = input.length();\n39         // Uses -2 to ensure there is something after the &#\n40         if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n41             int start = index + 2;\n42             boolean isHex = false;\n43 \n44             char firstChar = input.charAt(start);\n45             if(firstChar == 'x' || firstChar == 'X') {\n46                 start++;\n47                 isHex = true;\n48 \n49                 // Check there's more than just an x after the &#\n50             }\n51 \n52             int end = start;\n53             // Note that this supports character codes without a ; on the end\n54             while(input.charAt(end) != ';') \n55             {\n56                 end++;\n57             }\n58 \n59             int entityValue;\n60             try {\n61                 if(isHex) {\n62                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n63                 } else {\n64                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n65                 }\n66             } catch(NumberFormatException nfe) {\n67             System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n68                 return 0;\n69             }\n70 \n71             if(entityValue > 0xFFFF) {\n72                 char[] chrs = Character.toChars(entityValue);\n73                 out.write(chrs[0]);\n74                 out.write(chrs[1]);\n75             } else {\n76                 out.write(entityValue);\n77             }\n78 \n79 \n80             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n81         }\n82         return 0;\n83     }", "bm_classpath": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper"}, {"bug_name": "Lang_20", "report_text": "> StringUtils.join throws NPE when toString returns null for one of objects in collection\n> \n> Try\n> ```\n>  \n> StringUtils.join(new Object[]{\n>         new Object() {\n>           @Override\n>           public String toString() {\n>             return null;\n>           }\n>         }\n>     }, ',');\n> ```\n> ToString should probably never return null, but it does in javax.mail.internet.InternetAddress", "test_name": "org.apache.commons.lang3.StringUtilsTest::testJoin_ArrayChar", "test_method": "    public void testJoin_ArrayChar() {\n\n        assertEquals(\"null\", StringUtils.join(NULL_TO_STRING_LIST,'/', 0, 1)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.lang3.StringUtils.join(StringUtils.java:3298)\n\torg.apache.commons.lang3.StringUtilsTest.testJoin_ArrayChar(StringUtilsTest.java:209)", "buggy_method": "3368 public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n3369         if (array == null) {\n3370             return null;\n3371         }\n3372         if (separator == null) {\n3373             separator = EMPTY;\n3374         }\n3375 \n3376         // endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n3377         //           (Assuming that all Strings are roughly equally long)\n3378         int noOfItems = (endIndex - startIndex);\n3379         if (noOfItems <= 0) {\n3380             return EMPTY;\n3381         }\n3382 \n3383         StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n3384 \n3385         for (int i = startIndex; i < endIndex; i++) {\n3386             if (i > startIndex) {\n3387                 buf.append(separator);\n3388             }\n3389             if (array[i] != null) {\n3390                 buf.append(array[i]);\n3391             }\n3392         }\n3393         return buf.toString();\n3394     }", "bm_classpath": "org.apache.commons.lang3.StringUtils"}, {"bug_name": "Lang_21", "report_text": "> DateUtils.isSameLocalTime does not work correct\n> \n> Hi, I think I found a bug in the DateUtils class in the method isSameLocalTime.\n> Example:   \n> Calendar a = Calendar.getInstance();  \n> a.setTimeInMillis(1297364400000L);\n> Calendar b = Calendar.getInstance();  \n> b.setTimeInMillis(1297321200000L);\n> Assert.assertFalse(DateUtils.isSameLocalTime(a, b));\n> This is because the method compares   \n> cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) \n> but I think it has to be   \n> cal1.get(Calendar.HOUR\\_OF\\_DAY) == cal2.get(Calendar.HOUR\\_OF\\_DAY)", "test_name": "org.apache.commons.lang3.time.DateUtilsTest::testIsSameLocalTime_Cal", "test_method": "    public void testIsSameLocalTime_Cal() {\n        GregorianCalendar cal1 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n        GregorianCalendar cal2 = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n        cal1.set(2004, 6, 9, 13, 45, 0);\n        cal1.set(Calendar.MILLISECOND, 0);\n        cal2.set(2004, 6, 9, 13, 45, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal3 = Calendar.getInstance();\n        Calendar cal4 = Calendar.getInstance();\n        cal3.set(2004, 6, 9, 4,  0, 0);\n        cal4.set(2004, 6, 9, 16, 0, 0);\n        cal3.set(Calendar.MILLISECOND, 0);\n        cal4.set(Calendar.MILLISECOND, 0);\n        assertFalse(\"LANG-677\", DateUtils.isSameLocalTime(cal3, cal4)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: LANG-677\n\torg.apache.commons.lang3.time.DateUtilsTest.testIsSameLocalTime_Cal(DateUtilsTest.java:237)", "buggy_method": "258 public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n259         if (cal1 == null || cal2 == null) {\n260             throw new IllegalArgumentException(\"The date must not be null\");\n261         }\n262         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n263                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n264                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n265                 cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n266                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n267                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n268                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n269                 cal1.getClass() == cal2.getClass());\n270     }", "bm_classpath": "org.apache.commons.lang3.time.DateUtils"}, {"bug_name": "Lang_22", "report_text": "> org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)\n> \n> The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN\\_VALUE and 2^k, and this case can be triggered by taking Integer.MIN\\_VALUE as the numerator. Note that the case of taking Integer.MIN\\_VALUE as the denominator is handled explicitly in the getReducedFraction factory method.\n> **FractionTest.java**\n> ```\n> \t// additional test cases\n> \tpublic void testReducedFactory_int_int() {\n> \t\t// ...\n> \t\tf = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n> \t\tassertEquals(Integer.MIN_VALUE / 2, f.getNumerator());\n> \t\tassertEquals(1, f.getDenominator());\n> \tpublic void testReduce() {\n> \t\t// ...\n> \t\tf = Fraction.getFraction(Integer.MIN_VALUE, 2);\n> \t\tresult = f.reduce();\n> \t\tassertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n> \t\tassertEquals(1, result.getDenominator());\n> ```", "test_name": "org.apache.commons.lang3.math.FractionTest::testReducedFactory_int_int", "test_method": "    public void testReducedFactory_int_int() {\n        Fraction f = null;\n        \n        // zero\n        f = Fraction.getReducedFraction(0, 1);\n        \n        // normal\n        f = Fraction.getReducedFraction(1, 1);\n        \n        f = Fraction.getReducedFraction(2, 1);\n        \n        // improper\n        f = Fraction.getReducedFraction(22, 7);\n        \n        // negatives\n        f = Fraction.getReducedFraction(-6, 10);\n        \n        f = Fraction.getReducedFraction(6, -10);\n        \n        f = Fraction.getReducedFraction(-6, -10);\n        \n        // zero denominator\n        try {\n            f = Fraction.getReducedFraction(1, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(2, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n        \n        try {\n            f = Fraction.getReducedFraction(-3, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}\n\n        // reduced        \n        f = Fraction.getReducedFraction(0, 2);\n        \n        f = Fraction.getReducedFraction(2, 2);\n        \n        f = Fraction.getReducedFraction(2, 4);\n        \n        f = Fraction.getReducedFraction(15, 10);\n        \n        f = Fraction.getReducedFraction(121, 22);\n        \n        // Extreme values \n        // OK, can reduce before negating\n        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\n        \n        // Can't reduce, negation will throw\n        try { \n            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \n            fail(\"Expecting ArithmeticException\");\n        } catch (ArithmeticException ex) {}      \n\n        // LANG-662\n        f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\n        assertEquals(Integer.MIN_VALUE / 2, f.getNumerator()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-1073741824> but was:<-2147483648>\n\torg.apache.commons.lang3.math.FractionTest.testReducedFactory_int_int(FractionTest.java:336)", "buggy_method": "581 private static int greatestCommonDivisor(int u, int v) {\n582         // From Commons Math:\n583         //if either operand is abs 1, return 1:\n584         if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n585             return 1;\n586         }\n587         // keep u and v negative, as negative integers range down to\n588         // -2^31, while positive numbers can only be as large as 2^31-1\n589         // (i.e. we can't necessarily negate a negative number without\n590         // overflow)\n591         if (u>0) { u=-u; } // make u negative\n592         if (v>0) { v=-v; } // make v negative\n593         // B1. [Find power of 2]\n594         int k=0;\n595         while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n596             u/=2; v/=2; k++; // cast out twos.\n597         }\n598         if (k==31) {\n599             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n600         }\n601         // B2. Initialize: u and v have been divided by 2^k and at least\n602         //     one is odd.\n603         int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n604         // t negative: u was odd, v may be even (t replaces v)\n605         // t positive: u was even, v is odd (t replaces u)\n606         do {\n607             /* assert u<0 && v<0; */\n608             // B4/B3: cast out twos from t.\n609             while ((t&1)==0) { // while t is even..\n610                 t/=2; // cast out twos\n611             }\n612             // B5 [reset max(u,v)]\n613             if (t>0) {\n614                 u = -t;\n615             } else {\n616                 v = t;\n617             }\n618             // B6/B3. at this point both u and v should be odd.\n619             t = (v - u)/2;\n620             // |u| larger: t positive (replace u)\n621             // |v| larger: t negative (replace v)\n622         } while (t!=0);\n623         return -u*(1<<k); // gcd is u*2^k\n624     }", "bm_classpath": "org.apache.commons.lang3.math.Fraction"}, {"bug_name": "Lang_24", "report_text": "> NumberUtils.isNumber(String)  is not right when the String is \"1.1L\"\n> \n> \"1.1L\" is not a Java Number . but NumberUtils.isNumber(String) return true.\n> perhaps change:\n> ```\n>             if (chars[i] == 'l'\n>                 || chars[i] == 'L') {\n>                 // not allowing L with an exponent\n>                 return foundDigit && !hasExp;\n>             }\n> ```\n> to:\n> ```\n>             if (chars[i] == 'l'\n>                 || chars[i] == 'L') {\n>                 // not allowing L with an exponent\n>                 return foundDigit && !hasExp && !hasDecPoint;\n>             }\n> ```", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testIsNumber", "test_method": "    public void testIsNumber() {\n        String val = \"12345\";\n        val = \"1234.5\";\n        val = \".12345\";\n        val = \"1234E5\";\n        val = \"1234E+5\";\n        val = \"1234E-5\";\n        val = \"123.4E5\";\n        val = \"-1234\";\n        val = \"-1234.5\";\n        val = \"-.12345\";\n        val = \"-1234E5\";\n        val = \"0\";\n        val = \"-0\";\n        val = \"01234\";\n        val = \"-01234\";\n        val = \"0xABC123\";\n        val = \"0x0\";\n        val = \"123.4E21D\";\n        val = \"-221.23F\";\n        val = \"22338L\";\n        val = null;\n        val = \"\";\n        val = \"--2.3\";\n        val = \".12.3\";\n        val = \"-123E\";\n        val = \"-123E+-212\";\n        val = \"-123E2.12\";\n        val = \"0xGF\";\n        val = \"0xFAE-1\";\n        val = \".\";\n        val = \"-0ABC123\";\n        val = \"123.4E-D\";\n        val = \"123.4ED\";\n        val = \"1234E5l\";\n        val = \"11a\";\n        val = \"1a\";\n        val = \"a\";\n        val = \"11g\";\n        val = \"11z\";\n        val = \"11def\";\n        val = \"11d11\";\n        val = \"11 11\";\n        val = \" 1111\";\n        val = \"1111 \";\n\n        // LANG-521\n        val = \"2.\";\n\n        // LANG-664\n        val = \"1.1L\";\n        assertFalse(\"isNumber(String) LANG-664 failed\", NumberUtils.isNumber(val)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: isNumber(String) LANG-664 failed\n\torg.apache.commons.lang3.math.NumberUtilsTest.testIsNumber(NumberUtilsTest.java:1145)", "buggy_method": "1319 public static boolean isNumber(String str) {\n1320         if (StringUtils.isEmpty(str)) {\n1321             return false;\n1322         }\n1323         char[] chars = str.toCharArray();\n1324         int sz = chars.length;\n1325         boolean hasExp = false;\n1326         boolean hasDecPoint = false;\n1327         boolean allowSigns = false;\n1328         boolean foundDigit = false;\n1329         // deal with any possible sign up front\n1330         int start = (chars[0] == '-') ? 1 : 0;\n1331         if (sz > start + 1) {\n1332             if (chars[start] == '0' && chars[start + 1] == 'x') {\n1333                 int i = start + 2;\n1334                 if (i == sz) {\n1335                     return false; // str == \"0x\"\n1336                 }\n1337                 // checking hex (it can't be anything else)\n1338                 for (; i < chars.length; i++) {\n1339                     if ((chars[i] < '0' || chars[i] > '9')\n1340                         && (chars[i] < 'a' || chars[i] > 'f')\n1341                         && (chars[i] < 'A' || chars[i] > 'F')) {\n1342                         return false;\n1343                     }\n1344                 }\n1345                 return true;\n1346             }\n1347         }\n1348         sz--; // don't want to loop to the last char, check it afterwords\n1349               // for type qualifiers\n1350         int i = start;\n1351         // loop to the next to last char or to the last char if we need another digit to\n1352         // make a valid number (e.g. chars[0..5] = \"1234E\")\n1353         while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n1354             if (chars[i] >= '0' && chars[i] <= '9') {\n1355                 foundDigit = true;\n1356                 allowSigns = false;\n1357 \n1358             } else if (chars[i] == '.') {\n1359                 if (hasDecPoint || hasExp) {\n1360                     // two decimal points or dec in exponent   \n1361                     return false;\n1362                 }\n1363                 hasDecPoint = true;\n1364             } else if (chars[i] == 'e' || chars[i] == 'E') {\n1365                 // we've already taken care of hex.\n1366                 if (hasExp) {\n1367                     // two E's\n1368                     return false;\n1369                 }\n1370                 if (!foundDigit) {\n1371                     return false;\n1372                 }\n1373                 hasExp = true;\n1374                 allowSigns = true;\n1375             } else if (chars[i] == '+' || chars[i] == '-') {\n1376                 if (!allowSigns) {\n1377                     return false;\n1378                 }\n1379                 allowSigns = false;\n1380                 foundDigit = false; // we need a digit after the E\n1381             } else {\n1382                 return false;\n1383             }\n1384             i++;\n1385         }\n1386         if (i < chars.length) {\n1387             if (chars[i] >= '0' && chars[i] <= '9') {\n1388                 // no type qualifier, OK\n1389                 return true;\n1390             }\n1391             if (chars[i] == 'e' || chars[i] == 'E') {\n1392                 // can't have an E at the last byte\n1393                 return false;\n1394             }\n1395             if (chars[i] == '.') {\n1396                 if (hasDecPoint || hasExp) {\n1397                     // two decimal points or dec in exponent\n1398                     return false;\n1399                 }\n1400                 // single trailing decimal point after non-exponent is ok\n1401                 return foundDigit;\n1402             }\n1403             if (!allowSigns\n1404                 && (chars[i] == 'd'\n1405                     || chars[i] == 'D'\n1406                     || chars[i] == 'f'\n1407                     || chars[i] == 'F')) {\n1408                 return foundDigit;\n1409             }\n1410             if (chars[i] == 'l'\n1411                 || chars[i] == 'L') {\n1412                 // not allowing L with an exponent or decimal point\n1413                 return foundDigit && !hasExp;\n1414             }\n1415             // last character is illegal\n1416             return false;\n1417         }\n1418         // allowSigns is true iff the val ends in 'E'\n1419         // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n1420         return !allowSigns && foundDigit;\n1421     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_26", "report_text": "> FastDateFormat.format() outputs incorrect week of year because locale isn't respected\n> \n> FastDateFormat apparently doesn't respect the locale it was sent on creation when outputting week in year (e.g. \"ww\") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output.\n> Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:\n> ```\n> import java.util.Calendar;\n> import java.util.Date;\n> import java.util.Locale;\n> import java.text.SimpleDateFormat;\n> import org.apache.commons.lang.time.FastDateFormat;\n> public class FastDateFormatWeekBugDemo {\n>     public static void main(String[] args) {\n>         Locale.setDefault(new Locale(\"en\", \"US\"));\n>         Locale locale = new Locale(\"sv\", \"SE\");\n>         Calendar cal = Calendar.getInstance(); // setting locale here doesn't change outcome\n>         cal.set(2010, 0, 1, 12, 0, 0);\n>         Date d = cal.getTime();\n>         System.out.println(\"Target date: \" + d);\n>         FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n>         SimpleDateFormat sdf = new SimpleDateFormat(\"EEEE', week 'ww\", locale);\n>         System.out.println(\"FastDateFormat: \" + fdf.format(d)); // will output \"FastDateFormat: fredag, week 01\"\n>         System.out.println(\"SimpleDateFormat: \" + sdf.format(d)); // will output \"SimpleDateFormat: fredag, week 53\"\n>     }\n> }\n> ```\n> If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.", "test_name": "org.apache.commons.lang3.time.FastDateFormatTest::testLang645", "test_method": "    public void testLang645() {\n        Locale locale = new Locale(\"sv\", \"SE\");\n\n        Calendar cal = Calendar.getInstance();\n        cal.set(2010, 0, 1, 12, 0, 0);\n        Date d = cal.getTime();\n\n        FastDateFormat fdf = FastDateFormat.getInstance(\"EEEE', week 'ww\", locale);\n\n        assertEquals(\"fredag, week 53\", fdf.format(d)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<fredag, week [53]> but was:<fredag, week [01]>\n\torg.apache.commons.lang3.time.FastDateFormatTest.testLang645(FastDateFormatTest.java:337)", "buggy_method": "819 public String format(Date date) {\n820         Calendar c = new GregorianCalendar(mTimeZone);\n821         c.setTime(date);\n822         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n823     }", "bm_classpath": "org.apache.commons.lang3.time.FastDateFormat"}, {"bug_name": "Lang_27", "report_text": "> NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing \"e\" and \"E\" is passed in\n> \n> NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in.  \n> One example of such a String is \"1eE\".", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber", "test_method": "    public void testCreateNumber() {\n        // a lot of things can go wrong\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n\n        // LANG-521\n\n        // LANG-638\n        assertFalse(\"createNumber(String) succeeded\", checkCreateNumber(\"1eE\")); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 4\n\tjava.lang.String.substring(String.java:1963)\n\torg.apache.commons.lang3.math.NumberUtils.createNumber(NumberUtils.java:489)\n\torg.apache.commons.lang3.math.NumberUtilsTest.checkCreateNumber(NumberUtilsTest.java:1146)\n\torg.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber(NumberUtilsTest.java:216)", "buggy_method": "452 public static Number createNumber(String str) throws NumberFormatException {\n453         if (str == null) {\n454             return null;\n455         }\n456         if (StringUtils.isBlank(str)) {\n457             throw new NumberFormatException(\"A blank string is not a valid number\");\n458         }  \n459         if (str.startsWith(\"--\")) {\n460             // this is protection for poorness in java.lang.BigDecimal.\n461             // it accepts this as a legal value, but it does not appear \n462             // to be in specification of class. OS X Java parses it to \n463             // a wrong value.\n464             return null;\n465         }\n466         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n467             return createInteger(str);\n468         }   \n469         char lastChar = str.charAt(str.length() - 1);\n470         String mant;\n471         String dec;\n472         String exp;\n473         int decPos = str.indexOf('.');\n474         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n475 \n476         if (decPos > -1) {\n477 \n478             if (expPos > -1) {\n479                 if (expPos < decPos) {\n480                     throw new NumberFormatException(str + \" is not a valid number.\");\n481                 }\n482                 dec = str.substring(decPos + 1, expPos);\n483             } else {\n484                 dec = str.substring(decPos + 1);\n485             }\n486             mant = str.substring(0, decPos);\n487         } else {\n488             if (expPos > -1) {\n489                 mant = str.substring(0, expPos);\n490             } else {\n491                 mant = str;\n492             }\n493             dec = null;\n494         }\n495         if (!Character.isDigit(lastChar) && lastChar != '.') {\n496             if (expPos > -1 && expPos < str.length() - 1) {\n497                 exp = str.substring(expPos + 1, str.length() - 1);\n498             } else {\n499                 exp = null;\n500             }\n501             //Requesting a specific type..\n502             String numeric = str.substring(0, str.length() - 1);\n503             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n504             switch (lastChar) {\n505                 case 'l' :\n506                 case 'L' :\n507                     if (dec == null\n508                         && exp == null\n509                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n510                         try {\n511                             return createLong(numeric);\n512                         } catch (NumberFormatException nfe) {\n513                             //Too big for a long\n514                         }\n515                         return createBigInteger(numeric);\n516 \n517                     }\n518                     throw new NumberFormatException(str + \" is not a valid number.\");\n519                 case 'f' :\n520                 case 'F' :\n521                     try {\n522                         Float f = NumberUtils.createFloat(numeric);\n523                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n524                             //If it's too big for a float or the float value = 0 and the string\n525                             //has non-zeros in it, then float does not have the precision we want\n526                             return f;\n527                         }\n528 \n529                     } catch (NumberFormatException nfe) {\n530                         // ignore the bad number\n531                     }\n532                     //$FALL-THROUGH$\n533                 case 'd' :\n534                 case 'D' :\n535                     try {\n536                         Double d = NumberUtils.createDouble(numeric);\n537                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n538                             return d;\n539                         }\n540                     } catch (NumberFormatException nfe) {\n541                         // ignore the bad number\n542                     }\n543                     try {\n544                         return createBigDecimal(numeric);\n545                     } catch (NumberFormatException e) {\n546                         // ignore the bad number\n547                     }\n548                     //$FALL-THROUGH$\n549                 default :\n550                     throw new NumberFormatException(str + \" is not a valid number.\");\n551 \n552             }\n553         } else {\n554             //User doesn't have a preference on the return type, so let's start\n555             //small and go from there...\n556             if (expPos > -1 && expPos < str.length() - 1) {\n557                 exp = str.substring(expPos + 1, str.length());\n558             } else {\n559                 exp = null;\n560             }\n561             if (dec == null && exp == null) {\n562                 //Must be an int,long,bigint\n563                 try {\n564                     return createInteger(str);\n565                 } catch (NumberFormatException nfe) {\n566                     // ignore the bad number\n567                 }\n568                 try {\n569                     return createLong(str);\n570                 } catch (NumberFormatException nfe) {\n571                     // ignore the bad number\n572                 }\n573                 return createBigInteger(str);\n574 \n575             } else {\n576                 //Must be a float,double,BigDec\n577                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n578                 try {\n579                     Float f = createFloat(str);\n580                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n581                         return f;\n582                     }\n583                 } catch (NumberFormatException nfe) {\n584                     // ignore the bad number\n585                 }\n586                 try {\n587                     Double d = createDouble(str);\n588                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n589                         return d;\n590                     }\n591                 } catch (NumberFormatException nfe) {\n592                     // ignore the bad number\n593                 }\n594 \n595                 return createBigDecimal(str);\n596 \n597             }\n598         }\n599     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_28", "report_text": "> StringEscapeUtils.escapeXML() can't process UTF-16 supplementary characters\n> \n> Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: <http://java.sun.com/developer/technicalArticles/Intl/Supplementary/>\n> Currently, StringEscapeUtils.escapeXML() isn't aware of this coding scheme and treats each char as one character, which is not always right.\n> A possible solution in class Entities would be:\n>  public void escape(Writer writer, String str) throws IOException {  \n>  int len = str.length();  \n>  for (int i = 0; i < len; i++) {  \n>  int code = str.codePointAt![](/jira/images/icons/emoticons/information.png);  \n>  String entityName = this.entityName(code);  \n>  if (entityName != null) \n> {\n>  writer.write('&');\n>  writer.write(entityName);\n>  writer.write(';');\n>  }\n>  else if (code > 0x7F) \n> {\n>  writer.write(\"&#\");\n>  writer.write(code);\n>  writer.write(';');\n>  }\n>  else \n> {\n>  writer.write((char) code);\n>  }\n>  if (code > 0xffff) \n> {\n>  i++;\n>  }\n>  }  \n>  }\n> Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that's a good thing, but please remember I have only tested escapeXML().", "test_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest::testSupplementaryUnescaping", "test_method": "    public void testSupplementaryUnescaping() {\n        NumericEntityUnescaper neu = new NumericEntityUnescaper();\n        String input = \"&#68642;\";\n        String expected = \"\\uD803\\uDC22\";\n\n        String result = neu.translate(input);\n        assertEquals(\"Failed to unescape numeric entities supplementary characters\", expected, result); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: Failed to unescape numeric entities supplementary characters expected:<[\ud803\udc22]> but was:<[\u0c22]>\n\torg.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.testSupplementaryUnescaping(NumericEntityUnescaperTest.java:33)", "buggy_method": "34 @Override\n35     public int translate(CharSequence input, int index, Writer out) throws IOException {\n36         // TODO: Protect from ArrayIndexOutOfBounds\n37         if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n38             int start = index + 2;\n39             boolean isHex = false;\n40 \n41             char firstChar = input.charAt(start);\n42             if(firstChar == 'x' || firstChar == 'X') {\n43                 start++;\n44                 isHex = true;\n45             }\n46 \n47             int end = start;\n48             while(input.charAt(end) != ';') {\n49                 end++;\n50             }\n51 \n52             int entityValue;\n53             try {\n54                 if(isHex) {\n55                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n56                 } else {\n57                     entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n58                 }\n59             } catch(NumberFormatException nfe) {\n60                 return 0;\n61             }\n62 \n63                 out.write(entityValue);\n64             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n65         }\n66         return 0;\n67     }", "bm_classpath": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper"}, {"bug_name": "Lang_29", "report_text": "> SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM\n> \n> Can be replicated in the Android emulator quite easily.\n> Stack trace:\n> ```\n> at org.apache.commons.lang.builder.ToStringBuilder.<clinit>(ToStringBuilder.java:98)\n> E/AndroidRuntime( 1681): \t... 17 more\n> E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError\n> E/AndroidRuntime( 1681): \tat org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle.<init>(ToStringStyle.java:2276)\n> E/AndroidRuntime( 1681): \tat org.apache.commons.lang.builder.ToStringStyle.<clinit>(ToStringStyle.java:94)\n> E/AndroidRuntime( 1681): \t... 18 more\n> E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException\n> E/AndroidRuntime( 1681): \tat java.lang.String.substring(String.java:1571)\n> E/AndroidRuntime( 1681): \tat org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153)\n> E/AndroidRuntime( 1681): \tat org.apache.commons.lang.SystemUtils.<clinit>(SystemUtils.java:818)\n> ```", "test_name": "org.apache.commons.lang3.SystemUtilsTest::testJavaVersionAsInt", "test_method": "    public void testJavaVersionAsInt() {\n        assertEquals(0, SystemUtils.toJavaVersionInt(null)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<0.0>\n\torg.apache.commons.lang3.SystemUtilsTest.testJavaVersionAsInt(SystemUtilsTest.java:210)", "buggy_method": "1672 static float toJavaVersionInt(String version) {\n1673         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n1674     }", "bm_classpath": "org.apache.commons.lang3.SystemUtils"}, {"bug_name": "Lang_30", "report_text": "> StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.\n> \n> StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.\n> For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as \"\\uD840\\uDC00\"\n>  private static final String CharU20000 = \"\\uD840\\uDC00\";  \n>  private static final String CharU20001 = \"\\uD840\\uDC01\";\n> You can see Unicode supplementary characters correctly implemented in the JRE call:\n>  assertEquals(-1, CharU20000.indexOf(CharU20001));\n> But this is broken:\n>  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));  \n>  assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n> This is fine:\n>  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));  \n>  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));  \n>  assertEquals(true, StringUtils.contains(CharU20000, CharU20000));  \n>  assertEquals(false, StringUtils.contains(CharU20000, CharU20001));\n> because the method calls the JRE to perform the match.\n> More than you want to know:\n> * <http://java.sun.com/developer/technicalArticles/Intl/Supplementary/>", "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsNone_CharArrayWithSupplementaryChars", "test_method": "    public void testContainsNone_CharArrayWithSupplementaryChars() {\n        // Sanity check:\n        // Test:\n        assertEquals(true, StringUtils.containsNone(CharU20000, CharU20001.toCharArray())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<true> but was:<false>\n\torg.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsNone_CharArrayWithSupplementaryChars(StringUtilsEqualsIndexOfTest.java:327)", "buggy_method": "1371 public static int indexOfAny(CharSequence cs, char[] searchChars) {\n1372         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n1373             return INDEX_NOT_FOUND;\n1374         }\n1375         int csLen = cs.length();\n1376         int searchLen = searchChars.length;\n1377         for (int i = 0; i < csLen; i++) {\n1378             char ch = cs.charAt(i);\n1379             for (int j = 0; j < searchLen; j++) {\n1380                 if (searchChars[j] == ch) {\n1381                         // ch is a supplementary character\n1382                         return i;\n1383                 }\n1384             }\n1385         }\n1386         return INDEX_NOT_FOUND;\n1387     }", "bm_classpath": "org.apache.commons.lang3.StringUtils"}, {"bug_name": "Lang_31", "report_text": "> StringUtils methods do not handle Unicode 2.0+ supplementary characters correctly.\n> \n> StringUtils.containsAny methods incorrectly matches Unicode 2.0+ supplementary characters.\n> For example, define a test fixture to be the Unicode character U+20000 where U+20000 is written in Java source as \"\\uD840\\uDC00\"\n>  private static final String CharU20000 = \"\\uD840\\uDC00\";  \n>  private static final String CharU20001 = \"\\uD840\\uDC01\";\n> You can see Unicode supplementary characters correctly implemented in the JRE call:\n>  assertEquals(-1, CharU20000.indexOf(CharU20001));\n> But this is broken:\n>  assertEquals(false, StringUtils.containsAny(CharU20000, CharU20001));  \n>  assertEquals(false, StringUtils.containsAny(CharU20001, CharU20000));\n> This is fine:\n>  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20000));  \n>  assertEquals(true, StringUtils.contains(CharU20000 + CharU20001, CharU20001));  \n>  assertEquals(true, StringUtils.contains(CharU20000, CharU20000));  \n>  assertEquals(false, StringUtils.contains(CharU20000, CharU20001));\n> because the method calls the JRE to perform the match.\n> More than you want to know:\n> * <http://java.sun.com/developer/technicalArticles/Intl/Supplementary/>", "test_name": "org.apache.commons.lang3.StringUtilsEqualsIndexOfTest::testContainsAnyCharArrayWithSupplementaryChars", "test_method": "\tpublic void testContainsAnyCharArrayWithSupplementaryChars() {\n\t\t// Sanity check:\n\t\t// Test:\n\t\tassertEquals(false, StringUtils.containsAny(CharU20000, CharU20001.toCharArray())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<false> but was:<true>\n\torg.apache.commons.lang3.StringUtilsEqualsIndexOfTest.testContainsAnyCharArrayWithSupplementaryChars(StringUtilsEqualsIndexOfTest.java:696)", "buggy_method": "1440 public static boolean containsAny(CharSequence cs, char[] searchChars) {\n1441 \t\tif (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n1442 \t\t\treturn false;\n1443 \t\t}\n1444 \t\tint csLength = cs.length();\n1445 \t\tint searchLength = searchChars.length;\n1446 \t\tfor (int i = 0; i < csLength; i++) {\n1447 \t\t\tchar ch = cs.charAt(i);\n1448 \t\t\tfor (int j = 0; j < searchLength; j++) {\n1449 \t\t\t\tif (searchChars[j] == ch) {\n1450 \t\t\t\t\t\t// ch is a supplementary character\n1451 \t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n1452 \t\t\t\t\t\treturn true;\n1453 \t\t\t\t}\n1454 \t\t\t}\n1455 \t\t}\n1456 \t\treturn false;\n1457 \t}", "bm_classpath": "org.apache.commons.lang3.StringUtils"}, {"bug_name": "Lang_32", "report_text": "> Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments\n> \n> The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload.\n> See <http://markmail.org/thread/uetw2fdrsqgbh2cv> for more info.", "test_name": "org.apache.commons.lang3.builder.HashCodeBuilderTest::testReflectionObjectCycle", "test_method": "    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: <null> but was: []\n\torg.apache.commons.lang3.builder.HashCodeBuilderTest.testReflectionObjectCycle(HashCodeBuilderTest.java:524)", "buggy_method": "151 static boolean isRegistered(Object value) {\n152         return getRegistry().contains(new IDKey(value));\n153     }", "bm_classpath": "org.apache.commons.lang3.builder.HashCodeBuilder"}, {"bug_name": "Lang_33", "report_text": "> ClassUtils.toClass(Object[]) throws NPE on null array element\n> \n> see summary", "test_name": "org.apache.commons.lang3.ClassUtilsTest::testToClass_object", "test_method": "    public void testToClass_object() {\n\n\n\n        assertTrue(Arrays.equals(new Class[] { String.class, null, Double.class },\n                ClassUtils.toClass(new Object[] { \"Test\", null, 99d }))); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.lang3.ClassUtils.toClass(ClassUtils.java:910)\n\torg.apache.commons.lang3.ClassUtilsTest.testToClass_object(ClassUtilsTest.java:910)", "buggy_method": "902 public static Class<?>[] toClass(Object[] array) {\n903         if (array == null) {\n904             return null;\n905         } else if (array.length == 0) {\n906             return ArrayUtils.EMPTY_CLASS_ARRAY;\n907         }\n908         Class<?>[] classes = new Class[array.length];\n909         for (int i = 0; i < array.length; i++) {\n910             classes[i] = array[i].getClass();\n911         }\n912         return classes;\n913     }", "bm_classpath": "org.apache.commons.lang3.ClassUtils"}, {"bug_name": "Lang_34", "report_text": "> Use of ThreadLocals in ToStringStyle and HashCodeBuilder trigger memory leaks in container environments\n> \n> The thread local in org.apache.commons.lang3.builder.ToStringStyle is created but never removed and no API is provided to remove it. If a webapp's use of LANG triggers the loading of this class, a reference chain will be created that will cause a memory leak on web application reload.\n> See <http://markmail.org/thread/uetw2fdrsqgbh2cv> for more info.", "test_name": "org.apache.commons.lang3.builder.ToStringBuilderTest::testObjectCycle", "test_method": "    public void testObjectCycle() {\n        ObjectCycle a = new ObjectCycle();\n        ObjectCycle b = new ObjectCycle();\n        a.obj = b;\n        b.obj = a;\n\n        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n        validateNullToStringStyleRegistry(); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: <null> but was: {}\n\torg.apache.commons.lang3.builder.ToStringBuilderTest.validateNullToStringStyleRegistry(ToStringBuilderTest.java:586)\n\torg.apache.commons.lang3.builder.ToStringBuilderTest.testObjectCycle(ToStringBuilderTest.java:837)", "buggy_method": "147 static Map<Object, Object> getRegistry() {\n148         return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n149     }", "bm_classpath": "org.apache.commons.lang3.builder.ToStringStyle"}, {"bug_name": "Lang_35", "report_text": "> ArrayUtils.add(T[] array, T element) can create unexpected ClassCastException\n> \n> ArrayUtils.add(T[] array, T element) can create an unexpected ClassCastException.\n> For example, the following code compiles without a warning:\n> ```\n> String[] sa = ArrayUtils.add(stringArray, aString);\n> ```\n> and works fine, provided at least one of the parameters is non-null. However, if both parameters are null, the add() method returns an Object[] array, hence the Exception.\n> If both parameters are null, it's not possible to determine the correct array type to return, so it seems to me this should be disallowed.\n> I think the method ought to be changed to throw IllegalParameterException when both parameters are null.", "test_name": "org.apache.commons.lang3.ArrayUtilsAddTest::testLANG571", "test_method": "    public void testLANG571(){\n        String[] stringArray=null;\n        String aString=null;\n        try {\n            @SuppressWarnings(\"unused\")\n            String[] sa = ArrayUtils.add(stringArray, aString);\n            fail(\"Should have caused IllegalArgumentException\");\n        } catch (IllegalArgumentException iae){\n            //expected\n        } // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;\n\torg.apache.commons.lang3.ArrayUtilsAddTest.testLANG571(ArrayUtilsAddTest.java:232)", "buggy_method": "3567 public static <T> T[] add(T[] array, int index, T element) {\n3568         Class<?> clss = null;\n3569         if (array != null) {\n3570             clss = array.getClass().getComponentType();\n3571         } else if (element != null) {\n3572             clss = element.getClass();\n3573         } else {\n3574             return (T[]) new Object[] { null };\n3575         }\n3576         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n3577         final T[] newArray = (T[]) add(array, index, element, clss);\n3578         return newArray;\n3579     }", "bm_classpath": "org.apache.commons.lang3.ArrayUtils"}, {"bug_name": "Lang_36", "report_text": "> NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place\n> \n> NumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., \"2.\" should be considered a number because new BigDecimal(\"2.\") works fine. This could be done by adding the code below after line 1444, which is the if (chars[i] == 'e' || chars[i] == 'E') block.\n> if (chars[i] == '.') {  \n>  if (hasDecPoint || hasExp) \n> {\n>  // two decimal points or dec in exponent \n>  return false;\n>  }\n>  return foundDigit; // single trailing decimal point after non-exponent is ok  \n> }", "test_name": "org.apache.commons.lang3.math.NumberUtilsTest::testCreateNumber", "test_method": "    public void testCreateNumber() {\n        // a lot of things can go wrong\n\n        // jdk 1.2 doesn't support this. unsure about jdk 1.2.2\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\n            assertEquals(\"createNumber(String) 15 failed\", new BigDecimal(\"1.1E-700\"), NumberUtils\n                    .createNumber(\"1.1E-700F\"));\n        }\n\n        // LANG-521\n        assertEquals(\"createNumber(String) LANG-521 failed\", new Float(\"2.\"), NumberUtils.createNumber(\"2.\")); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: 2. is not a valid number.\n\torg.apache.commons.lang3.math.NumberUtils.createNumber(NumberUtils.java:546)\n\torg.apache.commons.lang3.math.NumberUtilsTest.testCreateNumber(NumberUtilsTest.java:213)", "buggy_method": "448 public static Number createNumber(String str) throws NumberFormatException {\n449         if (str == null) {\n450             return null;\n451         }\n452         if (StringUtils.isBlank(str)) {\n453             throw new NumberFormatException(\"A blank string is not a valid number\");\n454         }  \n455         if (str.startsWith(\"--\")) {\n456             // this is protection for poorness in java.lang.BigDecimal.\n457             // it accepts this as a legal value, but it does not appear \n458             // to be in specification of class. OS X Java parses it to \n459             // a wrong value.\n460             return null;\n461         }\n462         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n463             return createInteger(str);\n464         }   \n465         char lastChar = str.charAt(str.length() - 1);\n466         String mant;\n467         String dec;\n468         String exp;\n469         int decPos = str.indexOf('.');\n470         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n471 \n472         if (decPos > -1) {\n473 \n474             if (expPos > -1) {\n475                 if (expPos < decPos) {\n476                     throw new NumberFormatException(str + \" is not a valid number.\");\n477                 }\n478                 dec = str.substring(decPos + 1, expPos);\n479             } else {\n480                 dec = str.substring(decPos + 1);\n481             }\n482             mant = str.substring(0, decPos);\n483         } else {\n484             if (expPos > -1) {\n485                 mant = str.substring(0, expPos);\n486             } else {\n487                 mant = str;\n488             }\n489             dec = null;\n490         }\n491         if (!Character.isDigit(lastChar)) {\n492             if (expPos > -1 && expPos < str.length() - 1) {\n493                 exp = str.substring(expPos + 1, str.length() - 1);\n494             } else {\n495                 exp = null;\n496             }\n497             //Requesting a specific type..\n498             String numeric = str.substring(0, str.length() - 1);\n499             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n500             switch (lastChar) {\n501                 case 'l' :\n502                 case 'L' :\n503                     if (dec == null\n504                         && exp == null\n505                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n506                         try {\n507                             return createLong(numeric);\n508                         } catch (NumberFormatException nfe) {\n509                             //Too big for a long\n510                         }\n511                         return createBigInteger(numeric);\n512 \n513                     }\n514                     throw new NumberFormatException(str + \" is not a valid number.\");\n515                 case 'f' :\n516                 case 'F' :\n517                     try {\n518                         Float f = NumberUtils.createFloat(numeric);\n519                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n520                             //If it's too big for a float or the float value = 0 and the string\n521                             //has non-zeros in it, then float does not have the precision we want\n522                             return f;\n523                         }\n524 \n525                     } catch (NumberFormatException nfe) {\n526                         // ignore the bad number\n527                     }\n528                     //$FALL-THROUGH$\n529                 case 'd' :\n530                 case 'D' :\n531                     try {\n532                         Double d = NumberUtils.createDouble(numeric);\n533                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n534                             return d;\n535                         }\n536                     } catch (NumberFormatException nfe) {\n537                         // ignore the bad number\n538                     }\n539                     try {\n540                         return createBigDecimal(numeric);\n541                     } catch (NumberFormatException e) {\n542                         // ignore the bad number\n543                     }\n544                     //$FALL-THROUGH$\n545                 default :\n546                     throw new NumberFormatException(str + \" is not a valid number.\");\n547 \n548             }\n549         } else {\n550             //User doesn't have a preference on the return type, so let's start\n551             //small and go from there...\n552             if (expPos > -1 && expPos < str.length() - 1) {\n553                 exp = str.substring(expPos + 1, str.length());\n554             } else {\n555                 exp = null;\n556             }\n557             if (dec == null && exp == null) {\n558                 //Must be an int,long,bigint\n559                 try {\n560                     return createInteger(str);\n561                 } catch (NumberFormatException nfe) {\n562                     // ignore the bad number\n563                 }\n564                 try {\n565                     return createLong(str);\n566                 } catch (NumberFormatException nfe) {\n567                     // ignore the bad number\n568                 }\n569                 return createBigInteger(str);\n570 \n571             } else {\n572                 //Must be a float,double,BigDec\n573                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n574                 try {\n575                     Float f = createFloat(str);\n576                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n577                         return f;\n578                     }\n579                 } catch (NumberFormatException nfe) {\n580                     // ignore the bad number\n581                 }\n582                 try {\n583                     Double d = createDouble(str);\n584                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n585                         return d;\n586                     }\n587                 } catch (NumberFormatException nfe) {\n588                     // ignore the bad number\n589                 }\n590 \n591                 return createBigDecimal(str);\n592 \n593             }\n594         }\n595     }", "bm_classpath": "org.apache.commons.lang3.math.NumberUtils"}, {"bug_name": "Lang_37", "report_text": "> ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed types very well\n> \n> ArrayUtils.addAll(T[] array1, T... array2) does not handle mixed array types very well.\n> The stack trace for \n> Number[] st = ArrayUtils.addAll(new Integer[]\n> {1}\n> , new Long[]\n> {2L}\n> );\n> starts:\n> java.lang.ArrayStoreException  \n>  at java.lang.System.arraycopy(Native Method)  \n>  at org.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962)\n> which is not all that obvious.\n> It would be a lot clearer if the method threw an IlegalArgumentException or similar.", "test_name": "org.apache.commons.lang3.ArrayUtilsAddTest::testJira567", "test_method": "    public void testJira567(){\n        Number[] n;\n        // Valid array construction\n        n = ArrayUtils.addAll(new Number[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n        try {\n            // Invalid - can't store Long in Integer array\n               n = ArrayUtils.addAll(new Integer[]{Integer.valueOf(1)}, new Long[]{Long.valueOf(2)});\n               fail(\"Should have generated IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        } // <-- fails here\n    }", "error_message": "java.lang.ArrayStoreException\n\tjava.lang.System.arraycopy(Native Method)\n\torg.apache.commons.lang3.ArrayUtils.addAll(ArrayUtils.java:2962)\n\torg.apache.commons.lang3.ArrayUtilsAddTest.testJira567(ArrayUtilsAddTest.java:40)", "buggy_method": "2952 @SuppressWarnings(\"unchecked\")\n2953     public static <T> T[] addAll(T[] array1, T... array2) {\n2954         if (array1 == null) {\n2955             return clone(array2);\n2956         } else if (array2 == null) {\n2957             return clone(array1);\n2958         }\n2959         final Class<?> type1 = array1.getClass().getComponentType();\n2960         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n2961         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n2962             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n2963             // Check if problem is incompatible types\n2964         return joinedArray;\n2965     }", "bm_classpath": "org.apache.commons.lang3.ArrayUtils"}, {"bug_name": "Lang_38", "report_text": "> DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations\n> \n> If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields. Calling Calenar.getTime() seems to fix this problem. While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem.\n> For example, the following unit test fails:\n> ```\n>   public void testFormat_CalendarIsoMsZulu() {\n>     final String dateTime = \"2009-10-16T16:42:16.000Z\";\n>     // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n>     // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n>     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n>     cal.clear();\n>     cal.set(2009, 9, 16, 8, 42, 16);\n>     FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n>     assertEquals(\"dateTime\", dateTime, format.format(cal));\n>   }\n> ```\n> However, this unit test passes:\n> ```\n>   public void testFormat_CalendarIsoMsZulu() {\n>     final String dateTime = \"2009-10-16T16:42:16.000Z\";\n>     GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n>     cal.clear();\n>     cal.set(2009, 9, 16, 8, 42, 16);\n>     cal.getTime();\n>     FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n>     assertEquals(\"dateTime\", dateTime, format.format(cal));\n>   }\n> ```", "test_name": "org.apache.commons.lang3.time.FastDateFormatTest::testLang538", "test_method": "    public void testLang538() {\n        final String dateTime = \"2009-10-16T16:42:16.000Z\";\n\n        // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n        // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n        GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n        cal.clear();\n        cal.set(2009, 9, 16, 8, 42, 16);\n\n        FastDateFormat format = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZone.getTimeZone(\"GMT\"));\n        assertEquals(\"dateTime\", dateTime, format.format(cal)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: dateTime expected:<2009-10-16T[16]:42:16.000Z> but was:<2009-10-16T[08]:42:16.000Z>\n\torg.apache.commons.lang3.time.FastDateFormatTest.testLang538(FastDateFormatTest.java:349)", "buggy_method": "870 public StringBuffer format(Calendar calendar, StringBuffer buf) {\n871         if (mTimeZoneForced) {\n872             calendar = (Calendar) calendar.clone();\n873             calendar.setTimeZone(mTimeZone);\n874         }\n875         return applyRules(calendar, buf);\n876     }", "bm_classpath": "org.apache.commons.lang3.time.FastDateFormat"}, {"bug_name": "Lang_39", "report_text": "> StringUtils replaceEach - Bug or Missing Documentation\n> \n> The following Test Case for replaceEach fails with a null pointer exception.  \n> I have expected that all StringUtils methods are \"null-friendly\"  \n> The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null.  \n> I admit the use case is not perfect, because it is unclear what happens on the replace.  \n> I outlined three expectations in the test case, of course only one should be met.\n> If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string\n> ```\n> import static org.junit.Assert.assertEquals;\n> import org.apache.commons.lang.StringUtils;\n> import org.junit.Test;\n> public class StringUtilsTest {\n> \t@Test\n> \tpublic void replaceEach(){\n> \t\tString original = \"Hello World!\";\n> \t\tString[] searchList = {\"Hello\", \"World\"};\n> \t\tString[] replacementList = {\"Greetings\", null};\n> \t\tString result = StringUtils.replaceEach(original, searchList, replacementList);\n> \t\tassertEquals(\"Greetings !\", result);\n> \t\t//perhaps this is ok as well\n>                 //assertEquals(\"Greetings World!\", result);\n>                 //or even\n> \t\t//assertEquals(\"Greetings null!\", result);\n> \t}\n> \t\n> }\n> ```", "test_name": "org.apache.commons.lang3.StringUtilsTest::testReplace_StringStringArrayStringArray", "test_method": "    public void testReplace_StringStringArrayStringArray() {\n\n        \n        //JAVADOC TESTS START\n\n        //JAVADOC TESTS END\n\n\n        // Test null safety inside arrays - LANG-552\n        assertEquals(StringUtils.replaceEach(\"aba\", new String[]{\"a\", \"b\"}, new String[]{\"c\", null}),\"cbc\"); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.lang3.StringUtils.replaceEach(StringUtils.java:3676)\n\torg.apache.commons.lang3.StringUtils.replaceEach(StringUtils.java:3502)\n\torg.apache.commons.lang3.StringUtilsTest.testReplace_StringStringArrayStringArray(StringUtilsTest.java:1039)", "buggy_method": "3605 private static String replaceEach(String text, String[] searchList, String[] replacementList, \n3606                                       boolean repeat, int timeToLive) \n3607     {\n3608 \n3609         // mchyzer Performance note: This creates very few new objects (one major goal)\n3610         // let me know if there are performance requests, we can create a harness to measure\n3611 \n3612         if (text == null || text.length() == 0 || searchList == null || \n3613             searchList.length == 0 || replacementList == null || replacementList.length == 0) \n3614         {\n3615             return text;\n3616         }\n3617 \n3618         // if recursing, this shouldnt be less than 0\n3619         if (timeToLive < 0) {\n3620             throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n3621         }\n3622 \n3623         int searchLength = searchList.length;\n3624         int replacementLength = replacementList.length;\n3625 \n3626         // make sure lengths are ok, these need to be equal\n3627         if (searchLength != replacementLength) {\n3628             throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n3629                 + searchLength\n3630                 + \" vs \"\n3631                 + replacementLength);\n3632         }\n3633 \n3634         // keep track of which still have matches\n3635         boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n3636 \n3637         // index on index that the match was found\n3638         int textIndex = -1;\n3639         int replaceIndex = -1;\n3640         int tempIndex = -1;\n3641 \n3642         // index of replace array that will replace the search string found\n3643         // NOTE: logic duplicated below START\n3644         for (int i = 0; i < searchLength; i++) {\n3645             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n3646                 searchList[i].length() == 0 || replacementList[i] == null) \n3647             {\n3648                 continue;\n3649             }\n3650             tempIndex = text.indexOf(searchList[i]);\n3651 \n3652             // see if we need to keep searching for this\n3653             if (tempIndex == -1) {\n3654                 noMoreMatchesForReplIndex[i] = true;\n3655             } else {\n3656                 if (textIndex == -1 || tempIndex < textIndex) {\n3657                     textIndex = tempIndex;\n3658                     replaceIndex = i;\n3659                 }\n3660             }\n3661         }\n3662         // NOTE: logic mostly below END\n3663 \n3664         // no search strings found, we are done\n3665         if (textIndex == -1) {\n3666             return text;\n3667         }\n3668 \n3669         int start = 0;\n3670 \n3671         // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n3672         int increase = 0;\n3673 \n3674         // count the replacement text elements that are larger than their corresponding text being replaced\n3675         for (int i = 0; i < searchList.length; i++) {\n3676             int greater = replacementList[i].length() - searchList[i].length();\n3677             if (greater > 0) {\n3678                 increase += 3 * greater; // assume 3 matches\n3679             }\n3680         }\n3681         // have upper-bound at 20% increase, then let Java take over\n3682         increase = Math.min(increase, text.length() / 5);\n3683 \n3684         StringBuilder buf = new StringBuilder(text.length() + increase);\n3685 \n3686         while (textIndex != -1) {\n3687 \n3688             for (int i = start; i < textIndex; i++) {\n3689                 buf.append(text.charAt(i));\n3690             }\n3691             buf.append(replacementList[replaceIndex]);\n3692 \n3693             start = textIndex + searchList[replaceIndex].length();\n3694 \n3695             textIndex = -1;\n3696             replaceIndex = -1;\n3697             tempIndex = -1;\n3698             // find the next earliest match\n3699             // NOTE: logic mostly duplicated above START\n3700             for (int i = 0; i < searchLength; i++) {\n3701                 if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n3702                     searchList[i].length() == 0 || replacementList[i] == null) \n3703                 {\n3704                     continue;\n3705                 }\n3706                 tempIndex = text.indexOf(searchList[i], start);\n3707 \n3708                 // see if we need to keep searching for this\n3709                 if (tempIndex == -1) {\n3710                     noMoreMatchesForReplIndex[i] = true;\n3711                 } else {\n3712                     if (textIndex == -1 || tempIndex < textIndex) {\n3713                         textIndex = tempIndex;\n3714                         replaceIndex = i;\n3715                     }\n3716                 }\n3717             }\n3718             // NOTE: logic duplicated above END\n3719 \n3720         }\n3721         int textLength = text.length();\n3722         for (int i = start; i < textLength; i++) {\n3723             buf.append(text.charAt(i));\n3724         }\n3725         String result = buf.toString();\n3726         if (!repeat) {\n3727             return result;\n3728         }\n3729 \n3730         return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n3731     }", "bm_classpath": "org.apache.commons.lang3.StringUtils"}, {"bug_name": "Lang_40", "report_text": "> Fix case-insensitive string handling\n> \n> String.to\\*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see [Common Bug #3](http://www.nabble.com/Re%3A-Common-Bugs-p14931921s177.html) for details.", "test_name": "org.apache.commons.lang.StringUtilsEqualsIndexOfTest::testContainsIgnoreCase_LocaleIndependence", "test_method": "    public void testContainsIgnoreCase_LocaleIndependence() {\n        Locale orig = Locale.getDefault();\n\n        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\"), Locale.getDefault() };\n\n        String[][] tdata = { \n            { \"i\", \"I\" },\n            { \"I\", \"i\" },\n            { \"\\u03C2\", \"\\u03C3\" },\n            { \"\\u03A3\", \"\\u03C2\" },\n            { \"\\u03A3\", \"\\u03C3\" },\n        };\n\n        String[][] fdata = { \n            { \"\\u00DF\", \"SS\" },\n        };\n\n        try {\n            for (int i = 0; i < locales.length; i++) {\n                Locale.setDefault(locales[i]);\n                for (int j = 0; j < tdata.length; j++) {\n                    assertTrue(Locale.getDefault() + \": \" + j + \" \" + tdata[j][0] + \" \" + tdata[j][1], StringUtils\n                            .containsIgnoreCase(tdata[j][0], tdata[j][1]));\n                }\n                for (int j = 0; j < fdata.length; j++) {\n                    assertFalse(Locale.getDefault() + \": \" + j + \" \" + fdata[j][0] + \" \" + fdata[j][1], StringUtils\n                            .containsIgnoreCase(fdata[j][0], fdata[j][1]));\n                }\n            }\n        } finally {\n            Locale.setDefault(orig);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: en: 0 \u00df SS\n\torg.apache.commons.lang.StringUtilsEqualsIndexOfTest.testContainsIgnoreCase_LocaleIndependence(StringUtilsEqualsIndexOfTest.java:341)", "buggy_method": "1044 public static boolean containsIgnoreCase(String str, String searchStr) {\n1045         if (str == null || searchStr == null) {\n1046             return false;\n1047         }\n1048         return contains(str.toUpperCase(), searchStr.toUpperCase());\n1049     }", "bm_classpath": "org.apache.commons.lang.StringUtils"}, {"bug_name": "Lang_41", "report_text": "> ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.\n> \n> A semicolon is introduced into the class name at the end for all arrays...\n> String sArray[] = new String[2];  \n> sArray[0] = \"mark\";  \n> sArray[1] = \"is cool\";  \n> String simpleString = \"chris\";\n> assertEquals(\"String\", ClassUtils.getShortClassName(simpleString, null));  \n> assertEquals(\"String;\", ClassUtils.getShortClassName(sArray, null));", "test_name": "org.apache.commons.lang.ClassUtilsTest::test_getShortClassName_Class", "test_method": "    public void test_getShortClassName_Class() {\n\n        // LANG-535\n        assertEquals(\"String[]\", ClassUtils.getShortClassName(String[].class)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<String[[]]> but was:<String[;]>\n\torg.apache.commons.lang.ClassUtilsTest.test_getShortClassName_Class(ClassUtilsTest.java:97)", "buggy_method": "183 public static String getShortClassName(String className) {\n184         if (className == null) {\n185             return StringUtils.EMPTY;\n186         }\n187         if (className.length() == 0) {\n188             return StringUtils.EMPTY;\n189         }\n190 \n191 \n192         // Handle array encoding\n193             // Strip Object type encoding\n194 \n195 \n196         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n197         int innerIdx = className.indexOf(\n198                 INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n199         String out = className.substring(lastDotIdx + 1);\n200         if (innerIdx != -1) {\n201             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n202         }\n203         return out;\n204     }", "bm_classpath": "org.apache.commons.lang.ClassUtils"}, {"bug_name": "Lang_42", "report_text": "> StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters\n> \n> Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely:\n> import org.apache.commons.lang.\\*;\n> public class J2 {  \n>  public static void main(String[] args) throws Exception {  \n>  // this is the utf8 representation of the character:  \n>  // COUNTING ROD UNIT DIGIT THREE  \n>  // in unicode  \n>  // codepoint: U+1D362  \n>  byte[] data = new byte[] \n> { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 }\n> ;\n>  //output is: &#55348;&#57186;  \n>  // should be: &#119650;  \n>  System.out.println(\"'\" + StringEscapeUtils.escapeHtml(new String(data, \"UTF8\")) + \"'\");  \n>  }  \n> }\n> Should be very quick to fix, feel free to drop me an email if you want a patch.", "test_name": "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeHtmlHighUnicode", "test_method": "    public void testEscapeHtmlHighUnicode() throws java.io.UnsupportedEncodingException {\n        // this is the utf8 representation of the character:\n        // COUNTING ROD UNIT DIGIT THREE\n        // in unicode\n        // codepoint: U+1D362\n        byte[] data = new byte[] { (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 };\n\n        String escaped = StringEscapeUtils.escapeHtml( new String(data, \"UTF8\") );\n        String unescaped = StringEscapeUtils.unescapeHtml( escaped );\n\n        assertEquals( \"High unicode was not escaped correctly\", \"&#119650;\", escaped); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: High unicode was not escaped correctly expected:<&#[119650];> but was:<&#[55348;&#57186];>\n\torg.apache.commons.lang.StringEscapeUtilsTest.testEscapeHtmlHighUnicode(StringEscapeUtilsTest.java:430)", "buggy_method": "825 public void escape(Writer writer, String str) throws IOException {\n826         int len = str.length();\n827         for (int i = 0; i < len; i++) {\n828             char c = str.charAt(i);\n829             String entityName = this.entityName(c);\n830             if (entityName == null) {\n831                 if (c > 0x7F) {\n832                     writer.write(\"&#\");\n833                     writer.write(Integer.toString(c, 10));\n834                     writer.write(';');\n835                 } else {\n836                     writer.write(c);\n837                 }\n838             } else {\n839                 writer.write('&');\n840                 writer.write(entityName);\n841                 writer.write(';');\n842             }\n843         }\n844     }", "bm_classpath": "org.apache.commons.lang.Entities"}, {"bug_name": "Lang_43", "report_text": "> ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes\n> \n> When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur.\n> Example that will cause error:\n> **ExtendedMessageFormatTest.java**\n> ```\n> private static Map<String, Object> formatRegistry = new HashMap<String, Object>();    \n>     static {\n>         formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());\n>     }\n>     \n>     public static void main(String[] args) {\n>         ExtendedMessageFormat mf = new ExtendedMessageFormat(\"it''s a {dummy} 'test'!\", formatRegistry);\n>         String formattedPattern = mf.format(new String[] {\"great\"});\n>         System.out.println(formattedPattern);\n>     }\n> }\n> ```\n> The following change starting at line 421 on the 2.4 release seems to fix the problem:\n> **ExtendedMessageFormat.java**\n> ```\n> CURRENT (Broken):\n> if (escapingOn && c[start] == QUOTE) {\n>         return appendTo == null ? null : appendTo.append(QUOTE);\n> }\n> WORKING:\n> if (escapingOn && c[start] == QUOTE) {\n>         next(pos);\n>         return appendTo == null ? null : appendTo.append(QUOTE);\n> }\n> ```", "test_name": "org.apache.commons.lang.text.ExtendedMessageFormatTest::testEscapedQuote_LANG_477", "test_method": "    public void testEscapedQuote_LANG_477() {\n        String pattern = \"it''s a {0,lower} 'test'!\";\n        ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry); // <-- fails here\n    }", "error_message": "java.lang.OutOfMemoryError: Java heap space\n\tjava.util.Arrays.copyOf(Arrays.java:3332)\n\tjava.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\n\tjava.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:649)\n\tjava.lang.StringBuffer.append(StringBuffer.java:381)\n\torg.apache.commons.lang.text.ExtendedMessageFormat.appendQuotedString(ExtendedMessageFormat.java:422)\n\torg.apache.commons.lang.text.ExtendedMessageFormat.applyPattern(ExtendedMessageFormat.java:158)\n\torg.apache.commons.lang.text.ExtendedMessageFormat.<init>(ExtendedMessageFormat.java:127)\n\torg.apache.commons.lang.text.ExtendedMessageFormat.<init>(ExtendedMessageFormat.java:112)\n\torg.apache.commons.lang.text.ExtendedMessageFormatTest.testEscapedQuote_LANG_477(ExtendedMessageFormatTest.java:100)", "buggy_method": "417 private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n418             StringBuffer appendTo, boolean escapingOn) {\n419         int start = pos.getIndex();\n420         char[] c = pattern.toCharArray();\n421         if (escapingOn && c[start] == QUOTE) {\n422             return appendTo == null ? null : appendTo.append(QUOTE);\n423         }\n424         int lastHold = start;\n425         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n426             if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n427                 appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n428                         QUOTE);\n429                 pos.setIndex(i + ESCAPED_QUOTE.length());\n430                 lastHold = pos.getIndex();\n431                 continue;\n432             }\n433             switch (c[pos.getIndex()]) {\n434             case QUOTE:\n435                 next(pos);\n436                 return appendTo == null ? null : appendTo.append(c, lastHold,\n437                         pos.getIndex() - lastHold);\n438             default:\n439                 next(pos);\n440             }\n441         }\n442         throw new IllegalArgumentException(\n443                 \"Unterminated quoted string at position \" + start);\n444     }", "bm_classpath": "org.apache.commons.lang.text.ExtendedMessageFormat"}, {"bug_name": "Lang_44", "report_text": "> NumberUtils createNumber thows a StringIndexOutOfBoundsException when only an \"l\" is passed in.\n> \n> Seems to be similar to [~~LANG-300~~](https://issues.apache.org/jira/browse/LANG-300 \"NumberUtils.createNumber throws NumberFormatException for one digit long\"), except that if you don't place a digit in front of the \"l\" or \"L\" it throws a StringIndexOutOfBoundsException instead.", "test_name": "org.apache.commons.lang.NumberUtilsTest::testLang457", "test_method": "    public void testLang457() {\n        String[] badInputs = new String[] { \"l\", \"L\", \"f\", \"F\", \"junk\", \"bobL\"};\n        for(int i=0; i<badInputs.length; i++) {\n            try {\n                NumberUtils.createNumber(badInputs[i]);\n                fail(\"NumberFormatException was expected for \" + badInputs[i]);\n            } catch (NumberFormatException e) {\n                return; // expected\n            }\n        } // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 0\n\tjava.lang.String.charAt(String.java:658)\n\torg.apache.commons.lang.NumberUtils.createNumber(NumberUtils.java:193)\n\torg.apache.commons.lang.NumberUtilsTest.testLang457(NumberUtilsTest.java:528)", "buggy_method": "138 public static Number createNumber(String val) throws NumberFormatException {\n139         if (val == null) {\n140             return null;\n141         }\n142         if (val.length() == 0) {\n143             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n144         }\n145         if (val.startsWith(\"--\")) {\n146             // this is protection for poorness in java.lang.BigDecimal.\n147             // it accepts this as a legal value, but it does not appear \n148             // to be in specification of class. OS X Java parses it to \n149             // a wrong value.\n150             return null;\n151         }\n152         if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n153             return createInteger(val);\n154         }   \n155         char lastChar = val.charAt(val.length() - 1);\n156         String mant;\n157         String dec;\n158         String exp;\n159         int decPos = val.indexOf('.');\n160         int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n161 \n162         if (decPos > -1) {\n163 \n164             if (expPos > -1) {\n165                 if (expPos < decPos) {\n166                     throw new NumberFormatException(val + \" is not a valid number.\");\n167                 }\n168                 dec = val.substring(decPos + 1, expPos);\n169             } else {\n170                 dec = val.substring(decPos + 1);\n171             }\n172             mant = val.substring(0, decPos);\n173         } else {\n174             if (expPos > -1) {\n175                 mant = val.substring(0, expPos);\n176             } else {\n177                 mant = val;\n178             }\n179             dec = null;\n180         }\n181         if (!Character.isDigit(lastChar)) {\n182             if (expPos > -1 && expPos < val.length() - 1) {\n183                 exp = val.substring(expPos + 1, val.length() - 1);\n184             } else {\n185                 exp = null;\n186             }\n187             //Requesting a specific type..\n188             String numeric = val.substring(0, val.length() - 1);\n189             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n190             switch (lastChar) {\n191                 case 'l' :\n192                 case 'L' :\n193                     if (dec == null\n194                         && exp == null\n195                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n196                         try {\n197                             return createLong(numeric);\n198                         } catch (NumberFormatException nfe) {\n199                             //Too big for a long\n200                         }\n201                         return createBigInteger(numeric);\n202 \n203                     }\n204                     throw new NumberFormatException(val + \" is not a valid number.\");\n205                 case 'f' :\n206                 case 'F' :\n207                     try {\n208                         Float f = NumberUtils.createFloat(numeric);\n209                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n210                             //If it's too big for a float or the float value = 0 and the string\n211                             //has non-zeros in it, then float does not have the precision we want\n212                             return f;\n213                         }\n214 \n215                     } catch (NumberFormatException e) {\n216                         // ignore the bad number\n217                     }\n218                     //Fall through\n219                 case 'd' :\n220                 case 'D' :\n221                     try {\n222                         Double d = NumberUtils.createDouble(numeric);\n223                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n224                             return d;\n225                         }\n226                     } catch (NumberFormatException nfe) {\n227                         // empty catch\n228                     }\n229                     try {\n230                         return createBigDecimal(numeric);\n231                     } catch (NumberFormatException e) {\n232                         // empty catch\n233                     }\n234                     //Fall through\n235                 default :\n236                     throw new NumberFormatException(val + \" is not a valid number.\");\n237 \n238             }\n239         } else {\n240             //User doesn't have a preference on the return type, so let's start\n241             //small and go from there...\n242             if (expPos > -1 && expPos < val.length() - 1) {\n243                 exp = val.substring(expPos + 1, val.length());\n244             } else {\n245                 exp = null;\n246             }\n247             if (dec == null && exp == null) {\n248                 //Must be an int,long,bigint\n249                 try {\n250                     return createInteger(val);\n251                 } catch (NumberFormatException nfe) {\n252                     // empty catch\n253                 }\n254                 try {\n255                     return createLong(val);\n256                 } catch (NumberFormatException nfe) {\n257                     // empty catch\n258                 }\n259                 return createBigInteger(val);\n260 \n261             } else {\n262                 //Must be a float,double,BigDec\n263                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n264                 try {\n265                     Float f = createFloat(val);\n266                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n267                         return f;\n268                     }\n269                 } catch (NumberFormatException nfe) {\n270                     // empty catch\n271                 }\n272                 try {\n273                     Double d = createDouble(val);\n274                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n275                         return d;\n276                     }\n277                 } catch (NumberFormatException nfe) {\n278                     // empty catch\n279                 }\n280 \n281                 return createBigDecimal(val);\n282 \n283             }\n284 \n285         }\n286     }", "bm_classpath": "org.apache.commons.lang.NumberUtils"}, {"bug_name": "Lang_45", "report_text": "> WordUtils.abbreviate bug when lower is greater than str.length\n> \n> In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower.  \n> But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too...  \n> Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException\n> The fix is to adjust lower to the length of the string", "test_name": "org.apache.commons.lang.WordUtilsTest::testAbbreviate", "test_method": "    public void testAbbreviate() {\n        // check null and empty are returned respectively\n\n        // test upper limit\n\n        // test upper limit + append string\n\n        // test lower value\n        assertEquals(\"0123456789\", WordUtils.abbreviate(\"0123456789\", 15, 20, null)); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 15\n\tjava.lang.String.substring(String.java:1963)\n\torg.apache.commons.lang.WordUtils.abbreviate(WordUtils.java:629)\n\torg.apache.commons.lang.WordUtilsTest.testAbbreviate(WordUtilsTest.java:390)", "buggy_method": "605 public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n606         // initial parameter checks\n607         if (str == null) {\n608             return null;\n609         }\n610         if (str.length() == 0) {\n611             return StringUtils.EMPTY;\n612         }\n613 \n614         // if the lower value is greater than the length of the string,\n615         // set to the length of the string\n616         // if the upper value is -1 (i.e. no limit) or is greater\n617         // than the length of the string, set to the length of the string\n618         if (upper == -1 || upper > str.length()) {\n619             upper = str.length();\n620         }\n621         // if upper is less than lower, raise it to lower\n622         if (upper < lower) {\n623             upper = lower;\n624         }\n625 \n626         StringBuffer result = new StringBuffer();\n627         int index = StringUtils.indexOf(str, \" \", lower);\n628         if (index == -1) {\n629             result.append(str.substring(0, upper));\n630             // only if abbreviation has occured do we append the appendToEnd value\n631             if (upper != str.length()) {\n632                 result.append(StringUtils.defaultString(appendToEnd));\n633             }\n634         } else if (index > upper) {\n635             result.append(str.substring(0, upper));\n636             result.append(StringUtils.defaultString(appendToEnd));\n637         } else {\n638             result.append(str.substring(0, index));\n639             result.append(StringUtils.defaultString(appendToEnd));\n640         }\n641         return result.toString();\n642     }", "bm_classpath": "org.apache.commons.lang.WordUtils"}, {"bug_name": "Lang_46", "report_text": "> StringEscapeUtils.escapeJava(String) escapes '/' characters\n> \n> Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes '/' characters, which is not a valid \"escapable\" character in Java strings. I haven't tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java \"escapable\" characters are escaped by escapeJava(String).\n> This bug may have appeared as an unintended side-effect of the fix for [~~LANG-363~~](https://issues.apache.org/jira/browse/LANG-363 \"StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\\/', it will make IE render page uncorrectly\").\n> Also the javadoc for escapeJava is now a little off, in that '/' should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules.\n> The following is a JUnit3 test demonstrating the bug.\n> import junit.framework.TestCase;\n> import org.apache.commons.lang.StringEscapeUtils;\n> public class StringEscapeUtilsTest extends TestCase {  \n>  public void testEscapeJavaWithSlash() \n> {\n>  final String input = \"String with a slash (/) in it\";\n>  \n>  final String expected = input;\n>  final String actual = StringEscapeUtils.escapeJava( input );\n>  /\\*\\*\n>  \\* In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters,\n>  \\* which are not a valid character to escape in a Java string. \n>  \\*/\n>  assertEquals( expected, actual );\n>  }\n> }", "test_name": "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaWithSlash", "test_method": "    public void testEscapeJavaWithSlash() {\n        final String input = \"String with a slash (/) in it\";\n\n        final String expected = input;\n        final String actual = StringEscapeUtils.escapeJava(input);\n\n        /**\n         * In 2.4 StringEscapeUtils.escapeJava(String) escapes '/' characters, which are not a valid character to escape\n         * in a Java string.\n         */\n        assertEquals(expected, actual); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...tring with a slash ([]/) in it> but was:<...tring with a slash ([\\]/) in it>\n\torg.apache.commons.lang.StringEscapeUtilsTest.testEscapeJavaWithSlash(StringEscapeUtilsTest.java:113)", "buggy_method": "101 public static void escapeJava(Writer out, String str) throws IOException {\n102         escapeJavaStyleString(out, str, false);\n103     }", "bm_classpath": "org.apache.commons.lang.StringEscapeUtils"}, {"bug_name": "Lang_47", "report_text": "> StrBuilder appendFixedWidth does not handle nulls\n> \n> Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.", "test_name": "org.apache.commons.lang.text.StrBuilderTest::testLang412Left", "test_method": "    public void testLang412Left() {\n        StrBuilder sb = new StrBuilder();\n        sb.appendFixedWidthPadLeft(null, 10, '*'); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.lang.text.StrBuilder.appendFixedWidthPadLeft(StrBuilder.java:1186)\n\torg.apache.commons.lang.text.StrBuilderTest.testLang412Left(StrBuilderTest.java:1761)", "buggy_method": "1182 public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n1183         if (width > 0) {\n1184             ensureCapacity(size + width);\n1185             String str = (obj == null ? getNullText() : obj.toString());\n1186             int strLen = str.length();\n1187             if (strLen >= width) {\n1188                 str.getChars(strLen - width, strLen, buffer, size);\n1189             } else {\n1190                 int padLen = width - strLen;\n1191                 for (int i = 0; i < padLen; i++) {\n1192                     buffer[size + i] = padChar;\n1193                 }\n1194                 str.getChars(0, strLen, buffer, size + padLen);\n1195             }\n1196             size += width;\n1197         }\n1198         return this;\n1199     }", "bm_classpath": "org.apache.commons.lang.text.StrBuilder"}, {"bug_name": "Lang_48", "report_text": "> EqualsBuilder don't compare BigDecimals correctly\n> \n> When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal. ", "test_name": "org.apache.commons.lang.builder.EqualsBuilderTest::testBigDecimal", "test_method": "    public void testBigDecimal() {\n        BigDecimal o1 = new BigDecimal(\"2.0\");\n        BigDecimal o2 = new BigDecimal(\"2.00\");\n        assertTrue(new EqualsBuilder().append(o1, o2).isEquals()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.lang.builder.EqualsBuilderTest.testBigDecimal(EqualsBuilderTest.java:385)", "buggy_method": "367 public EqualsBuilder append(Object lhs, Object rhs) {\n368         if (isEquals == false) {\n369             return this;\n370         }\n371         if (lhs == rhs) {\n372             return this;\n373         }\n374         if (lhs == null || rhs == null) {\n375             this.setEquals(false);\n376             return this;\n377         }\n378         Class lhsClass = lhs.getClass();\n379         if (!lhsClass.isArray()) {\n380                 // The simple case, not an array, just test the element\n381                 isEquals = lhs.equals(rhs);\n382         } else if (lhs.getClass() != rhs.getClass()) {\n383             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n384             this.setEquals(false);\n385         }\n386         // 'Switch' on type of array, to dispatch to the correct handler\n387         // This handles multi dimensional arrays of the same depth\n388         else if (lhs instanceof long[]) {\n389             append((long[]) lhs, (long[]) rhs);\n390         } else if (lhs instanceof int[]) {\n391             append((int[]) lhs, (int[]) rhs);\n392         } else if (lhs instanceof short[]) {\n393             append((short[]) lhs, (short[]) rhs);\n394         } else if (lhs instanceof char[]) {\n395             append((char[]) lhs, (char[]) rhs);\n396         } else if (lhs instanceof byte[]) {\n397             append((byte[]) lhs, (byte[]) rhs);\n398         } else if (lhs instanceof double[]) {\n399             append((double[]) lhs, (double[]) rhs);\n400         } else if (lhs instanceof float[]) {\n401             append((float[]) lhs, (float[]) rhs);\n402         } else if (lhs instanceof boolean[]) {\n403             append((boolean[]) lhs, (boolean[]) rhs);\n404         } else {\n405             // Not an array of primitives\n406             append((Object[]) lhs, (Object[]) rhs);\n407         }\n408         return this;\n409     }", "bm_classpath": "org.apache.commons.lang.builder.EqualsBuilder"}, {"bug_name": "Lang_49", "report_text": "> infinite loop in Fraction.reduce when numerator == 0\n> \n> Summary pretty much says it all.", "test_name": "org.apache.commons.lang.math.FractionTest::testReduce", "test_method": "    public void testReduce() {\n        Fraction f = null;\n        \n        f = Fraction.getFraction(50, 75);\n        Fraction result = f.reduce();\n\n        f = Fraction.getFraction(-2, -3);\n        result = f.reduce();\n\n        f = Fraction.getFraction(2, -3);\n        result = f.reduce();\n\n        f = Fraction.getFraction(-2, 3);\n        result = f.reduce();\n\n        f = Fraction.getFraction(2, 3);\n        result = f.reduce();\n\n        f = Fraction.getFraction(0, 1);\n        result = f.reduce();\n\n        f = Fraction.getFraction(0, 100);\n        result = f.reduce();\n        assertEquals(1, result.getDenominator()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1> but was:<100>\n\torg.apache.commons.lang.math.FractionTest.testReduce(FractionTest.java:655)", "buggy_method": "465 public Fraction reduce() {\n466         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n467         if (gcd == 1) {\n468             return this;\n469         }\n470         return Fraction.getFraction(numerator / gcd, denominator / gcd);\n471     }", "bm_classpath": "org.apache.commons.lang.math.Fraction"}, {"bug_name": "Lang_50", "report_text": "> FastDateFormat getDateInstance() and getDateTimeInstance() assume Locale.getDefault() won't change\n> \n> The FastDateFormat getDateInstance() and getDateTimeInstance() methods create the HashMap key from various items including the locale.\n> If the locale is null, then it is not made part of the key, but the stored object is created using the current default locale.\n> If the Locale is changed subsequently, then the wrong locale is applied.\n> Patch for test case to follow.", "test_name": "org.apache.commons.lang.time.FastDateFormatTest::test_changeDefault_Locale_DateInstance", "test_method": "    public void test_changeDefault_Locale_DateInstance() {\n        Locale realDefaultLocale = Locale.getDefault();\n        try {\n            Locale.setDefault(Locale.US);\n            FastDateFormat format1 = FastDateFormat.getDateInstance(FastDateFormat.FULL, Locale.GERMANY);\n            FastDateFormat format2 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n            Locale.setDefault(Locale.GERMANY);\n            FastDateFormat format3 = FastDateFormat.getDateInstance(FastDateFormat.FULL);\n\n            assertSame(Locale.GERMANY, format1.getLocale());\n            assertSame(Locale.US, format2.getLocale());\n            assertSame(Locale.GERMANY, format3.getLocale());\n            assertTrue(format1 != format2); // -- junit 3.8 version -- assertFalse(format1 == format2);\n            assertTrue(format2 != format3);\n\n        } finally {\n            Locale.setDefault(realDefaultLocale);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected same:<de_DE> was not:<en_US>\n\torg.apache.commons.lang.time.FastDateFormatTest.test_changeDefault_Locale_DateInstance(FastDateFormatTest.java:146)", "buggy_method": "279 public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n280         Object key = new Integer(style);\n281         if (timeZone != null) {\n282             key = new Pair(key, timeZone);\n283         }\n284 \n285         if (locale != null) {\n286             key = new Pair(key, locale);\n287         }\n288 \n289 \n290         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n291         if (format == null) {\n292             if (locale == null) {\n293                 locale = Locale.getDefault();\n294             }\n295             try {\n296                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n297                 String pattern = formatter.toPattern();\n298                 format = getInstance(pattern, timeZone, locale);\n299                 cDateInstanceCache.put(key, format);\n300                 \n301             } catch (ClassCastException ex) {\n302                 throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n303             }\n304         }\n305         return format;\n306     }", "bm_classpath": "org.apache.commons.lang.time.FastDateFormat"}, {"bug_name": "Lang_51", "report_text": "> BooleanUtils.toBoolean() - invalid drop-thru in case statement causes StringIndexOutOfBoundsException\n> \n> The method BooleanUtils.toBoolean() has a case statement; case 3 drops through to case 4; this can cause StringIndexOutOfBoundsException, for example with the test:\n> assertEquals(false, BooleanUtils.toBoolean(\"tru\"));\n> The end of case 3 should return false.\n> Patch to follow for source and unit test.", "test_name": "org.apache.commons.lang.BooleanUtilsTest::test_toBoolean_String", "test_method": "    public void test_toBoolean_String() {\n        assertEquals(false, BooleanUtils.toBoolean(\"tru\")); // <-- fails here\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 3\n\tjava.lang.String.charAt(String.java:658)\n\torg.apache.commons.lang.BooleanUtils.toBoolean(BooleanUtils.java:686)\n\torg.apache.commons.lang.BooleanUtilsTest.test_toBoolean_String(BooleanUtilsTest.java:334)", "buggy_method": "649 public static boolean toBoolean(String str) {\n650         // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n651         // Non interned 'true' matched 15 times slower.\n652         // \n653         // Optimisation provides same performance as before for interned 'true'.\n654         // Similar performance for null, 'false', and other strings not length 2/3/4.\n655         // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n656         if (str == \"true\") {\n657             return true;\n658         }\n659         if (str == null) {\n660             return false;\n661         }\n662         switch (str.length()) {\n663             case 2: {\n664                 char ch0 = str.charAt(0);\n665                 char ch1 = str.charAt(1);\n666                 return \n667                     (ch0 == 'o' || ch0 == 'O') &&\n668                     (ch1 == 'n' || ch1 == 'N');\n669             }\n670             case 3: {\n671                 char ch = str.charAt(0);\n672                 if (ch == 'y') {\n673                     return \n674                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n675                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n676                 }\n677                 if (ch == 'Y') {\n678                     return \n679                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n680                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n681                 }\n682             }\n683             case 4: {\n684                 char ch = str.charAt(0);\n685                 if (ch == 't') {\n686                     return \n687                         (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n688                         (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n689                         (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n690                 }\n691                 if (ch == 'T') {\n692                     return \n693                         (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n694                         (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n695                         (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n696                 }\n697             }\n698         }\n699         return false;\n700     }", "bm_classpath": "org.apache.commons.lang.BooleanUtils"}, {"bug_name": "Lang_52", "report_text": "> StringEscapeUtils.escapeJavaScript() method did not escape '/' into '\\/', it will make IE render page uncorrectly\n> \n> If Javascripts including'/', IE will parse the scripts uncorrectly, actually '/' should be escaped to '\\/'.  \n> For example, document.getElementById(\"test\").value = '<script>alert(\\'aaa\\');</script>';this expression will make IE render page uncorrect, it should be document.getElementById(\"test\").value = '<script>alert(\\'aaa\\');<\\/script>';\n> Btw, Spring's JavascriptEscape behavor is correct.  \n> Try to run below codes, you will find the difference:  \n>  String s = \"<script>alert('aaa');</script>\";  \n>  String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);  \n>  System.out.println(\"Spring JS Escape : \"+str);  \n>  str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);  \n>  System.out.println(\"Apache Common Lang JS Escape : \"+ str);", "test_name": "org.apache.commons.lang.StringEscapeUtilsTest::testEscapeJavaScript", "test_method": "    public void testEscapeJavaScript() {\n        try {\n            StringEscapeUtils.escapeJavaScript(null, null);\n            fail();\n        } catch (IOException ex) {\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        try {\n            StringEscapeUtils.escapeJavaScript(null, \"\");\n            fail();\n        } catch (IOException ex) {\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        \n        assertEquals(\"document.getElementById(\\\\\\\"test\\\\\\\").value = \\\\'<script>alert(\\\\'aaa\\\\');<\\\\/script>\\\\';\", \n                StringEscapeUtils.escapeJavaScript(\"document.getElementById(\\\"test\\\").value = '<script>alert('aaa');</script>';\")); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...ipt>alert(\\'aaa\\');<[\\]/script>\\';> but was:<...ipt>alert(\\'aaa\\');<[]/script>\\';>\n\torg.apache.commons.lang.StringEscapeUtilsTest.testEscapeJavaScript(StringEscapeUtilsTest.java:187)", "buggy_method": "171 private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n172         if (out == null) {\n173             throw new IllegalArgumentException(\"The Writer must not be null\");\n174         }\n175         if (str == null) {\n176             return;\n177         }\n178         int sz;\n179         sz = str.length();\n180         for (int i = 0; i < sz; i++) {\n181             char ch = str.charAt(i);\n182 \n183             // handle unicode\n184             if (ch > 0xfff) {\n185                 out.write(\"\\\\u\" + hex(ch));\n186             } else if (ch > 0xff) {\n187                 out.write(\"\\\\u0\" + hex(ch));\n188             } else if (ch > 0x7f) {\n189                 out.write(\"\\\\u00\" + hex(ch));\n190             } else if (ch < 32) {\n191                 switch (ch) {\n192                     case '\\b':\n193                         out.write('\\\\');\n194                         out.write('b');\n195                         break;\n196                     case '\\n':\n197                         out.write('\\\\');\n198                         out.write('n');\n199                         break;\n200                     case '\\t':\n201                         out.write('\\\\');\n202                         out.write('t');\n203                         break;\n204                     case '\\f':\n205                         out.write('\\\\');\n206                         out.write('f');\n207                         break;\n208                     case '\\r':\n209                         out.write('\\\\');\n210                         out.write('r');\n211                         break;\n212                     default :\n213                         if (ch > 0xf) {\n214                             out.write(\"\\\\u00\" + hex(ch));\n215                         } else {\n216                             out.write(\"\\\\u000\" + hex(ch));\n217                         }\n218                         break;\n219                 }\n220             } else {\n221                 switch (ch) {\n222                     case '\\'':\n223                         if (escapeSingleQuote) {\n224                           out.write('\\\\');\n225                         }\n226                         out.write('\\'');\n227                         break;\n228                     case '\"':\n229                         out.write('\\\\');\n230                         out.write('\"');\n231                         break;\n232                     case '\\\\':\n233                         out.write('\\\\');\n234                         out.write('\\\\');\n235                         break;\n236                     default :\n237                         out.write(ch);\n238                         break;\n239                 }\n240             }\n241         }\n242     }", "bm_classpath": "org.apache.commons.lang.StringEscapeUtils"}, {"bug_name": "Lang_53", "report_text": "> Dates.round() behaves incorrectly for minutes and seconds\n> \n> Get unexpected output for rounding by minutes or seconds.\n> public void testRound()  \n> {  \n>  Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));  \n>  testCalendar.set(2007, 6, 2, 8, 9, 50);  \n>  Date date = testCalendar.getTime();  \n>  System.out.println(\"Before round() \" + date);  \n>  System.out.println(\"After round() \" + DateUtils.round(date, Calendar.MINUTE));  \n> }\n> --2.1 produces  \n> Before round() Mon Jul 02 03:09:50 CDT 2007  \n> After round() Mon Jul 02 03:10:00 CDT 2007 \u2013 this is what I would expect\n> --2.2 and 2.3 produces  \n> Before round() Mon Jul 02 03:09:50 CDT 2007  \n> After round() Mon Jul 02 03:01:00 CDT 2007 \u2013 this appears to be wrong", "test_name": "org.apache.commons.lang.time.DateUtilsTest::testRoundLang346", "test_method": "    public void testRoundLang346() throws Exception\n    {\n        TimeZone.setDefault(defaultZone);\n        dateTimeParser.setTimeZone(defaultZone);\n        Calendar testCalendar = Calendar.getInstance();\n        testCalendar.set(2007, 6, 2, 8, 8, 50);\n        Date date = testCalendar.getTime();\n        assertEquals(\"Minute Round Up Failed\",\n                     dateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\n                     DateUtils.round(date, Calendar.MINUTE)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Minute Round Up Failed expected:<Mon Jul 02 08:09:00 PDT 2007> but was:<Mon Jul 02 08:01:00 PDT 2007>\n\torg.apache.commons.lang.time.DateUtilsTest.testRoundLang346(DateUtilsTest.java:712)", "buggy_method": "620 private static void modify(Calendar val, int field, boolean round) {\n621         if (val.get(Calendar.YEAR) > 280000000) {\n622             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n623         }\n624         \n625         if (field == Calendar.MILLISECOND) {\n626             return;\n627         }\n628 \n629         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n630         // see http://issues.apache.org/jira/browse/LANG-59\n631         //\n632         // Manually truncate milliseconds, seconds and minutes, rather than using\n633         // Calendar methods.\n634 \n635         Date date = val.getTime();\n636         long time = date.getTime();\n637         boolean done = false;\n638 \n639         // truncate milliseconds\n640         int millisecs = val.get(Calendar.MILLISECOND);\n641         if (!round || millisecs < 500) {\n642             time = time - millisecs;\n643         if (field == Calendar.SECOND) {\n644             done = true;\n645             }\n646         }\n647 \n648         // truncate seconds\n649         int seconds = val.get(Calendar.SECOND);\n650         if (!done && (!round || seconds < 30)) {\n651             time = time - (seconds * 1000L);\n652         if (field == Calendar.MINUTE) {\n653             done = true;\n654             }\n655         }\n656 \n657         // truncate minutes\n658         int minutes = val.get(Calendar.MINUTE);\n659         if (!done && (!round || minutes < 30)) {\n660             time = time - (minutes * 60000L);\n661         }\n662 \n663         // reset time\n664         if (date.getTime() != time) {\n665             date.setTime(time);\n666             val.setTime(date);\n667         }\n668         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n669 \n670         boolean roundUp = false;\n671         for (int i = 0; i < fields.length; i++) {\n672             for (int j = 0; j < fields[i].length; j++) {\n673                 if (fields[i][j] == field) {\n674                     //This is our field... we stop looping\n675                     if (round && roundUp) {\n676                         if (field == DateUtils.SEMI_MONTH) {\n677                             //This is a special case that's hard to generalize\n678                             //If the date is 1, we round up to 16, otherwise\n679                             //  we subtract 15 days and add 1 month\n680                             if (val.get(Calendar.DATE) == 1) {\n681                                 val.add(Calendar.DATE, 15);\n682                             } else {\n683                                 val.add(Calendar.DATE, -15);\n684                                 val.add(Calendar.MONTH, 1);\n685                             }\n686                         } else {\n687                             //We need at add one to this field since the\n688                             //  last number causes us to round up\n689                             val.add(fields[i][0], 1);\n690                         }\n691                     }\n692                     return;\n693                 }\n694             }\n695             //We have various fields that are not easy roundings\n696             int offset = 0;\n697             boolean offsetSet = false;\n698             //These are special types of fields that require different rounding rules\n699             switch (field) {\n700                 case DateUtils.SEMI_MONTH:\n701                     if (fields[i][0] == Calendar.DATE) {\n702                         //If we're going to drop the DATE field's value,\n703                         //  we want to do this our own way.\n704                         //We need to subtrace 1 since the date has a minimum of 1\n705                         offset = val.get(Calendar.DATE) - 1;\n706                         //If we're above 15 days adjustment, that means we're in the\n707                         //  bottom half of the month and should stay accordingly.\n708                         if (offset >= 15) {\n709                             offset -= 15;\n710                         }\n711                         //Record whether we're in the top or bottom half of that range\n712                         roundUp = offset > 7;\n713                         offsetSet = true;\n714                     }\n715                     break;\n716                 case Calendar.AM_PM:\n717                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n718                         //If we're going to drop the HOUR field's value,\n719                         //  we want to do this our own way.\n720                         offset = val.get(Calendar.HOUR_OF_DAY);\n721                         if (offset >= 12) {\n722                             offset -= 12;\n723                         }\n724                         roundUp = offset > 6;\n725                         offsetSet = true;\n726                     }\n727                     break;\n728             }\n729             if (!offsetSet) {\n730                 int min = val.getActualMinimum(fields[i][0]);\n731                 int max = val.getActualMaximum(fields[i][0]);\n732                 //Calculate the offset from the minimum allowed value\n733                 offset = val.get(fields[i][0]) - min;\n734                 //Set roundUp if this is more than half way between the minimum and maximum\n735                 roundUp = offset > ((max - min) / 2);\n736             }\n737             //We need to remove this field\n738             if (offset != 0) {\n739                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n740             }\n741         }\n742         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n743 \n744     }", "bm_classpath": "org.apache.commons.lang.time.DateUtils"}, {"bug_name": "Lang_54", "report_text": "> LocaleUtils.toLocale() rejects strings with only language+variant\n> \n> LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr\\_\\_POSIX\n> This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale(\"fr\", \"\", \"POSIX\").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code.\n> Commons Configuration handles this case in its PropertyConverter.toLocale() method. I'd like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.", "test_name": "org.apache.commons.lang.LocaleUtilsTest::testLang328", "test_method": "    public void testLang328() {\n        assertValidToLocale(\"fr__POSIX\", \"fr\", \"\", \"POSIX\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid locale format: fr__POSIX\n\torg.apache.commons.lang.LocaleUtils.toLocale(LocaleUtils.java:116)\n\torg.apache.commons.lang.LocaleUtilsTest.assertValidToLocale(LocaleUtilsTest.java:140)\n\torg.apache.commons.lang.LocaleUtilsTest.testLang328(LocaleUtilsTest.java:505)", "buggy_method": "94 public static Locale toLocale(String str) {\n95         if (str == null) {\n96             return null;\n97         }\n98         int len = str.length();\n99         if (len != 2 && len != 5 && len < 7) {\n100             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n101         }\n102         char ch0 = str.charAt(0);\n103         char ch1 = str.charAt(1);\n104         if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n105             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n106         }\n107         if (len == 2) {\n108             return new Locale(str, \"\");\n109         } else {\n110             if (str.charAt(2) != '_') {\n111                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n112             }\n113             char ch3 = str.charAt(3);\n114             char ch4 = str.charAt(4);\n115             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n116                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n117             }\n118             if (len == 5) {\n119                 return new Locale(str.substring(0, 2), str.substring(3, 5));\n120             } else {\n121                 if (str.charAt(5) != '_') {\n122                     throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n123                 }\n124                 return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n125             }\n126         }\n127     }", "bm_classpath": "org.apache.commons.lang.LocaleUtils"}, {"bug_name": "Lang_55", "report_text": "> StopWatch: suspend() acts as split(), if followed by stop()\n> \n> In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:\n>  StopWatch sw = new StopWatch();\n>  sw.start();  \n>  Thread.sleep(1000);  \n>  sw.suspend();  \n>  // Time 1 (ok)  \n>  System.out.println(sw.getTime());\n>  Thread.sleep(2000);  \n>  // Time 1 (again, ok)  \n>  System.out.println(sw.getTime());\n>  sw.resume();  \n>  Thread.sleep(3000);  \n>  sw.suspend();  \n>  // Time 2 (ok)  \n>  System.out.println(sw.getTime());\n>  Thread.sleep(4000);  \n>  // Time 2 (again, ok)  \n>  System.out.println(sw.getTime());\n>  Thread.sleep(5000);  \n>  sw.stop();  \n>  // Time 2 (should be, but is Time 3 => NOT ok)  \n>  System.out.println(sw.getTime());\n> suspend/resume is like a pause, where time counter doesn't continue. So a following stop()-call shouldn't increase the time counter, should it?", "test_name": "org.apache.commons.lang.time.StopWatchTest::testLang315", "test_method": "    public void testLang315() {\n        StopWatch watch = new StopWatch();\n        watch.start();\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n        watch.suspend();\n        long suspendTime = watch.getTime();\n            try {Thread.sleep(200);} catch (InterruptedException ex) {}\n        watch.stop();\n        long totalTime = watch.getTime();\n        assertTrue( suspendTime == totalTime ); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.lang.time.StopWatchTest.testLang315(StopWatchTest.java:120)", "buggy_method": "114 public void stop() {\n115         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n116             throw new IllegalStateException(\"Stopwatch is not running. \");\n117         }\n118             stopTime = System.currentTimeMillis();\n119         this.runningState = STATE_STOPPED;\n120     }", "bm_classpath": "org.apache.commons.lang.time.StopWatch"}, {"bug_name": "Lang_57", "report_text": "> NullPointerException in isAvailableLocale(Locale)\n> \n> FindBugs pointed out:\n>  UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet\n> cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn't been called it will cause a NullPointerException.", "test_name": "org.apache.commons.lang.LocaleUtilsTest::testAvailableLocaleSet", "test_method": "public void testAvailableLocaleSet() {\n        Set set = LocaleUtils.availableLocaleSet();\n        Set set2 = LocaleUtils.availableLocaleSet();\n        assertNotNull(set);\n        assertSame(set, set2);\n        assertUnmodifiableCollection(set);\n        \n        Locale[] jdkLocaleArray = Locale.getAvailableLocales();\n        List jdkLocaleList = Arrays.asList(jdkLocaleArray);\n        Set jdkLocaleSet = new HashSet(jdkLocaleList);\n        assertEquals(jdkLocaleSet, set);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Test availableLocaleSet() method.\n     */", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.lang.LocaleUtils.isAvailableLocale(LocaleUtils.java:223)\n\torg.apache.commons.lang.LocaleUtilsTest.setUp(LocaleUtilsTest.java:82)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)\n\torg.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\n\torg.apache.tools.ant.Task.perform(Task.java:348)\n\torg.apache.tools.ant.Target.execute(Target.java:392)\n\torg.apache.tools.ant.Target.performTasks(Target.java:413)\n\torg.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\n\torg.apache.tools.ant.Project.executeTarget(Project.java:1368)\n\torg.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\n\torg.apache.tools.ant.Project.executeTargets(Project.java:1251)", "buggy_method": "222 public static boolean isAvailableLocale(Locale locale) {\n223         return cAvailableLocaleSet.contains(locale);\n224     }", "bm_classpath": "org.apache.commons.lang.LocaleUtils"}, {"bug_name": "Lang_58", "report_text": "> NumberUtils.createNumber throws NumberFormatException for one digit long\n> \n> NumberUtils.createNumber throws a NumberFormatException when parsing \"1l\", \"2l\" .. etc...\n> It works fine if you try to parse \"01l\" or \"02l\". The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for \"1l\"", "test_name": "org.apache.commons.lang.math.NumberUtilsTest::testLang300", "test_method": "    public void testLang300() {\n        NumberUtils.createNumber(\"-1l\");\n        NumberUtils.createNumber(\"01l\");\n        NumberUtils.createNumber(\"1l\"); // <-- fails here\n    }", "error_message": "java.lang.NumberFormatException: 1l is not a valid number.\n\torg.apache.commons.lang.math.NumberUtils.createNumber(NumberUtils.java:464)\n\torg.apache.commons.lang.math.NumberUtilsTest.testLang300(NumberUtilsTest.java:1371)", "buggy_method": "397 public static Number createNumber(String str) throws NumberFormatException {\n398         if (str == null) {\n399             return null;\n400         }\n401         if (StringUtils.isBlank(str)) {\n402             throw new NumberFormatException(\"A blank string is not a valid number\");\n403         }  \n404         if (str.startsWith(\"--\")) {\n405             // this is protection for poorness in java.lang.BigDecimal.\n406             // it accepts this as a legal value, but it does not appear \n407             // to be in specification of class. OS X Java parses it to \n408             // a wrong value.\n409             return null;\n410         }\n411         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n412             return createInteger(str);\n413         }   \n414         char lastChar = str.charAt(str.length() - 1);\n415         String mant;\n416         String dec;\n417         String exp;\n418         int decPos = str.indexOf('.');\n419         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n420 \n421         if (decPos > -1) {\n422 \n423             if (expPos > -1) {\n424                 if (expPos < decPos) {\n425                     throw new NumberFormatException(str + \" is not a valid number.\");\n426                 }\n427                 dec = str.substring(decPos + 1, expPos);\n428             } else {\n429                 dec = str.substring(decPos + 1);\n430             }\n431             mant = str.substring(0, decPos);\n432         } else {\n433             if (expPos > -1) {\n434                 mant = str.substring(0, expPos);\n435             } else {\n436                 mant = str;\n437             }\n438             dec = null;\n439         }\n440         if (!Character.isDigit(lastChar)) {\n441             if (expPos > -1 && expPos < str.length() - 1) {\n442                 exp = str.substring(expPos + 1, str.length() - 1);\n443             } else {\n444                 exp = null;\n445             }\n446             //Requesting a specific type..\n447             String numeric = str.substring(0, str.length() - 1);\n448             boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n449             switch (lastChar) {\n450                 case 'l' :\n451                 case 'L' :\n452                     if (dec == null\n453                         && exp == null\n454                         && isDigits(numeric.substring(1))\n455                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n456                         try {\n457                             return createLong(numeric);\n458                         } catch (NumberFormatException nfe) {\n459                             //Too big for a long\n460                         }\n461                         return createBigInteger(numeric);\n462 \n463                     }\n464                     throw new NumberFormatException(str + \" is not a valid number.\");\n465                 case 'f' :\n466                 case 'F' :\n467                     try {\n468                         Float f = NumberUtils.createFloat(numeric);\n469                         if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n470                             //If it's too big for a float or the float value = 0 and the string\n471                             //has non-zeros in it, then float does not have the precision we want\n472                             return f;\n473                         }\n474 \n475                     } catch (NumberFormatException nfe) {\n476                         // ignore the bad number\n477                     }\n478                     //Fall through\n479                 case 'd' :\n480                 case 'D' :\n481                     try {\n482                         Double d = NumberUtils.createDouble(numeric);\n483                         if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n484                             return d;\n485                         }\n486                     } catch (NumberFormatException nfe) {\n487                         // ignore the bad number\n488                     }\n489                     try {\n490                         return createBigDecimal(numeric);\n491                     } catch (NumberFormatException e) {\n492                         // ignore the bad number\n493                     }\n494                     //Fall through\n495                 default :\n496                     throw new NumberFormatException(str + \" is not a valid number.\");\n497 \n498             }\n499         } else {\n500             //User doesn't have a preference on the return type, so let's start\n501             //small and go from there...\n502             if (expPos > -1 && expPos < str.length() - 1) {\n503                 exp = str.substring(expPos + 1, str.length());\n504             } else {\n505                 exp = null;\n506             }\n507             if (dec == null && exp == null) {\n508                 //Must be an int,long,bigint\n509                 try {\n510                     return createInteger(str);\n511                 } catch (NumberFormatException nfe) {\n512                     // ignore the bad number\n513                 }\n514                 try {\n515                     return createLong(str);\n516                 } catch (NumberFormatException nfe) {\n517                     // ignore the bad number\n518                 }\n519                 return createBigInteger(str);\n520 \n521             } else {\n522                 //Must be a float,double,BigDec\n523                 boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n524                 try {\n525                     Float f = createFloat(str);\n526                     if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n527                         return f;\n528                     }\n529                 } catch (NumberFormatException nfe) {\n530                     // ignore the bad number\n531                 }\n532                 try {\n533                     Double d = createDouble(str);\n534                     if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n535                         return d;\n536                     }\n537                 } catch (NumberFormatException nfe) {\n538                     // ignore the bad number\n539                 }\n540 \n541                 return createBigDecimal(str);\n542 \n543             }\n544         }\n545     }", "bm_classpath": "org.apache.commons.lang.math.NumberUtils"}, {"bug_name": "Lang_59", "report_text": "> Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException\n> \n> There's a bug in method appendFixedWidthPadRight of class StrBuilder:\n> public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {  \n>  if (width > 0) {  \n>  ensureCapacity(size + width);  \n>  String str = (obj == null ? getNullText() : obj.toString());  \n>  int strLen = str.length();  \n>  if (strLen >= width) \n> {\n>  ==> str.getChars(0, strLen, buffer, size); <==== BUG: it should be str.getChars(0, width, buffer, size);\n>  }\n>  else {  \n>  int padLen = width - strLen;  \n>  str.getChars(0, strLen, buffer, size);  \n>  for (int i = 0; i < padLen; i++) \n> {\n>  buffer[size + strLen + i] = padChar;\n>  }\n>  }  \n>  size += width;  \n>  }  \n>  return this;  \n>  }\n> This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen > width.\n> It's counterpart method appendFixedWidthPadLeft seems to be ok.", "test_name": "org.apache.commons.lang.text.StrBuilderAppendInsertTest::testLang299", "test_method": "    public void testLang299() {\n        StrBuilder sb = new StrBuilder(1);\n        sb.appendFixedWidthPadRight(\"foo\", 1, '-'); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException\n\tjava.lang.String.getChars(String.java:826)\n\torg.apache.commons.lang.text.StrBuilder.appendFixedWidthPadRight(StrBuilder.java:884)\n\torg.apache.commons.lang.text.StrBuilderAppendInsertTest.testLang299(StrBuilderAppendInsertTest.java:602)", "buggy_method": "878 public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n879         if (width > 0) {\n880             ensureCapacity(size + width);\n881             String str = (obj == null ? getNullText() : obj.toString());\n882             int strLen = str.length();\n883             if (strLen >= width) {\n884                 str.getChars(0, strLen, buffer, size);\n885             } else {\n886                 int padLen = width - strLen;\n887                 str.getChars(0, strLen, buffer, size);\n888                 for (int i = 0; i < padLen; i++) {\n889                     buffer[size + strLen + i] = padChar;\n890                 }\n891             }\n892             size += width;\n893         }\n894         return this;\n895     }", "bm_classpath": "org.apache.commons.lang.text.StrBuilder"}, {"bug_name": "Lang_60", "report_text": "> StrBuilder contains usages of thisBuf.length when they should use size\n> \n> While fixing [~~LANG-294~~](https://issues.apache.org/jira/browse/LANG-294 \"StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.\") I noticed that there are two other places in StrBuilder that reference thisBuf.length and unless I'm mistaken they shouldn't.", "test_name": "org.apache.commons.lang.text.StrBuilderTest::testLang295", "test_method": "    public void testLang295() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertFalse( \"The contains(char) method is looking beyond the end of the string\", sb.contains('h')); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: The contains(char) method is looking beyond the end of the string\n\torg.apache.commons.lang.text.StrBuilderTest.testLang295(StrBuilderTest.java:1748)", "buggy_method": "1671 public boolean contains(char ch) {\n1672         char[] thisBuf = buffer;\n1673         for (int i = 0; i < thisBuf.length; i++) {\n1674             if (thisBuf[i] == ch) {\n1675                 return true;\n1676             }\n1677         }\n1678         return false;\n1679     }", "bm_classpath": "org.apache.commons.lang.text.StrBuilder"}, {"bug_name": "Lang_61", "report_text": "> StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.\n> \n> StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException's. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem:\n> StrBuilder.deleteAll() - added to testDeleteAll\\_String():\n>  sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");  \n>  sb.deleteAll(\"\\n%BLAH%\");  \n>  assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString());\n> this causes the following error:  \n> java.lang.ArrayIndexOutOfBoundsException  \n>  at java.lang.System.arraycopy(Native Method)  \n>  at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114)  \n>  at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188)  \n>  at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll\\_String(StrBuilderTest.java:606)  \n>  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  \n>  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  \n>  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  \n>  at java.lang.reflect.Method.invoke(Method.java:585)  \n>  at junit.framework.TestCase.runTest(TestCase.java:154)  \n>  at junit.framework.TestCase.runBare(TestCase.java:127)  \n>  at junit.framework.TestResult$1.protect(TestResult.java:106)  \n>  at junit.framework.TestResult.runProtected(TestResult.java:124)  \n>  at junit.framework.TestResult.run(TestResult.java:109)  \n>  at junit.framework.TestCase.run(TestCase.java:118)  \n>  at junit.framework.TestSuite.runTest(TestSuite.java:208)  \n>  at junit.framework.TestSuite.run(TestSuite.java:203)  \n>  at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)  \n>  at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)\n> StrBuilder.replaceAll() - added to testReplaceAll\\_String\\_String():\n>  sb = new StrBuilder(\"\\n%BLAH%\\nDo more stuff\\neven more stuff\\n%BLAH%\\n\");  \n>  sb.replaceAll(\"\\n%BLAH%\", \"\");  \n>  assertEquals(\"\\nDo more stuff\\neven more stuff\\n\", sb.toString());\n> this causes the exception:\n> java.lang.ArrayIndexOutOfBoundsException  \n>  at java.lang.System.arraycopy(Native Method)  \n>  at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256)  \n>  at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339)  \n>  at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll\\_String\\_String(StrBuilderTest.java:763)  \n>  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  \n>  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)  \n>  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)  \n>  at java.lang.reflect.Method.invoke(Method.java:585)  \n>  at junit.framework.TestCase.runTest(TestCase.java:154)  \n>  at junit.framework.TestCase.runBare(TestCase.java:127)  \n>  at junit.framework.TestResult$1.protect(TestResult.java:106)  \n>  at junit.framework.TestResult.runProtected(TestResult.java:124)  \n>  at junit.framework.TestResult.run(TestResult.java:109)  \n>  at junit.framework.TestCase.run(TestCase.java:118)  \n>  at junit.framework.TestSuite.runTest(TestSuite.java:208)  \n>  at junit.framework.TestSuite.run(TestSuite.java:203)  \n>  at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)  \n>  at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)  \n>  at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)", "test_name": "org.apache.commons.lang.text.StrBuilderTest::testIndexOfLang294", "test_method": "    public void testIndexOfLang294() {\n        StrBuilder sb = new StrBuilder(\"onetwothree\");\n        sb.deleteFirst(\"three\");\n        assertEquals(-1, sb.indexOf(\"three\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-1> but was:<6>\n\torg.apache.commons.lang.text.StrBuilderTest.testIndexOfLang294(StrBuilderTest.java:1741)", "buggy_method": "1760 public int indexOf(String str, int startIndex) {\n1761         startIndex = (startIndex < 0 ? 0 : startIndex);\n1762         if (str == null || startIndex >= size) {\n1763             return -1;\n1764         }\n1765         int strLen = str.length();\n1766         if (strLen == 1) {\n1767             return indexOf(str.charAt(0), startIndex);\n1768         }\n1769         if (strLen == 0) {\n1770             return startIndex;\n1771         }\n1772         if (strLen > size) {\n1773             return -1;\n1774         }\n1775         char[] thisBuf = buffer;\n1776         int len = thisBuf.length - strLen;\n1777         outer:\n1778         for (int i = startIndex; i < len; i++) {\n1779             for (int j = 0; j < strLen; j++) {\n1780                 if (str.charAt(j) != thisBuf[i + j]) {\n1781                     continue outer;\n1782                 }\n1783             }\n1784             return i;\n1785         }\n1786         return -1;\n1787     }", "bm_classpath": "org.apache.commons.lang.text.StrBuilder"}, {"bug_name": "Lang_62", "report_text": "> unescapeXml(\"&12345678;\") should be \"&12345678;\"\n> \n> Following test (in EntitiesTest.java) fails:\n>  public void testNumberOverflow() throws Exception \n> {\n>  doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\");\n>  doTestUnescapeEntity(\"x&#12345678;y\", \"x&#12345678;y\");\n>  doTestUnescapeEntity(\"&#x12345678;\", \"&#x12345678;\");\n>  doTestUnescapeEntity(\"x&#x12345678;y\", \"x&#x12345678;y\");\n>  }\n> Maximim value for char is 0xFFFF, so &#12345678; is invalid entity reference, and so should be left as is.", "test_name": "org.apache.commons.lang.EntitiesTest::testNumberOverflow", "test_method": "    public void testNumberOverflow() throws Exception {\n        doTestUnescapeEntity(\"&#12345678;\", \"&#12345678;\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[&#12345678;]> but was:<[\u614e]>\n\torg.apache.commons.lang.EntitiesTest.doTestUnescapeEntity(EntitiesTest.java:101)\n\torg.apache.commons.lang.EntitiesTest.testNumberOverflow(EntitiesTest.java:201)", "buggy_method": "884 public void unescape(Writer writer, String string) throws IOException {\n885         int firstAmp = string.indexOf('&');\n886         if (firstAmp < 0) {\n887             writer.write(string);\n888             return;\n889         }\n890 \n891         writer.write(string, 0, firstAmp);\n892         int len = string.length();\n893         for (int i = firstAmp; i < len; i++) {\n894             char c = string.charAt(i);\n895             if (c == '&') {\n896                 int nextIdx = i+1;\n897                 int semiColonIdx = string.indexOf(';', nextIdx);\n898                 if (semiColonIdx == -1) {\n899                     writer.write(c);\n900                     continue;\n901                 }\n902                 int amphersandIdx = string.indexOf('&', i + 1);\n903                 if( amphersandIdx != -1 && amphersandIdx < semiColonIdx ) {\n904                     // Then the text looks like &...&...;\n905                     writer.write(c);\n906                     continue;\n907                 }\n908                 String entityContent = string.substring(nextIdx, semiColonIdx);\n909                 int entityValue = -1;\n910                 int entityContentLen = entityContent.length();\n911                 if (entityContentLen > 0) {\n912                     if (entityContent.charAt(0) == '#') { //escaped value content is an integer (decimal or hexidecimal)\n913                         if (entityContentLen > 1) {  \n914                             char isHexChar = entityContent.charAt(1);\n915                             try {\n916                                 switch (isHexChar) {\n917                                     case 'X' :\n918                                     case 'x' : {\n919                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n920                                     }\n921                                     default : {\n922                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n923                                     }\n924                                 }\n925                             } catch (NumberFormatException e) {\n926                             }\n927                         }\n928                     } else { //escaped value content is an entity name\n929                         entityValue = this.entityValue(entityContent);\n930                     }\n931                 }\n932                 \n933                 if (entityValue == -1) {\n934                     writer.write('&');\n935                     writer.write(entityContent);\n936                     writer.write(';');\n937                 } else {\n938                     writer.write(entityValue);\n939                 }\n940                 i = semiColonIdx; //move index up to the semi-colon                \n941             } else {\n942                 writer.write(c);\n943             }\n944         }\n945     }", "bm_classpath": "org.apache.commons.lang.Entities"}, {"bug_name": "Lang_63", "report_text": "> DurationFormatUtils returns wrong result\n> \n> DurationFormatUtils returns wrong result. oddly, it is only when Date is set to Dec 31, 2005\n> The following code will result in a String of -2 which is way off.\n> I've tested against 2.1 and 2.2.\n>  Calendar cal = Calendar.getInstance();  \n>  cal.set(Calendar.MONTH, Calendar.DECEMBER);  \n>  cal.set(Calendar.DAY\\_OF\\_MONTH, 31);  \n>  cal.set(Calendar.YEAR, 2005);  \n>  cal.set(Calendar.HOUR\\_OF\\_DAY, 0);  \n>  cal.set(Calendar.MINUTE, 0);  \n>  cal.set(Calendar.SECOND, 0);  \n>  cal.set(Calendar.MILLISECOND, 0);\n>  String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), \"MM\");  \n>  System.out.println(result);", "test_name": "org.apache.commons.lang.time.DurationFormatUtilsTest::testJiraLang281", "test_method": "    public void testJiraLang281() {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 31);\n        cal.set(Calendar.YEAR, 2005);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n\n        Calendar cal2 = Calendar.getInstance();\n        cal2.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal2.set(Calendar.DAY_OF_MONTH, 6);\n        cal2.set(Calendar.YEAR, 2006);\n        cal2.set(Calendar.HOUR_OF_DAY, 0);\n        cal2.set(Calendar.MINUTE, 0);\n        cal2.set(Calendar.SECOND, 0);\n        cal2.set(Calendar.MILLISECOND, 0);\n        String result = DurationFormatUtils.formatPeriod(cal.getTime().getTime(), cal2.getTime().getTime(), \"MM\");\n        assertEquals(\"09\", result); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[09]> but was:<[-2]>\n\torg.apache.commons.lang.time.DurationFormatUtilsTest.testJiraLang281(DurationFormatUtilsTest.java:436)", "buggy_method": "262 public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, \n263             TimeZone timezone) {\n264 \n265         long millis = endMillis - startMillis;\n266         if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n267             return formatDuration(millis, format, padWithZeros);\n268         }\n269 \n270         Token[] tokens = lexx(format);\n271 \n272         // timezones get funky around 0, so normalizing everything to GMT \n273         // stops the hours being off\n274         Calendar start = Calendar.getInstance(timezone);\n275         start.setTime(new Date(startMillis));\n276         Calendar end = Calendar.getInstance(timezone);\n277         end.setTime(new Date(endMillis));\n278 \n279         // initial estimates\n280         int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n281         int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n282         int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n283         int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n284         int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n285         int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n286         int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n287 \n288         // each initial estimate is adjusted in case it is under 0\n289         while (milliseconds < 0) {\n290             milliseconds += 1000;\n291             seconds -= 1;\n292         }\n293         while (seconds < 0) {\n294             seconds += 60;\n295             minutes -= 1;\n296         }\n297         while (minutes < 0) {\n298             minutes += 60;\n299             hours -= 1;\n300         }\n301         while (hours < 0) {\n302             hours += 24;\n303             days -= 1;\n304         }\n305         while (days < 0) {\n306             days += 31;\n307 //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n308 // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n309 // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n310 // Also it's contextual - if asked for no M in the format then I should probably \n311 // be doing no calculating here.\n312             months -= 1;\n313         }\n314         while (months < 0) {\n315             months += 12;\n316             years -= 1;\n317         }\n318         milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n319         seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n320         minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n321         hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n322         days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n323         months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n324         years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n325 \n326         // This next block of code adds in values that \n327         // aren't requested. This allows the user to ask for the \n328         // number of months and get the real count and not just 0->11.\n329         if (!Token.containsTokenWithValue(tokens, y)) {\n330             if (Token.containsTokenWithValue(tokens, M)) {\n331                 months += 12 * years;\n332                 years = 0;\n333             } else {\n334                 // TODO: this is a bit weak, needs work to know about leap years\n335                 days += 365 * years;\n336                 years = 0;\n337             }\n338         }\n339         if (!Token.containsTokenWithValue(tokens, M)) {\n340             days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n341             months = 0;\n342         }\n343         if (!Token.containsTokenWithValue(tokens, d)) {\n344             hours += 24 * days;\n345             days = 0;\n346         }\n347         if (!Token.containsTokenWithValue(tokens, H)) {\n348             minutes += 60 * hours;\n349             hours = 0;\n350         }\n351         if (!Token.containsTokenWithValue(tokens, m)) {\n352             seconds += 60 * minutes;\n353             minutes = 0;\n354         }\n355         if (!Token.containsTokenWithValue(tokens, s)) {\n356             milliseconds += 1000 * seconds;\n357             seconds = 0;\n358         }\n359 \n360         return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n361     }", "bm_classpath": "org.apache.commons.lang.time.DurationFormatUtils"}, {"bug_name": "Lang_64", "report_text": "> ValuedEnum.compareTo(Object other) not typesafe - it easily could be...\n> \n> int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)  \n>  is not typesafe - if the int-values are the same, it will return \"0\" even for two totally different sub-classes of ValuedEnum", "test_name": "org.apache.commons.lang.enums.ValuedEnumTest::testCompareTo_otherEnumType", "test_method": "    public void testCompareTo_otherEnumType() {\n        try {\n            ValuedColorEnum.BLUE.compareTo(ValuedLanguageEnum.ENGLISH);\n            fail();\n        } catch (ClassCastException ex) {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.lang.enums.ValuedEnumTest.testCompareTo_otherEnumType(ValuedEnumTest.java:108)", "buggy_method": "182 public int compareTo(Object other) {\n183         return iValue - ((ValuedEnum) other).iValue;\n184     }", "bm_classpath": "org.apache.commons.lang.enums.ValuedEnum"}, {"bug_name": "Lang_65", "report_text": "> [lang] DateUtils.truncate method is buggy when dealing with DST switching hours\n> \n> Try to truncate 2004-10-31 01:00:00 MDT by hour and you'll actually get 2004-10-  \n> 31 01:00:00 MST, which is one hour after the input hour.\n>  // truncate 2004-10-31 01:00:00 MDT  \n>  Date oct31\\_01MDT = new Date(1099206000000L);   \n>  Date result = DateUtils.truncate(oct31\\_01MDT, Calendar.HOUR\\_OF\\_DAY);  \n>  assertEquals(oct31\\_01MDT, result);", "test_name": "org.apache.commons.lang.time.DateUtilsTest::testTruncateLang59", "test_method": "    public void testTruncateLang59() throws Exception {\n\n        // Set TimeZone to Mountain Time\n        TimeZone MST_MDT = TimeZone.getTimeZone(\"MST7MDT\");\n        TimeZone.setDefault(MST_MDT);\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\");\n        format.setTimeZone(MST_MDT);\n\n        Date oct31_01MDT = new Date(1099206000000L); \n\n        Date oct31MDT             = new Date(oct31_01MDT.getTime()       - 3600000L); // - 1 hour\n        Date oct31_01_02MDT       = new Date(oct31_01MDT.getTime()       + 120000L);  // + 2 minutes\n        Date oct31_01_02_03MDT    = new Date(oct31_01_02MDT.getTime()    + 3000L);    // + 3 seconds\n        Date oct31_01_02_03_04MDT = new Date(oct31_01_02_03MDT.getTime() + 4L);       // + 4 milliseconds\n\n\n        // ------- Demonstrate Problem -------\n        Calendar gval = Calendar.getInstance();\n        gval.setTime(new Date(oct31_01MDT.getTime()));\n        gval.set(Calendar.MINUTE, gval.get(Calendar.MINUTE)); // set minutes to the same value\n\n        // ---------- Test Truncate ----------\n\n        assertEquals(\"Truncate Calendar.SECOND\",\n                   oct31_01_02_03MDT, DateUtils.truncate(oct31_01_02_03_04MDT, Calendar.SECOND)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Truncate Calendar.SECOND expected:<Sun Oct 31 01:02:03 MDT 2004> but was:<Sun Oct 31 01:02:03 MST 2004>\n\torg.apache.commons.lang.time.DateUtilsTest.testTruncateLang59(DateUtilsTest.java:927)", "buggy_method": "619 private static void modify(Calendar val, int field, boolean round) {\n620         if (val.get(Calendar.YEAR) > 280000000) {\n621             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n622         }\n623         \n624 \n625         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n626         // see http://issues.apache.org/jira/browse/LANG-59\n627         //\n628         // Manually truncate milliseconds, seconds and minutes, rather than using\n629         // Calendar methods.\n630 \n631 \n632         // truncate milliseconds\n633 \n634         // truncate seconds\n635 \n636         // truncate minutes\n637 \n638         // reset time\n639         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n640 \n641         boolean roundUp = false;\n642         for (int i = 0; i < fields.length; i++) {\n643             for (int j = 0; j < fields[i].length; j++) {\n644                 if (fields[i][j] == field) {\n645                     //This is our field... we stop looping\n646                     if (round && roundUp) {\n647                         if (field == DateUtils.SEMI_MONTH) {\n648                             //This is a special case that's hard to generalize\n649                             //If the date is 1, we round up to 16, otherwise\n650                             //  we subtract 15 days and add 1 month\n651                             if (val.get(Calendar.DATE) == 1) {\n652                                 val.add(Calendar.DATE, 15);\n653                             } else {\n654                                 val.add(Calendar.DATE, -15);\n655                                 val.add(Calendar.MONTH, 1);\n656                             }\n657                         } else {\n658                             //We need at add one to this field since the\n659                             //  last number causes us to round up\n660                             val.add(fields[i][0], 1);\n661                         }\n662                     }\n663                     return;\n664                 }\n665             }\n666             //We have various fields that are not easy roundings\n667             int offset = 0;\n668             boolean offsetSet = false;\n669             //These are special types of fields that require different rounding rules\n670             switch (field) {\n671                 case DateUtils.SEMI_MONTH:\n672                     if (fields[i][0] == Calendar.DATE) {\n673                         //If we're going to drop the DATE field's value,\n674                         //  we want to do this our own way.\n675                         //We need to subtrace 1 since the date has a minimum of 1\n676                         offset = val.get(Calendar.DATE) - 1;\n677                         //If we're above 15 days adjustment, that means we're in the\n678                         //  bottom half of the month and should stay accordingly.\n679                         if (offset >= 15) {\n680                             offset -= 15;\n681                         }\n682                         //Record whether we're in the top or bottom half of that range\n683                         roundUp = offset > 7;\n684                         offsetSet = true;\n685                     }\n686                     break;\n687                 case Calendar.AM_PM:\n688                     if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n689                         //If we're going to drop the HOUR field's value,\n690                         //  we want to do this our own way.\n691                         offset = val.get(Calendar.HOUR_OF_DAY);\n692                         if (offset >= 12) {\n693                             offset -= 12;\n694                         }\n695                         roundUp = offset > 6;\n696                         offsetSet = true;\n697                     }\n698                     break;\n699             }\n700             if (!offsetSet) {\n701                 int min = val.getActualMinimum(fields[i][0]);\n702                 int max = val.getActualMaximum(fields[i][0]);\n703                 //Calculate the offset from the minimum allowed value\n704                 offset = val.get(fields[i][0]) - min;\n705                 //Set roundUp if this is more than half way between the minimum and maximum\n706                 roundUp = offset > ((max - min) / 2);\n707             }\n708             //We need to remove this field\n709                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n710         }\n711         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n712 \n713     }", "bm_classpath": "org.apache.commons.lang.time.DateUtils"}, {"bug_name": "Math_1", "report_text": "> Fraction specified with maxDenominator and a value very close to a simple fraction should not throw an overflow exception\n> \n> An overflow exception is thrown when a Fraction is initialized with a maxDenominator from a double that is very close to a simple  \n> fraction. For example:\n> double d = 0.5000000001;  \n> Fraction f = new Fraction(d, 10);\n> Patch with unit test on way.", "test_name": "org.apache.commons.math3.fraction.BigFractionTest::testDigitLimitConstructor", "test_method": "    @Test\n    public void testDigitLimitConstructor() throws ConvergenceException {\n\n        \n        // MATH-996\n        assertFraction(1, 2, new BigFraction(0.5000000001, 10)); // <-- fails here\n    }", "error_message": "org.apache.commons.math3.fraction.FractionConversionException: illegal state: Overflow trying to convert 0.5 to fraction (2,499,999,794/4,999,999,587)\n\torg.apache.commons.math3.fraction.BigFraction.<init>(BigFraction.java:306)\n\torg.apache.commons.math3.fraction.BigFraction.<init>(BigFraction.java:356)\n\torg.apache.commons.math3.fraction.BigFractionTest.testDigitLimitConstructor(BigFractionTest.java:159)", "buggy_method": "269 private BigFraction(final double value, final double epsilon,\n270                         final int maxDenominator, int maxIterations)\n271         throws FractionConversionException {\n272         long overflow = Integer.MAX_VALUE;\n273         double r0 = value;\n274         long a0 = (long) FastMath.floor(r0);\n275         if (a0 > overflow) {\n276             throw new FractionConversionException(value, a0, 1l);\n277         }\n278 \n279         // check for (almost) integer arguments, which should not go\n280         // to iterations.\n281         if (FastMath.abs(a0 - value) < epsilon) {\n282             numerator = BigInteger.valueOf(a0);\n283             denominator = BigInteger.ONE;\n284             return;\n285         }\n286 \n287         long p0 = 1;\n288         long q0 = 0;\n289         long p1 = a0;\n290         long q1 = 1;\n291 \n292         long p2 = 0;\n293         long q2 = 1;\n294 \n295         int n = 0;\n296         boolean stop = false;\n297         do {\n298             ++n;\n299             final double r1 = 1.0 / (r0 - a0);\n300             final long a1 = (long) FastMath.floor(r1);\n301             p2 = (a1 * p1) + p0;\n302             q2 = (a1 * q1) + q0;\n303             if ((p2 > overflow) || (q2 > overflow)) {\n304                 // in maxDenominator mode, if the last fraction was very close to the actual value\n305                 // q2 may overflow in the next iteration; in this case return the last one.\n306                 throw new FractionConversionException(value, p2, q2);\n307             }\n308 \n309             final double convergent = (double) p2 / (double) q2;\n310             if ((n < maxIterations) &&\n311                 (FastMath.abs(convergent - value) > epsilon) &&\n312                 (q2 < maxDenominator)) {\n313                 p0 = p1;\n314                 p1 = p2;\n315                 q0 = q1;\n316                 q1 = q2;\n317                 a0 = a1;\n318                 r0 = r1;\n319             } else {\n320                 stop = true;\n321             }\n322         } while (!stop);\n323 \n324         if (n >= maxIterations) {\n325             throw new FractionConversionException(value, maxIterations);\n326         }\n327 \n328         if (q2 < maxDenominator) {\n329             numerator   = BigInteger.valueOf(p2);\n330             denominator = BigInteger.valueOf(q2);\n331         } else {\n332             numerator   = BigInteger.valueOf(p1);\n333             denominator = BigInteger.valueOf(q1);\n334         }\n335     }", "bm_classpath": "org.apache.commons.math3.fraction.BigFraction"}, {"bug_name": "Math_2", "report_text": "> HypergeometricDistribution.sample suffers from integer overflow\n> \n> Hi, I have an application which broke when ported from commons math 2.2 to 3.2. It looks like the HypergeometricDistribution.sample() method doesn't work as well as it used to with large integer values \u2013 the example code below should return a sample between 0 and 50, but usually returns -50.\n> ```\n> import org.apache.commons.math3.distribution.HypergeometricDistribution;\n> public class Foo {\n>   public static void main(String[] args) {\n>     HypergeometricDistribution a = new HypergeometricDistribution(\n>         43130568, 42976365, 50);\n>     System.out.printf(\"%d %d%n\", a.getSupportLowerBound(), a.getSupportUpperBound()); // Prints \"0 50\"\n>     System.out.printf(\"%d%n\",a.sample());                                             // Prints \"-50\"\n>   }\n> }\n> ```\n> In the debugger, I traced it as far as an integer overflow in HypergeometricDistribution.getNumericalMean() \u2013 instead of doing\n> ```\n> return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n> ```\n> it could do:\n> ```\n> return getSampleSize() * ((double) getNumberOfSuccesses() / (double) getPopulationSize());\n> ```\n> This seemed to fix it, based on a quick test.", "test_name": "org.apache.commons.math3.distribution.HypergeometricDistributionTest::testMath1021", "test_method": "    @Test\n    public void testMath1021() {\n        final int N = 43130568;\n        final int m = 42976365;\n        final int n = 50;\n        final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);\n\n        for (int i = 0; i < 100; i++) {\n            final int sample = dist.sample();\n            Assert.assertTrue(\"sample=\" + sample, 0 <= sample);\n            Assert.assertTrue(\"sample=\" + sample, sample <= n);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: sample=-50\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math3.distribution.HypergeometricDistributionTest.testMath1021(HypergeometricDistributionTest.java:297)", "buggy_method": "267 public double getNumericalMean() {\n268         return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n269     }", "bm_classpath": "org.apache.commons.math3.distribution.HypergeometricDistribution"}, {"bug_name": "Math_3", "report_text": "> ArrayIndexOutOfBoundsException in MathArrays.linearCombination\n> \n> When MathArrays.linearCombination is passed arguments with length 1, it throws an ArrayOutOfBoundsException. This is caused by this line:\n> double prodHighNext = prodHigh[1];\n> linearCombination should check the length of the arguments and fall back to simple multiplication if length == 1.", "test_name": "org.apache.commons.math3.util.MathArraysTest::testLinearCombinationWithSingleElementArray", "test_method": "    @Test\n    public void testLinearCombinationWithSingleElementArray() {\n        final double[] a = { 1.23456789 };\n        final double[] b = { 98765432.1 };\n\n        Assert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 1\n\torg.apache.commons.math3.util.MathArrays.linearCombination(MathArrays.java:846)\n\torg.apache.commons.math3.util.MathArraysTest.testLinearCombinationWithSingleElementArray(MathArraysTest.java:591)", "buggy_method": "814 public static double linearCombination(final double[] a, final double[] b)\n815         throws DimensionMismatchException {\n816         final int len = a.length;\n817         if (len != b.length) {\n818             throw new DimensionMismatchException(len, b.length);\n819         }\n820 \n821             // Revert to scalar multiplication.\n822 \n823         final double[] prodHigh = new double[len];\n824         double prodLowSum = 0;\n825 \n826         for (int i = 0; i < len; i++) {\n827             final double ai = a[i];\n828             final double ca = SPLIT_FACTOR * ai;\n829             final double aHigh = ca - (ca - ai);\n830             final double aLow = ai - aHigh;\n831 \n832             final double bi = b[i];\n833             final double cb = SPLIT_FACTOR * bi;\n834             final double bHigh = cb - (cb - bi);\n835             final double bLow = bi - bHigh;\n836             prodHigh[i] = ai * bi;\n837             final double prodLow = aLow * bLow - (((prodHigh[i] -\n838                                                     aHigh * bHigh) -\n839                                                    aLow * bHigh) -\n840                                                   aHigh * bLow);\n841             prodLowSum += prodLow;\n842         }\n843 \n844 \n845         final double prodHighCur = prodHigh[0];\n846         double prodHighNext = prodHigh[1];\n847         double sHighPrev = prodHighCur + prodHighNext;\n848         double sPrime = sHighPrev - prodHighNext;\n849         double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n850 \n851         final int lenMinusOne = len - 1;\n852         for (int i = 1; i < lenMinusOne; i++) {\n853             prodHighNext = prodHigh[i + 1];\n854             final double sHighCur = sHighPrev + prodHighNext;\n855             sPrime = sHighCur - prodHighNext;\n856             sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n857             sHighPrev = sHighCur;\n858         }\n859 \n860         double result = sHighPrev + (prodLowSum + sLowSum);\n861 \n862         if (Double.isNaN(result)) {\n863             // either we have split infinite numbers or some coefficients were NaNs,\n864             // just rely on the naive implementation and let IEEE754 handle this\n865             result = 0;\n866             for (int i = 0; i < len; ++i) {\n867                 result += a[i] * b[i];\n868             }\n869         }\n870 \n871         return result;\n872     }", "bm_classpath": "org.apache.commons.math3.util.MathArrays"}, {"bug_name": "Math_4", "report_text": "> NPE when calling SubLine.intersection() with non-intersecting lines\n> \n> When calling SubLine.intersection() with two lines that not intersect, then a NullPointerException is thrown in Line.toSubSpace(). This bug is in the twod and threed implementations.\n> The attached patch fixes both implementations and adds the required test cases.", "test_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest::testIntersectionNotIntersecting", "test_method": "    @Test\n    public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\n        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\n        SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\n        Assert.assertNull(sub1.intersection(sub2, true)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(Line.java:114)\n\torg.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(Line.java:129)\n\torg.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(SubLine.java:116)\n\torg.apache.commons.math3.geometry.euclidean.threed.SubLineTest.testIntersectionNotIntersecting(SubLineTest.java:160)", "buggy_method": "110 public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n111 \n112         // compute the intersection on infinite line\n113         Vector3D v1D = line.intersection(subLine.line);\n114 \n115         // check location of point with respect to first sub-line\n116         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n117 \n118         // check location of point with respect to second sub-line\n119         Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n120 \n121         if (includeEndPoints) {\n122             return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n123         } else {\n124             return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n125         }\n126 \n127     }", "bm_classpath": "org.apache.commons.math3.geometry.euclidean.threed.SubLine"}, {"bug_name": "Math_5", "report_text": "> Complex.ZERO.reciprocal() returns NaN but should return INF.\n> \n> Complex.ZERO.reciprocal() returns NaN but should return INF.\n> Class: org.apache.commons.math3.complex.Complex;  \n> Method: reciprocal()  \n> @version $Id: Complex.java 1416643 2012-12-03 19:37:14Z tn $", "test_name": "org.apache.commons.math3.complex.ComplexTest::testReciprocalZero", "test_method": "    @Test\n    public void testReciprocalZero() {\n        Assert.assertEquals(Complex.ZERO.reciprocal(), Complex.INF); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<(NaN, NaN)> but was:<(Infinity, Infinity)>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.math3.complex.ComplexTest.testReciprocalZero(ComplexTest.java:334)", "buggy_method": "299 public Complex reciprocal() {\n300         if (isNaN) {\n301             return NaN;\n302         }\n303 \n304         if (real == 0.0 && imaginary == 0.0) {\n305             return NaN;\n306         }\n307 \n308         if (isInfinite) {\n309             return ZERO;\n310         }\n311 \n312         if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n313             double q = real / imaginary;\n314             double scale = 1. / (real * q + imaginary);\n315             return createComplex(scale * q, -scale);\n316         } else {\n317             double q = imaginary / real;\n318             double scale = 1. / (imaginary * q + real);\n319             return createComplex(scale, -scale * q);\n320         }\n321     }", "bm_classpath": "org.apache.commons.math3.complex.Complex"}, {"bug_name": "Math_6", "report_text": "> LevenbergMarquardtOptimizer reports 0 iterations\n> \n> The method LevenbergMarquardtOptimizer.getIterations() does not report the correct number of iterations; It always returns 0. A quick look at the code shows that only SimplexOptimizer calls BaseOptimizer.incrementEvaluationsCount()\n> I've put a test case below. Notice how the evaluations count is correctly incremented, but the iterations count is not.\n> ```\n>     @Test\n>     public void testGetIterations() {\n>         // setup\n>         LevenbergMarquardtOptimizer otim = new LevenbergMarquardtOptimizer();\n>         // action\n>         otim.optimize(new MaxEval(100), new Target(new double[] { 1 }),\n>                 new Weight(new double[] { 1 }), new InitialGuess(\n>                         new double[] { 3 }), new ModelFunction(\n>                         new MultivariateVectorFunction() {\n>                             @Override\n>                             public double[] value(double[] point)\n>                                     throws IllegalArgumentException {\n>                                 return new double[] { FastMath.pow(point[0], 4) };\n>                             }\n>                         }), new ModelFunctionJacobian(\n>                         new MultivariateMatrixFunction() {\n>                             @Override\n>                             public double[][] value(double[] point)\n>                                     throws IllegalArgumentException {\n>                                 return new double[][] { { 0.25 * FastMath.pow(\n>                                         point[0], 3) } };\n>                             }\n>                         }));\n>         // verify\n>         assertThat(otim.getEvaluations(), greaterThan(1));\n>         assertThat(otim.getIterations(), greaterThan(1));\n>     }\n> ```", "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest::testTrivial", "test_method": "    @Test\n    public void testTrivial() {\n        LinearProblem problem\n            = new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n        NonLinearConjugateGradientOptimizer optimizer\n            = new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\n                                                      new SimpleValueChecker(1e-6, 1e-6));\n        PointValuePair optimum\n            = optimizer.optimize(new MaxEval(100),\n                                 problem.getObjectiveFunction(),\n                                 problem.getObjectiveFunctionGradient(),\n                                 GoalType.MINIMIZE,\n                                 new InitialGuess(new double[] { 0 }));\n\n        // Check that the number of iterations is updated (MATH-949).\n        Assert.assertTrue(optimizer.getIterations() > 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest.testTrivial(NonLinearConjugateGradientOptimizerTest.java:141)", "buggy_method": "47 protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n48         this.checker = checker;\n49 \n50         evaluations = new Incrementor(0, new MaxEvalCallback());\n51         iterations = new Incrementor(0, new MaxIterCallback());\n52     }", "bm_classpath": "org.apache.commons.math3.optim.BaseOptimizer"}, {"bug_name": "Math_7", "report_text": "> event state not updated if an unrelated event triggers a RESET_STATE during ODE integration\n> \n> When an ODE solver manages several different event types, there are some unwanted side effects.\n> If one event handler asks for a RESET\\_STATE (for integration state) when its eventOccurred method is called, the other event handlers that did not trigger an event in the same step are not updated correctly, due to an early return.\n> As a result, when the next step is processed with a reset integration state, the forgotten event still refer to the start date of the previous state. This implies that when these event handlers will be checked for In some cases, the function defining an event g(double t, double[] y) is called with state parameters y that are completely wrong. In one case when the y array should have contained values between -1 and +1, one function call got values up to 1.0e20.\n> The attached file reproduces the problem.", "test_name": "org.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest::testEventsScheduling", "test_method": "  @Test\n  public void testEventsScheduling() {\n\n      FirstOrderDifferentialEquations sincos = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return 2;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              yDot[0] =  y[1];\n              yDot[1] = -y[0];\n          }\n\n      };\n\n      SchedulingChecker sinChecker = new SchedulingChecker(0); // events at 0, PI, 2PI ...\n      SchedulingChecker cosChecker = new SchedulingChecker(1); // events at PI/2, 3PI/2, 5PI/2 ...\n\n      FirstOrderIntegrator integ =\n              new DormandPrince853Integrator(0.001, 1.0, 1.0e-12, 0.0);\n      integ.addEventHandler(sinChecker, 0.01, 1.0e-7, 100);\n      integ.addStepHandler(sinChecker);\n      integ.addEventHandler(cosChecker, 0.01, 1.0e-7, 100);\n      integ.addStepHandler(cosChecker);\n      double   t0 = 0.5;\n      double[] y0 = new double[] { FastMath.sin(t0), FastMath.cos(t0) };\n      double   t  = 10.0;\n      double[] y  = new double[2];\n      integ.integrate(sincos, t0, y0, t, y); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest$SchedulingChecker.g(DormandPrince853IntegratorTest.java:389)\n\torg.apache.commons.math3.ode.events.EventState.evaluateStep(EventState.java:224)\n\torg.apache.commons.math3.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:323)\n\torg.apache.commons.math3.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:303)\n\torg.apache.commons.math3.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:228)\n\torg.apache.commons.math3.ode.nonstiff.DormandPrince853IntegratorTest.testEventsScheduling(DormandPrince853IntegratorTest.java:365)", "buggy_method": "296 protected double acceptStep(final AbstractStepInterpolator interpolator,\n297                                 final double[] y, final double[] yDot, final double tEnd)\n298         throws MaxCountExceededException, DimensionMismatchException, NoBracketingException {\n299 \n300             double previousT = interpolator.getGlobalPreviousTime();\n301             final double currentT = interpolator.getGlobalCurrentTime();\n302 \n303             // initialize the events states if needed\n304             if (! statesInitialized) {\n305                 for (EventState state : eventsStates) {\n306                     state.reinitializeBegin(interpolator);\n307                 }\n308                 statesInitialized = true;\n309             }\n310 \n311             // search for next events that may occur during the step\n312             final int orderingSign = interpolator.isForward() ? +1 : -1;\n313             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n314 \n315                 /** {@inheritDoc} */\n316                 public int compare(EventState es0, EventState es1) {\n317                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n318                 }\n319 \n320             });\n321 \n322             for (final EventState state : eventsStates) {\n323                 if (state.evaluateStep(interpolator)) {\n324                     // the event occurs during the current step\n325                     occuringEvents.add(state);\n326                 }\n327             }\n328 \n329             while (!occuringEvents.isEmpty()) {\n330 \n331                 // handle the chronologically first event\n332                 final Iterator<EventState> iterator = occuringEvents.iterator();\n333                 final EventState currentEvent = iterator.next();\n334                 iterator.remove();\n335 \n336                 // restrict the interpolator to the first part of the step, up to the event\n337                 final double eventT = currentEvent.getEventTime();\n338                 interpolator.setSoftPreviousTime(previousT);\n339                 interpolator.setSoftCurrentTime(eventT);\n340 \n341                 // get state at event time\n342                 interpolator.setInterpolatedTime(eventT);\n343                 final double[] eventY = interpolator.getInterpolatedState().clone();\n344 \n345                 // advance all event states to current time\n346                 currentEvent.stepAccepted(eventT, eventY);\n347                 isLastStep = currentEvent.stop();\n348 \n349                 // handle the first part of the step, up to the event\n350                 for (final StepHandler handler : stepHandlers) {\n351                     handler.handleStep(interpolator, isLastStep);\n352                 }\n353 \n354                 if (isLastStep) {\n355                     // the event asked to stop integration\n356                     System.arraycopy(eventY, 0, y, 0, y.length);\n357                     for (final EventState remaining : occuringEvents) {\n358                         remaining.stepAccepted(eventT, eventY);\n359                     }\n360                     return eventT;\n361                 }\n362 \n363                 boolean needReset = currentEvent.reset(eventT, eventY);\n364                 if (needReset) {\n365                     // some event handler has triggered changes that\n366                     // invalidate the derivatives, we need to recompute them\n367                     System.arraycopy(eventY, 0, y, 0, y.length);\n368                     computeDerivatives(eventT, y, yDot);\n369                     resetOccurred = true;\n370                     for (final EventState remaining : occuringEvents) {\n371                         remaining.stepAccepted(eventT, eventY);\n372                     }\n373                     return eventT;\n374                 }\n375 \n376                 // prepare handling of the remaining part of the step\n377                 previousT = eventT;\n378                 interpolator.setSoftPreviousTime(eventT);\n379                 interpolator.setSoftCurrentTime(currentT);\n380 \n381                 // check if the same event occurs again in the remaining part of the step\n382                 if (currentEvent.evaluateStep(interpolator)) {\n383                     // the event occurs during the current step\n384                     occuringEvents.add(currentEvent);\n385                 }\n386 \n387             }\n388 \n389             // last part of the step, after the last event\n390             interpolator.setInterpolatedTime(currentT);\n391             final double[] currentY = interpolator.getInterpolatedState();\n392             for (final EventState state : eventsStates) {\n393                 state.stepAccepted(currentT, currentY);\n394                 isLastStep = isLastStep || state.stop();\n395             }\n396             isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n397 \n398             // handle the remaining part of the step, after all events if any\n399             for (StepHandler handler : stepHandlers) {\n400                 handler.handleStep(interpolator, isLastStep);\n401             }\n402 \n403             return currentT;\n404 \n405     }", "bm_classpath": "org.apache.commons.math3.ode.AbstractIntegrator"}, {"bug_name": "Math_8", "report_text": "> DiscreteDistribution.sample(int) may throw an exception if first element of singletons of sub-class type\n> \n> Creating an array with Array.newInstance(singletons.get(0).getClass(), sampleSize) in DiscreteDistribution.sample(int) is risky. An exception will be thrown if:\n> * singleons.get(0) is of type T1, an sub-class of T, and\n> * DiscreteDistribution.sample() returns an object which is of type T, but not of type T1.\n> To reproduce:\n> ```\n> List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();\n> list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));\n> list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));\n> new DiscreteDistribution<Object>(list).sample(1);\n> ```\n> Attaching a patch.", "test_name": "org.apache.commons.math3.distribution.DiscreteRealDistributionTest::testIssue942", "test_method": "    @Test\n    public void testIssue942() {\n        List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));\n        list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));\n        Assert.assertEquals(1, new DiscreteDistribution<Object>(list).sample(1).length); // <-- fails here\n    }", "error_message": "java.lang.ArrayStoreException: org.apache.commons.math3.distribution.DiscreteRealDistributionTest$2\n\torg.apache.commons.math3.distribution.DiscreteDistribution.sample(DiscreteDistribution.java:190)\n\torg.apache.commons.math3.distribution.DiscreteRealDistributionTest.testIssue942(DiscreteRealDistributionTest.java:212)", "buggy_method": "181 public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n182         if (sampleSize <= 0) {\n183             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n184                     sampleSize);\n185         }\n186 \n187         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n188 \n189         for (int i = 0; i < sampleSize; i++) {\n190             out[i] = sample();\n191         }\n192 \n193         return out;\n194 \n195     }", "bm_classpath": "org.apache.commons.math3.distribution.DiscreteDistribution"}, {"bug_name": "Math_9", "report_text": "> Line.revert() is imprecise\n> \n> Line.revert() only maintains ~10 digits for the direction. This becomes an issue when the line's position is evaluated far from the origin. A simple fix would be to use Vector3D.negate() for the direction.\n> Also, is there a reason why Line is not immutable? It is just comprised of two vectors.", "test_name": "org.apache.commons.math3.geometry.euclidean.threed.LineTest::testRevert", "test_method": "    @Test\n    public void testRevert() {\n        \n        // setup\n        Line line = new Line(new Vector3D(1653345.6696423641, 6170370.041579291, 90000),\n                             new Vector3D(1650757.5050732433, 6160710.879908984, 0.9));\n        Vector3D expected = line.getDirection().negate();\n\n        // action\n        Line reverted = line.revert();\n\n        // verify\n        Assert.assertArrayEquals(expected.toArray(), reverted.getDirection().toArray(), 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0.028581782127907646> but was:<0.028581782243293483>\n\torg.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\n\torg.junit.Assert.assertArrayEquals(Assert.java:419)\n\torg.junit.Assert.assertArrayEquals(Assert.java:430)\n\torg.apache.commons.math3.geometry.euclidean.threed.LineTest.testRevert(LineTest.java:144)", "buggy_method": "86 public Line revert() {\n87         final Line reverted = new Line(zero, zero.subtract(direction));\n88         return reverted;\n89     }", "bm_classpath": "org.apache.commons.math3.geometry.euclidean.threed.Line"}, {"bug_name": "Math_10", "report_text": "> DerivativeStructure.atan2(y,x) does not handle special cases properly\n> \n> The four special cases +/-0 for both x and y should give the same values as Math.atan2 and FastMath.atan2. However, they give NaN for the value in all cases.", "test_name": "org.apache.commons.math3.analysis.differentiation.DerivativeStructureTest::testAtan2SpecialCases", "test_method": "    @Test\n    public void testAtan2SpecialCases() {\n\n        DerivativeStructure pp =\n                DerivativeStructure.atan2(new DerivativeStructure(2, 2, 1, +0.0),\n                                          new DerivativeStructure(2, 2, 1, +0.0));\n        Assert.assertEquals(0, pp.getValue(), 1.0e-15); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<NaN>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.analysis.differentiation.DerivativeStructureTest.testAtan2SpecialCases(DerivativeStructureTest.java:816)", "buggy_method": "1382 public void atan2(final double[] y, final int yOffset,\n1383                       final double[] x, final int xOffset,\n1384                       final double[] result, final int resultOffset) {\n1385 \n1386         // compute r = sqrt(x^2+y^2)\n1387         double[] tmp1 = new double[getSize()];\n1388         multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n1389         double[] tmp2 = new double[getSize()];\n1390         multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n1391         add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n1392         rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n1393 \n1394         if (x[xOffset] >= 0) {\n1395 \n1396             // compute atan2(y, x) = 2 atan(y / (r + x))\n1397             add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n1398             divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n1399             atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n1400             for (int i = 0; i < tmp2.length; ++i) {\n1401                 result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n1402             }\n1403 \n1404         } else {\n1405 \n1406             // compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n1407             subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n1408             divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n1409             atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n1410             result[resultOffset] =\n1411                     ((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n1412             for (int i = 1; i < tmp2.length; ++i) {\n1413                 result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n1414             }\n1415 \n1416         }\n1417 \n1418         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n1419 \n1420     }", "bm_classpath": "org.apache.commons.math3.analysis.differentiation.DSCompiler"}, {"bug_name": "Math_11", "report_text": "> MultivariateNormalDistribution.density(double[]) returns wrong value when the dimension is odd\n> \n> To reproduce:\n> ```\n> Assert.assertEquals(0.398942280401433, new MultivariateNormalDistribution(new double[]{0}, new double[][]{{1}}).density(new double[]{0}), 1e-15);\n> ```", "test_name": "org.apache.commons.math3.distribution.MultivariateNormalDistributionTest::testUnivariateDistribution", "test_method": "    @Test\n    public void testUnivariateDistribution() {\n        final double[] mu = { -1.5 };\n        final double[][] sigma = { { 1 } };\n \n        final MultivariateNormalDistribution multi = new MultivariateNormalDistribution(mu, sigma);\n\n        final NormalDistribution uni = new NormalDistribution(mu[0], sigma[0][0]);\n        final Random rng = new Random();\n        final int numCases = 100;\n        final double tol = Math.ulp(1d);\n        for (int i = 0; i < numCases; i++) {\n            final double v = rng.nextDouble() * 10 - 5;\n            Assert.assertEquals(uni.density(v), multi.density(new double[] { v }), tol);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.34456358187863456> but was:<0.8636928167451191>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.distribution.MultivariateNormalDistributionTest.testUnivariateDistribution(MultivariateNormalDistributionTest.java:151)", "buggy_method": "177 public double density(final double[] vals) throws DimensionMismatchException {\n178         final int dim = getDimension();\n179         if (vals.length != dim) {\n180             throw new DimensionMismatchException(vals.length, dim);\n181         }\n182 \n183         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n184             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n185             getExponentTerm(vals);\n186     }", "bm_classpath": "org.apache.commons.math3.distribution.MultivariateNormalDistribution"}, {"bug_name": "Math_13", "report_text": "> new multivariate vector optimizers cannot be used with large number of weights\n> \n> When using the Weigth class to pass a large number of weights to multivariate vector optimizers, an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large.\n> This happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points, which created a matrix with 1.7 billion elements.", "test_name": "org.apache.commons.math3.optimization.fitting.PolynomialFitterTest::testLargeSample", "test_method": "    @Test\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        } // <-- fails here\n    }", "error_message": "java.lang.OutOfMemoryError: Java heap space\n\torg.apache.commons.math3.linear.DiagonalMatrix.getData(DiagonalMatrix.java:204)\n\torg.apache.commons.math3.linear.TriDiagonalTransformer.<init>(TriDiagonalTransformer.java:69)\n\torg.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(EigenDecomposition.java:561)\n\torg.apache.commons.math3.linear.EigenDecomposition.<init>(EigenDecomposition.java:122)\n\torg.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.squareRoot(AbstractLeastSquaresOptimizer.java:562)\n\torg.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.setUp(AbstractLeastSquaresOptimizer.java:508)\n\torg.apache.commons.math3.optimization.direct.BaseAbstractMultivariateVectorOptimizer.optimizeInternal(BaseAbstractMultivariateVectorOptimizer.java:239)\n\torg.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.optimizeInternal(AbstractLeastSquaresOptimizer.java:496)\n\torg.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:423)\n\torg.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:62)\n\torg.apache.commons.math3.optimization.fitting.CurveFitter.fit(CurveFitter.java:189)\n\torg.apache.commons.math3.optimization.fitting.CurveFitter.fit(CurveFitter.java:153)\n\torg.apache.commons.math3.optimization.fitting.PolynomialFitter.fit(PolynomialFitter.java:110)\n\torg.apache.commons.math3.optimization.fitting.PolynomialFitterTest.testLargeSample(PolynomialFitterTest.java:241)", "buggy_method": "561 private RealMatrix squareRoot(RealMatrix m) {\n562             final EigenDecomposition dec = new EigenDecomposition(m);\n563             return dec.getSquareRoot();\n564     }", "bm_classpath": "org.apache.commons.math3.optimization.general.AbstractLeastSquaresOptimizer"}, {"bug_name": "Math_14", "report_text": "> new multivariate vector optimizers cannot be used with large number of weights\n> \n> When using the Weigth class to pass a large number of weights to multivariate vector optimizers, an nxn full matrix is created (and copied) when a n elements vector is used. This exhausts memory when n is large.\n> This happens for example when using curve fitters (even simple curve fitters like polynomial ones for low degree) with large number of points. I encountered this with curve fitting on 41200 points, which created a matrix with 1.7 billion elements.", "test_name": "org.apache.commons.math3.fitting.PolynomialFitterTest::testLargeSample", "test_method": "    @Test\n    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        } // <-- fails here\n    }", "error_message": "java.lang.OutOfMemoryError: Java heap space\n\torg.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(BlockRealMatrix.java:271)\n\torg.apache.commons.math3.linear.BlockRealMatrix.<init>(BlockRealMatrix.java:107)\n\torg.apache.commons.math3.linear.MatrixUtils.createRealMatrix(MatrixUtils.java:81)\n\torg.apache.commons.math3.optim.nonlinear.vector.Weight.<init>(Weight.java:43)\n\torg.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:172)\n\torg.apache.commons.math3.fitting.CurveFitter.fit(CurveFitter.java:136)\n\torg.apache.commons.math3.fitting.PolynomialFitter.fit(PolynomialFitter.java:68)\n\torg.apache.commons.math3.fitting.PolynomialFitterTest.testLargeSample(PolynomialFitterTest.java:238)", "buggy_method": "41 public Weight(double[] weight) {\n42         final int dim = weight.length;\n43         weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n44         for (int i = 0; i < dim; i++) {\n45             weightMatrix.setEntry(i, i, weight[i]);\n46         }\n47     }", "bm_classpath": "org.apache.commons.math3.optim.nonlinear.vector.Weight"}, {"bug_name": "Math_15", "report_text": "> FastMath.pow deviates from Math.pow for negative, finite base values with an exponent 2^52 < y < 2^53\n> \n> As reported by Jeff Hain:\n> pow(double,double):  \n> Math.pow(-1.0,5.000000000000001E15) = -1.0  \n> FastMath.pow(-1.0,5.000000000000001E15) = 1.0  \n> ===> This is due to considering that power is an even  \n> integer if it is >= 2^52, while you need to test  \n> that it is >= 2^53 for it.  \n> ===> replace  \n> \"if (y >= TWO\\_POWER\\_52 || y <= -TWO\\_POWER\\_52)\"  \n> with  \n> \"if (y >= 2\\*TWO\\_POWER\\_52 || y <= -2\\*TWO\\_POWER\\_52)\"  \n> and that solves it.", "test_name": "org.apache.commons.math3.util.FastMathTest::testMath904", "test_method": "    @Test\n    public void testMath904() {\n        final double x = -1;\n        final double y = (5 + 1e-15) * 1e15;\n        Assert.assertEquals(Math.pow(x, y),\n                            FastMath.pow(x, y), 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-1.0> but was:<1.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.util.FastMathTest.testMath904(FastMathTest.java:164)", "buggy_method": "1441 public static double pow(double x, double y) {\n1442         final double lns[] = new double[2];\n1443 \n1444         if (y == 0.0) {\n1445             return 1.0;\n1446         }\n1447 \n1448         if (x != x) { // X is NaN\n1449             return x;\n1450         }\n1451 \n1452 \n1453         if (x == 0) {\n1454             long bits = Double.doubleToLongBits(x);\n1455             if ((bits & 0x8000000000000000L) != 0) {\n1456                 // -zero\n1457                 long yi = (long) y;\n1458 \n1459                 if (y < 0 && y == yi && (yi & 1) == 1) {\n1460                     return Double.NEGATIVE_INFINITY;\n1461                 }\n1462 \n1463                 if (y > 0 && y == yi && (yi & 1) == 1) {\n1464                     return -0.0;\n1465                 }\n1466             }\n1467 \n1468             if (y < 0) {\n1469                 return Double.POSITIVE_INFINITY;\n1470             }\n1471             if (y > 0) {\n1472                 return 0.0;\n1473             }\n1474 \n1475             return Double.NaN;\n1476         }\n1477 \n1478         if (x == Double.POSITIVE_INFINITY) {\n1479             if (y != y) { // y is NaN\n1480                 return y;\n1481             }\n1482             if (y < 0.0) {\n1483                 return 0.0;\n1484             } else {\n1485                 return Double.POSITIVE_INFINITY;\n1486             }\n1487         }\n1488 \n1489         if (y == Double.POSITIVE_INFINITY) {\n1490             if (x * x == 1.0) {\n1491                 return Double.NaN;\n1492             }\n1493 \n1494             if (x * x > 1.0) {\n1495                 return Double.POSITIVE_INFINITY;\n1496             } else {\n1497                 return 0.0;\n1498             }\n1499         }\n1500 \n1501         if (x == Double.NEGATIVE_INFINITY) {\n1502             if (y != y) { // y is NaN\n1503                 return y;\n1504             }\n1505 \n1506             if (y < 0) {\n1507                 long yi = (long) y;\n1508                 if (y == yi && (yi & 1) == 1) {\n1509                     return -0.0;\n1510                 }\n1511 \n1512                 return 0.0;\n1513             }\n1514 \n1515             if (y > 0)  {\n1516                 long yi = (long) y;\n1517                 if (y == yi && (yi & 1) == 1) {\n1518                     return Double.NEGATIVE_INFINITY;\n1519                 }\n1520 \n1521                 return Double.POSITIVE_INFINITY;\n1522             }\n1523         }\n1524 \n1525         if (y == Double.NEGATIVE_INFINITY) {\n1526 \n1527             if (x * x == 1.0) {\n1528                 return Double.NaN;\n1529             }\n1530 \n1531             if (x * x < 1.0) {\n1532                 return Double.POSITIVE_INFINITY;\n1533             } else {\n1534                 return 0.0;\n1535             }\n1536         }\n1537 \n1538         /* Handle special case x<0 */\n1539         if (x < 0) {\n1540             // y is an even integer in this case\n1541             if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n1542                 return pow(-x, y);\n1543             }\n1544 \n1545             if (y == (long) y) {\n1546                 // If y is an integer\n1547                 return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n1548             } else {\n1549                 return Double.NaN;\n1550             }\n1551         }\n1552 \n1553         /* Split y into ya and yb such that y = ya+yb */\n1554         double ya;\n1555         double yb;\n1556         if (y < 8e298 && y > -8e298) {\n1557             double tmp1 = y * HEX_40000000;\n1558             ya = y + tmp1 - tmp1;\n1559             yb = y - ya;\n1560         } else {\n1561             double tmp1 = y * 9.31322574615478515625E-10;\n1562             double tmp2 = tmp1 * 9.31322574615478515625E-10;\n1563             ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n1564             yb = y - ya;\n1565         }\n1566 \n1567         /* Compute ln(x) */\n1568         final double lores = log(x, lns);\n1569         if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n1570             return lores;\n1571         }\n1572 \n1573         double lna = lns[0];\n1574         double lnb = lns[1];\n1575 \n1576         /* resplit lns */\n1577         double tmp1 = lna * HEX_40000000;\n1578         double tmp2 = lna + tmp1 - tmp1;\n1579         lnb += lna - tmp2;\n1580         lna = tmp2;\n1581 \n1582         // y*ln(x) = (aa+ab)\n1583         final double aa = lna * ya;\n1584         final double ab = lna * yb + lnb * ya + lnb * yb;\n1585 \n1586         lna = aa+ab;\n1587         lnb = -(lna - aa - ab);\n1588 \n1589         double z = 1.0 / 120.0;\n1590         z = z * lnb + (1.0 / 24.0);\n1591         z = z * lnb + (1.0 / 6.0);\n1592         z = z * lnb + 0.5;\n1593         z = z * lnb + 1.0;\n1594         z = z * lnb;\n1595 \n1596         final double result = exp(lna, z, null);\n1597         //result = result + result * z;\n1598         return result;\n1599     }", "bm_classpath": "org.apache.commons.math3.util.FastMath"}, {"bug_name": "Math_16", "report_text": "> FastMath.[cosh, sinh] do not support the same range of values as the Math counterparts\n> \n> As reported by Jeff Hain:\n> cosh(double) and sinh(double):  \n> Math.cosh(709.783) = 8.991046692770538E307  \n> FastMath.cosh(709.783) = Infinity  \n> Math.sinh(709.783) = 8.991046692770538E307  \n> FastMath.sinh(709.783) = Infinity  \n> ===> This is due to using exp( x )/2 for values of |x|  \n> above 20: the result sometimes should not overflow,  \n> but exp( x ) does, so we end up with some infinity.  \n> ===> for values of |x| >= StrictMath.log(Double.MAX\\_VALUE),  \n> exp will overflow, so you need to use that instead:  \n> for x positive:  \n> double t = exp(x\\*0.5);  \n> return (0.5\\*t)\\*t;  \n> for x negative:  \n> double t = exp(-x\\*0.5);  \n> return (-0.5\\*t)\\*t;", "test_name": "org.apache.commons.math3.util.FastMathTest::testMath905LargePositive", "test_method": "    @Test\n    public void testMath905LargePositive() {\n        final double start = StrictMath.log(Double.MAX_VALUE);\n        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n        final double end = 2 * StrictMath.log(endT);\n\n        double maxErr = 0;\n        for (double x = start; x < end; x += 1e-3) {\n            final double tst = FastMath.cosh(x);\n            final double ref = Math.cosh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<Infinity>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.util.FastMathTest.testMath905LargePositive(FastMathTest.java:172)", "buggy_method": "383 public static double cosh(double x) {\n384       if (x != x) {\n385           return x;\n386       }\n387 \n388       // cosh[z] = (exp(z) + exp(-z))/2\n389 \n390       // for numbers with magnitude 20 or so,\n391       // exp(-z) can be ignored in comparison with exp(z)\n392 \n393       if (x > 20) {\n394               // Avoid overflow (MATH-905).\n395               return 0.5 * exp(x);\n396           }\n397       if (x < -20) {\n398               // Avoid overflow (MATH-905).\n399               return 0.5 * exp(-x);\n400       }\n401 \n402       final double hiPrec[] = new double[2];\n403       if (x < 0.0) {\n404           x = -x;\n405       }\n406       exp(x, 0.0, hiPrec);\n407 \n408       double ya = hiPrec[0] + hiPrec[1];\n409       double yb = -(ya - hiPrec[0] - hiPrec[1]);\n410 \n411       double temp = ya * HEX_40000000;\n412       double yaa = ya + temp - temp;\n413       double yab = ya - yaa;\n414 \n415       // recip = 1/y\n416       double recip = 1.0/ya;\n417       temp = recip * HEX_40000000;\n418       double recipa = recip + temp - temp;\n419       double recipb = recip - recipa;\n420 \n421       // Correct for rounding in division\n422       recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n423       // Account for yb\n424       recipb += -yb * recip * recip;\n425 \n426       // y = y + 1/y\n427       temp = ya + recipa;\n428       yb += -(temp - ya - recipa);\n429       ya = temp;\n430       temp = ya + recipb;\n431       yb += -(temp - ya - recipb);\n432       ya = temp;\n433 \n434       double result = ya + yb;\n435       result *= 0.5;\n436       return result;\n437     }", "bm_classpath": "org.apache.commons.math3.util.FastMath"}, {"bug_name": "Math_17", "report_text": "> Dfp Dfp.multiply(int x) does not comply with the general contract FieldElement.multiply(int n)\n> \n> In class org.apache.commons.math3.Dfp, the method multiply(int n) is limited to 0 <= n <= 9999. This is not consistent with the general contract of FieldElement.multiply(int n), where there should be no limitation on the values of n.", "test_name": "org.apache.commons.math3.dfp.DfpTest::testMultiply", "test_method": "    @Test\n    public void testMultiply()\n    {\n        test(field.newDfp(\"1\").multiply(field.newDfp(\"1\")),      // Basic tests   1*1 = 1\n             field.newDfp(\"1\"),\n             0, \"Multiply #1\");\n\n        test(field.newDfp(\"1\").multiply(1),             // Basic tests   1*1 = 1\n             field.newDfp(\"1\"),\n             0, \"Multiply #2\");\n\n        test(field.newDfp(\"-1\").multiply(field.newDfp(\"1\")),     // Basic tests   -1*1 = -1\n             field.newDfp(\"-1\"),\n             0, \"Multiply #3\");\n\n        test(field.newDfp(\"-1\").multiply(1),            // Basic tests   -1*1 = -1\n             field.newDfp(\"-1\"),\n             0, \"Multiply #4\");\n\n        // basic tests with integers\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"3\")),\n             field.newDfp(\"6\"),\n             0, \"Multiply #5\");\n\n        test(field.newDfp(\"2\").multiply(3),\n             field.newDfp(\"6\"),\n             0, \"Multiply #6\");\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"3\")),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #7\");\n\n        test(field.newDfp(\"-2\").multiply(3),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #8\");\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"-3\")),\n             field.newDfp(\"-6\"),\n             0, \"Multiply #9\");\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"-3\")),\n             field.newDfp(\"6\"),\n             0, \"Multiply #10\");\n\n        //multiply by zero\n\n        test(field.newDfp(\"-2\").multiply(field.newDfp(\"0\")),\n             field.newDfp(\"-0\"),\n             0, \"Multiply #11\");\n\n        test(field.newDfp(\"-2\").multiply(0),\n             field.newDfp(\"-0\"),\n             0, \"Multiply #12\");\n\n        test(field.newDfp(\"2\").multiply(field.newDfp(\"0\")),\n             field.newDfp(\"0\"),\n             0, \"Multiply #13\");\n\n        test(field.newDfp(\"2\").multiply(0),\n             field.newDfp(\"0\"),\n             0, \"Multiply #14\");\n\n        test(field.newDfp(\"2\").multiply(pinf),\n             pinf,\n             0, \"Multiply #15\");\n\n        test(field.newDfp(\"2\").multiply(ninf),\n             ninf,\n             0, \"Multiply #16\");\n\n        test(field.newDfp(\"-2\").multiply(pinf),\n             ninf,\n             0, \"Multiply #17\");\n\n        test(field.newDfp(\"-2\").multiply(ninf),\n             pinf,\n             0, \"Multiply #18\");\n\n        test(ninf.multiply(field.newDfp(\"-2\")),\n             pinf,\n             0, \"Multiply #18.1\");\n\n        test(field.newDfp(\"5e131071\").multiply(2),\n             pinf,\n             DfpField.FLAG_OVERFLOW, \"Multiply #19\");\n\n        test(field.newDfp(\"5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n             field.newDfp(\"9.9999999999999950000e131071\"),\n             0, \"Multiply #20\");\n\n        test(field.newDfp(\"-5e131071\").multiply(2),\n             ninf,\n             DfpField.FLAG_OVERFLOW, \"Multiply #22\");\n\n        test(field.newDfp(\"-5e131071\").multiply(field.newDfp(\"1.999999999999999\")),\n             field.newDfp(\"-9.9999999999999950000e131071\"),\n             0, \"Multiply #23\");\n\n        test(field.newDfp(\"1e-65539\").multiply(field.newDfp(\"1e-65539\")),\n             field.newDfp(\"1e-131078\"),\n             DfpField.FLAG_UNDERFLOW, \"Multiply #24\");\n\n        test(field.newDfp(\"1\").multiply(nan),\n             nan,\n             0, \"Multiply #25\");\n\n        test(nan.multiply(field.newDfp(\"1\")),\n             nan,\n             0, \"Multiply #26\");\n\n        test(nan.multiply(pinf),\n             nan,\n             0, \"Multiply #27\");\n\n        test(pinf.multiply(nan),\n             nan,\n             0, \"Multiply #27\");\n\n        test(pinf.multiply(field.newDfp(\"0\")),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #28\");\n\n        test(field.newDfp(\"0\").multiply(pinf),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #29\");\n\n        test(pinf.multiply(pinf),\n             pinf,\n             0, \"Multiply #30\");\n\n        test(ninf.multiply(pinf),\n             ninf,\n             0, \"Multiply #31\");\n\n        test(pinf.multiply(ninf),\n             ninf,\n             0, \"Multiply #32\");\n\n        test(ninf.multiply(ninf),\n             pinf,\n             0, \"Multiply #33\");\n\n        test(pinf.multiply(1),\n             pinf,\n             0, \"Multiply #34\");\n\n        test(pinf.multiply(0),\n             nan,\n             DfpField.FLAG_INVALID, \"Multiply #35\");\n\n        test(nan.multiply(1),\n             nan,\n             0, \"Multiply #36\");\n\n        test(field.newDfp(\"1\").multiply(10000),\n             field.newDfp(\"10000\"),\n             0, \"Multiply #37\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: assersion failed Multiply #37 x = NaN flags = 1\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math3.dfp.DfpTest.test(DfpTest.java:74)\n\torg.apache.commons.math3.dfp.DfpTest.testMultiply(DfpTest.java:909)", "buggy_method": "1602 public Dfp multiply(final int x) {\n1603             return multiplyFast(x);\n1604     }", "bm_classpath": "org.apache.commons.math3.dfp.Dfp"}, {"bug_name": "Math_18", "report_text": "> CMAESOptimizer with bounds fits finely near lower bound and coarsely near upper bound.\n> \n> When fitting with bounds, the CMAESOptimizer fits finely near the lower bound and coarsely near the upper bound. This is because it internally maps the fitted parameter range into the interval [0,1]. The unit of least precision (ulp) between floating point numbers is much smaller near zero than near one. Thus, fits have much better resolution near the lower bound (which is mapped to zero) than the upper bound (which is mapped to one). I will attach a example program to demonstrate.", "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest::testFitAccuracyDependsOnBoundary", "test_method": "public void testFitAccuracyDependsOnBoundary() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                public double value(double[] parameters) {\n                    final double target = 11.1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 1 };\n \n        // No bounds.\n        PointValuePair result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start);\n        final double resNoBound = result.getPoint()[0];\n\n        // Optimum is near the lower bound.\n        final double[] lower = { -20 };\n        final double[] upper = { 5e16 };\n        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                    start, lower, upper);\n        final double resNearLo = result.getPoint()[0];\n\n        // Optimum is near the upper bound.\n        lower[0] = -5e16;\n        upper[0] = 20;\n        result = optimizer.optimize(100000, fitnessFunction, GoalType.MINIMIZE,\n                                    start, lower, upper);\n        final double resNearHi = result.getPoint()[0];\n\n        // System.out.println(\"resNoBound=\" + resNoBound +\n        //                    \" resNearLo=\" + resNearLo +\n        //                    \" resNearHi=\" + resNearHi);\n\n        // The two values currently differ by a substantial amount, indicating that\n        // the bounds definition can prevent reaching the optimum.\n        Assert.assertEquals(resNoBound, resNearLo, 1e-3);\n        Assert.assertEquals(resNoBound, resNearHi, 1e-3);\n    }\n \n    /**\n     * @param func Function to optimize.\n     * @param startPoint Starting point.\n     * @param inSigma Individual input sigma.\n     * @param boundaries Upper / lower point limit.\n     * @param goal Minimization or maximization.\n     * @param lambda Population size used for offspring.\n     * @param isActive Covariance update mechanism.\n     * @param diagonalOnly Simplified covariance update.\n     * @param stopValue Termination criteria for optimization.\n     * @param fTol Tolerance relative error on the objective function.\n     * @param pointTol Tolerance for checking that the optimum is correct.\n     * @param maxEvaluations Maximum number of evaluations.\n     * @param expected Expected point / value.\n     */", "error_message": "junit.framework.AssertionFailedError: expected:<11.100000000847896> but was:<8.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testFitAccuracyDependsOnBoundary(CMAESOptimizerTest.java:477)", "buggy_method": "925 public double[] encode(final double[] x) {\n926             if (boundaries == null) {\n927                 return x;\n928             }\n929             double[] res = new double[x.length];\n930             for (int i = 0; i < x.length; i++) {\n931                 double diff = boundaries[1][i] - boundaries[0][i];\n932                 res[i] = (x[i] - boundaries[0][i]) / diff;\n933             }\n934             return res;\n935         }", "bm_classpath": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction"}, {"bug_name": "Math_19", "report_text": "> Wide bounds to CMAESOptimizer result in NaN parameters passed to fitness function\n> \n> If you give large values as lower/upper bounds (for example -Double.MAX\\_VALUE as a lower bound), the optimizer can call the fitness function with parameters set to NaN. My guess is this is due to FitnessFunction.encode/decode generating NaN when normalizing/denormalizing parameters. For example, if the difference between the lower and upper bound is greater than Double.MAX\\_VALUE, encode could divide infinity by infinity.", "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest::testBoundaryRangeTooLarge", "test_method": "public void testBoundaryRangeTooLarge() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                public double value(double[] parameters) {\n                    if (Double.isNaN(parameters[0])) {\n                        throw new MathIllegalStateException();\n                    }\n                    final double target = 1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 0 };\n\n        // The difference between upper and lower bounds is used to used\n        // normalize the variables: In case of overflow, NaN is produced.\n        final double max = Double.MAX_VALUE / 2;\n        final double tooLarge = FastMath.nextUp(max);\n        final double[] lower = { -tooLarge };\n        final double[] upper = { tooLarge };\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start, lower, upper).getPoint();\n    }\n\n    /**\n     * @param func Function to optimize.\n     * @param startPoint Starting point.\n     * @param inSigma Individual input sigma.\n     * @param boundaries Upper / lower point limit.\n     * @param goal Minimization or maximization.\n     * @param lambda Population size used for offspring.\n     * @param isActive Covariance update mechanism.\n     * @param diagonalOnly Simplified covariance update.\n     * @param stopValue Termination criteria for optimization.\n     * @param fTol Tolerance relative error on the objective function.\n     * @param pointTol Tolerance for checking that the optimum is correct.\n     * @param maxEvaluations Maximum number of evaluations.\n     * @param expected Expected point / value.\n     */", "error_message": "java.lang.Exception: Unexpected exception, expected<org.apache.commons.math3.exception.NumberIsTooLargeException> but was<org.apache.commons.math3.exception.MathIllegalStateException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "504 private void checkParameters() {\n505         final double[] init = getStartPoint();\n506         final double[] lB = getLowerBound();\n507         final double[] uB = getUpperBound();\n508 \n509         // Checks whether there is at least one finite bound value.\n510         boolean hasFiniteBounds = false;\n511         for (int i = 0; i < lB.length; i++) {\n512             if (!Double.isInfinite(lB[i]) ||\n513                 !Double.isInfinite(uB[i])) {\n514                 hasFiniteBounds = true;\n515                 break;\n516             }\n517         }\n518         // Checks whether there is at least one infinite bound value.\n519         boolean hasInfiniteBounds = false;\n520         if (hasFiniteBounds) {\n521             for (int i = 0; i < lB.length; i++) {\n522                 if (Double.isInfinite(lB[i]) ||\n523                     Double.isInfinite(uB[i])) {\n524                     hasInfiniteBounds = true;\n525                     break;\n526                 }\n527             }\n528 \n529             if (hasInfiniteBounds) {\n530                 // If there is at least one finite bound, none can be infinite,\n531                 // because mixed cases are not supported by the current code.\n532                 throw new MathUnsupportedOperationException();\n533             } else {\n534                 // Convert API to internal handling of boundaries.\n535                 boundaries = new double[2][];\n536                 boundaries[0] = lB;\n537                 boundaries[1] = uB;\n538 \n539                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n540             }\n541         } else {\n542             // Convert API to internal handling of boundaries.\n543             boundaries = null;\n544         }\n545 \n546         if (inputSigma != null) {\n547             if (inputSigma.length != init.length) {\n548                 throw new DimensionMismatchException(inputSigma.length, init.length);\n549             }\n550             for (int i = 0; i < init.length; i++) {\n551                 if (inputSigma[i] < 0) {\n552                     throw new NotPositiveException(inputSigma[i]);\n553                 }\n554                 if (boundaries != null) {\n555                     if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n556                         throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n557                     }\n558                 }\n559             }\n560         }\n561     }", "bm_classpath": "org.apache.commons.math3.optimization.direct.CMAESOptimizer"}, {"bug_name": "Math_20", "report_text": "> CMAESOptimizer does not enforce bounds\n> \n> The CMAESOptimizer can exceed the bounds passed to optimize. Looking at the generationLoop in doOptimize(), it does a bounds check by calling isFeasible() but if checkFeasableCount is zero (the default) then isFeasible() is never even called. Also, even with non-zero checkFeasableCount it may give up before finding an in-bounds offspring and go forward with an out-of-bounds offspring. This is against svn revision 1387637. I can provide an example program where the optimizer ends up with a fit outside the prescribed bounds if that would help.", "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest::testMath864", "test_method": "public void testMath864() {\n        final CMAESOptimizer optimizer = new CMAESOptimizer();\n        final MultivariateFunction fitnessFunction = new MultivariateFunction() {\n                @Override\n                public double value(double[] parameters) {\n                    final double target = 1;\n                    final double error = target - parameters[0];\n                    return error * error;\n                }\n            };\n\n        final double[] start = { 0 };\n        final double[] lower = { -1e6 };\n        final double[] upper = { 0.5 };\n        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\n                                                   start, lower, upper).getPoint();\n        Assert.assertTrue(\"Out of bounds (\" + result[0] + \" > \" + upper[0] + \")\",\n                          result[0] <= upper[0]);\n    }\n\n    /**\n     * @param func Function to optimize.\n     * @param startPoint Starting point.\n     * @param inSigma Individual input sigma.\n     * @param boundaries Upper / lower point limit.\n     * @param goal Minimization or maximization.\n     * @param lambda Population size used for offspring.\n     * @param isActive Covariance update mechanism.\n     * @param diagonalOnly Simplified covariance update.\n     * @param stopValue Termination criteria for optimization.\n     * @param fTol Tolerance relative error on the objective function.\n     * @param pointTol Tolerance for checking that the optimum is correct.\n     * @param maxEvaluations Maximum number of evaluations.\n     * @param expected Expected point / value.\n     */", "error_message": "junit.framework.AssertionFailedError: Out of bounds (0.573450883035548 > 0.5)\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testMath864(CMAESOptimizerTest.java:400)", "buggy_method": "920 public double[] repairAndDecode(final double[] x) {\n921             return\n922                 decode(x);\n923         }", "bm_classpath": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction"}, {"bug_name": "Math_21", "report_text": "> Correlated random vector generator fails (silently) when faced with zero rows in covariance matrix\n> \n> The following three matrices (which are basically permutations of each other) produce different results when sampling a multi-variate Gaussian with the help of CorrelatedRandomVectorGenerator (sample covariances calculated in R, based on 10,000 samples):\n> Array2DRowRealMatrix\n> {\n> {0.0,0.0,0.0,0.0,0.0}\n> ,\n> {0.0,0.013445532,0.01039469,0.009881156,0.010499559}\n> ,\n> {0.0,0.01039469,0.023006616,0.008196856,0.010732709}\n> ,\n> {0.0,0.009881156,0.008196856,0.019023866,0.009210099}\n> ,  \n> {0.0,0.010499559,0.010732709,0.009210099,0.019107243}}\n> > cov(data1)  \n>  V1 V2 V3 V4 V5  \n> V1 0 0.000000000 0.00000000 0.000000000 0.000000000  \n> V2 0 0.013383931 0.01034401 0.009913271 0.010506733  \n> V3 0 0.010344006 0.02309479 0.008374730 0.010759306  \n> V4 0 0.009913271 0.00837473 0.019005488 0.009187287  \n> V5 0 0.010506733 0.01075931 0.009187287 0.019021483\n> Array2DRowRealMatrix\n> {\n> {0.013445532,0.01039469,0.0,0.009881156,0.010499559}\n> ,\n> {0.01039469,0.023006616,0.0,0.008196856,0.010732709}\n> ,\n> {0.0,0.0,0.0,0.0,0.0},\n> {0.009881156,0.008196856,0.0,0.019023866,0.009210099},  \n> {0.010499559,0.010732709,0.0,0.009210099,0.019107243}}  \n>   \n> > cov(data2)  \n>  V1 V2 V3 V4 V5  \n> V1 0.006922905 0.010507692 0 0.005817399 0.010330529  \n> V2 0.010507692 0.023428918 0 0.008273152 0.010735568  \n> V3 0.000000000 0.000000000 0 0.000000000 0.000000000  \n> V4 0.005817399 0.008273152 0 0.004929843 0.009048759  \n> V5 0.010330529 0.010735568 0 0.009048759 0.018683544   \n>   \n> Array2DRowRealMatrix{\n> {0.013445532,0.01039469,0.009881156,0.010499559},\n> {0.01039469,0.023006616,0.008196856,0.010732709},\n> {0.009881156,0.008196856,0.019023866,0.009210099},  \n> {0.010499559,0.010732709,0.009210099,0.019107243}}  \n>   \n> > cov(data3)  \n>  V1 V2 V3 V4  \n> V1 0.013445047 0.010478862 0.009955904 0.010529542  \n> V2 0.010478862 0.022910522 0.008610113 0.011046353  \n> V3 0.009955904 0.008610113 0.019250975 0.009464442  \n> V4 0.010529542 0.011046353 0.009464442 0.019260317  \n>   \n>   \n> I've traced this back to the RectangularCholeskyDecomposition, which does not seem to handle the second matrix very well (decompositions in the same order as the matrices above):  \n>   \n> CorrelatedRandomVectorGenerator.getRootMatrix() =   \n> Array2DRowRealMatrix{{0.0,0.0,0.0,0.0,0.0}\n> ,\n> {0.0759577418122063,0.0876125188474239,0.0,0.0,0.0}\n> ,\n> {0.07764443622513505,0.05132821221460752,0.11976381821791235,0.0,0.0}\n> ,\n> {0.06662930527909404,0.05501661744114585,0.0016662506519307997,0.10749324207653632,0.0}\n> ,{0.13822895138139477,0.0,0.0,0.0,0.0}}  \n> CorrelatedRandomVectorGenerator.getRank() = 5\n> CorrelatedRandomVectorGenerator.getRootMatrix() =   \n> Array2DRowRealMatrix{{0.0759577418122063,0.034512751379448724,0.0},\n> {0.07764443622513505,0.13029949164628746,0.0}\n> ,\n> {0.0,0.0,0.0}\n> ,\n> {0.06662930527909404,0.023203936694855674,0.0}\n> ,{0.13822895138139477,0.0,0.0}}  \n> CorrelatedRandomVectorGenerator.getRank() = 3\n> CorrelatedRandomVectorGenerator.getRootMatrix() =   \n> Array2DRowRealMatrix{{0.0759577418122063,0.034512751379448724,0.033913748226348225,0.07303890149947785},\n> {0.07764443622513505,0.13029949164628746,0.0,0.0}\n> ,\n> {0.06662930527909404,0.023203936694855674,0.11851573313229945,0.0}\n> ,{0.13822895138139477,0.0,0.0,0.0}}  \n> CorrelatedRandomVectorGenerator.getRank() = 4\n> Clearly, the rank of each of these matrices should be 4. The first matrix does not lead to incorrect results, but the second one does. Unfortunately, I don't know enough about the Cholesky decomposition to find the flaw in the implementation, and I could not find documentation for the \"rectangular\" variant (also not at the links provided in the javadoc).", "test_name": "org.apache.commons.math3.linear.RectangularCholeskyDecompositionTest::testMath789", "test_method": "    @Test\n    public void testMath789() {\n\n        final RealMatrix m1 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.013445532, 0.010394690, 0.009881156, 0.010499559},\n            {0.010394690, 0.023006616, 0.008196856, 0.010732709},\n            {0.009881156, 0.008196856, 0.019023866, 0.009210099},\n            {0.010499559, 0.010732709, 0.009210099, 0.019107243}\n        });\n        RealMatrix root1 = new RectangularCholeskyDecomposition(m1, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM1 = root1.multiply(root1.transpose());\n\n        final RealMatrix m2 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n            {0.0, 0.013445532, 0.010394690, 0.009881156, 0.010499559},\n            {0.0, 0.010394690, 0.023006616, 0.008196856, 0.010732709},\n            {0.0, 0.009881156, 0.008196856, 0.019023866, 0.009210099},\n            {0.0, 0.010499559, 0.010732709, 0.009210099, 0.019107243}\n        });\n        RealMatrix root2 = new RectangularCholeskyDecomposition(m2, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM2 = root2.multiply(root2.transpose());\n\n        final RealMatrix m3 = MatrixUtils.createRealMatrix(new double[][]{\n            {0.013445532, 0.010394690, 0.0, 0.009881156, 0.010499559},\n            {0.010394690, 0.023006616, 0.0, 0.008196856, 0.010732709},\n            {0.0, 0.0, 0.0, 0.0, 0.0},\n            {0.009881156, 0.008196856, 0.0, 0.019023866, 0.009210099},\n            {0.010499559, 0.010732709, 0.0, 0.009210099, 0.019107243}\n        });\n        RealMatrix root3 = new RectangularCholeskyDecomposition(m3, 1.0e-10).getRootMatrix();\n        RealMatrix rebuiltM3 = root3.multiply(root3.transpose());\n        Assert.assertEquals(0.0, m3.subtract(rebuiltM3).getNorm(), 1.0e-16); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<0.0180652917341963>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.linear.RectangularCholeskyDecompositionTest.testMath789(RectangularCholeskyDecompositionTest.java:108)", "buggy_method": "62 public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n63         throws NonPositiveDefiniteMatrixException {\n64 \n65         final int order = matrix.getRowDimension();\n66         final double[][] c = matrix.getData();\n67         final double[][] b = new double[order][order];\n68 \n69         int[] swap  = new int[order];\n70         int[] index = new int[order];\n71         for (int i = 0; i < order; ++i) {\n72             index[i] = i;\n73         }\n74 \n75         int r = 0;\n76         for (boolean loop = true; loop;) {\n77 \n78             // find maximal diagonal element\n79             swap[r] = r;\n80             for (int i = r + 1; i < order; ++i) {\n81                 int ii  = index[i];\n82                 int isi = index[swap[i]];\n83                 if (c[ii][ii] > c[isi][isi]) {\n84                     swap[r] = i;\n85                 }\n86             }\n87 \n88 \n89             // swap elements\n90             if (swap[r] != r) {\n91                 int tmp = index[r];\n92                 index[r] = index[swap[r]];\n93                 index[swap[r]] = tmp;\n94             }\n95 \n96             // check diagonal element\n97             int ir = index[r];\n98             if (c[ir][ir] < small) {\n99 \n100                 if (r == 0) {\n101                     throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n102                 }\n103 \n104                 // check remaining diagonal elements\n105                 for (int i = r; i < order; ++i) {\n106                     if (c[index[i]][index[i]] < -small) {\n107                         // there is at least one sufficiently negative diagonal element,\n108                         // the symmetric positive semidefinite matrix is wrong\n109                         throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n110                     }\n111                 }\n112 \n113                 // all remaining diagonal elements are close to zero, we consider we have\n114                 // found the rank of the symmetric positive semidefinite matrix\n115                 ++r;\n116                 loop = false;\n117 \n118             } else {\n119 \n120                 // transform the matrix\n121                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n122                 b[r][r] = sqrt;\n123                 final double inverse  = 1 / sqrt;\n124                 for (int i = r + 1; i < order; ++i) {\n125                     final int ii = index[i];\n126                     final double e = inverse * c[ii][ir];\n127                     b[i][r] = e;\n128                     c[ii][ii] -= e * e;\n129                     for (int j = r + 1; j < i; ++j) {\n130                         final int ij = index[j];\n131                         final double f = c[ii][ij] - e * b[j][r];\n132                         c[ii][ij] = f;\n133                         c[ij][ii] = f;\n134                     }\n135                 }\n136 \n137                 // prepare next iteration\n138                 loop = ++r < order;\n139             }\n140         }\n141 \n142         // build the root matrix\n143         rank = r;\n144         root = MatrixUtils.createRealMatrix(order, r);\n145         for (int i = 0; i < order; ++i) {\n146             for (int j = 0; j < r; ++j) {\n147                 root.setEntry(index[i], j, b[i][j]);\n148             }\n149         }\n150 \n151     }", "bm_classpath": "org.apache.commons.math3.linear.RectangularCholeskyDecomposition"}, {"bug_name": "Math_22", "report_text": "> Fix and then deprecate isSupportXxxInclusive in RealDistribution interface\n> \n> The conclusion from [1] was never implemented. We should deprecate these  \n> properties from the RealDistribution interface, but since removal  \n> will have to wait until 4.0, we should agree on a precise  \n> definition and fix the code to match it in the mean time.\n> The definition that I propose is that isSupportXxxInclusive means  \n> that when the density function is applied to the upper or lower  \n> bound of support returned by getSupportXxxBound, a finite (i.e. not  \n> infinite), not NaN value is returned.\n> [1] <http://markmail.org/message/dxuxh7eybl7xejde>", "test_name": "org.apache.commons.math3.distribution.FDistributionTest::testIsSupportLowerBoundInclusive", "test_method": "@Test\n    public void testIsSupportLowerBoundInclusive() {\n        final double lowerBound = distribution.getSupportLowerBound();\n        double result = Double.NaN;\n        result = distribution.density(lowerBound);\n        Assert.assertEquals(\n                !Double.isInfinite(lowerBound) && !Double.isNaN(result) &&\n                !Double.isInfinite(result),\n                distribution.isSupportLowerBoundInclusive());\n         \n    }", "error_message": "junit.framework.AssertionFailedError: expected:<false> but was:<true>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:144)\n\torg.apache.commons.math3.distribution.RealDistributionAbstractTest.testIsSupportLowerBoundInclusive(RealDistributionAbstractTest.java:351)", "buggy_method": "274 public boolean isSupportLowerBoundInclusive() {\n275         return true;\n276     }", "bm_classpath": "org.apache.commons.math3.distribution.FDistribution"}, {"bug_name": "Math_23", "report_text": "> \"BrentOptimizer\" not always reporting the best point\n> \n> BrentOptimizer (package \"o.a.c.m.optimization.univariate\") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.", "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest::testKeepInitIfBest", "test_method": "    @Test\n    public void testKeepInitIfBest() {\n        final double minSin = 3 * Math.PI / 2;\n        final double offset = 1e-8;\n        final double delta = 1e-7;\n        final UnivariateFunction f1 = new Sin();\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\n                                                       new double[] { 0, -1, 0 });\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n        // A slightly less stringent tolerance would make the test pass\n        // even with the previous implementation.\n        final double relTol = 1e-8;\n        final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\n        final double init = minSin + 1.5 * offset;\n        final UnivariatePointValuePair result\n            = optimizer.optimize(200, f, GoalType.MINIMIZE,\n                                 minSin - 6.789 * delta,\n                                 minSin + 9.876 * delta,\n                                 init);\n        final int numEval = optimizer.getEvaluations();\n\n        final double sol = result.getPoint();\n        final double expected = init;\n\n//         System.out.println(\"numEval=\" + numEval);\n//         System.out.println(\"min=\" + init + \" f=\" + f.value(init));\n//         System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n//         System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Best point not reported\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testKeepInitIfBest(BrentOptimizerTest.java:221)", "buggy_method": "114 @Override\n115     protected UnivariatePointValuePair doOptimize() {\n116         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n117         final double lo = getMin();\n118         final double mid = getStartValue();\n119         final double hi = getMax();\n120 \n121         // Optional additional convergence criteria.\n122         final ConvergenceChecker<UnivariatePointValuePair> checker\n123             = getConvergenceChecker();\n124 \n125         double a;\n126         double b;\n127         if (lo < hi) {\n128             a = lo;\n129             b = hi;\n130         } else {\n131             a = hi;\n132             b = lo;\n133         }\n134 \n135         double x = mid;\n136         double v = x;\n137         double w = x;\n138         double d = 0;\n139         double e = 0;\n140         double fx = computeObjectiveValue(x);\n141         if (!isMinim) {\n142             fx = -fx;\n143         }\n144         double fv = fx;\n145         double fw = fx;\n146 \n147         UnivariatePointValuePair previous = null;\n148         UnivariatePointValuePair current\n149             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n150         // Best point encountered so far (which is the initial guess).\n151 \n152         int iter = 0;\n153         while (true) {\n154             final double m = 0.5 * (a + b);\n155             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n156             final double tol2 = 2 * tol1;\n157 \n158             // Default stopping criterion.\n159             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n160             if (!stop) {\n161                 double p = 0;\n162                 double q = 0;\n163                 double r = 0;\n164                 double u = 0;\n165 \n166                 if (FastMath.abs(e) > tol1) { // Fit parabola.\n167                     r = (x - w) * (fx - fv);\n168                     q = (x - v) * (fx - fw);\n169                     p = (x - v) * q - (x - w) * r;\n170                     q = 2 * (q - r);\n171 \n172                     if (q > 0) {\n173                         p = -p;\n174                     } else {\n175                         q = -q;\n176                     }\n177 \n178                     r = e;\n179                     e = d;\n180 \n181                     if (p > q * (a - x) &&\n182                         p < q * (b - x) &&\n183                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n184                         // Parabolic interpolation step.\n185                         d = p / q;\n186                         u = x + d;\n187 \n188                         // f must not be evaluated too close to a or b.\n189                         if (u - a < tol2 || b - u < tol2) {\n190                             if (x <= m) {\n191                                 d = tol1;\n192                             } else {\n193                                 d = -tol1;\n194                             }\n195                         }\n196                     } else {\n197                         // Golden section step.\n198                         if (x < m) {\n199                             e = b - x;\n200                         } else {\n201                             e = a - x;\n202                         }\n203                         d = GOLDEN_SECTION * e;\n204                     }\n205                 } else {\n206                     // Golden section step.\n207                     if (x < m) {\n208                         e = b - x;\n209                     } else {\n210                         e = a - x;\n211                     }\n212                     d = GOLDEN_SECTION * e;\n213                 }\n214 \n215                 // Update by at least \"tol1\".\n216                 if (FastMath.abs(d) < tol1) {\n217                     if (d >= 0) {\n218                         u = x + tol1;\n219                     } else {\n220                         u = x - tol1;\n221                     }\n222                 } else {\n223                     u = x + d;\n224                 }\n225 \n226                 double fu = computeObjectiveValue(u);\n227                 if (!isMinim) {\n228                     fu = -fu;\n229                 }\n230 \n231                 // User-defined convergence checker.\n232                 previous = current;\n233                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n234 \n235                 if (checker != null) {\n236                     if (checker.converged(iter, previous, current)) {\n237                         return best(current, previous, isMinim);\n238                     }\n239                 }\n240 \n241                 // Update a, b, v, w and x.\n242                 if (fu <= fx) {\n243                     if (u < x) {\n244                         b = x;\n245                     } else {\n246                         a = x;\n247                     }\n248                     v = w;\n249                     fv = fw;\n250                     w = x;\n251                     fw = fx;\n252                     x = u;\n253                     fx = fu;\n254                 } else {\n255                     if (u < x) {\n256                         a = u;\n257                     } else {\n258                         b = u;\n259                     }\n260                     if (fu <= fw ||\n261                         Precision.equals(w, x)) {\n262                         v = w;\n263                         fv = fw;\n264                         w = u;\n265                         fw = fu;\n266                     } else if (fu <= fv ||\n267                                Precision.equals(v, x) ||\n268                                Precision.equals(v, w)) {\n269                         v = u;\n270                         fv = fu;\n271                     }\n272                 }\n273             } else { // Default termination (Brent's criterion).\n274                 return\n275                             best(current,\n276                                  previous,\n277                             isMinim);\n278             }\n279             ++iter;\n280         }\n281     }", "bm_classpath": "org.apache.commons.math3.optimization.univariate.BrentOptimizer"}, {"bug_name": "Math_24", "report_text": "> \"BrentOptimizer\" not always reporting the best point\n> \n> BrentOptimizer (package \"o.a.c.m.optimization.univariate\") does not check that the point it is going to return is indeed the best one it has encountered. Indeed, the last evaluated point might be slightly worse than the one before last.", "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest::testMath855", "test_method": "    @Test\n    public void testMath855() {\n        final double minSin = 3 * Math.PI / 2;\n        final double offset = 1e-8;\n        final double delta = 1e-7;\n        final UnivariateFunction f1 = new Sin();\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },\n                                                       new double[] { 0, -1, 0 });\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\n        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\n        final UnivariatePointValuePair result\n            = optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\n        final int numEval = optimizer.getEvaluations();\n\n        final double sol = result.getPoint();\n        final double expected = 4.712389027602411;\n\n        // System.out.println(\"min=\" + (minSin + offset) + \" f=\" + f.value(minSin + offset));\n        // System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n        // System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\n\n        Assert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Best point not reported\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testMath855(BrentOptimizerTest.java:213)", "buggy_method": "108 @Override\n109     protected UnivariatePointValuePair doOptimize() {\n110         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n111         final double lo = getMin();\n112         final double mid = getStartValue();\n113         final double hi = getMax();\n114 \n115         // Optional additional convergence criteria.\n116         final ConvergenceChecker<UnivariatePointValuePair> checker\n117             = getConvergenceChecker();\n118 \n119         double a;\n120         double b;\n121         if (lo < hi) {\n122             a = lo;\n123             b = hi;\n124         } else {\n125             a = hi;\n126             b = lo;\n127         }\n128 \n129         double x = mid;\n130         double v = x;\n131         double w = x;\n132         double d = 0;\n133         double e = 0;\n134         double fx = computeObjectiveValue(x);\n135         if (!isMinim) {\n136             fx = -fx;\n137         }\n138         double fv = fx;\n139         double fw = fx;\n140 \n141         UnivariatePointValuePair previous = null;\n142         UnivariatePointValuePair current\n143             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n144 \n145         int iter = 0;\n146         while (true) {\n147             final double m = 0.5 * (a + b);\n148             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n149             final double tol2 = 2 * tol1;\n150 \n151             // Default stopping criterion.\n152             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n153             if (!stop) {\n154                 double p = 0;\n155                 double q = 0;\n156                 double r = 0;\n157                 double u = 0;\n158 \n159                 if (FastMath.abs(e) > tol1) { // Fit parabola.\n160                     r = (x - w) * (fx - fv);\n161                     q = (x - v) * (fx - fw);\n162                     p = (x - v) * q - (x - w) * r;\n163                     q = 2 * (q - r);\n164 \n165                     if (q > 0) {\n166                         p = -p;\n167                     } else {\n168                         q = -q;\n169                     }\n170 \n171                     r = e;\n172                     e = d;\n173 \n174                     if (p > q * (a - x) &&\n175                         p < q * (b - x) &&\n176                         FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n177                         // Parabolic interpolation step.\n178                         d = p / q;\n179                         u = x + d;\n180 \n181                         // f must not be evaluated too close to a or b.\n182                         if (u - a < tol2 || b - u < tol2) {\n183                             if (x <= m) {\n184                                 d = tol1;\n185                             } else {\n186                                 d = -tol1;\n187                             }\n188                         }\n189                     } else {\n190                         // Golden section step.\n191                         if (x < m) {\n192                             e = b - x;\n193                         } else {\n194                             e = a - x;\n195                         }\n196                         d = GOLDEN_SECTION * e;\n197                     }\n198                 } else {\n199                     // Golden section step.\n200                     if (x < m) {\n201                         e = b - x;\n202                     } else {\n203                         e = a - x;\n204                     }\n205                     d = GOLDEN_SECTION * e;\n206                 }\n207 \n208                 // Update by at least \"tol1\".\n209                 if (FastMath.abs(d) < tol1) {\n210                     if (d >= 0) {\n211                         u = x + tol1;\n212                     } else {\n213                         u = x - tol1;\n214                     }\n215                 } else {\n216                     u = x + d;\n217                 }\n218 \n219                 double fu = computeObjectiveValue(u);\n220                 if (!isMinim) {\n221                     fu = -fu;\n222                 }\n223 \n224                 // User-defined convergence checker.\n225                 previous = current;\n226                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n227 \n228                 if (checker != null) {\n229                     if (checker.converged(iter, previous, current)) {\n230                         return current;\n231                     }\n232                 }\n233 \n234                 // Update a, b, v, w and x.\n235                 if (fu <= fx) {\n236                     if (u < x) {\n237                         b = x;\n238                     } else {\n239                         a = x;\n240                     }\n241                     v = w;\n242                     fv = fw;\n243                     w = x;\n244                     fw = fx;\n245                     x = u;\n246                     fx = fu;\n247                 } else {\n248                     if (u < x) {\n249                         a = u;\n250                     } else {\n251                         b = u;\n252                     }\n253                     if (fu <= fw ||\n254                         Precision.equals(w, x)) {\n255                         v = w;\n256                         fv = fw;\n257                         w = u;\n258                         fw = fu;\n259                     } else if (fu <= fv ||\n260                                Precision.equals(v, x) ||\n261                                Precision.equals(v, w)) {\n262                         v = u;\n263                         fv = fu;\n264                     }\n265                 }\n266             } else { // Default termination (Brent's criterion).\n267                 return current;\n268             }\n269             ++iter;\n270         }\n271     }", "bm_classpath": "org.apache.commons.math3.optimization.univariate.BrentOptimizer"}, {"bug_name": "Math_25", "report_text": "> \"HarmonicFitter.ParameterGuesser\" sometimes fails to return sensible values\n> \n> The inner class \"ParameterGuesser\" in \"HarmonicFitter\" (package \"o.a.c.m.optimization.fitting\") fails to compute a usable guess for the \"amplitude\" parameter.", "test_name": "org.apache.commons.math3.optimization.fitting.HarmonicFitterTest::testMath844", "test_method": "public void testMath844() {\n        final double[] y = { 0, 1, 2, 3, 2, 1,\n                             0, -1, -2, -3, -2, -1,\n                             0, 1, 2, 3, 2, 1,\n                             0, -1, -2, -3, -2, -1,\n                             0, 1, 2, 3, 2, 1, 0 };\n        final int len = y.length;\n        final WeightedObservedPoint[] points = new WeightedObservedPoint[len];\n        for (int i = 0; i < len; i++) {\n            points[i] = new WeightedObservedPoint(1, i, y[i]);\n        }\n\n        final HarmonicFitter.ParameterGuesser guesser\n            = new HarmonicFitter.ParameterGuesser(points);\n\n        // The guesser fails because the function is far from an harmonic\n        // function: It is a triangular periodic function with amplitude 3\n        // and period 12, and all sample points are taken at integer abscissae\n        // so function values all belong to the integer subset {-3, -2, -1, 0,\n        // 1, 2, 3}.\n        guesser.guess();\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math3.exception.MathIllegalStateException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "257 private void guessAOmega() {\n258             // initialize the sums for the linear model between the two integrals\n259             double sx2 = 0;\n260             double sy2 = 0;\n261             double sxy = 0;\n262             double sxz = 0;\n263             double syz = 0;\n264 \n265             double currentX = observations[0].getX();\n266             double currentY = observations[0].getY();\n267             double f2Integral = 0;\n268             double fPrime2Integral = 0;\n269             final double startX = currentX;\n270             for (int i = 1; i < observations.length; ++i) {\n271                 // one step forward\n272                 final double previousX = currentX;\n273                 final double previousY = currentY;\n274                 currentX = observations[i].getX();\n275                 currentY = observations[i].getY();\n276 \n277                 // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n278                 // considering a linear model for f (and therefore constant f')\n279                 final double dx = currentX - previousX;\n280                 final double dy = currentY - previousY;\n281                 final double f2StepIntegral =\n282                     dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n283                 final double fPrime2StepIntegral = dy * dy / dx;\n284 \n285                 final double x = currentX - startX;\n286                 f2Integral += f2StepIntegral;\n287                 fPrime2Integral += fPrime2StepIntegral;\n288 \n289                 sx2 += x * x;\n290                 sy2 += f2Integral * f2Integral;\n291                 sxy += x * f2Integral;\n292                 sxz += x * fPrime2Integral;\n293                 syz += f2Integral * fPrime2Integral;\n294             }\n295 \n296             // compute the amplitude and pulsation coefficients\n297             double c1 = sy2 * sxz - sxy * syz;\n298             double c2 = sxy * sxz - sx2 * syz;\n299             double c3 = sx2 * sy2 - sxy * sxy;\n300             if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n301                 final int last = observations.length - 1;\n302                 // Range of the observations, assuming that the\n303                 // observations are sorted.\n304                 final double xRange = observations[last].getX() - observations[0].getX();\n305                 if (xRange == 0) {\n306                     throw new ZeroException();\n307                 }\n308                 omega = 2 * Math.PI / xRange;\n309 \n310                 double yMin = Double.POSITIVE_INFINITY;\n311                 double yMax = Double.NEGATIVE_INFINITY;\n312                 for (int i = 1; i < observations.length; ++i) {\n313                     final double y = observations[i].getY();\n314                     if (y < yMin) {\n315                         yMin = y;\n316                     }\n317                     if (y > yMax) {\n318                         yMax = y;\n319                     }\n320                 }\n321                 a = 0.5 * (yMax - yMin);\n322             } else {\n323                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n324                     // procedure cannot produce sensible results.\n325 \n326                 a = FastMath.sqrt(c1 / c2);\n327                 omega = FastMath.sqrt(c2 / c3);\n328             }\n329         }", "bm_classpath": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser"}, {"bug_name": "Math_26", "report_text": "> Fraction(double, int) constructor strange behaviour\n> \n> The Fraction constructor Fraction(double, int) takes a double value and a int maximal denominator, and approximates a fraction. When the double value is a large, negative number with many digits in the fractional part, and the maximal denominator is a big, positive integer (in the 100'000s), two distinct bugs can manifest:\n> 1: the constructor returns a positive Fraction. Calling Fraction(-33655.1677817278, 371880) returns the fraction 410517235/243036, which both has the wrong sign, and is far away from the absolute value of the given value\n> 2: the constructor does not manage to reduce the Fraction properly. Calling Fraction(-43979.60679604749, 366081) returns the fraction -1651878166/256677, which should have\\* been reduced to -24654898/3831.\n> I have, as of yet, not found a solution. The constructor looks like this:\n> public Fraction(double value, int maxDenominator)  \n>  throws FractionConversionException\n>  {\n>  this(value, 0, maxDenominator, 100);\n>  }\n> Increasing the 100 value (max iterations) does not fix the problem for all cases. Changing the 0-value (the epsilon, maximum allowed error) to something small does not work either, as this breaks the tests in FractionTest. \n> The problem is not neccissarily that the algorithm is unable to approximate a fraction correctly. A solution where a FractionConversionException had been thrown in each of these examples would probably be the best solution if an improvement on the approximation algorithm turns out to be hard to find.\n> This bug has been found when trying to explore the idea of axiom-based testing (<http://bldl.ii.uib.no/testing.html>). Attached is a java test class FractionTestByAxiom (junit, goes into org.apache.commons.math3.fraction) which shows these bugs through a simplified approach to this kind of testing, and a text file describing some of the value/maxDenominator combinations which causes one of these failures.\n> * It is never specified in the documentation that the Fraction class guarantees that completely reduced rational numbers are constructed, but a comment inside the equals method claims that \"since fractions are always in lowest terms, numerators and can be compared directly for equality\", so it seems like this is the intention.", "test_name": "org.apache.commons.math3.fraction.FractionTest::testIntegerOverflow", "test_method": "    @Test\n    public void testIntegerOverflow() {\n        checkIntegerOverflow(0.75000000001455192);\n        checkIntegerOverflow(1.0e10);\n        checkIntegerOverflow(-1.0e10); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: an exception should have been thrown\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.apache.commons.math3.fraction.FractionTest.checkIntegerOverflow(FractionTest.java:145)\n\torg.apache.commons.math3.fraction.FractionTest.testIntegerOverflow(FractionTest.java:138)", "buggy_method": "175 private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n176         throws FractionConversionException\n177     {\n178         long overflow = Integer.MAX_VALUE;\n179         double r0 = value;\n180         long a0 = (long)FastMath.floor(r0);\n181         if (a0 > overflow) {\n182             throw new FractionConversionException(value, a0, 1l);\n183         }\n184 \n185         // check for (almost) integer arguments, which should not go\n186         // to iterations.\n187         if (FastMath.abs(a0 - value) < epsilon) {\n188             this.numerator = (int) a0;\n189             this.denominator = 1;\n190             return;\n191         }\n192 \n193         long p0 = 1;\n194         long q0 = 0;\n195         long p1 = a0;\n196         long q1 = 1;\n197 \n198         long p2 = 0;\n199         long q2 = 1;\n200 \n201         int n = 0;\n202         boolean stop = false;\n203         do {\n204             ++n;\n205             double r1 = 1.0 / (r0 - a0);\n206             long a1 = (long)FastMath.floor(r1);\n207             p2 = (a1 * p1) + p0;\n208             q2 = (a1 * q1) + q0;\n209             if ((p2 > overflow) || (q2 > overflow)) {\n210                 throw new FractionConversionException(value, p2, q2);\n211             }\n212 \n213             double convergent = (double)p2 / (double)q2;\n214             if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n215                 p0 = p1;\n216                 p1 = p2;\n217                 q0 = q1;\n218                 q1 = q2;\n219                 a0 = a1;\n220                 r0 = r1;\n221             } else {\n222                 stop = true;\n223             }\n224         } while (!stop);\n225 \n226         if (n >= maxIterations) {\n227             throw new FractionConversionException(value, maxIterations);\n228         }\n229 \n230         if (q2 < maxDenominator) {\n231             this.numerator = (int) p2;\n232             this.denominator = (int) q2;\n233         } else {\n234             this.numerator = (int) p1;\n235             this.denominator = (int) q1;\n236         }\n237 \n238     }", "bm_classpath": "org.apache.commons.math3.fraction.Fraction"}, {"bug_name": "Math_27", "report_text": "> Fraction percentageValue rare overflow\n> \n> The percentageValue() method of the Fraction class works by first multiplying the Fraction by 100, then converting the Fraction to a double. This causes overflows when the numerator is greater than Integer.MAX\\_VALUE/100, even when the value of the fraction is far below this value.\n> The patch changes the method to first convert to a double value, and then multiply this value by 100 - the result should be the same, but with less overflows. An addition to the test for the method that covers this bug is also included.", "test_name": "org.apache.commons.math3.fraction.FractionTest::testMath835", "test_method": "    @Test\n    public void testMath835() {\n        final int numer = Integer.MAX_VALUE / 99;\n        final int denom = 1;\n        final double percentage = 100 * ((double) numer) / denom;\n        final Fraction frac = new Fraction(numer, denom);\n        // With the implementation that preceded the fix suggested in MATH-835,\n        // this test was failing, due to overflow.\n        Assert.assertEquals(percentage, frac.percentageValue(), Math.ulp(percentage)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2.1691754E9> but was:<-2.125791896E9>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math3.fraction.FractionTest.testMath835(FractionTest.java:253)", "buggy_method": "596 public double percentageValue() {\n597         return multiply(100).doubleValue();\n598     }", "bm_classpath": "org.apache.commons.math3.fraction.Fraction"}, {"bug_name": "Math_28", "report_text": "> Not expected UnboundedSolutionException\n> \n> SimplexSolver throws UnboundedSolutionException when trying to solve minimization linear programming problem. The number of exception thrown depends on the number of variables.\n> In order to see that behavior of SimplexSolver first try to run JUnit test setting a final variable ENTITIES\\_COUNT = 2 and that will give almost good result and then set it to 15 and you'll get a massive of unbounded exceptions.  \n> First iteration is runned with predefined set of input data with which the Solver gives back an appropriate result.\n> The problem itself is well tested by it's authors (mathematicians who I believe know what they developed) using Matlab 10 with no unbounded solutions on the same rules of creatnig random variables values.\n> What is strange to me is the dependence of the number of UnboundedSolutionException exceptions on the number of variables in the problem.\n> The problem is formulated as  \n> min(1\\*t + 0\\*L) (for every r-th subject)  \n> s.t.  \n> -q(r) + QL >= 0  \n> x(r)t - XL >= 0  \n> L >= 0  \n> where   \n> r = 1..R,   \n> L = \n> {l(1), l(2), ..., l(R)}\n>  (vector of R rows and 1 column),  \n> Q - coefficients matrix MxR  \n> X - coefficients matrix NxR ", "test_name": "org.apache.commons.math3.optimization.linear.SimplexSolverTest::testMath828Cycle", "test_method": "    @Test\n    public void testMath828Cycle() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(\n                new double[] { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}, 0.0);\n        \n        ArrayList <LinearConstraint>constraints = new ArrayList<LinearConstraint>();\n\n        constraints.add(new LinearConstraint(new double[] {0.0, 16.0, 14.0, 69.0, 1.0, 85.0, 52.0, 43.0, 64.0, 97.0, 14.0, 74.0, 89.0, 28.0, 94.0, 58.0, 13.0, 22.0, 21.0, 17.0, 30.0, 25.0, 1.0, 59.0, 91.0, 78.0, 12.0, 74.0, 56.0, 3.0, 88.0,}, Relationship.GEQ, 91.0));\n        constraints.add(new LinearConstraint(new double[] {0.0, 60.0, 40.0, 81.0, 71.0, 72.0, 46.0, 45.0, 38.0, 48.0, 40.0, 17.0, 33.0, 85.0, 64.0, 32.0, 84.0, 3.0, 54.0, 44.0, 71.0, 67.0, 90.0, 95.0, 54.0, 99.0, 99.0, 29.0, 52.0, 98.0, 9.0,}, Relationship.GEQ, 54.0));\n        constraints.add(new LinearConstraint(new double[] {0.0, 41.0, 12.0, 86.0, 90.0, 61.0, 31.0, 41.0, 23.0, 89.0, 17.0, 74.0, 44.0, 27.0, 16.0, 47.0, 80.0, 32.0, 11.0, 56.0, 68.0, 82.0, 11.0, 62.0, 62.0, 53.0, 39.0, 16.0, 48.0, 1.0, 63.0,}, Relationship.GEQ, 62.0));\n        constraints.add(new LinearConstraint(new double[] {83.0, -76.0, -94.0, -19.0, -15.0, -70.0, -72.0, -57.0, -63.0, -65.0, -22.0, -94.0, -22.0, -88.0, -86.0, -89.0, -72.0, -16.0, -80.0, -49.0, -70.0, -93.0, -95.0, -17.0, -83.0, -97.0, -31.0, -47.0, -31.0, -13.0, -23.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {41.0, -96.0, -41.0, -48.0, -70.0, -43.0, -43.0, -43.0, -97.0, -37.0, -85.0, -70.0, -45.0, -67.0, -87.0, -69.0, -94.0, -54.0, -54.0, -92.0, -79.0, -10.0, -35.0, -20.0, -41.0, -41.0, -65.0, -25.0, -12.0, -8.0, -46.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {27.0, -42.0, -65.0, -49.0, -53.0, -42.0, -17.0, -2.0, -61.0, -31.0, -76.0, -47.0, -8.0, -93.0, -86.0, -62.0, -65.0, -63.0, -22.0, -43.0, -27.0, -23.0, -32.0, -74.0, -27.0, -63.0, -47.0, -78.0, -29.0, -95.0, -73.0,}, Relationship.GEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] {15.0, -46.0, -41.0, -83.0, -98.0, -99.0, -21.0, -35.0, -7.0, -14.0, -80.0, -63.0, -18.0, -42.0, -5.0, -34.0, -56.0, -70.0, -16.0, -18.0, -74.0, -61.0, -47.0, -41.0, -15.0, -79.0, -18.0, -47.0, -88.0, -68.0, -55.0,}, Relationship.GEQ, 0.0));\n        \n        double epsilon = 1e-6;\n        PointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MINIMIZE, true); // <-- fails here\n    }", "error_message": "org.apache.commons.math3.exception.MaxCountExceededException: illegal state: maximal count (100) exceeded\n\torg.apache.commons.math3.optimization.linear.AbstractLinearOptimizer.incrementIterationsCounter(AbstractLinearOptimizer.java:128)\n\torg.apache.commons.math3.optimization.linear.SimplexSolver.doIteration(SimplexSolver.java:165)\n\torg.apache.commons.math3.optimization.linear.SimplexSolver.doOptimize(SimplexSolver.java:227)\n\torg.apache.commons.math3.optimization.linear.AbstractLinearOptimizer.optimize(AbstractLinearOptimizer.java:147)\n\torg.apache.commons.math3.optimization.linear.SimplexSolverTest.testMath828Cycle(SimplexSolverTest.java:70)", "buggy_method": "90 private Integer getPivotRow(SimplexTableau tableau, final int col) {\n91         // create a list of all the rows that tie for the lowest score in the minimum ratio test\n92         List<Integer> minRatioPositions = new ArrayList<Integer>();\n93         double minRatio = Double.MAX_VALUE;\n94         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n95             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n96             final double entry = tableau.getEntry(i, col);\n97 \n98             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n99                 final double ratio = rhs / entry;\n100                 // check if the entry is strictly equal to the current min ratio\n101                 // do not use a ulp/epsilon check\n102                 final int cmp = Double.compare(ratio, minRatio);\n103                 if (cmp == 0) {\n104                     minRatioPositions.add(i);\n105                 } else if (cmp < 0) {\n106                     minRatio = ratio;\n107                     minRatioPositions = new ArrayList<Integer>();\n108                     minRatioPositions.add(i);\n109                 }\n110             }\n111         }\n112 \n113         if (minRatioPositions.size() == 0) {\n114             return null;\n115         } else if (minRatioPositions.size() > 1) {\n116             // there's a degeneracy as indicated by a tie in the minimum ratio test\n117 \n118             // 1. check if there's an artificial variable that can be forced out of the basis\n119                 for (Integer row : minRatioPositions) {\n120                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n121                         int column = i + tableau.getArtificialVariableOffset();\n122                         final double entry = tableau.getEntry(row, column);\n123                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n124                             return row;\n125                         }\n126                     }\n127                 }\n128 \n129             // 2. apply Bland's rule to prevent cycling:\n130             //    take the row for which the corresponding basic variable has the smallest index\n131             //\n132             // see http://www.stanford.edu/class/msande310/blandrule.pdf\n133             // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n134             //\n135             // Additional heuristic: if we did not get a solution after half of maxIterations\n136             //                       revert to the simple case of just returning the top-most row\n137             // This heuristic is based on empirical data gathered while investigating MATH-828.\n138                 Integer minRow = null;\n139                 int minIndex = tableau.getWidth();\n140                 for (Integer row : minRatioPositions) {\n141                     int i = tableau.getNumObjectiveFunctions();\n142                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n143                         if (row == tableau.getBasicRow(i)) {\n144                             if (i < minIndex) {\n145                                 minIndex = i;\n146                                 minRow = row;\n147                             }\n148                         }\n149                     }\n150                 }\n151                 return minRow;\n152         }\n153         return minRatioPositions.get(0);\n154     }", "bm_classpath": "org.apache.commons.math3.optimization.linear.SimplexSolver"}, {"bug_name": "Math_29", "report_text": "> Bugs in RealVector.ebeMultiply(RealVector) and ebeDivide(RealVector)\n> \n> OpenMapRealVector.ebeMultiply(RealVector) and OpenMapRealVector.ebeDivide(RealVector) return wrong values when one entry of the specified RealVector is nan or infinity. The bug is easy to understand. Here is the current implementation of ebeMultiply\n> ```\n>     public OpenMapRealVector ebeMultiply(RealVector v) {\n>         checkVectorDimensions(v.getDimension());\n>         OpenMapRealVector res = new OpenMapRealVector(this);\n>         Iterator iter = entries.iterator();\n>         while (iter.hasNext()) {\n>             iter.advance();\n>             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n>         }\n>         return res;\n>     }\n> ```\n> The assumption is that for any double x, x \\* 0d == 0d holds, which is not true. The bug is easy enough to identify, but more complex to solve. The only solution I can come up with is to loop through **all** entries of v (instead of those entries which correspond to non-zero entries of this). I'm afraid about performance losses.", "test_name": "org.apache.commons.math3.linear.SparseRealVectorTest::testEbeDivideMixedTypes", "test_method": "@Test\n    public void testEbeDivideMixedTypes() {\n        doTestEbeBinaryOperation(BinaryOperation.DIV, true);\n    }", "error_message": "junit.framework.AssertionFailedError: entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.apache.commons.math3.linear.RealVectorAbstractTest.doTestEbeBinaryOperation(RealVectorAbstractTest.java:519)\n\torg.apache.commons.math3.linear.RealVectorAbstractTest.testEbeDivideMixedTypes(RealVectorAbstractTest.java:595)", "buggy_method": "340 @Override\n341     public OpenMapRealVector ebeDivide(RealVector v) {\n342         checkVectorDimensions(v.getDimension());\n343         OpenMapRealVector res = new OpenMapRealVector(this);\n344         /*\n345          * MATH-803: it is not sufficient to loop through non zero entries of\n346          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n347          * this[i] / v[i] = NaN, and not 0d.\n348          */\n349         Iterator iter = entries.iterator();\n350         while (iter.hasNext()) {\n351             iter.advance();\n352             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n353         }\n354         return res;\n355     }", "bm_classpath": "org.apache.commons.math3.linear.OpenMapRealVector"}, {"bug_name": "Math_30", "report_text": "> Mann-Whitney U Test Suffers From Integer Overflow With Large Data Sets\n> \n> When performing a Mann-Whitney U Test on large data sets (the attached test uses two 1500 element sets), intermediate integer values used in calculateAsymptoticPValue can overflow, leading to invalid results, such as p-values of NaN, or incorrect calculations.\n> Attached is a patch, including a test, and a fix, which modifies the affected code to use doubles", "test_name": "org.apache.commons.math3.stat.inference.MannWhitneyUTestTest::testBigDataSet", "test_method": "    @Test\n    public void testBigDataSet() throws Exception {\n        double[] d1 = new double[1500];\n        double[] d2 = new double[1500];\n        for (int i = 0; i < 1500; i++) {\n            d1[i] = 2 * i;\n            d2[i] = 2 * i + 1;\n        }\n        double result = testStatistic.mannWhitneyUTest(d1, d2);\n        Assert.assertTrue(result > 0.1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math3.stat.inference.MannWhitneyUTestTest.testBigDataSet(MannWhitneyUTestTest.java:113)", "buggy_method": "168 private double calculateAsymptoticPValue(final double Umin,\n169                                              final int n1,\n170                                              final int n2)\n171         throws ConvergenceException, MaxCountExceededException {\n172 \n173         final int n1n2prod = n1 * n2;\n174 \n175         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n176         final double EU = n1n2prod / 2.0;\n177         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n178 \n179         final double z = (Umin - EU) / FastMath.sqrt(VarU);\n180 \n181         final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n182 \n183         return 2 * standardNormal.cumulativeProbability(z);\n184     }", "bm_classpath": "org.apache.commons.math3.stat.inference.MannWhitneyUTest"}, {"bug_name": "Math_31", "report_text": "> inverseCumulativeProbability of BinomialDistribution returns wrong value for large trials.\n> \n> The inverseCumulativeProbability method of the BinomialDistributionImpl class returns wrong value for large trials. Following code will be reproduce the problem.\n> System.out.println(new BinomialDistributionImpl(1000000, 0.5).inverseCumulativeProbability(0.5));\n> This returns 499525, though it should be 499999.\n> I'm not sure how it should be fixed, but the cause is that the cumulativeProbability method returns Infinity, not NaN. As the result the checkedCumulativeProbability method doesn't work as expected.", "test_name": "org.apache.commons.math3.distribution.BinomialDistributionTest::testMath718", "test_method": "    @Test\n    public void testMath718() {\n        // for large trials the evaluation of ContinuedFraction was inaccurate\n        // do a sweep over several large trials to test if the current implementation is\n        // numerically stable.\n\n        for (int trials = 500000; trials < 20000000; trials += 100000) {\n            BinomialDistribution dist = new BinomialDistribution(trials, 0.5);\n            int p = dist.inverseCumulativeProbability(0.5);\n            Assert.assertEquals(trials / 2, p);\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.math3.exception.ConvergenceException: illegal state: Continued fraction diverged to NaN for value 0.5\n\torg.apache.commons.math3.util.ContinuedFraction.evaluate(ContinuedFraction.java:177)\n\torg.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:154)\n\torg.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:129)\n\torg.apache.commons.math3.special.Beta.regularizedBeta(Beta.java:50)\n\torg.apache.commons.math3.distribution.BinomialDistribution.cumulativeProbability(BinomialDistribution.java:101)\n\torg.apache.commons.math3.distribution.AbstractIntegerDistribution.checkedCumulativeProbability(AbstractIntegerDistribution.java:201)\n\torg.apache.commons.math3.distribution.AbstractIntegerDistribution.solveInverseCumulativeProbability(AbstractIntegerDistribution.java:143)\n\torg.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability(AbstractIntegerDistribution.java:116)\n\torg.apache.commons.math3.distribution.BinomialDistributionTest.testMath718(BinomialDistributionTest.java:140)", "buggy_method": "123 public double evaluate(double x, double epsilon, int maxIterations) {\n124         final double small = 1e-50;\n125         double hPrev = getA(0, x);\n126 \n127         // use the value of small as epsilon criteria for zero checks\n128         if (Precision.equals(hPrev, 0.0, small)) {\n129             hPrev = small;\n130         }\n131 \n132         int n = 1;\n133         double dPrev = 0.0;\n134         double p0 = 1.0;\n135         double q1 = 1.0;\n136         double cPrev = hPrev;\n137         double hN = hPrev;\n138 \n139         while (n < maxIterations) {\n140             final double a = getA(n, x);\n141             final double b = getB(n, x);\n142 \n143             double cN = a * hPrev + b * p0;\n144             double q2 = a * q1 + b * dPrev;\n145             if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n146                 double scaleFactor = 1d;\n147                 double lastScaleFactor = 1d;\n148                 final int maxPower = 5;\n149                 final double scale = FastMath.max(a,b);\n150                 if (scale <= 0) {  // Can't scale\n151                     throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n152                 }\n153                 for (int i = 0; i < maxPower; i++) {\n154                     lastScaleFactor = scaleFactor;\n155                     scaleFactor *= scale;\n156                     if (a != 0.0 && a > b) {\n157                         cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n158                         q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n159                     } else if (b != 0) {\n160                         cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n161                         q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n162                     }\n163                     if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n164                         break;\n165                     }\n166                 }\n167             }\n168 \n169             final double deltaN = cN / q2 / cPrev;\n170             hN = cPrev * deltaN;\n171 \n172             if (Double.isInfinite(hN)) {\n173                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n174                                                x);\n175             }\n176             if (Double.isNaN(hN)) {\n177                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n178                                                x);\n179             }\n180 \n181             if (FastMath.abs(deltaN - 1.0) < epsilon) {\n182                 break;\n183             }\n184 \n185             dPrev = q1;\n186             cPrev = cN / q2;\n187             p0 = hPrev;\n188             hPrev = cN;\n189             q1 = q2;\n190             n++;\n191         }\n192 \n193         if (n >= maxIterations) {\n194             throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n195                                                 maxIterations, x);\n196         }\n197 \n198         return hN;\n199     }", "bm_classpath": "org.apache.commons.math3.util.ContinuedFraction"}, {"bug_name": "Math_32", "report_text": "> BSPTree class and recovery of a Euclidean 3D BRep\n> \n> New to the work here. Thanks for your efforts on this code.\n> I create a BSPTree from a BoundaryRep (Brep) my test Brep is a cube as represented by a float array containing 8 3D points in(x,y,z) order and an array of indices (12 triplets for the 12 faces of the cube). I construct a BSPMesh() as shown in the code below. I can construct the PolyhedronsSet() but have problems extracting the faces from the BSPTree to reconstruct the BRep. The attached code (BSPMesh2.java) shows that a small change to 1 of the vertex positions causes/corrects the problem.\n> Any ideas?", "test_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest::testIssue780", "test_method": "    @Test\n    public void testIssue780() {\n        float[] coords = {\n            1.000000f, -1.000000f, -1.000000f, \n            1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, -1.000000f, \n            1.000000f, 1.000000f, -1f, \n            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, -1.000000f};\n        int[] indices = {\n            0, 1, 2, 0, 2, 3, \n            4, 7, 6, 4, 6, 5, \n            0, 4, 5, 0, 5, 1, \n            1, 5, 6, 1, 6, 2, \n            2, 6, 7, 2, 7, 3, \n            4, 0, 3, 4, 3, 7};\n        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n        for (int idx = 0; idx < indices.length; idx += 3) {\n            int idxA = indices[idx] * 3;\n            int idxB = indices[idx + 1] * 3;\n            int idxC = indices[idx + 2] * 3;\n            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n            Vector3D[] vertices = {v_1, v_2, v_3};\n            Plane polyPlane = new Plane(v_1, v_2, v_3);\n            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n\n            Vector2D[] projPts = new Vector2D[vertices.length];\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n            }\n\n            SubLine lineInPlane = null;\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n                lines.add(lineInPlane);\n            }\n            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n            subHyperplaneList.add(polygon);\n        }\n        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\n\torg.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:136)\n\torg.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\n\torg.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.addContribution(PolyhedronsSet.java:171)\n\torg.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitInternalNode(PolyhedronsSet.java:153)\n\torg.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:263)\n\torg.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\n\torg.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\n\torg.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:264)\n\torg.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties(PolyhedronsSet.java:118)\n\torg.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\n\torg.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest.testIssue780(PolyhedronsSetTest.java:281)", "buggy_method": "129 @Override\n130     protected void computeGeometricalProperties() {\n131 \n132         final Vector2D[][] v = getVertices();\n133 \n134         if (v.length == 0) {\n135             final BSPTree<Euclidean2D> tree = getTree(false);\n136             if ((Boolean) tree.getAttribute()) {\n137                 // the instance covers the whole space\n138                 setSize(Double.POSITIVE_INFINITY);\n139                 setBarycenter(Vector2D.NaN);\n140             } else {\n141                 setSize(0);\n142                 setBarycenter(new Vector2D(0, 0));\n143             }\n144         } else if (v[0][0] == null) {\n145             // there is at least one open-loop: the polygon is infinite\n146             setSize(Double.POSITIVE_INFINITY);\n147             setBarycenter(Vector2D.NaN);\n148         } else {\n149             // all loops are closed, we compute some integrals around the shape\n150 \n151             double sum  = 0;\n152             double sumX = 0;\n153             double sumY = 0;\n154 \n155             for (Vector2D[] loop : v) {\n156                 double x1 = loop[loop.length - 1].getX();\n157                 double y1 = loop[loop.length - 1].getY();\n158                 for (final Vector2D point : loop) {\n159                     final double x0 = x1;\n160                     final double y0 = y1;\n161                     x1 = point.getX();\n162                     y1 = point.getY();\n163                     final double factor = x0 * y1 - y0 * x1;\n164                     sum  += factor;\n165                     sumX += factor * (x0 + x1);\n166                     sumY += factor * (y0 + y1);\n167                 }\n168             }\n169 \n170             if (sum < 0) {\n171                 // the polygon as a finite outside surrounded by an infinite inside\n172                 setSize(Double.POSITIVE_INFINITY);\n173                 setBarycenter(Vector2D.NaN);\n174             } else {\n175                 setSize(sum / 2);\n176                 setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n177             }\n178 \n179         }\n180 \n181     }", "bm_classpath": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"}, {"bug_name": "Math_33", "report_text": "> SimplexSolver gives bad results\n> \n> Methode SimplexSolver.optimeze(...) gives bad results with commons-math3-3.0  \n> in a simple test problem. It works well in commons-math-2.2. ", "test_name": "org.apache.commons.math3.optimization.linear.SimplexSolverTest::testMath781", "test_method": "    @Test\n    public void testMath781() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 6, 7 }, 0);\n\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1, 2, 1 }, Relationship.LEQ, 2));\n        constraints.add(new LinearConstraint(new double[] { -1, 1, 1 }, Relationship.LEQ, -1));\n        constraints.add(new LinearConstraint(new double[] { 2, -3, 1 }, Relationship.LEQ, -1));\n\n        double epsilon = 1e-6;\n        SimplexSolver solver = new SimplexSolver();\n        PointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[0], 0.0d, epsilon) > 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math3.optimization.linear.SimplexSolverTest.testMath781(SimplexSolverTest.java:45)", "buggy_method": "327 protected void dropPhase1Objective() {\n328         if (getNumObjectiveFunctions() == 1) {\n329             return;\n330         }\n331 \n332         List<Integer> columnsToDrop = new ArrayList<Integer>();\n333         columnsToDrop.add(0);\n334 \n335         // positive cost non-artificial variables\n336         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n337             final double entry = tableau.getEntry(0, i);\n338             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n339                 columnsToDrop.add(i);\n340             }\n341         }\n342 \n343         // non-basic artificial variables\n344         for (int i = 0; i < getNumArtificialVariables(); i++) {\n345           int col = i + getArtificialVariableOffset();\n346           if (getBasicRow(col) == null) {\n347             columnsToDrop.add(col);\n348           }\n349         }\n350 \n351         double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n352         for (int i = 1; i < getHeight(); i++) {\n353           int col = 0;\n354           for (int j = 0; j < getWidth(); j++) {\n355             if (!columnsToDrop.contains(j)) {\n356               matrix[i - 1][col++] = tableau.getEntry(i, j);\n357             }\n358           }\n359         }\n360 \n361         for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n362           columnLabels.remove((int) columnsToDrop.get(i));\n363         }\n364 \n365         this.tableau = new Array2DRowRealMatrix(matrix);\n366         this.numArtificialVariables = 0;\n367     }", "bm_classpath": "org.apache.commons.math3.optimization.linear.SimplexTableau"}, {"bug_name": "Math_34", "report_text": "> ListPopulation Iterator allows you to remove chromosomes from the population.\n> \n> Calling the iterator method of ListPopulation returns an iterator of the protected modifiable list. Before returning the iterator we should wrap it in an unmodifiable list.", "test_name": "org.apache.commons.math3.genetics.ListPopulationTest::testIterator", "test_method": "public void testIterator() {\n        final ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome>();\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n        chromosomes.add(new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(3)));\n\n        final ListPopulation population = new ListPopulation(10) {\n            public Population nextGeneration() {\n                // not important\n                return null;\n            }\n        };\n\n        population.addChromosomes(chromosomes);\n\n        final Iterator<Chromosome> iter = population.iterator();\n        while (iter.hasNext()) {\n            iter.next();\n            iter.remove();\n        }\n    }\n    \n    @Test(expected=NumberIsTooSmallException.class)", "error_message": "junit.framework.AssertionFailedError: Expected exception: java.lang.UnsupportedOperationException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "208 public Iterator<Chromosome> iterator() {\n209         return chromosomes.iterator();\n210     }", "bm_classpath": "org.apache.commons.math3.genetics.ListPopulation"}, {"bug_name": "Math_35", "report_text": "> Need range checks for elitismRate in ElitisticListPopulation constructors.\n> \n> There is a range check for setting the elitismRate via ElitisticListPopulation's setElitismRate method, but not via the constructors.", "test_name": "org.apache.commons.math3.genetics.ElitisticListPopulationTest::testChromosomeListConstructorTooLow", "test_method": "public void testChromosomeListConstructorTooLow() {\n        final List<Chromosome> chromosomes = Collections.emptyList();\n        final double rate = -0.25;\n        new ElitisticListPopulation(chromosomes, 100, rate);\n    }\n\n    @Test(expected = OutOfRangeException.class)", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math3.exception.OutOfRangeException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "63 public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n64         super(populationLimit);\n65         this.elitismRate = elitismRate;\n66     }", "bm_classpath": "org.apache.commons.math3.genetics.ElitisticListPopulation"}, {"bug_name": "Math_36", "report_text": "> BigFraction.doubleValue() returns Double.NaN for large numerators or denominators\n> \n> The current implementation of doubleValue() divides numerator.doubleValue() / denominator.doubleValue(). BigInteger.doubleValue() fails for any number greater than Double.MAX\\_VALUE. So if the user has 308-digit numerator or denominator, the resulting quotient fails, even in cases where the result would be well inside Double's range.\n> I have a patch to fix it, if I can figure out how to attach it here I will.", "test_name": "org.apache.commons.math.fraction.BigFractionTest::testFloatValueForLargeNumeratorAndDenominator", "test_method": "    @Test\n    public void testFloatValueForLargeNumeratorAndDenominator() {\n        final BigInteger pow400 = BigInteger.TEN.pow(400);\n        final BigInteger pow401 = BigInteger.TEN.pow(401);\n        final BigInteger two = new BigInteger(\"2\");\n        final BigFraction large = new BigFraction(pow401.add(BigInteger.ONE),\n                                                  pow400.multiply(two));\n\n        Assert.assertEquals(5, large.floatValue(), 1e-15); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<5.0> but was:<NaN>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.fraction.BigFractionTest.testFloatValueForLargeNumeratorAndDenominator(BigFractionTest.java:222)", "buggy_method": "683 @Override\n684     public double doubleValue() {\n685         double result = numerator.doubleValue() / denominator.doubleValue();\n686             // Numerator and/or denominator must be out of range:\n687             // Calculate how far to shift them to put them in range.\n688         return result;\n689     }", "bm_classpath": "org.apache.commons.math.fraction.BigFraction"}, {"bug_name": "Math_37", "report_text": "> [math] Complex Tanh for \"big\" numbers\n> \n> Hi,\n> In Complex.java the tanh is computed with the following formula:\n> tanh(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i\n> The problem that I'm finding is that as soon as \"a\" is a \"big\" number,  \n> both sinh(2a) and cosh(2a) are infinity and then the method tanh returns in  \n> the real part NaN (infinity/infinity) when it should return 1.0.\n> Wouldn't it be appropiate to add something as in the FastMath library??:\n> if (real>20.0){  \n>  return createComplex(1.0, 0.0);  \n> }  \n> if (real<-20.0){  \n>  return createComplex(-1.0, 0.0);  \n> }\n> Best regards,\n> JBB", "test_name": "org.apache.commons.math.complex.ComplexTest::testTanhInf", "test_method": "    @Test\n    public void testTanhInf() {\n        TestUtils.assertSame(Complex.valueOf(1.0, 0.0), infOne.tanh()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1.0> but was:<NaN>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.TestUtils.assertSame(TestUtils.java:77)\n\torg.apache.commons.math.TestUtils.assertSame(TestUtils.java:85)\n\torg.apache.commons.math.complex.ComplexTest.testTanhInf(ComplexTest.java:1054)", "buggy_method": "1017 public Complex tan() {\n1018         if (isNaN) {\n1019             return NaN;\n1020         }\n1021 \n1022         double real2 = 2.0 * real;\n1023         double imaginary2 = 2.0 * imaginary;\n1024         double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n1025 \n1026         return createComplex(FastMath.sin(real2) / d,\n1027                              FastMath.sinh(imaginary2) / d);\n1028     }", "bm_classpath": "org.apache.commons.math.complex.Complex"}, {"bug_name": "Math_38", "report_text": "> Errors in BOBYQAOptimizer when numberOfInterpolationPoints is greater than 2*dim+1\n> \n> I've been having trouble getting BOBYQA to minimize a function (actually a non-linear least squares fit) so as one change I increased the number of interpolation points. It seems that anything larger than 2\\*dim+1 causes an error (typically at\n> line 1662  \n>  interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));\n> I'm guessing there is an off by one error in the translation from FORTRAN. Changing the BOBYQAOptimizerTest as follows (increasing number of interpolation points by one) will cause failures.\n> Bruce\n> Index: src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java  \n> ===================================================================  \n> \u2014 src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java (revision 1221065)  \n> +++ src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java (working copy)  \n> @@ -258,7 +258,7 @@  \n>  // RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);  \n>  final double[] lB = boundaries == null ? null : boundaries[0];  \n>  final double[] uB = boundaries == null ? null : boundaries[1];\n> * BOBYQAOptimizer optim = new BOBYQAOptimizer(2 \\* dim + 1);  \n> + BOBYQAOptimizer optim = new BOBYQAOptimizer(2 \\* dim + 2);  \n>  RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);  \n>  // System.out.println(func.getClass().getName() + \" = \"   \n>  // + optim.getEvaluations() + \" f(\");", "test_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest::testConstrainedRosenWithMoreInterpolationPoints", "test_method": "    @Test\n    public void testConstrainedRosenWithMoreInterpolationPoints() {\n        final double[] startPoint = point(DIM, 0.1);\n        final double[][] boundaries = boundaries(DIM, -1, 2);\n        final RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n\n        // This should have been 78 because in the code the hard limit is\n        // said to be\n        //   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n        // i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n        // 65, 66, ...\n        final int maxAdditionalPoints = 47;\n\n        for (int num = 1; num <= maxAdditionalPoints; num++) {\n            doTest(new Rosen(), startPoint, boundaries,\n                   GoalType.MINIMIZE,\n                   1e-12, 1e-6, 2000,\n                   num,\n                   expected,\n                   \"num=\" + num);\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException: If this exception is thrown, just remove it from the code prelim (at line 1752)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim(BOBYQAOptimizer.java:1752)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqb(BOBYQAOptimizer.java:407)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqa(BOBYQAOptimizer.java:332)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizer.doOptimize(BOBYQAOptimizer.java:244)\n\torg.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(BaseAbstractMultivariateOptimizer.java:125)\n\torg.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(BaseAbstractMultivariateSimpleBoundsOptimizer.java:138)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.doTest(BOBYQAOptimizerTest.java:327)\n\torg.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints(BOBYQAOptimizerTest.java:255)", "buggy_method": "1582 private void prelim(double[] lowerBound,\n1583                         double[] upperBound) {\n1584         printMethod(); // XXX\n1585 \n1586         final int n = currentBest.getDimension();\n1587         final int npt = numberOfInterpolationPoints;\n1588         final int ndim = bMatrix.getRowDimension();\n1589 \n1590         final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n1591         final double recip = 1d / rhosq;\n1592         final int np = n + 1;\n1593 \n1594         // Set XBASE to the initial vector of variables, and set the initial\n1595         // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n1596 \n1597         for (int j = 0; j < n; j++) {\n1598             originShift.setEntry(j, currentBest.getEntry(j));\n1599             for (int k = 0; k < npt; k++) {\n1600                 interpolationPoints.setEntry(k, j, ZERO);\n1601             }\n1602             for (int i = 0; i < ndim; i++) {\n1603                 bMatrix.setEntry(i, j, ZERO);\n1604             }\n1605         }\n1606         for (int i = 0, max = n * np / 2; i < max; i++) {\n1607             modelSecondDerivativesValues.setEntry(i, ZERO);\n1608         }\n1609         for (int k = 0; k < npt; k++) {\n1610             modelSecondDerivativesParameters.setEntry(k, ZERO);\n1611             for (int j = 0, max = npt - np; j < max; j++) {\n1612                 zMatrix.setEntry(k, j, ZERO);\n1613             }\n1614         }\n1615 \n1616         // Begin the initialization procedure. NF becomes one more than the number\n1617         // of function values so far. The coordinates of the displacement of the\n1618         // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n1619 \n1620         int ipt = 0;\n1621         int jpt = 0;\n1622         double fbeg = Double.NaN;\n1623         do {\n1624             final int nfm = getEvaluations();\n1625             final int nfx = nfm - n;\n1626             final int nfmm = nfm - 1;\n1627             final int nfxm = nfx - 1;\n1628             double stepa = 0;\n1629             double stepb = 0;\n1630             if (nfm <= 2 * n) {\n1631                 if (nfm >= 1 &&\n1632                     nfm <= n) {\n1633                     stepa = initialTrustRegionRadius;\n1634                     if (upperDifference.getEntry(nfmm) == ZERO) {\n1635                         stepa = -stepa;\n1636                         throw new PathIsExploredException(); // XXX\n1637                     }\n1638                     interpolationPoints.setEntry(nfm, nfmm, stepa);\n1639                 } else if (nfm > n) {\n1640                     stepa = interpolationPoints.getEntry(nfx, nfxm);\n1641                     stepb = -initialTrustRegionRadius;\n1642                     if (lowerDifference.getEntry(nfxm) == ZERO) {\n1643                         stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n1644                         throw new PathIsExploredException(); // XXX\n1645                     }\n1646                     if (upperDifference.getEntry(nfxm) == ZERO) {\n1647                         stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n1648                         throw new PathIsExploredException(); // XXX\n1649                     }\n1650                     interpolationPoints.setEntry(nfm, nfxm, stepb);\n1651                 }\n1652             } else {\n1653                 final int tmp1 = (nfm - np) / n;\n1654                 jpt = nfm - tmp1 * n - n;\n1655                 ipt = jpt + tmp1;\n1656                 if (ipt > n) {\n1657                     final int tmp2 = jpt;\n1658                     jpt = ipt - n;\n1659                     ipt = tmp2;\n1660                     throw new PathIsExploredException(); // XXX\n1661                 }\n1662                 final int iptMinus1 = ipt;\n1663                 final int jptMinus1 = jpt;\n1664                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n1665                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n1666             }\n1667 \n1668             // Calculate the next value of F. The least function value so far and\n1669             // its index are required.\n1670 \n1671             for (int j = 0; j < n; j++) {\n1672                 currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n1673                                                           originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n1674                                                  upperBound[j]));\n1675                 if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n1676                     currentBest.setEntry(j, lowerBound[j]);\n1677                 }\n1678                 if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n1679                     currentBest.setEntry(j, upperBound[j]);\n1680                 }\n1681             }\n1682 \n1683             final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n1684             final double f = isMinimize ? objectiveValue : -objectiveValue;\n1685             final int numEval = getEvaluations(); // nfm + 1\n1686             fAtInterpolationPoints.setEntry(nfm, f);\n1687 \n1688             if (numEval == 1) {\n1689                 fbeg = f;\n1690                 trustRegionCenterInterpolationPointIndex = 0;\n1691             } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n1692                 trustRegionCenterInterpolationPointIndex = nfm;\n1693             }\n1694 \n1695             // Set the nonzero initial elements of BMAT and the quadratic model in the\n1696             // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n1697             // of the NF-th and (NF-N)-th interpolation points may be switched, in\n1698             // order that the function value at the first of them contributes to the\n1699             // off-diagonal second derivative terms of the initial quadratic model.\n1700 \n1701             if (numEval <= 2 * n + 1) {\n1702                 if (numEval >= 2 &&\n1703                     numEval <= n + 1) {\n1704                     gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n1705                     if (npt < numEval + n) {\n1706                         final double oneOverStepA = ONE / stepa;\n1707                         bMatrix.setEntry(0, nfmm, -oneOverStepA);\n1708                         bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n1709                         bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n1710                         throw new PathIsExploredException(); // XXX\n1711                     }\n1712                 } else if (numEval >= n + 2) {\n1713                     final int ih = nfx * (nfx + 1) / 2 - 1;\n1714                     final double tmp = (f - fbeg) / stepb;\n1715                     final double diff = stepb - stepa;\n1716                     modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n1717                     gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n1718                     if (stepa * stepb < ZERO) {\n1719                         if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n1720                             fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n1721                             fAtInterpolationPoints.setEntry(nfm - n, f);\n1722                             if (trustRegionCenterInterpolationPointIndex == nfm) {\n1723                                 trustRegionCenterInterpolationPointIndex = nfm - n;\n1724                             }\n1725                             interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n1726                             interpolationPoints.setEntry(nfm, nfxm, stepa);\n1727                         }\n1728                     }\n1729                     bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n1730                     bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n1731                     bMatrix.setEntry(nfm - n, nfxm,\n1732                                   -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n1733                     zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n1734                     zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n1735                     // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n1736                     zMatrix.setEntry(nfm - n, nfxm,\n1737                                   -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n1738                 }\n1739 \n1740                 // Set the off-diagonal second derivatives of the Lagrange functions and\n1741                 // the initial quadratic model.\n1742 \n1743             } else {\n1744                 zMatrix.setEntry(0, nfxm, recip);\n1745                 zMatrix.setEntry(nfm, nfxm, recip);\n1746                 zMatrix.setEntry(ipt, nfxm, -recip);\n1747                 zMatrix.setEntry(jpt, nfxm, -recip);\n1748 \n1749                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n1750                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n1751                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n1752                 throw new PathIsExploredException(); // XXX\n1753             }\n1754         } while (getEvaluations() < npt);\n1755     } // prelim", "bm_classpath": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer"}, {"bug_name": "Math_39", "report_text": "> too large first step with embedded Runge-Kutta integrators (Dormand-Prince 8(5,3) ...)\n> \n> Adaptive step size integrators compute the first step size by themselves if it is not provided.  \n> For embedded Runge-Kutta type, this step size is not checked against the integration range, so if the integration range is extremely short, this step size may evaluate the function out of the range (and in fact it tries afterward to go back, and fails to stop). Gragg-Bulirsch-Stoer integrators do not have this problem, the step size is checked and truncated if needed.", "test_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest::testTooLargeFirstStep", "test_method": "  @Test\n  public void testTooLargeFirstStep() {\n\n      AdaptiveStepsizeIntegrator integ =\n              new DormandPrince853Integrator(0, Double.POSITIVE_INFINITY, Double.NaN, Double.NaN);\n      final double start = 0.0;\n      final double end   = 0.001;\n      FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return 1;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              Assert.assertTrue(t >= FastMath.nextAfter(start, Double.NEGATIVE_INFINITY));\n              Assert.assertTrue(t <= FastMath.nextAfter(end,   Double.POSITIVE_INFINITY));\n              yDot[0] = -100.0 * y[0];\n          }\n\n      };\n\n      integ.setStepSizeControl(0, 1.0, 1.0e-6, 1.0e-8);\n      integ.integrate(equations, start, new double[] { 1.0 }, end, new double[1]); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest$3.computeDerivatives(DormandPrince853IntegratorTest.java:194)\n\torg.apache.commons.math.ode.ExpandableStatefulODE.computeDerivatives(ExpandableStatefulODE.java:115)\n\torg.apache.commons.math.ode.AbstractIntegrator.computeDerivatives(AbstractIntegrator.java:265)\n\torg.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:262)\n\torg.apache.commons.math.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:228)\n\torg.apache.commons.math.ode.nonstiff.DormandPrince853IntegratorTest.testTooLargeFirstStep(DormandPrince853IntegratorTest.java:201)", "buggy_method": "190 @Override\n191   public void integrate(final ExpandableStatefulODE equations, final double t)\n192       throws MathIllegalStateException, MathIllegalArgumentException {\n193 \n194     sanityChecks(equations, t);\n195     setEquations(equations);\n196     final boolean forward = t > equations.getTime();\n197 \n198     // create some internal working arrays\n199     final double[] y0  = equations.getCompleteState();\n200     final double[] y = y0.clone();\n201     final int stages = c.length + 1;\n202     final double[][] yDotK = new double[stages][y.length];\n203     final double[] yTmp    = y0.clone();\n204     final double[] yDotTmp = new double[y.length];\n205 \n206     // set up an interpolator sharing the integrator arrays\n207     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n208     interpolator.reinitialize(this, yTmp, yDotK, forward,\n209                               equations.getPrimaryMapper(), equations.getSecondaryMappers());\n210     interpolator.storeTime(equations.getTime());\n211 \n212     // set up integration control objects\n213     stepStart         = equations.getTime();\n214     double  hNew      = 0;\n215     boolean firstTime = true;\n216     initIntegration(equations.getTime(), y0, t);\n217 \n218     // main integration loop\n219     isLastStep = false;\n220     do {\n221 \n222       interpolator.shift();\n223 \n224       // iterate over step size, ensuring local normalized error is smaller than 1\n225       double error = 10;\n226       while (error >= 1.0) {\n227 \n228         if (firstTime || !fsal) {\n229           // first stage\n230           computeDerivatives(stepStart, y, yDotK[0]);\n231         }\n232 \n233         if (firstTime) {\n234           final double[] scale = new double[mainSetDimension];\n235           if (vecAbsoluteTolerance == null) {\n236               for (int i = 0; i < scale.length; ++i) {\n237                 scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n238               }\n239           } else {\n240               for (int i = 0; i < scale.length; ++i) {\n241                 scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n242               }\n243           }\n244           hNew = initializeStep(forward, getOrder(), scale,\n245                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n246           firstTime = false;\n247         }\n248 \n249         stepSize = hNew;\n250 \n251         // next stages\n252         for (int k = 1; k < stages; ++k) {\n253 \n254           for (int j = 0; j < y0.length; ++j) {\n255             double sum = a[k-1][0] * yDotK[0][j];\n256             for (int l = 1; l < k; ++l) {\n257               sum += a[k-1][l] * yDotK[l][j];\n258             }\n259             yTmp[j] = y[j] + stepSize * sum;\n260           }\n261 \n262           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n263 \n264         }\n265 \n266         // estimate the state at the end of the step\n267         for (int j = 0; j < y0.length; ++j) {\n268           double sum    = b[0] * yDotK[0][j];\n269           for (int l = 1; l < stages; ++l) {\n270             sum    += b[l] * yDotK[l][j];\n271           }\n272           yTmp[j] = y[j] + stepSize * sum;\n273         }\n274 \n275         // estimate the error at the end of the step\n276         error = estimateError(yDotK, y, yTmp, stepSize);\n277         if (error >= 1.0) {\n278           // reject the step and attempt to reduce error by stepsize control\n279           final double factor =\n280               FastMath.min(maxGrowth,\n281                            FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n282           hNew = filterStep(stepSize * factor, forward, false);\n283         }\n284 \n285       }\n286 \n287       // local error is small enough: accept the step, trigger events and step handlers\n288       interpolator.storeTime(stepStart + stepSize);\n289       System.arraycopy(yTmp, 0, y, 0, y0.length);\n290       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n291       stepStart = acceptStep(interpolator, y, yDotTmp, t);\n292       System.arraycopy(y, 0, yTmp, 0, y.length);\n293 \n294       if (!isLastStep) {\n295 \n296           // prepare next step\n297           interpolator.storeTime(stepStart);\n298 \n299           if (fsal) {\n300               // save the last evaluation for the next step\n301               System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n302           }\n303 \n304           // stepsize control for next step\n305           final double factor =\n306               FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n307           final double  scaledH    = stepSize * factor;\n308           final double  nextT      = stepStart + scaledH;\n309           final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n310           hNew = filterStep(scaledH, forward, nextIsLast);\n311 \n312           final double  filteredNextT      = stepStart + hNew;\n313           final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n314           if (filteredNextIsLast) {\n315               hNew = t - stepStart;\n316           }\n317 \n318       }\n319 \n320     } while (!isLastStep);\n321 \n322     // dispatch results\n323     equations.setTime(stepStart);\n324     equations.setCompleteState(y);\n325 \n326     resetInternalState();\n327 \n328   }", "bm_classpath": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator"}, {"bug_name": "Math_40", "report_text": "> BracketingNthOrderBrentSolver exceeds maxIterationCount while updating always the same boundary\n> \n> In some cases, the aging feature in BracketingNthOrderBrentSolver fails.  \n> It attempts to balance the bracketing points by targeting a non-zero value instead of the real root. However, the chosen target is too close too zero, and the inverse polynomial approximation is always on the same side, thus always updates the same bracket.  \n> In the real used case for a large program, I had a bracket point xA = 12500.0, yA = 3.7e-16, agingA = 0, which is the (really good) estimate of the zero on one side of the root and xB = 12500.03, yB = -7.0e-5, agingB = 97. This shows that the bracketing interval is completely unbalanced, and we never succeed to rebalance it as we always updates (xA, yA) and never updates (xB, yB).", "test_name": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest::testIssue716", "test_method": "    @Test\n    public void testIssue716() {\n        BracketingNthOrderBrentSolver solver =\n                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\n        UnivariateFunction sharpTurn = new UnivariateFunction() {\n            public double value(double x) {\n                return (2 * x + 1) / (1.0e9 * (x + 1));\n            }\n        };\n        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE); // <-- fails here\n    }", "error_message": "org.apache.commons.math.exception.TooManyEvaluationsException: illegal state: maximal count (100) exceeded: evaluations\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.incrementEvaluationCount(BaseAbstractUnivariateRealSolver.java:296)\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.computeObjectiveValue(BaseAbstractUnivariateRealSolver.java:153)\n\torg.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.doSolve(BracketingNthOrderBrentSolver.java:283)\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(BaseAbstractUnivariateRealSolver.java:190)\n\torg.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.solve(BracketingNthOrderBrentSolver.java:394)\n\torg.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest.testIssue716(BracketingNthOrderBrentSolverTest.java:93)", "buggy_method": "142 @Override\n143     protected double doSolve() {\n144 \n145         // prepare arrays with the first points\n146         final double[] x = new double[maximalOrder + 1];\n147         final double[] y = new double[maximalOrder + 1];\n148         x[0] = getMin();\n149         x[1] = getStartValue();\n150         x[2] = getMax();\n151         verifySequence(x[0], x[1], x[2]);\n152 \n153         // evaluate initial guess\n154         y[1] = computeObjectiveValue(x[1]);\n155         if (Precision.equals(y[1], 0.0, 1)) {\n156             // return the initial guess if it is a perfect root.\n157             return x[1];\n158         }\n159 \n160         // evaluate first  endpoint\n161         y[0] = computeObjectiveValue(x[0]);\n162         if (Precision.equals(y[0], 0.0, 1)) {\n163             // return the first endpoint if it is a perfect root.\n164             return x[0];\n165         }\n166 \n167         int nbPoints;\n168         int signChangeIndex;\n169         if (y[0] * y[1] < 0) {\n170 \n171             // reduce interval if it brackets the root\n172             nbPoints        = 2;\n173             signChangeIndex = 1;\n174 \n175         } else {\n176 \n177             // evaluate second endpoint\n178             y[2] = computeObjectiveValue(x[2]);\n179             if (Precision.equals(y[2], 0.0, 1)) {\n180                 // return the second endpoint if it is a perfect root.\n181                 return x[2];\n182             }\n183 \n184             if (y[1] * y[2] < 0) {\n185                 // use all computed point as a start sampling array for solving\n186                 nbPoints        = 3;\n187                 signChangeIndex = 2;\n188             } else {\n189                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n190             }\n191 \n192         }\n193 \n194         // prepare a work array for inverse polynomial interpolation\n195         final double[] tmpX = new double[x.length];\n196 \n197         // current tightest bracketing of the root\n198         double xA    = x[signChangeIndex - 1];\n199         double yA    = y[signChangeIndex - 1];\n200         double absYA = FastMath.abs(yA);\n201         int agingA   = 0;\n202         double xB    = x[signChangeIndex];\n203         double yB    = y[signChangeIndex];\n204         double absYB = FastMath.abs(yB);\n205         int agingB   = 0;\n206 \n207         // search loop\n208         while (true) {\n209 \n210             // check convergence of bracketing interval\n211             final double xTol = getAbsoluteAccuracy() +\n212                                 getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n213             if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n214                 switch (allowed) {\n215                 case ANY_SIDE :\n216                     return absYA < absYB ? xA : xB;\n217                 case LEFT_SIDE :\n218                     return xA;\n219                 case RIGHT_SIDE :\n220                     return xB;\n221                 case BELOW_SIDE :\n222                     return (yA <= 0) ? xA : xB;\n223                 case ABOVE_SIDE :\n224                     return (yA <  0) ? xB : xA;\n225                 default :\n226                     // this should never happen\n227                     throw new MathInternalError(null);\n228                 }\n229             }\n230 \n231             // target for the next evaluation point\n232             double targetY;\n233             if (agingA >= MAXIMAL_AGING) {\n234                 // we keep updating the high bracket, try to compensate this\n235                 targetY = -REDUCTION_FACTOR * yB;\n236             } else if (agingB >= MAXIMAL_AGING) {\n237                 // we keep updating the low bracket, try to compensate this\n238                 targetY = -REDUCTION_FACTOR * yA;\n239             } else {\n240                 // bracketing is balanced, try to find the root itself\n241                 targetY = 0;\n242             }\n243 \n244             // make a few attempts to guess a root,\n245             double nextX;\n246             int start = 0;\n247             int end   = nbPoints;\n248             do {\n249 \n250                 // guess a value for current target, using inverse polynomial interpolation\n251                 System.arraycopy(x, start, tmpX, start, end - start);\n252                 nextX = guessX(targetY, tmpX, y, start, end);\n253 \n254                 if (!((nextX > xA) && (nextX < xB))) {\n255                     // the guessed root is not strictly inside of the tightest bracketing interval\n256 \n257                     // the guessed root is either not strictly inside the interval or it\n258                     // is a NaN (which occurs when some sampling points share the same y)\n259                     // we try again with a lower interpolation order\n260                     if (signChangeIndex - start >= end - signChangeIndex) {\n261                         // we have more points before the sign change, drop the lowest point\n262                         ++start;\n263                     } else {\n264                         // we have more points after sign change, drop the highest point\n265                         --end;\n266                     }\n267 \n268                     // we need to do one more attempt\n269                     nextX = Double.NaN;\n270 \n271                 }\n272 \n273             } while (Double.isNaN(nextX) && (end - start > 1));\n274 \n275             if (Double.isNaN(nextX)) {\n276                 // fall back to bisection\n277                 nextX = xA + 0.5 * (xB - xA);\n278                 start = signChangeIndex - 1;\n279                 end   = signChangeIndex;\n280             }\n281 \n282             // evaluate the function at the guessed root\n283             final double nextY = computeObjectiveValue(nextX);\n284             if (Precision.equals(nextY, 0.0, 1)) {\n285                 // we have found an exact root, since it is not an approximation\n286                 // we don't need to bother about the allowed solutions setting\n287                 return nextX;\n288             }\n289 \n290             if ((nbPoints > 2) && (end - start != nbPoints)) {\n291 \n292                 // we have been forced to ignore some points to keep bracketing,\n293                 // they are probably too far from the root, drop them from now on\n294                 nbPoints = end - start;\n295                 System.arraycopy(x, start, x, 0, nbPoints);\n296                 System.arraycopy(y, start, y, 0, nbPoints);\n297                 signChangeIndex -= start;\n298 \n299             } else  if (nbPoints == x.length) {\n300 \n301                 // we have to drop one point in order to insert the new one\n302                 nbPoints--;\n303 \n304                 // keep the tightest bracketing interval as centered as possible\n305                 if (signChangeIndex >= (x.length + 1) / 2) {\n306                     // we drop the lowest point, we have to shift the arrays and the index\n307                     System.arraycopy(x, 1, x, 0, nbPoints);\n308                     System.arraycopy(y, 1, y, 0, nbPoints);\n309                     --signChangeIndex;\n310                 }\n311 \n312             }\n313 \n314             // insert the last computed point\n315             //(by construction, we know it lies inside the tightest bracketing interval)\n316             System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n317             x[signChangeIndex] = nextX;\n318             System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n319             y[signChangeIndex] = nextY;\n320             ++nbPoints;\n321 \n322             // update the bracketing interval\n323             if (nextY * yA <= 0) {\n324                 // the sign change occurs before the inserted point\n325                 xB = nextX;\n326                 yB = nextY;\n327                 absYB = FastMath.abs(yB);\n328                 ++agingA;\n329                 agingB = 0;\n330             } else {\n331                 // the sign change occurs after the inserted point\n332                 xA = nextX;\n333                 yA = nextY;\n334                 absYA = FastMath.abs(yA);\n335                 agingA = 0;\n336                 ++agingB;\n337 \n338                 // update the sign change index\n339                 signChangeIndex++;\n340 \n341             }\n342 \n343         }\n344 \n345     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver"}, {"bug_name": "Math_41", "report_text": "> One of Variance.evaluate() methods does not work correctly\n> \n> The method org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[] values, double[] weights, double mean, int begin, int length) does not work properly. Looks loke it ignores the length parameter and grabs the whole dataset.  \n> Similar method in Mean class seems to work.  \n> I did not check other methods taking the part of the array; they may have the same problem.\n> Workaround: I had to shrink my arrays and use the method without the length.", "test_name": "org.apache.commons.math.stat.descriptive.moment.VarianceTest::testEvaluateArraySegmentWeighted", "test_method": "@Test\n    public void testEvaluateArraySegmentWeighted() {\n        // See if this statistic computes weighted statistics\n        // If not, skip this test\n        UnivariateStatistic statistic = getUnivariateStatistic();\n        if (!(statistic instanceof WeightedEvaluation)) {\n            return;\n        }\n        final WeightedEvaluation stat = (WeightedEvaluation) getUnivariateStatistic();\n        final double[] arrayZero = new double[5];\n        final double[] weightZero = new double[5];\n        System.arraycopy(testArray, 0, arrayZero, 0, 5);\n        System.arraycopy(testWeightsArray, 0, weightZero, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayZero, weightZero),\n                stat.evaluate(testArray, testWeightsArray, 0, 5), 0);\n        final double[] arrayOne = new double[5];\n        final double[] weightOne = new double[5];\n        System.arraycopy(testArray, 5, arrayOne, 0, 5);\n        System.arraycopy(testWeightsArray, 5, weightOne, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayOne, weightOne),\n                stat.evaluate(testArray, testWeightsArray, 5, 5), 0);\n        final double[] arrayEnd = new double[5];\n        final double[] weightEnd = new double[5];\n        System.arraycopy(testArray, testArray.length - 5, arrayEnd, 0, 5);\n        System.arraycopy(testWeightsArray, testArray.length - 5, weightEnd, 0, 5);\n        Assert.assertEquals(stat.evaluate(arrayEnd, weightEnd),\n                stat.evaluate(testArray, testWeightsArray, testArray.length - 5, 5), 0);\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1.6644508338125354> but was:<0.31909161062727365>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest.testEvaluateArraySegmentWeighted(UnivariateStatisticAbstractTest.java:130)", "buggy_method": "501 public double evaluate(final double[] values, final double[] weights,\n502                            final double mean, final int begin, final int length) {\n503 \n504         double var = Double.NaN;\n505 \n506         if (test(values, weights, begin, length)) {\n507             if (length == 1) {\n508                 var = 0.0;\n509             } else if (length > 1) {\n510                 double accum = 0.0;\n511                 double dev = 0.0;\n512                 double accum2 = 0.0;\n513                 for (int i = begin; i < begin + length; i++) {\n514                     dev = values[i] - mean;\n515                     accum += weights[i] * (dev * dev);\n516                     accum2 += weights[i] * dev;\n517                 }\n518 \n519                 double sumWts = 0;\n520                 for (int i = 0; i < weights.length; i++) {\n521                     sumWts += weights[i];\n522                 }\n523 \n524                 if (isBiasCorrected) {\n525                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n526                 } else {\n527                     var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n528                 }\n529             }\n530         }\n531         return var;\n532     }", "bm_classpath": "org.apache.commons.math.stat.descriptive.moment.Variance"}, {"bug_name": "Math_42", "report_text": "> Negative value with restrictNonNegative\n> \n> Problem: commons-math-2.2 SimplexSolver.\n> A variable with 0 coefficient may be assigned a negative value nevertheless restrictToNonnegative flag in call:  \n> SimplexSolver.optimize(function, constraints, GoalType.MINIMIZE, true);\n> Function  \n> 1 \\* x + 1 \\* y + 0\n> Constraints:  \n> 1 \\* x + 0 \\* y = 1\n> Result:  \n> x = 1; y = -1;\n> Probably variables with 0 coefficients are omitted at some point of computation and because of that the restrictions do not affect their values.", "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath713NegativeVariable", "test_method": "    @Test\n    public void testMath713NegativeVariable() {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] {1.0, 1.0}, 0.0d);\n        ArrayList<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.EQ, 1));\n\n        double epsilon = 1e-6;\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n\n        Assert.assertTrue(Precision.compareTo(solution.getPoint()[1], 0.0d, epsilon) >= 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.optimization.linear.SimplexSolverTest.testMath713NegativeVariable(SimplexSolverTest.java:43)", "buggy_method": "396 protected RealPointValuePair getSolution() {\n397       int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n398       Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n399       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n400 \n401       Set<Integer> basicRows = new HashSet<Integer>();\n402       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n403       for (int i = 0; i < coefficients.length; i++) {\n404           int colIndex = columnLabels.indexOf(\"x\" + i);\n405           if (colIndex < 0) {\n406             coefficients[i] = 0;\n407             continue;\n408           }\n409           Integer basicRow = getBasicRow(colIndex);\n410               // if the basic row is found to be the objective function row\n411               // set the coefficient to 0 -> this case handles unconstrained \n412               // variables that are still part of the objective function\n413           if (basicRows.contains(basicRow)) {\n414               // if multiple variables can take a given value\n415               // then we choose the first and set the rest equal to 0\n416               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n417           } else {\n418               basicRows.add(basicRow);\n419               coefficients[i] =\n420                   (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n421                   (restrictToNonNegative ? 0 : mostNegative);\n422           }\n423       }\n424       return new RealPointValuePair(coefficients, f.getValue(coefficients));\n425     }", "bm_classpath": "org.apache.commons.math.optimization.linear.SimplexTableau"}, {"bug_name": "Math_43", "report_text": "> Statistics.setVarianceImpl makes getStandardDeviation produce NaN\n> \n> Invoking SummaryStatistics.setVarianceImpl(new Variance(true/false) makes getStandardDeviation produce NaN. The code to reproduce it:\n> ```\n> int[] scores = {1, 2, 3, 4};\n> SummaryStatistics stats = new SummaryStatistics();\n> stats.setVarianceImpl(new Variance(false)); //use \"population variance\"\n> for(int i : scores) {\n>   stats.addValue(i);\n> }\n> double sd = stats.getStandardDeviation();\n> System.out.println(sd);\n> ```\n> A workaround suggested by Mikkel is:\n> ```\n>   double sd = FastMath.sqrt(stats.getSecondMoment() / stats.getN());\n> ```", "test_name": "org.apache.commons.math.stat.descriptive.SummaryStatisticsTest::testOverrideMeanWithMathClass", "test_method": "    @Test\n    public void testOverrideMeanWithMathClass() throws Exception {\n        double[] scores = {1, 2, 3, 4};\n        SummaryStatistics stats = new SummaryStatistics();\n        stats.setMeanImpl(new Mean()); \n        for(double i : scores) {\n          stats.addValue(i);\n        }\n        Assert.assertEquals((new Mean()).evaluate(scores),stats.getMean(), 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2.5> but was:<NaN>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.stat.descriptive.SummaryStatisticsTest.testOverrideMeanWithMathClass(SummaryStatisticsTest.java:335)", "buggy_method": "149 public void addValue(double value) {\n150         sumImpl.increment(value);\n151         sumsqImpl.increment(value);\n152         minImpl.increment(value);\n153         maxImpl.increment(value);\n154         sumLogImpl.increment(value);\n155         secondMoment.increment(value);\n156         // If mean, variance or geomean have been overridden,\n157         // need to increment these\n158         if (!(meanImpl instanceof Mean)) {\n159             meanImpl.increment(value);\n160         }\n161         if (!(varianceImpl instanceof Variance)) {\n162             varianceImpl.increment(value);\n163         }\n164         if (!(geoMeanImpl instanceof GeometricMean)) {\n165             geoMeanImpl.increment(value);\n166         }\n167         n++;\n168     }", "bm_classpath": "org.apache.commons.math.stat.descriptive.SummaryStatistics"}, {"bug_name": "Math_44", "report_text": "> Incomplete reinitialization with some events handling\n> \n> I get a bug with event handling: I track 2 events that occur in the same step, when the first one is accepted, it resets the state but the reinitialization is not complete and the second one becomes unable to find its way.  \n> I can't give my context, which is rather large, but I tried a patch that works for me, unfortunately it breaks the unit tests.", "test_name": "org.apache.commons.math.ode.events.EventStateTest::testIssue695", "test_method": "    @Test\n    public void testIssue695() {\n\n        FirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\n            \n            public int getDimension() {\n                return 1;\n            }\n            \n            public void computeDerivatives(double t, double[] y, double[] yDot) {\n                yDot[0] = 1.0;\n            }\n        };\n\n        DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\n        integrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\n        integrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\n        integrator.setInitialStepSize(3.0);\n\n        double target = 30.0;\n        double[] y = new double[1];\n        double tEnd = integrator.integrate(equation, 0.0, y, target, y); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: going backard in time! (7.796578226186635 < 10.99)\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.apache.commons.math.ode.events.EventStateTest$ResettingEvent.g(EventStateTest.java:120)\n\torg.apache.commons.math.ode.events.EventState.evaluateStep(EventState.java:214)\n\torg.apache.commons.math.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:302)\n\torg.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:296)\n\torg.apache.commons.math.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:213)\n\torg.apache.commons.math.ode.events.EventStateTest.testIssue695(EventStateTest.java:100)", "buggy_method": "274 protected double acceptStep(final AbstractStepInterpolator interpolator,\n275                                 final double[] y, final double[] yDot, final double tEnd)\n276         throws MathIllegalStateException {\n277 \n278             double previousT = interpolator.getGlobalPreviousTime();\n279             final double currentT = interpolator.getGlobalCurrentTime();\n280             resetOccurred = false;\n281 \n282             // initialize the events states if needed\n283             if (! statesInitialized) {\n284                 for (EventState state : eventsStates) {\n285                     state.reinitializeBegin(interpolator);\n286                 }\n287                 statesInitialized = true;\n288             }\n289 \n290             // search for next events that may occur during the step\n291             final int orderingSign = interpolator.isForward() ? +1 : -1;\n292             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n293 \n294                 /** {@inheritDoc} */\n295                 public int compare(EventState es0, EventState es1) {\n296                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n297                 }\n298 \n299             });\n300 \n301             for (final EventState state : eventsStates) {\n302                 if (state.evaluateStep(interpolator)) {\n303                     // the event occurs during the current step\n304                     occuringEvents.add(state);\n305                 }\n306             }\n307 \n308             while (!occuringEvents.isEmpty()) {\n309 \n310                 // handle the chronologically first event\n311                 final Iterator<EventState> iterator = occuringEvents.iterator();\n312                 final EventState currentEvent = iterator.next();\n313                 iterator.remove();\n314 \n315                 // restrict the interpolator to the first part of the step, up to the event\n316                 final double eventT = currentEvent.getEventTime();\n317                 interpolator.setSoftPreviousTime(previousT);\n318                 interpolator.setSoftCurrentTime(eventT);\n319 \n320                 // trigger the event\n321                 interpolator.setInterpolatedTime(eventT);\n322                 final double[] eventY = interpolator.getInterpolatedState();\n323                 currentEvent.stepAccepted(eventT, eventY);\n324                 isLastStep = currentEvent.stop();\n325 \n326                 // handle the first part of the step, up to the event\n327                 for (final StepHandler handler : stepHandlers) {\n328                     handler.handleStep(interpolator, isLastStep);\n329                 }\n330 \n331                 if (isLastStep) {\n332                     // the event asked to stop integration\n333                     System.arraycopy(eventY, 0, y, 0, y.length);\n334                     return eventT;\n335                 }\n336 \n337                 if (currentEvent.reset(eventT, eventY)) {\n338                     // some event handler has triggered changes that\n339                     // invalidate the derivatives, we need to recompute them\n340                     System.arraycopy(eventY, 0, y, 0, y.length);\n341                     computeDerivatives(eventT, y, yDot);\n342                     resetOccurred = true;\n343                     return eventT;\n344                 }\n345 \n346                 // prepare handling of the remaining part of the step\n347                 previousT = eventT;\n348                 interpolator.setSoftPreviousTime(eventT);\n349                 interpolator.setSoftCurrentTime(currentT);\n350 \n351                 // check if the same event occurs again in the remaining part of the step\n352                 if (currentEvent.evaluateStep(interpolator)) {\n353                     // the event occurs during the current step\n354                     occuringEvents.add(currentEvent);\n355                 }\n356 \n357             }\n358 \n359             interpolator.setInterpolatedTime(currentT);\n360             final double[] currentY = interpolator.getInterpolatedState();\n361             for (final EventState state : eventsStates) {\n362                 state.stepAccepted(currentT, currentY);\n363                 isLastStep = isLastStep || state.stop();\n364             }\n365             isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n366 \n367             // handle the remaining part of the step, after all events if any\n368             for (StepHandler handler : stepHandlers) {\n369                 handler.handleStep(interpolator, isLastStep);\n370             }\n371 \n372             return currentT;\n373 \n374     }", "bm_classpath": "org.apache.commons.math.ode.AbstractIntegrator"}, {"bug_name": "Math_45", "report_text": "> Integer overflow in OpenMapRealMatrix\n> \n> computeKey() has an integer overflow. Since it is a sparse matrix, this is quite easily encountered long before heap space is exhausted. The attached code demonstrates the problem, which could potentially be a security vulnerability (for example, if one was to use this matrix to store access control information).\n> Workaround: never create an OpenMapRealMatrix with more cells than are addressable with an int.", "test_name": "org.apache.commons.math.linear.OpenMapRealMatrixTest::testMath679", "test_method": "public void testMath679() {\n        new OpenMapRealMatrix(3, Integer.MAX_VALUE);\n    }", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math.exception.NumberIsTooLargeException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "48 public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n49         super(rowDimension, columnDimension);\n50         this.rows = rowDimension;\n51         this.columns = columnDimension;\n52         this.entries = new OpenIntToDoubleHashMap(0.0);\n53     }", "bm_classpath": "org.apache.commons.math.linear.OpenMapRealMatrix"}, {"bug_name": "Math_46", "report_text": "> Division by zero\n> \n> In class Complex, division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO, otherwise the result should be INF. See [here](http://en.wikipedia.org/wiki/Riemann_sphere#Arithmetic_operations).", "test_name": "org.apache.commons.math.complex.ComplexTest::testAtanI", "test_method": "    @Test\n    public void testAtanI() {\n        Assert.assertTrue(Complex.I.atan().isNaN()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.complex.ComplexTest.testAtanI(ComplexTest.java:577)", "buggy_method": "291 public Complex divide(double divisor) {\n292         if (isNaN || Double.isNaN(divisor)) {\n293             return NaN;\n294         }\n295         if (divisor == 0d) {\n296             // return isZero ? NaN : INF; // See MATH-657\n297             return isZero ? NaN : INF;\n298         }\n299         if (Double.isInfinite(divisor)) {\n300             return !isInfinite() ? ZERO : NaN;\n301         }\n302         return createComplex(real / divisor,\n303                              imaginary  / divisor);\n304     }", "bm_classpath": "org.apache.commons.math.complex.Complex"}, {"bug_name": "Math_47", "report_text": "> Division by zero\n> \n> In class Complex, division by zero always returns NaN. I think that it should return NaN only when the numerator is also ZERO, otherwise the result should be INF. See [here](http://en.wikipedia.org/wiki/Riemann_sphere#Arithmetic_operations).", "test_name": "org.apache.commons.math.complex.ComplexTest::testAtanI", "test_method": "    @Test\n    public void testAtanI() {\n        for (int i = -10; i < 10; i++) {\n            System.out.println(new Complex(0, 1 - 0.1 * i).atan());\n        }\n        Assert.assertTrue(Complex.I.atan().isInfinite()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.complex.ComplexTest.testAtanI(ComplexTest.java:579)", "buggy_method": "98 public Complex(double real, double imaginary) {\n99         this.real = real;\n100         this.imaginary = imaginary;\n101 \n102         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n103         isInfinite = !isNaN &&\n104             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n105     }", "bm_classpath": "org.apache.commons.math.complex.Complex"}, {"bug_name": "Math_48", "report_text": "> \"RegulaFalsiSolver\" failure\n> \n> The following unit test:\n> ```\n> @Test\n> public void testBug() {\n>     final UnivariateRealFunction f = new UnivariateRealFunction() {\n>             @Override\n>             public double value(double x) {\n>                 return Math.exp(x) - Math.pow(Math.PI, 3.0);\n>             }\n>         };\n>     UnivariateRealSolver solver = new RegulaFalsiSolver();\n>     double root = solver.solve(100, f, 1, 10);\n> }\n> ```\n> fails with\n> ```\n> illegal state: maximal count (100) exceeded: evaluations\n> ```\n> Using \"PegasusSolver\", the answer is found after 17 evaluations.", "test_name": "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631", "test_method": "    @Test(expected=ConvergenceException.class)\n    public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                /** {@inheritDoc} */\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10); // <-- fails here\n    }", "error_message": "java.lang.Exception: Unexpected exception, expected<org.apache.commons.math.exception.ConvergenceException> but was<org.apache.commons.math.exception.TooManyEvaluationsException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "129 protected final double doSolve() {\n130         // Get initial solution\n131         double x0 = getMin();\n132         double x1 = getMax();\n133         double f0 = computeObjectiveValue(x0);\n134         double f1 = computeObjectiveValue(x1);\n135 \n136         // If one of the bounds is the exact root, return it. Since these are\n137         // not under-approximations or over-approximations, we can return them\n138         // regardless of the allowed solutions.\n139         if (f0 == 0.0) {\n140             return x0;\n141         }\n142         if (f1 == 0.0) {\n143             return x1;\n144         }\n145 \n146         // Verify bracketing of initial solution.\n147         verifyBracketing(x0, x1);\n148 \n149         // Get accuracies.\n150         final double ftol = getFunctionValueAccuracy();\n151         final double atol = getAbsoluteAccuracy();\n152         final double rtol = getRelativeAccuracy();\n153 \n154         // Keep track of inverted intervals, meaning that the left bound is\n155         // larger than the right bound.\n156         boolean inverted = false;\n157 \n158         // Keep finding better approximations.\n159         while (true) {\n160             // Calculate the next approximation.\n161             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n162             final double fx = computeObjectiveValue(x);\n163 \n164             // If the new approximation is the exact root, return it. Since\n165             // this is not an under-approximation or an over-approximation,\n166             // we can return it regardless of the allowed solutions.\n167             if (fx == 0.0) {\n168                 return x;\n169             }\n170 \n171             // Update the bounds with the new approximation.\n172             if (f1 * fx < 0) {\n173                 // The value of x1 has switched to the other bound, thus inverting\n174                 // the interval.\n175                 x0 = x1;\n176                 f0 = f1;\n177                 inverted = !inverted;\n178             } else {\n179                 switch (method) {\n180                 case ILLINOIS:\n181                     f0 *= 0.5;\n182                     break;\n183                 case PEGASUS:\n184                     f0 *= f1 / (f1 + fx);\n185                     break;\n186                 case REGULA_FALSI:\n187                     // Detect early that algorithm is stuck, instead of waiting\n188                     // for the maximum number of iterations to be exceeded.\n189                     break;\n190                 default:\n191                     // Should never happen.\n192                     throw new MathInternalError();\n193                 }\n194             }\n195             // Update from [x0, x1] to [x0, x].\n196             x1 = x;\n197             f1 = fx;\n198 \n199             // If the function value of the last approximation is too small,\n200             // given the function value accuracy, then we can't get closer to\n201             // the root than we already are.\n202             if (FastMath.abs(f1) <= ftol) {\n203                 switch (allowed) {\n204                 case ANY_SIDE:\n205                     return x1;\n206                 case LEFT_SIDE:\n207                     if (inverted) {\n208                         return x1;\n209                     }\n210                     break;\n211                 case RIGHT_SIDE:\n212                     if (!inverted) {\n213                         return x1;\n214                     }\n215                     break;\n216                 case BELOW_SIDE:\n217                     if (f1 <= 0) {\n218                         return x1;\n219                     }\n220                     break;\n221                 case ABOVE_SIDE:\n222                     if (f1 >= 0) {\n223                         return x1;\n224                     }\n225                     break;\n226                 default:\n227                     throw new MathInternalError();\n228                 }\n229             }\n230 \n231             // If the current interval is within the given accuracies, we\n232             // are satisfied with the current approximation.\n233             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n234                                                      atol)) {\n235                 switch (allowed) {\n236                 case ANY_SIDE:\n237                     return x1;\n238                 case LEFT_SIDE:\n239                     return inverted ? x1 : x0;\n240                 case RIGHT_SIDE:\n241                     return inverted ? x0 : x1;\n242                 case BELOW_SIDE:\n243                     return (f1 <= 0) ? x1 : x0;\n244                 case ABOVE_SIDE:\n245                     return (f1 >= 0) ? x1 : x0;\n246                 default:\n247                     throw new MathInternalError();\n248                 }\n249             }\n250         }\n251     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BaseSecantSolver"}, {"bug_name": "Math_49", "report_text": "> MathRuntimeException with simple ebeMultiply on OpenMapRealVector\n> \n> The following piece of code\n> ```\n> import org.apache.commons.math.linear.OpenMapRealVector;\n> import org.apache.commons.math.linear.RealVector;\n> public class DemoBugOpenMapRealVector {\n>     public static void main(String[] args) {\n>         final RealVector u = new OpenMapRealVector(3, 1E-6);\n>         u.setEntry(0, 1.);\n>         u.setEntry(1, 0.);\n>         u.setEntry(2, 2.);\n>         final RealVector v = new OpenMapRealVector(3, 1E-6);\n>         v.setEntry(0, 0.);\n>         v.setEntry(1, 3.);\n>         v.setEntry(2, 0.);\n>         System.out.println(u);\n>         System.out.println(v);\n>         System.out.println(u.ebeMultiply(v));\n>     }\n> }\n> ```\n> raises an exception\n> ```\n> org.apache.commons.math.linear.OpenMapRealVector@7170a9b6\n> Exception in thread \"main\" org.apache.commons.math.MathRuntimeException$6: map has been modified while iterating\n> \tat org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373)\n> \tat org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.advance(OpenIntToDoubleHashMap.java:564)\n> \tat org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372)\n> \tat org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:1)\n> \tat DemoBugOpenMapRealVector.main(DemoBugOpenMapRealVector.java:17)\n> ```", "test_name": "org.apache.commons.math.linear.SparseRealVectorTest::testConcurrentModification", "test_method": "    @Test\n    public void testConcurrentModification() {\n        final RealVector u = new OpenMapRealVector(3, 1e-6);\n        u.setEntry(0, 1);\n        u.setEntry(1, 0);\n        u.setEntry(2, 2);\n\n        final RealVector v1 = new OpenMapRealVector(3, 1e-6);\n        final double[] v2 = new double[3];\n        v1.setEntry(0, 0);\n        v2[0] = 0;\n        v1.setEntry(1, 3);\n        v2[1] = 3;\n        v1.setEntry(2, 0);\n        v2[2] = 0;\n\n        RealVector w;\n\n        w = u.ebeMultiply(v1); // <-- fails here\n    }", "error_message": "org.apache.commons.math.MathRuntimeException$6: map has been modified while iterating\n\torg.apache.commons.math.MathRuntimeException.createConcurrentModificationException(MathRuntimeException.java:373)\n\torg.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.advance(OpenIntToDoubleHashMap.java:564)\n\torg.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:372)\n\torg.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(OpenMapRealVector.java:33)\n\torg.apache.commons.math.linear.SparseRealVectorTest.testConcurrentModification(SparseRealVectorTest.java:1021)", "buggy_method": "354 @Override\n355     public OpenMapRealVector ebeDivide(double[] v) {\n356         checkVectorDimensions(v.length);\n357         OpenMapRealVector res = new OpenMapRealVector(this);\n358         Iterator iter = res.entries.iterator();\n359         while (iter.hasNext()) {\n360             iter.advance();\n361             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n362         }\n363         return res;\n364     }", "bm_classpath": "org.apache.commons.math.linear.OpenMapRealVector"}, {"bug_name": "Math_50", "report_text": "> \"RegulaFalsiSolver\" failure\n> \n> The following unit test:\n> ```\n> @Test\n> public void testBug() {\n>     final UnivariateRealFunction f = new UnivariateRealFunction() {\n>             @Override\n>             public double value(double x) {\n>                 return Math.exp(x) - Math.pow(Math.PI, 3.0);\n>             }\n>         };\n>     UnivariateRealSolver solver = new RegulaFalsiSolver();\n>     double root = solver.solve(100, f, 1, 10);\n> }\n> ```\n> fails with\n> ```\n> illegal state: maximal count (100) exceeded: evaluations\n> ```\n> Using \"PegasusSolver\", the answer is found after 17 evaluations.", "test_name": "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631", "test_method": "public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                /** {@inheritDoc} */\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10);\n        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n\t}", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math.exception.TooManyEvaluationsException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "128 protected final double doSolve() {\n129         // Get initial solution\n130         double x0 = getMin();\n131         double x1 = getMax();\n132         double f0 = computeObjectiveValue(x0);\n133         double f1 = computeObjectiveValue(x1);\n134 \n135         // If one of the bounds is the exact root, return it. Since these are\n136         // not under-approximations or over-approximations, we can return them\n137         // regardless of the allowed solutions.\n138         if (f0 == 0.0) {\n139             return x0;\n140         }\n141         if (f1 == 0.0) {\n142             return x1;\n143         }\n144 \n145         // Verify bracketing of initial solution.\n146         verifyBracketing(x0, x1);\n147 \n148         // Get accuracies.\n149         final double ftol = getFunctionValueAccuracy();\n150         final double atol = getAbsoluteAccuracy();\n151         final double rtol = getRelativeAccuracy();\n152 \n153         // Keep track of inverted intervals, meaning that the left bound is\n154         // larger than the right bound.\n155         boolean inverted = false;\n156 \n157         // Keep finding better approximations.\n158         while (true) {\n159             // Calculate the next approximation.\n160             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n161             final double fx = computeObjectiveValue(x);\n162 \n163             // If the new approximation is the exact root, return it. Since\n164             // this is not an under-approximation or an over-approximation,\n165             // we can return it regardless of the allowed solutions.\n166             if (fx == 0.0) {\n167                 return x;\n168             }\n169 \n170             // Update the bounds with the new approximation.\n171             if (f1 * fx < 0) {\n172                 // The value of x1 has switched to the other bound, thus inverting\n173                 // the interval.\n174                 x0 = x1;\n175                 f0 = f1;\n176                 inverted = !inverted;\n177             } else {\n178                 switch (method) {\n179                 case ILLINOIS:\n180                     f0 *= 0.5;\n181                     break;\n182                 case PEGASUS:\n183                     f0 *= f1 / (f1 + fx);\n184                     break;\n185                 case REGULA_FALSI:\n186                     // Nothing.\n187                     if (x == x1) {\n188                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n189                         f0 = computeObjectiveValue(x0);\n190                     }\n191                     break;\n192                 default:\n193                     // Should never happen.\n194                     throw new MathInternalError();\n195                 }\n196             }\n197             // Update from [x0, x1] to [x0, x].\n198             x1 = x;\n199             f1 = fx;\n200 \n201             // If the function value of the last approximation is too small,\n202             // given the function value accuracy, then we can't get closer to\n203             // the root than we already are.\n204             if (FastMath.abs(f1) <= ftol) {\n205                 switch (allowed) {\n206                 case ANY_SIDE:\n207                     return x1;\n208                 case LEFT_SIDE:\n209                     if (inverted) {\n210                         return x1;\n211                     }\n212                     break;\n213                 case RIGHT_SIDE:\n214                     if (!inverted) {\n215                         return x1;\n216                     }\n217                     break;\n218                 case BELOW_SIDE:\n219                     if (f1 <= 0) {\n220                         return x1;\n221                     }\n222                     break;\n223                 case ABOVE_SIDE:\n224                     if (f1 >= 0) {\n225                         return x1;\n226                     }\n227                     break;\n228                 default:\n229                     throw new MathInternalError();\n230                 }\n231             }\n232 \n233             // If the current interval is within the given accuracies, we\n234             // are satisfied with the current approximation.\n235             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n236                                                      atol)) {\n237                 switch (allowed) {\n238                 case ANY_SIDE:\n239                     return x1;\n240                 case LEFT_SIDE:\n241                     return inverted ? x1 : x0;\n242                 case RIGHT_SIDE:\n243                     return inverted ? x0 : x1;\n244                 case BELOW_SIDE:\n245                     return (f1 <= 0) ? x1 : x0;\n246                 case ABOVE_SIDE:\n247                     return (f1 >= 0) ? x1 : x0;\n248                 default:\n249                     throw new MathInternalError();\n250                 }\n251             }\n252         }\n253     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BaseSecantSolver"}, {"bug_name": "Math_51", "report_text": "> \"RegulaFalsiSolver\" failure\n> \n> The following unit test:\n> ```\n> @Test\n> public void testBug() {\n>     final UnivariateRealFunction f = new UnivariateRealFunction() {\n>             @Override\n>             public double value(double x) {\n>                 return Math.exp(x) - Math.pow(Math.PI, 3.0);\n>             }\n>         };\n>     UnivariateRealSolver solver = new RegulaFalsiSolver();\n>     double root = solver.solve(100, f, 1, 10);\n> }\n> ```\n> fails with\n> ```\n> illegal state: maximal count (100) exceeded: evaluations\n> ```\n> Using \"PegasusSolver\", the answer is found after 17 evaluations.", "test_name": "org.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest::testIssue631", "test_method": "    @Test\n    public void testIssue631() {\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n                @Override\n                public double value(double x) {\n                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n                }\n            };\n\n        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n        final double root = solver.solve(3624, f, 1, 10); // <-- fails here\n    }", "error_message": "org.apache.commons.math.exception.TooManyEvaluationsException: illegal state: maximal count (3,624) exceeded: evaluations\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.incrementEvaluationCount(BaseAbstractUnivariateRealSolver.java:296)\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.computeObjectiveValue(BaseAbstractUnivariateRealSolver.java:153)\n\torg.apache.commons.math.analysis.solvers.BaseSecantSolver.doSolve(BaseSecantSolver.java:161)\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(BaseAbstractUnivariateRealSolver.java:190)\n\torg.apache.commons.math.analysis.solvers.BaseSecantSolver.solve(BaseSecantSolver.java:117)\n\torg.apache.commons.math.analysis.solvers.BaseSecantSolver.solve(BaseSecantSolver.java:124)\n\torg.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver.solve(BaseAbstractUnivariateRealSolver.java:195)\n\torg.apache.commons.math.analysis.solvers.RegulaFalsiSolverTest.testIssue631(RegulaFalsiSolverTest.java:53)", "buggy_method": "128 protected final double doSolve() {\n129         // Get initial solution\n130         double x0 = getMin();\n131         double x1 = getMax();\n132         double f0 = computeObjectiveValue(x0);\n133         double f1 = computeObjectiveValue(x1);\n134 \n135         // If one of the bounds is the exact root, return it. Since these are\n136         // not under-approximations or over-approximations, we can return them\n137         // regardless of the allowed solutions.\n138         if (f0 == 0.0) {\n139             return x0;\n140         }\n141         if (f1 == 0.0) {\n142             return x1;\n143         }\n144 \n145         // Verify bracketing of initial solution.\n146         verifyBracketing(x0, x1);\n147 \n148         // Get accuracies.\n149         final double ftol = getFunctionValueAccuracy();\n150         final double atol = getAbsoluteAccuracy();\n151         final double rtol = getRelativeAccuracy();\n152 \n153         // Keep track of inverted intervals, meaning that the left bound is\n154         // larger than the right bound.\n155         boolean inverted = false;\n156 \n157         // Keep finding better approximations.\n158         while (true) {\n159             // Calculate the next approximation.\n160             final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n161             final double fx = computeObjectiveValue(x);\n162 \n163             // If the new approximation is the exact root, return it. Since\n164             // this is not an under-approximation or an over-approximation,\n165             // we can return it regardless of the allowed solutions.\n166             if (fx == 0.0) {\n167                 return x;\n168             }\n169 \n170             // Update the bounds with the new approximation.\n171             if (f1 * fx < 0) {\n172                 // The value of x1 has switched to the other bound, thus inverting\n173                 // the interval.\n174                 x0 = x1;\n175                 f0 = f1;\n176                 inverted = !inverted;\n177             } else {\n178                 switch (method) {\n179                 case ILLINOIS:\n180                     f0 *= 0.5;\n181                     break;\n182                 case PEGASUS:\n183                     f0 *= f1 / (f1 + fx);\n184                     break;\n185                         // Update formula cannot make any progress: Update the\n186                         // search interval.\n187                 default:\n188                     // Should never happen.\n189                 }\n190             }\n191             // Update from [x0, x1] to [x0, x].\n192             x1 = x;\n193             f1 = fx;\n194 \n195             // If the function value of the last approximation is too small,\n196             // given the function value accuracy, then we can't get closer to\n197             // the root than we already are.\n198             if (FastMath.abs(f1) <= ftol) {\n199                 switch (allowed) {\n200                 case ANY_SIDE:\n201                     return x1;\n202                 case LEFT_SIDE:\n203                     if (inverted) {\n204                         return x1;\n205                     }\n206                     break;\n207                 case RIGHT_SIDE:\n208                     if (!inverted) {\n209                         return x1;\n210                     }\n211                     break;\n212                 case BELOW_SIDE:\n213                     if (f1 <= 0) {\n214                         return x1;\n215                     }\n216                     break;\n217                 case ABOVE_SIDE:\n218                     if (f1 >= 0) {\n219                         return x1;\n220                     }\n221                     break;\n222                 default:\n223                     throw new MathInternalError();\n224                 }\n225             }\n226 \n227             // If the current interval is within the given accuracies, we\n228             // are satisfied with the current approximation.\n229             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n230                                                      atol)) {\n231                 switch (allowed) {\n232                 case ANY_SIDE:\n233                     return x1;\n234                 case LEFT_SIDE:\n235                     return inverted ? x1 : x0;\n236                 case RIGHT_SIDE:\n237                     return inverted ? x0 : x1;\n238                 case BELOW_SIDE:\n239                     return (f1 <= 0) ? x1 : x0;\n240                 case ABOVE_SIDE:\n241                     return (f1 >= 0) ? x1 : x0;\n242                 default:\n243                     throw new MathInternalError();\n244                 }\n245             }\n246         }\n247     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BaseSecantSolver"}, {"bug_name": "Math_52", "report_text": "> numerical problems in rotation creation\n> \n> building a rotation from the following vector pairs leads to NaN:  \n> u1 = -4921140.837095533, -2.1512094250440013E7, -890093.279426377  \n> u2 = -2.7238580938724895E9, -2.169664921341876E9, 6.749688708885301E10  \n> v1 = 1, 0, 0  \n> v2 = 0, 0, 1\n> The constructor first changes the (v1, v2) pair into (v1', v2') ensuring the following scalar products hold:  \n>  <v1'|v1'> == <u1|u1>  \n>  <v2'|v2'> == <u2|u2>  \n>  <u1 |u2> == <v1'|v2'>\n> Once the (v1', v2') pair has been computed, we compute the cross product:  \n>  k = (v1' - u1)^(v2' - u2)\n> and the scalar product:  \n>  c = <k | (u1^u2)>\n> By construction, c is positive or null and the quaternion axis we want to build is q = k/[2\\*sqrt(c)].  \n> c should be null only if some of the vectors are aligned, and this is dealt with later in the algorithm.\n> However, there are numerical problems with the vector above with the way these computations are done, as shown  \n> by the following comparisons, showing the result we get from our Java code and the result we get from manual  \n> computation with the same formulas but with enhanced precision:\n> commons math: k = 38514476.5, -84., -1168590144  \n> high precision: k = 38514410.36093388..., -0.374075245201180409222711..., -1168590152.10599715208...\n> and it becomes worse when computing c because the vectors are almost orthogonal to each other, hence inducing additional cancellations. We get:  \n> commons math c = -1.2397173627587605E20  \n> high precision: c = 558382746168463196.7079627...\n> We have lost ALL significant digits in cancellations, and even the sign is wrong!", "test_name": "org.apache.commons.math.geometry.euclidean.threed.RotationTest::testIssue639", "test_method": "  @Test\n  public void testIssue639(){\n      Vector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n                                 -5774608829631843.0 /  268435456.0,\n                                 -3822921525525679.0 / 4294967296.0);\n      Vector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,\n                                 -2275058564560979.0 /    1048576.0,\n                                  4423475992255071.0 /      65536.0);\n      Rotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);\n      Assert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.6228370359608201> but was:<NaN>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.geometry.euclidean.threed.RotationTest.testIssue639(RotationTest.java:488)", "buggy_method": "313 public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n314 \n315   // norms computation\n316   double u1u1 = u1.getNormSq();\n317   double u2u2 = u2.getNormSq();\n318   double v1v1 = v1.getNormSq();\n319   double v2v2 = v2.getNormSq();\n320   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n321     throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n322   }\n323 \n324   // normalize v1 in order to have (v1'|v1') = (u1|u1)\n325   v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n326 \n327   // adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n328   double u1u2   = u1.dotProduct(u2);\n329   double v1v2   = v1.dotProduct(v2);\n330   double coeffU = u1u2 / u1u1;\n331   double coeffV = v1v2 / u1u1;\n332   double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n333   double alpha  = coeffU - beta * coeffV;\n334   v2 = new Vector3D(alpha, v1, beta, v2);\n335 \n336   // preliminary computation\n337   Vector3D uRef  = u1;\n338   Vector3D vRef  = v1;\n339   Vector3D v1Su1 = v1.subtract(u1);\n340   Vector3D v2Su2 = v2.subtract(u2);\n341   Vector3D k     = v1Su1.crossProduct(v2Su2);\n342   Vector3D u3    = u1.crossProduct(u2);\n343   double c       = k.dotProduct(u3);\n344   if (c == 0) {\n345     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n346     // we try other vectors\n347     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n348     Vector3D v3Su3 = v3.subtract(u3);\n349     k = v1Su1.crossProduct(v3Su3);\n350     Vector3D u2Prime = u1.crossProduct(u3);\n351     c = k.dotProduct(u2Prime);\n352 \n353     if (c == 0) {\n354       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n355       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n356       k = v2Su2.crossProduct(v3Su3);;\n357       c = k.dotProduct(u2.crossProduct(u3));;\n358 \n359       if (c == 0) {\n360         // the (q1, q2, q3) vector is aligned with everything\n361         // this is really the identity rotation\n362         q0 = 1.0;\n363         q1 = 0.0;\n364         q2 = 0.0;\n365         q3 = 0.0;\n366         return;\n367       }\n368 \n369       // we will have to use u2 and v2 to compute the scalar part\n370       uRef = u2;\n371       vRef = v2;\n372 \n373     }\n374 \n375   }\n376 \n377   // compute the vectorial part\n378   c = FastMath.sqrt(c);\n379   double inv = 1.0 / (c + c);\n380   q1 = inv * k.getX();\n381   q2 = inv * k.getY();\n382   q3 = inv * k.getZ();\n383 \n384   // compute the scalar part\n385    k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n386                     uRef.getZ() * q1 - uRef.getX() * q3,\n387                     uRef.getX() * q2 - uRef.getY() * q1);\n388   q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n389 \n390   }", "bm_classpath": "org.apache.commons.math.geometry.euclidean.threed.Rotation"}, {"bug_name": "Math_53", "report_text": "> Complex Add and Subtract handle NaN arguments differently, but javadoc contracts are the same\n> \n> For both Complex add and subtract, the javadoc states that\n> ```\n>      * If either this or <code>rhs</code> has a NaN value in either part,\n>      * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n>      * returned in the parts of the result according to the rules for\n>      * {@link java.lang.Double} arithmetic\n> ```\n> Subtract includes an isNaN test and returns Complex.NaN if either complex argument isNaN; but add omits this test. The test should be added to the add implementation (actually restored, since this looks like a code merge problem going back to 1.1).", "test_name": "org.apache.commons.math.complex.ComplexTest::testAddNaN", "test_method": "    @Test\n    public void testAddNaN() {\n        Complex x = new Complex(3.0, 4.0);\n        Complex z = x.add(Complex.NaN);\n        z = new Complex(1, nan);\n        Complex w = x.add(z);\n        Assert.assertTrue(Double.isNaN(w.getReal())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.complex.ComplexTest.testAddNaN(ComplexTest.java:116)", "buggy_method": "150 public Complex add(Complex rhs)\n151         throws NullArgumentException {\n152         MathUtils.checkNotNull(rhs);\n153         return createComplex(real + rhs.getReal(),\n154             imaginary + rhs.getImaginary());\n155     }", "bm_classpath": "org.apache.commons.math.complex.Complex"}, {"bug_name": "Math_54", "report_text": "> class Dfp toDouble method return -inf whan Dfp value is 0 \"zero\"\n> \n> I found a bug in the toDouble() method of the Dfp class.  \n> If the Dfp's value is 0 \"zero\", the toDouble() method returns a negative infini.\n> This is because the double value returned has an exposant equal to 0xFFF   \n> and a significand is equal to 0.  \n> In the IEEE754 this is a -inf.\n> To be equal to zero, the exposant and the significand must be equal to zero.\n> A simple test case is :  \n> ----------------------------------------------  \n> import org.apache.commons.math.dfp.DfpField;\n> public class test {\n>  /\\*\\*\n> * @param args  \n>  \\*/  \n>  public static void main(String[] args) \n> {\n>  DfpField field = new DfpField(100);\n>  System.out.println(\"toDouble value of getZero() =\"+field.getZero().toDouble()+\n>  \"\\ntoDouble value of newDfp(0.0) =\"+\n>  field.newDfp(0.0).toDouble());\n>  }\n> }\n> May be the simplest way to fix it is to test the zero equality at the begin of the toDouble() method, to be able to return the correctly signed zero ?", "test_name": "org.apache.commons.math.dfp.DfpTest::testIssue567", "test_method": "    @Test\n    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<-Infinity>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.dfp.DfpTest.testIssue567(DfpTest.java:1512)", "buggy_method": "256 protected Dfp(final DfpField field, double x) {\n257 \n258         // initialize as if 0\n259         mant = new int[field.getRadixDigits()];\n260         sign = 1;\n261         exp = 0;\n262         nans = FINITE;\n263         this.field = field;\n264 \n265         long bits = Double.doubleToLongBits(x);\n266         long mantissa = bits & 0x000fffffffffffffL;\n267         int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n268 \n269         if (exponent == -1023) {\n270             // Zero or sub-normal\n271             if (x == 0) {\n272                 // make sure 0 has the right sign\n273                 return;\n274             }\n275 \n276             exponent++;\n277 \n278             // Normalize the subnormal number\n279             while ( (mantissa & 0x0010000000000000L) == 0) {\n280                 exponent--;\n281                 mantissa <<= 1;\n282             }\n283             mantissa &= 0x000fffffffffffffL;\n284         }\n285 \n286         if (exponent == 1024) {\n287             // infinity or NAN\n288             if (x != x) {\n289                 sign = (byte) 1;\n290                 nans = QNAN;\n291             } else if (x < 0) {\n292                 sign = (byte) -1;\n293                 nans = INFINITE;\n294             } else {\n295                 sign = (byte) 1;\n296                 nans = INFINITE;\n297             }\n298             return;\n299         }\n300 \n301         Dfp xdfp = new Dfp(field, mantissa);\n302         xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n303         xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n304 \n305         if ((bits & 0x8000000000000000L) != 0) {\n306             xdfp = xdfp.negate();\n307         }\n308 \n309         System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n310         sign = xdfp.sign;\n311         exp  = xdfp.exp;\n312         nans = xdfp.nans;\n313 \n314     }", "bm_classpath": "org.apache.commons.math.dfp.Dfp"}, {"bug_name": "Math_55", "report_text": "> Vector3D.crossProduct is sensitive to numerical cancellation\n> \n> Cross product implementation uses the naive formulas (y1 z2 - y2 z1, ...). These formulas fail when vectors are almost colinear, like in the following example:\n> ```\n> Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n> Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n> System.out.println(Vector3D.crossProduct(v1, v2));\n> ```\n> The previous code displays \n> { -1, 2, 0 }\n>  instead of the correct answer \n> { -1, 2, 1 }\n>  ", "test_name": "org.apache.commons.math.geometry.Vector3DTest::testCrossProductCancellation", "test_method": "    @Test\n    public void testCrossProductCancellation() {\n        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1.0> but was:<0.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.geometry.Vector3DTest.checkVector(Vector3DTest.java:242)\n\torg.apache.commons.math.geometry.Vector3DTest.testCrossProductCancellation(Vector3DTest.java:159)", "buggy_method": "457 public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n458 \n459 \n460       // rescale both vectors without losing precision,\n461       // to ensure their norm are the same order of magnitude\n462 \n463       // we reduce cancellation errors by preconditioning,\n464       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n465       // v3 without loss of precision. See Kahan lecture\n466       // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n467       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n468 \n469       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n470 \n471 \n472       // compute cross product from v3 and v2 instead of v1 and v2\n473       return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n474 \n475   }", "bm_classpath": "org.apache.commons.math.geometry.Vector3D"}, {"bug_name": "Math_56", "report_text": "> MultidimensionalCounter.getCounts(int) returns wrong array of indices\n> \n> MultidimensionalCounter counter = new MultidimensionalCounter(2, 4);  \n> for (Integer i : counter) {  \n>  int[] x = counter.getCounts![](/jira/images/icons/emoticons/information.png);  \n>  System.out.println(i + \" \" + Arrays.toString![](/jira/images/icons/emoticons/error.png));  \n> }\n> Output is:  \n> 0 [0, 0]  \n> 1 [0, 1]  \n> 2 [0, 2]  \n> 3 [0, 2] <=== should be [0, 3]  \n> 4 [1, 0]  \n> 5 [1, 1]  \n> 6 [1, 2]  \n> 7 [1, 2] <=== should be [1, 3]", "test_name": "org.apache.commons.math.util.MultidimensionalCounterTest::testIterationConsistency", "test_method": "    @Test\n    public void testIterationConsistency() {\n        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);\n        final int[][] expected = new int[][] {\n            { 0, 0, 0 },\n            { 0, 0, 1 },\n            { 0, 0, 2 },\n            { 0, 0, 3 },\n            { 0, 1, 0 },\n            { 0, 1, 1 },\n            { 0, 1, 2 },\n            { 0, 1, 3 },\n            { 0, 2, 0 },\n            { 0, 2, 1 },\n            { 0, 2, 2 },\n            { 0, 2, 3 },\n            { 1, 0, 0 },\n            { 1, 0, 1 },\n            { 1, 0, 2 },\n            { 1, 0, 3 },\n            { 1, 1, 0 },\n            { 1, 1, 1 },\n            { 1, 1, 2 },\n            { 1, 1, 3 },\n            { 1, 2, 0 },\n            { 1, 2, 1 },\n            { 1, 2, 2 },\n            { 1, 2, 3 }\n        };\n\n        final int totalSize = c.getSize();\n        final int nDim = c.getDimension();\n        final MultidimensionalCounter.Iterator iter = c.iterator();\n        for (int i = 0; i < totalSize; i++) {\n            if (!iter.hasNext()) {\n                Assert.fail(\"Too short\");\n            }\n            final int uniDimIndex = iter.next();\n            Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], iter.getCount(dimIndex));\n            }\n\n            Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n                                c.getCount(expected[i]), uniDimIndex);\n\n            final int[] indices = c.getCounts(uniDimIndex);\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], indices[dimIndex]);\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Wrong multidimensional index for [3][2] expected:<3> but was:<2>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:118)\n\torg.junit.Assert.assertEquals(Assert.java:555)\n\torg.apache.commons.math.util.MultidimensionalCounterTest.testIterationConsistency(MultidimensionalCounterTest.java:172)", "buggy_method": "216 public int[] getCounts(int index) {\n217         if (index < 0 ||\n218             index >= totalSize) {\n219             throw new OutOfRangeException(index, 0, totalSize);\n220         }\n221 \n222         final int[] indices = new int[dimension];\n223 \n224         int count = 0;\n225         for (int i = 0; i < last; i++) {\n226             int idx = 0;\n227             final int offset = uniCounterOffset[i];\n228             while (count <= index) {\n229                 count += offset;\n230                 ++idx;\n231             }\n232             --idx;\n233             count -= offset;\n234             indices[i] = idx;\n235         }\n236 \n237         int idx = 1;\n238         while (count < index) {\n239             count += idx;\n240             ++idx;\n241         }\n242         --idx;\n243         indices[last] = idx;\n244 \n245         return indices;\n246     }", "bm_classpath": "org.apache.commons.math.util.MultidimensionalCounter"}, {"bug_name": "Math_57", "report_text": "> Truncation issue in KMeansPlusPlusClusterer\n> \n> The for loop inside KMeansPlusPlusClusterer.chooseInitialClusters defines a variable  \n>  int sum = 0;  \n> This variable should have type double, rather than int. Using an int causes the method to truncate the distances between points to (square roots of) integers. It's especially bad when the distances between points are typically less than 1.\n> As an aside, in version 2.2, this bug manifested itself by making the clusterer return empty clusters. I wonder if the EmptyClusterStrategy would still be necessary if this bug were fixed.", "test_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testSmallDistances", "test_method": "    @Test\n    public void testSmallDistances() {\n        // Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\n        // small distance.\n        int[] repeatedArray = { 0 };\n        int[] uniqueArray = { 1 };\n        CloseIntegerPoint repeatedPoint =\n            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\n        CloseIntegerPoint uniquePoint =\n            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\n\n        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\n        final int NUM_REPEATED_POINTS = 10 * 1000;\n        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\n            points.add(repeatedPoint);\n        }\n        points.add(uniquePoint);\n\n        // Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n        // cluster centers).\n        final long RANDOM_SEED = 0;\n        final int NUM_CLUSTERS = 2;\n        final int NUM_ITERATIONS = 0;\n        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\n            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\n        List<Cluster<CloseIntegerPoint>> clusters =\n            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\n\n        // Check that one of the chosen centers is the unique point.\n        boolean uniquePointIsCenter = false;\n        for (Cluster<CloseIntegerPoint> cluster : clusters) {\n            if (cluster.getCenter().equals(uniquePoint)) {\n                uniquePointIsCenter = true;\n            }\n        }\n        assertTrue(uniquePointIsCenter); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testSmallDistances(KMeansPlusPlusClustererTest.java:249)", "buggy_method": "161 private static <T extends Clusterable<T>> List<Cluster<T>>\n162         chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n163 \n164         final List<T> pointSet = new ArrayList<T>(points);\n165         final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n166 \n167         // Choose one center uniformly at random from among the data points.\n168         final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n169         resultSet.add(new Cluster<T>(firstPoint));\n170 \n171         final double[] dx2 = new double[pointSet.size()];\n172         while (resultSet.size() < k) {\n173             // For each data point x, compute D(x), the distance between x and\n174             // the nearest center that has already been chosen.\n175             int sum = 0;\n176             for (int i = 0; i < pointSet.size(); i++) {\n177                 final T p = pointSet.get(i);\n178                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n179                 final double d = p.distanceFrom(nearest.getCenter());\n180                 sum += d * d;\n181                 dx2[i] = sum;\n182             }\n183 \n184             // Add one new data point as a center. Each point x is chosen with\n185             // probability proportional to D(x)2\n186             final double r = random.nextDouble() * sum;\n187             for (int i = 0 ; i < dx2.length; i++) {\n188                 if (dx2[i] >= r) {\n189                     final T p = pointSet.remove(i);\n190                     resultSet.add(new Cluster<T>(p));\n191                     break;\n192                 }\n193             }\n194         }\n195 \n196         return resultSet;\n197 \n198     }", "bm_classpath": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer"}, {"bug_name": "Math_58", "report_text": "> GaussianFitter Unexpectedly Throws NotStrictlyPositiveException\n> \n> Running the following:\n>  double[] observations =   \n> { \n>  1.1143831578403364E-29, \n>  4.95281403484594E-28, \n>  1.1171347211930288E-26, \n>  1.7044813962636277E-25, \n>  1.9784716574832164E-24, \n>  1.8630236407866774E-23, \n>  1.4820532905097742E-22, \n>  1.0241963854632831E-21, \n>  6.275077366673128E-21, \n>  3.461808994532493E-20, \n>  1.7407124684715706E-19, \n>  8.056687953553974E-19, \n>  3.460193945992071E-18, \n>  1.3883326374011525E-17, \n>  5.233894983671116E-17, \n>  1.8630791465263745E-16, \n>  6.288759227922111E-16, \n>  2.0204433920597856E-15, \n>  6.198768938576155E-15, \n>  1.821419346860626E-14, \n>  5.139176445538471E-14, \n>  1.3956427429045787E-13, \n>  3.655705706448139E-13, \n>  9.253753324779779E-13, \n>  2.267636001476696E-12, \n>  5.3880460095836855E-12, \n>  1.2431632654852931E-11 \n>  }\n> ;\n>  GaussianFitter g =   \n>  new GaussianFitter(new LevenbergMarquardtOptimizer());\n>  for (int index = 0; index < 27; index++)\n>  {\n>  g.addObservedPoint(index, observations[index]);\n>  }\n>  g.fit();\n> Results in:\n> org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than, or equal to, the minimum (0)  \n>  at org.apache.commons.math.analysis.function.Gaussian$Parametric.validateParameters(Gaussian.java:184)  \n>  at org.apache.commons.math.analysis.function.Gaussian$Parametric.value(Gaussian.java:129)\n> I'm guessing the initial guess for sigma is off. ", "test_name": "org.apache.commons.math.optimization.fitting.GaussianFitterTest::testMath519", "test_method": "    @Test\n    public void testMath519() {\n        // The optimizer will try negative sigma values but \"GaussianFitter\"\n        // will catch the raised exceptions and return NaN values instead.\n\n        final double[] data = { \n            1.1143831578403364E-29,\n            4.95281403484594E-28,\n            1.1171347211930288E-26,\n            1.7044813962636277E-25,\n            1.9784716574832164E-24,\n            1.8630236407866774E-23,\n            1.4820532905097742E-22,\n            1.0241963854632831E-21,\n            6.275077366673128E-21,\n            3.461808994532493E-20,\n            1.7407124684715706E-19,\n            8.056687953553974E-19,\n            3.460193945992071E-18,\n            1.3883326374011525E-17,\n            5.233894983671116E-17,\n            1.8630791465263745E-16,\n            6.288759227922111E-16,\n            2.0204433920597856E-15,\n            6.198768938576155E-15,\n            1.821419346860626E-14,\n            5.139176445538471E-14,\n            1.3956427429045787E-13,\n            3.655705706448139E-13,\n            9.253753324779779E-13,\n            2.267636001476696E-12,\n            5.3880460095836855E-12,\n            1.2431632654852931E-11\n        };\n\n        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n        for (int i = 0; i < data.length; i++) {\n            fitter.addObservedPoint(i, data[i]);\n        }\n        final double[] p = fitter.fit(); // <-- fails here\n    }", "error_message": "org.apache.commons.math.exception.NotStrictlyPositiveException: -1.277 is smaller than, or equal to, the minimum (0)\n\torg.apache.commons.math.analysis.function.Gaussian$Parametric.validateParameters(Gaussian.java:183)\n\torg.apache.commons.math.analysis.function.Gaussian$Parametric.value(Gaussian.java:128)\n\torg.apache.commons.math.optimization.fitting.CurveFitter$TheoreticalValuesFunction.value(CurveFitter.java:203)\n\torg.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.computeObjectiveValue(BaseAbstractVectorialOptimizer.java:107)\n\torg.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.updateResidualsAndCost(AbstractLeastSquaresOptimizer.java:128)\n\torg.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.doOptimize(LevenbergMarquardtOptimizer.java:350)\n\torg.apache.commons.math.optimization.direct.BaseAbstractVectorialOptimizer.optimize(BaseAbstractVectorialOptimizer.java:141)\n\torg.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:253)\n\torg.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer.optimize(AbstractLeastSquaresOptimizer.java:43)\n\torg.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:160)\n\torg.apache.commons.math.optimization.fitting.CurveFitter.fit(CurveFitter.java:126)\n\torg.apache.commons.math.optimization.fitting.GaussianFitter.fit(GaussianFitter.java:121)\n\torg.apache.commons.math.optimization.fitting.GaussianFitterTest.testMath519(GaussianFitterTest.java:336)", "buggy_method": "119 public double[] fit() {\n120         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n121         return fit(new Gaussian.Parametric(), guess);\n122     }", "bm_classpath": "org.apache.commons.math.optimization.fitting.GaussianFitter"}, {"bug_name": "Math_59", "report_text": "> FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f\n> \n> FastMath.max(50.0f, -50.0f) => -50.0f; should be +50.0f.\n> This is because the wrong variable is returned.\n> The bug was not detected by the test case \"testMinMaxFloat()\" because that has a bug too - it tests doubles, not floats.", "test_name": "org.apache.commons.math.util.FastMathTest::testMinMaxFloat", "test_method": "    @Test\n    public void testMinMaxFloat() {\n        float[][] pairs = {\n            { -50.0f, 50.0f },\n            {  Float.POSITIVE_INFINITY, 1.0f },\n            {  Float.NEGATIVE_INFINITY, 1.0f },\n            {  Float.NaN, 1.0f },\n            {  Float.POSITIVE_INFINITY, 0.0f },\n            {  Float.NEGATIVE_INFINITY, 0.0f },\n            {  Float.NaN, 0.0f },\n            {  Float.NaN, Float.NEGATIVE_INFINITY },\n            {  Float.NaN, Float.POSITIVE_INFINITY }\n        };\n        for (float[] pair : pairs) {\n            Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n                                Math.min(pair[0], pair[1]),\n                                FastMath.min(pair[0], pair[1]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n                                Math.min(pair[1], pair[0]),\n                                FastMath.min(pair[1], pair[0]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n                                Math.max(pair[0], pair[1]),\n                                FastMath.max(pair[0], pair[1]),\n                                MathUtils.EPSILON);\n            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n                                Math.max(pair[1], pair[0]),\n                                FastMath.max(pair[1], pair[0]),\n                                MathUtils.EPSILON);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: max(50.0, -50.0) expected:<50.0> but was:<-50.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.apache.commons.math.util.FastMathTest.testMinMaxFloat(FastMathTest.java:103)", "buggy_method": "3481 public static float max(final float a, final float b) {\n3482         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n3483     }", "bm_classpath": "org.apache.commons.math.util.FastMath"}, {"bug_name": "Math_60", "report_text": "> ConvergenceException in NormalDistributionImpl.cumulativeProbability()\n> \n> I get a ConvergenceException in NormalDistributionImpl.cumulativeProbability() for very large/small parameters including Infinity, -Infinity.  \n> For instance in the following code:\n>  @Test  \n>  public void testCumulative() {  \n>  final NormalDistribution nd = new NormalDistributionImpl();  \n>  for (int i = 0; i < 500; i++) {  \n>  final double val = Math.exp![](/jira/images/icons/emoticons/information.png);  \n>  try \n> {\n>  System.out.println(\"val = \" + val + \" cumulative = \" + nd.cumulativeProbability(val));\n>  }\n>  catch (MathException e) \n> {\n>  e.printStackTrace();\n>  fail();\n>  }\n>  }  \n>  }\n> In version 2.0, I get no exception. \n> My suggestion is to change in the implementation of cumulativeProbability(double) to catch all ConvergenceException (and return for very large and very small values), not just MaxIterationsExceededException.", "test_name": "org.apache.commons.math.distribution.NormalDistributionTest::testExtremeValues", "test_method": "    public void testExtremeValues() throws Exception {\n        NormalDistribution distribution = new NormalDistributionImpl(0, 1);\n        for (int i = 0; i < 100; i++) { // make sure no convergence exception\n            double lowerTail = distribution.cumulativeProbability(-i);\n            double upperTail = distribution.cumulativeProbability(i);\n            if (i < 9) { // make sure not top-coded \n                // For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n                // TODO: once MATH-364 is resolved, replace 9 with 30\n                assertTrue(lowerTail > 0.0d);\n                assertTrue(upperTail < 1.0d);\n            }\n            else { // make sure top coding not reversed\n                assertTrue(lowerTail < 0.00001);\n                assertTrue(upperTail > 0.99999);\n            }\n        }\n        \n        assertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0); // <-- fails here\n    }", "error_message": "org.apache.commons.math.ConvergenceException: Continued fraction diverged to NaN for value \u221e\n\torg.apache.commons.math.util.ContinuedFraction.evaluate(ContinuedFraction.java:186)\n\torg.apache.commons.math.special.Gamma.regularizedGammaQ(Gamma.java:266)\n\torg.apache.commons.math.special.Gamma.regularizedGammaP(Gamma.java:173)\n\torg.apache.commons.math.special.Erf.erf(Erf.java:51)\n\torg.apache.commons.math.distribution.NormalDistributionImpl.cumulativeProbability(NormalDistributionImpl.java:127)\n\torg.apache.commons.math.distribution.NormalDistributionTest.testExtremeValues(NormalDistributionTest.java:174)", "buggy_method": "124 public double cumulativeProbability(double x) throws MathException {\n125         final double dev = x - mean;\n126         try {\n127         return 0.5 * (1.0 + Erf.erf((dev) /\n128                     (standardDeviation * FastMath.sqrt(2.0))));\n129         } catch (MaxIterationsExceededException ex) {\n130             if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n131                 return 0;\n132             } else if (x > (mean + 20 * standardDeviation)) {\n133                 return 1;\n134             } else {\n135                 throw ex;\n136             }\n137         }\n138     }", "bm_classpath": "org.apache.commons.math.distribution.NormalDistributionImpl"}, {"bug_name": "Math_61", "report_text": "> Dangerous code in \"PoissonDistributionImpl\"\n> \n> In the following excerpt from class \"PoissonDistributionImpl\":\n> **PoissonDistributionImpl.java**\n> ```\n>     public PoissonDistributionImpl(double p, NormalDistribution z) {\n>         super();\n>         setNormal(z);\n>         setMean(p);\n>     }\n> ```\n> (1) Overridable methods are called within the constructor.  \n> (2) The reference \"z\" is stored and modified within the class.\n> I've encountered problem (1) in several classes while working on issue 348. In those cases, in order to remove potential problems, I copied/pasted the body of the \"setter\" methods inside the constructor but I think that a more elegant solution would be to remove the \"setters\" altogether (i.e. make the classes immutable).  \n> Problem (2) can also create unexpected behaviour. Is it really necessary to pass the \"NormalDistribution\" object; can't it be always created within the class?", "test_name": "org.apache.commons.math.distribution.PoissonDistributionTest::testMean", "test_method": "    public void testMean() {\n        PoissonDistribution dist;\n        try {\n            dist = new PoissonDistributionImpl(-1);\n            fail(\"negative mean: NotStrictlyPositiveException expected\");\n        } catch(NotStrictlyPositiveException ex) {\n            // Expected.\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.math.MathRuntimeException$4: the Poisson mean must be positive (-1)\n\torg.apache.commons.math.MathRuntimeException.createIllegalArgumentException(MathRuntimeException.java:387)\n\torg.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:94)\n\torg.apache.commons.math.distribution.PoissonDistributionImpl.<init>(PoissonDistributionImpl.java:80)\n\torg.apache.commons.math.distribution.PoissonDistributionTest.testMean(PoissonDistributionTest.java:140)", "buggy_method": "92 public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n93         if (p <= 0) {\n94             throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n95         }\n96         mean = p;\n97         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n98         this.epsilon = epsilon;\n99         this.maxIterations = maxIterations;\n100     }", "bm_classpath": "org.apache.commons.math.distribution.PoissonDistributionImpl"}, {"bug_name": "Math_62", "report_text": "> Miscellaneous issues concerning the \"optimization\" package\n> \n> Revision 990792 contains changes triggered the following issues:\n> * [MATH-394](https://issues.apache.org/jira/browse/MATH-394)\n> * [MATH-397](https://issues.apache.org/jira/browse/MATH-397)\n> * [MATH-404](https://issues.apache.org/jira/browse/MATH-404)\n> This issue collects the currently still unsatisfactory code (not necessarily sorted in order of annoyance):\n> 1. \"BrentOptimizer\": a specific convergence checker must be used. \"LevenbergMarquardtOptimizer\" also has specific convergence checks.\n> 2. Trying to make convergence checking independent of the optimization algorithm creates problems (conceptual and practical):\n> \t* See \"BrentOptimizer\" and \"LevenbergMarquardtOptimizer\", the algorithm passes \"points\" to the convergence checker, but the actual meaning of the points can very well be different in the caller (optimization algorithm) and the callee (convergence checker).\n> \t* In \"PowellOptimizer\" the line search (\"BrentOptimizer\") tolerances depend on the tolerances within the main algorithm. Since tolerances come with \"ConvergenceChecker\" and so can be changed at any time, it is awkward to adapt the values within the line search optimizer without exposing its internals (\"BrentOptimizer\" field) to the enclosing class (\"PowellOptimizer\").\n> 3. Given the numerous changes, some Javadoc comments might be out-of-sync, although I did try to update them all.\n> 4. Class \"DirectSearchOptimizer\" (in package \"optimization.direct\") inherits from class \"AbstractScalarOptimizer\" (in package \"optimization.general\").\n> 5. Some interfaces are defined in package \"optimization\" but their base implementations (abstract class that contain the boiler-plate code) are in package \"optimization.general\" (e.g. \"DifferentiableMultivariateVectorialOptimizer\" and \"BaseAbstractVectorialOptimizer\").\n> 6. No check is performed to ensure the the convergence checker has been set (see e.g. \"BrentOptimizer\" and \"PowellOptimizer\"); if it hasn't there will be a NPE. The alternative is to initialize a default checker that will never be used in case the user had intended to explicitly sets the checker.\n> 7. \"NonLinearConjugateGradientOptimizer\": Ugly workaround for the checked \"ConvergenceException\".\n> 8. Everywhere, we trail the checked \"FunctionEvaluationException\" although it is never used.\n> 9. There remains some duplicate code (such as the \"multi-start loop\" in the various \"MultiStart...\" implementations).\n> 10. The \"ConvergenceChecker\" interface is very general (the \"converged\" method can take any number of \"...PointValuePair\"). However there remains a \"semantic\" problem: One cannot be sure that the list of points means the same thing for the caller of \"converged\" and within the implementation of the \"ConvergenceChecker\" that was independently set.\n> 11. It is not clear whether it is wise to aggregate the counter of gradient evaluations to the function evaluation counter. In \"LevenbergMarquartdOptimizer\" for example, it would be unfair to do so. Currently I had to remove all tests referring to gradient and Jacobian evaluations.\n> 12. In \"AbstractLeastSquaresOptimizer\" and \"LevenbergMarquardtOptimizer\", occurences of \"OptimizationException\" were replaced by the unchecked \"ConvergenceException\" but in some cases it might not be the most appropriate one.\n> 13. \"MultiStartUnivariateRealOptimizer\": in the other classes (\"MultiStartMultivariate...\") similar to this one, the randomization is on the firts-guess value while in this class, it is on the search interval. I think that here also we should randomly choose the start value (within the user-selected interval).\n> 14. The Javadoc utility raises warnings (see output of \"mvn site\") which I couldn't figure out how to correct.\n> 15. Some previously existing classes and interfaces have become no more than a specialisation of new \"generics\" classes; it might be interesting to remove them in order to reduce the number of classes and thus limit the potential for confusion.", "test_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest::testQuinticMin", "test_method": "    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer(1e-9, 1e-14);\n        underlying.setMaxEvaluations(300);\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053L);\n        MultiStartUnivariateRealOptimizer optimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n\n        UnivariateRealPointValuePair optimum\n            = optimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n        assertEquals(-0.2719561293, optimum.getPoint(), 1e-9); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-0.2719561293> but was:<-0.2719561278056452>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizerTest.testQuinticMin(MultiStartUnivariateRealOptimizerTest.java:71)", "buggy_method": "150 public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n151                                                  final double min, final double max,\n152                                                  final double startValue)\n153         throws FunctionEvaluationException {\n154         optima = new UnivariateRealPointValuePair[starts];\n155         totalEvaluations = 0;\n156 \n157         // Multi-start loop.\n158         for (int i = 0; i < starts; ++i) {\n159             try {\n160                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n161                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n162                 optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n163             } catch (FunctionEvaluationException fee) {\n164                 optima[i] = null;\n165             } catch (ConvergenceException ce) {\n166                 optima[i] = null;\n167             }\n168 \n169             final int usedEvaluations = optimizer.getEvaluations();\n170             optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n171             totalEvaluations += usedEvaluations;\n172         }\n173 \n174         sortPairs(goal);\n175 \n176         if (optima[0] == null) {\n177             throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n178                                            starts);\n179         }\n180 \n181         // Return the point with the best objective function value.\n182         return optima[0];\n183     }", "bm_classpath": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer"}, {"bug_name": "Math_63", "report_text": "> NaN in \"equals\" methods\n> \n> In \"MathUtils\", some \"equals\" methods will return true if both argument are NaN.  \n> Unless I'm mistaken, this contradicts the IEEE standard.\n> If nobody objects, I'm going to make the changes.", "test_name": "org.apache.commons.math.util.MathUtilsTest::testArrayEquals", "test_method": "    public void testArrayEquals() {\n\n        assertFalse(MathUtils.equals(new double[] { Double.NaN },\n                                     new double[] { Double.NaN })); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.math.util.MathUtilsTest.testArrayEquals(MathUtilsTest.java:456)", "buggy_method": "416 public static boolean equals(double x, double y) {\n417         return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n418     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_64", "report_text": "> Inconsistent result from Levenberg-Marquardt\n> \n> Levenberg-Marquardt (its method doOptimize) returns a VectorialPointValuePair. However, the class holds the optimum point, the vector of the objective function, the cost and residuals. The value returns by doOptimize does not always corresponds to the point which leads to the residuals and cost", "test_name": "org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson", "test_method": "  public void testMinpackJennrichSampson() {\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                            64.5856498144943, 11.1517793413499,\n                                            new double[] {\n //                                            0.2578330049, 0.257829976764542\n                                               0.2578199266368004, 0.25782997676455244\n                                            }), false); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.2578199266368004> but was:<0.2578330049004441>\n\torg.apache.commons.math.optimization.general.MinpackTest$MinpackFunction.checkTheoreticalMinParams(MinpackTest.java:576)\n\torg.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:504)\n\torg.apache.commons.math.optimization.general.MinpackTest.testMinpackJennrichSampson(MinpackTest.java:325)", "buggy_method": "240 @Override\n241     protected VectorialPointValuePair doOptimize()\n242         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n243 \n244         // arrays shared with the other private methods\n245         solvedCols  = Math.min(rows, cols);\n246         diagR       = new double[cols];\n247         jacNorm     = new double[cols];\n248         beta        = new double[cols];\n249         permutation = new int[cols];\n250         lmDir       = new double[cols];\n251 \n252         // local point\n253         double   delta   = 0;\n254         double   xNorm   = 0;\n255         double[] diag    = new double[cols];\n256         double[] oldX    = new double[cols];\n257         double[] oldRes  = new double[rows];\n258         double[] work1   = new double[cols];\n259         double[] work2   = new double[cols];\n260         double[] work3   = new double[cols];\n261 \n262         // evaluate the function at the starting point and calculate its norm\n263         updateResidualsAndCost();\n264 \n265         // outer loop\n266         lmPar = 0;\n267         boolean firstIteration = true;\n268         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n269         while (true) {\n270             incrementIterationsCounter();\n271 \n272             // compute the Q.R. decomposition of the jacobian matrix\n273             VectorialPointValuePair previous = current;\n274             updateJacobian();\n275             qrDecomposition();\n276 \n277             // compute Qt.res\n278             qTy(residuals);\n279             // now we don't need Q anymore,\n280             // so let jacobian contain the R matrix with its diagonal elements\n281             for (int k = 0; k < solvedCols; ++k) {\n282                 int pk = permutation[k];\n283                 jacobian[k][pk] = diagR[pk];\n284             }\n285 \n286             if (firstIteration) {\n287 \n288                 // scale the point according to the norms of the columns\n289                 // of the initial jacobian\n290                 xNorm = 0;\n291                 for (int k = 0; k < cols; ++k) {\n292                     double dk = jacNorm[k];\n293                     if (dk == 0) {\n294                         dk = 1.0;\n295                     }\n296                     double xk = dk * point[k];\n297                     xNorm  += xk * xk;\n298                     diag[k] = dk;\n299                 }\n300                 xNorm = Math.sqrt(xNorm);\n301 \n302                 // initialize the step bound delta\n303                 delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n304 \n305             }\n306 \n307             // check orthogonality between function vector and jacobian columns\n308             double maxCosine = 0;\n309             if (cost != 0) {\n310                 for (int j = 0; j < solvedCols; ++j) {\n311                     int    pj = permutation[j];\n312                     double s  = jacNorm[pj];\n313                     if (s != 0) {\n314                         double sum = 0;\n315                         for (int i = 0; i <= j; ++i) {\n316                             sum += jacobian[i][pj] * residuals[i];\n317                         }\n318                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n319                     }\n320                 }\n321             }\n322             if (maxCosine <= orthoTolerance) {\n323                 // convergence has been reached\n324                 return current;\n325             }\n326 \n327             // rescale if necessary\n328             for (int j = 0; j < cols; ++j) {\n329                 diag[j] = Math.max(diag[j], jacNorm[j]);\n330             }\n331 \n332             // inner loop\n333             for (double ratio = 0; ratio < 1.0e-4;) {\n334 \n335                 // save the state\n336                 for (int j = 0; j < solvedCols; ++j) {\n337                     int pj = permutation[j];\n338                     oldX[pj] = point[pj];\n339                 }\n340                 double previousCost = cost;\n341                 double[] tmpVec = residuals;\n342                 residuals = oldRes;\n343                 oldRes    = tmpVec;\n344 \n345                 // determine the Levenberg-Marquardt parameter\n346                 determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n347 \n348                 // compute the new point and the norm of the evolution direction\n349                 double lmNorm = 0;\n350                 for (int j = 0; j < solvedCols; ++j) {\n351                     int pj = permutation[j];\n352                     lmDir[pj] = -lmDir[pj];\n353                     point[pj] = oldX[pj] + lmDir[pj];\n354                     double s = diag[pj] * lmDir[pj];\n355                     lmNorm  += s * s;\n356                 }\n357                 lmNorm = Math.sqrt(lmNorm);\n358                 // on the first iteration, adjust the initial step bound.\n359                 if (firstIteration) {\n360                     delta = Math.min(delta, lmNorm);\n361                 }\n362 \n363                 // evaluate the function at x + p and calculate its norm\n364                 updateResidualsAndCost();\n365                 current = new VectorialPointValuePair(point, objective);\n366 \n367                 // compute the scaled actual reduction\n368                 double actRed = -1.0;\n369                 if (0.1 * cost < previousCost) {\n370                     double r = cost / previousCost;\n371                     actRed = 1.0 - r * r;\n372                 }\n373 \n374                 // compute the scaled predicted reduction\n375                 // and the scaled directional derivative\n376                 for (int j = 0; j < solvedCols; ++j) {\n377                     int pj = permutation[j];\n378                     double dirJ = lmDir[pj];\n379                     work1[j] = 0;\n380                     for (int i = 0; i <= j; ++i) {\n381                         work1[i] += jacobian[i][pj] * dirJ;\n382                     }\n383                 }\n384                 double coeff1 = 0;\n385                 for (int j = 0; j < solvedCols; ++j) {\n386                     coeff1 += work1[j] * work1[j];\n387                 }\n388                 double pc2 = previousCost * previousCost;\n389                 coeff1 = coeff1 / pc2;\n390                 double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n391                 double preRed = coeff1 + 2 * coeff2;\n392                 double dirDer = -(coeff1 + coeff2);\n393 \n394                 // ratio of the actual to the predicted reduction\n395                 ratio = (preRed == 0) ? 0 : (actRed / preRed);\n396 \n397                 // update the step bound\n398                 if (ratio <= 0.25) {\n399                     double tmp =\n400                         (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n401                         if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n402                             tmp = 0.1;\n403                         }\n404                         delta = tmp * Math.min(delta, 10.0 * lmNorm);\n405                         lmPar /= tmp;\n406                 } else if ((lmPar == 0) || (ratio >= 0.75)) {\n407                     delta = 2 * lmNorm;\n408                     lmPar *= 0.5;\n409                 }\n410 \n411                 // test for successful iteration.\n412                 if (ratio >= 1.0e-4) {\n413                     // successful iteration, update the norm\n414                     firstIteration = false;\n415                     xNorm = 0;\n416                     for (int k = 0; k < cols; ++k) {\n417                         double xK = diag[k] * point[k];\n418                         xNorm    += xK * xK;\n419                     }\n420                     xNorm = Math.sqrt(xNorm);\n421 \n422                     // tests for convergence.\n423                     // we use the vectorial convergence checker\n424                 } else {\n425                     // failed iteration, reset the previous values\n426                     cost = previousCost;\n427                     for (int j = 0; j < solvedCols; ++j) {\n428                         int pj = permutation[j];\n429                         point[pj] = oldX[pj];\n430                     }\n431                     tmpVec    = residuals;\n432                     residuals = oldRes;\n433                     oldRes    = tmpVec;\n434                 }\n435                 if (checker==null) {\n436                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n437                         (preRed <= costRelativeTolerance) &&\n438                         (ratio <= 2.0)) ||\n439                        (delta <= parRelativeTolerance * xNorm)) {\n440                        return current;\n441                    }\n442                 } else {\n443                     if (checker.converged(getIterations(), previous, current)) {\n444                         return current;\n445                     }\n446                 }\n447                 // tests for termination and stringent tolerances\n448                 // (2.2204e-16 is the machine epsilon for IEEE754)\n449                 if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n450                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n451                             costRelativeTolerance);\n452                 } else if (delta <= 2.2204e-16 * xNorm) {\n453                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n454                             parRelativeTolerance);\n455                 } else if (maxCosine <= 2.2204e-16)  {\n456                     throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n457                             orthoTolerance);\n458                 }\n459 \n460             }\n461 \n462         }\n463 \n464     }", "bm_classpath": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer"}, {"bug_name": "Math_65", "report_text": "> weight versus sigma in AbstractLeastSquares\n> \n> In AbstractLeastSquares, residualsWeights contains the WEIGHTS assigned to each observation. In the method getRMS(), these weights are multiplicative as they should. unlike in getChiSquare() where it appears at the denominator! If the weight is really the weight of the observation, it should multiply the square of the residual even in the computation of the chi2.\n>  Once corrected, getRMS() can even reduce\n>  public double getRMS() \n> {return Math.sqrt(getChiSquare()/rows);}\n>  ", "test_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest::testCircleFitting", "test_method": "    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n        Circle circle = new Circle();\n        circle.addPoint( 30.0,  68.0);\n        circle.addPoint( 50.0,  -6.0);\n        circle.addPoint(110.0, -20.0);\n        circle.addPoint( 35.0,  15.0);\n        circle.addPoint( 45.0,  97.0);\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n        VectorialPointValuePair optimum =\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\n                               new double[] { 98.680, 47.345 });\n        double rms = optimizer.getRMS();\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\n        double[][] cov = optimizer.getCovariances();\n        double[] errors = optimizer.guessParametersErrors();\n\n        // add perfect measurements and check errors are reduced\n        double  r = circle.getRadius(center);\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n        }\n        double[] target = new double[circle.getN()];\n        Arrays.fill(target, 0.0);\n        double[] weights = new double[circle.getN()];\n        Arrays.fill(weights, 2.0);\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\n        cov = optimizer.getCovariances();\n        errors = optimizer.guessParametersErrors();\n        assertEquals(0.004, errors[0], 0.001); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.004> but was:<0.0019737107108948474>\n\torg.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest.testCircleFitting(LevenbergMarquardtOptimizerTest.java:442)", "buggy_method": "239 public double getRMS() {\n240         double criterion = 0;\n241         for (int i = 0; i < rows; ++i) {\n242             final double residual = residuals[i];\n243             criterion += residual * residual * residualsWeights[i];\n244         }\n245         return Math.sqrt(criterion / rows);\n246     }", "bm_classpath": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer"}, {"bug_name": "Math_66", "report_text": "> Bugs in \"BrentOptimizer\"\n> \n> I apologize for having provided a buggy implementation of Brent's optimization algorithm (class \"BrentOptimizer\" in package \"optimization.univariate\").  \n> The unit tests didn't show that there was something wrong, although (from the \"changes.xml\" file) I discovered that, at the time, Luc had noticed something weird in the implementation's behaviour.  \n> Comparing with an implementation in Python, I could figure out the fixes. I'll modify \"BrentOptimizer\" and add a test. I also propose to change the name of the unit test class from \"BrentMinimizerTest\" to \"BrentOptimizerTest\".", "test_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest::testQuinticMin", "test_method": "    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer();\n        underlying.setRelativeAccuracy(1e-15);\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053L);\n        MultiStartUnivariateRealOptimizer minimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n        minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n        minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n        try {\n            minimizer.getOptima();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        try {\n            minimizer.getOptimaValues();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        double result = minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2);\n        assertEquals(-0.2719561270319131, result, 1.0e-13); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-0.2719561270319131> but was:<-0.2719561299044896>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest.testQuinticMin(MultiStartUnivariateRealOptimizerTest.java:87)", "buggy_method": "43 public BrentOptimizer() {\n44         setMaxEvaluations(Integer.MAX_VALUE);\n45         setMaximalIterationCount(100);\n46         setAbsoluteAccuracy(1E-10);\n47         setRelativeAccuracy(1.0e-14);\n48     }", "bm_classpath": "org.apache.commons.math.optimization.univariate.BrentOptimizer"}, {"bug_name": "Math_67", "report_text": "> Method \"getResult()\" in \"MultiStartUnivariateRealOptimizer\"\n> \n> In \"MultiStartUnivariateRealOptimizer\" (package \"optimization\"), the method \"getResult\" returns the result of the last run of the \"underlying\" optimizer; this last result might not be the best one, in which case it will not correspond to the value returned by the \"optimize\" method. This is confusing and does not seem very useful. I think that \"getResult\" should be defined as\n> ```\n>  \n> public double getResult() {\n>     return optima[0];\n> }\n> ```\n> and similarly\n> ```\n> public double getFunctionValue() {\n>     return optimaValues[0];\n> }\n> ```", "test_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest::testQuinticMin", "test_method": "    @Test\n    public void testQuinticMin() throws MathException {\n        // The quintic function has zeros at 0, +-0.5 and +-1.\n        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer underlying = new BrentOptimizer();\n        JDKRandomGenerator g = new JDKRandomGenerator();\n        g.setSeed(4312000053l);\n        MultiStartUnivariateRealOptimizer minimizer =\n            new MultiStartUnivariateRealOptimizer(underlying, 5, g);\n        minimizer.setAbsoluteAccuracy(10 * minimizer.getAbsoluteAccuracy());\n        minimizer.setRelativeAccuracy(10 * minimizer.getRelativeAccuracy());\n\n        try {\n            minimizer.getOptima();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        try {\n            minimizer.getOptimaValues();\n            fail(\"an exception should have been thrown\");\n        } catch (IllegalStateException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n\n        assertEquals(-0.27195612846834, minimizer.getResult(), 1.0e-13); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-0.27195612846834> but was:<-0.27194301946870036>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest.testQuinticMin(MultiStartUnivariateRealOptimizerTest.java:86)", "buggy_method": "91 public double getFunctionValue() {\n92         return optimizer.getFunctionValue();\n93     }", "bm_classpath": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer"}, {"bug_name": "Math_68", "report_text": "> LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it\n> \n> LevenbergMarquardtOptimizer ignores the VectorialConvergenceChecker parameter passed to it. This makes it hard to specify custom stopping criteria for the optimizer.", "test_name": "org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson", "test_method": "  public void testMinpackJennrichSampson() {\n    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                            64.5856498144943, 11.1517793413499,\n                                            new double[] {\n                                             0.2578330049, 0.257829976764542\n                                            }), false); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.2578330049> but was:<0.257819926636807>\n\torg.apache.commons.math.optimization.general.MinpackTest$MinpackFunction.checkTheoreticalMinParams(MinpackTest.java:575)\n\torg.apache.commons.math.optimization.general.MinpackTest.minpackTest(MinpackTest.java:503)\n\torg.apache.commons.math.optimization.general.MinpackTest.testMinpackJennrichSampson(MinpackTest.java:325)", "buggy_method": "160 public LevenbergMarquardtOptimizer() {\n161 \n162         // set up the superclass with a default  max cost evaluations setting\n163         setMaxIterations(1000);\n164 \n165         // default values for the tuning parameters\n166         setInitialStepBoundFactor(100.0);\n167         setCostRelativeTolerance(1.0e-10);\n168         setParRelativeTolerance(1.0e-10);\n169         setOrthoTolerance(1.0e-10);\n170 \n171     }", "bm_classpath": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer"}, {"bug_name": "Math_69", "report_text": "> PearsonsCorrelation.getCorrelationPValues() precision limited by machine epsilon\n> \n> Similar to the issue described in [~~MATH-201~~](https://issues.apache.org/jira/browse/MATH-201 \"T-test p-value precision hampered by machine epsilon\"), using PearsonsCorrelation.getCorrelationPValues() with many treatments results in p-values that are continuous down to 2.2e-16 but that drop to 0 after that.\n> In [~~MATH-201~~](https://issues.apache.org/jira/browse/MATH-201 \"T-test p-value precision hampered by machine epsilon\"), the problem was described as such:  \n> > So in essence, the p-value returned by TTestImpl.tTest() is:  \n> >   \n> > 1.0 - (cumulativeProbability(t) - cumulativeProbabily(-t))  \n> >   \n> > For large-ish t-statistics, cumulativeProbabilty(-t) can get quite small, and cumulativeProbabilty(t) can get very close to 1.0. When   \n> > cumulativeProbability(-t) is less than the machine epsilon, we get p-values equal to zero because:  \n> >   \n> > 1.0 - 1.0 + 0.0 = 0.0\n> The solution in [~~MATH-201~~](https://issues.apache.org/jira/browse/MATH-201 \"T-test p-value precision hampered by machine epsilon\") was to modify the p-value calculation to this:  \n> > p = 2.0 \\* cumulativeProbability(-t)\n> Here, the problem is similar. From PearsonsCorrelation.getCorrelationPValues():  \n>  p = 2 \\* (1 - tDistribution.cumulativeProbability(t));\n> Directly calculating the p-value using identical code as PearsonsCorrelation.getCorrelationPValues(), but with the following change seems to solve the problem:  \n>  p = 2 \\* (tDistribution.cumulativeProbability(-t));", "test_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelationTest::testPValueNearZero", "test_method": "    public void testPValueNearZero() throws Exception {\n        /*\n         * Create a dataset that has r -> 1, p -> 0 as dimension increases.\n         * Prior to the fix for MATH-371, p vanished for dimension >= 14.\n         * Post fix, p-values diminish smoothly, vanishing at dimension = 127.\n         * Tested value is ~1E-303.\n         */\n        int dimension = 120; \n        double[][] data = new double[dimension][2];\n        for (int i = 0; i < dimension; i++) {\n            data[i][0] = i;\n            data[i][1] = i + 1/((double)i + 1);\n        }\n        PearsonsCorrelation corrInstance = new PearsonsCorrelation(data);\n        assertTrue(corrInstance.getCorrelationPValues().getEntry(0, 1) > 0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.math.stat.correlation.PearsonsCorrelationTest.testPValueNearZero(PearsonsCorrelationTest.java:181)", "buggy_method": "160 public RealMatrix getCorrelationPValues() throws MathException {\n161         TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n162         int nVars = correlationMatrix.getColumnDimension();\n163         double[][] out = new double[nVars][nVars];\n164         for (int i = 0; i < nVars; i++) {\n165             for (int j = 0; j < nVars; j++) {\n166                 if (i == j) {\n167                     out[i][j] = 0d;\n168                 } else {\n169                     double r = correlationMatrix.getEntry(i, j);\n170                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n171                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n172                 }\n173             }\n174         }\n175         return new BlockRealMatrix(out);\n176     }", "bm_classpath": "org.apache.commons.math.stat.correlation.PearsonsCorrelation"}, {"bug_name": "Math_70", "report_text": "> BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) throws NullPointerException\n> \n> Method \n>  BisectionSolver.solve(final UnivariateRealFunction f, double min, double max, double initial) \n> invokes \n>  BisectionSolver.solve(double min, double max) \n> which throws NullPointerException, as member variable\n>  UnivariateRealSolverImpl.f \n> is null.\n> Instead the method:\n>  BisectionSolver.solve(final UnivariateRealFunction f, double min, double max)\n> should be called.\n> Steps to reproduce:\n> invoke:\n>  new BisectionSolver().solve(someUnivariateFunctionImpl, 0.0, 1.0, 0.5);\n> NullPointerException will be thrown.", "test_name": "org.apache.commons.math.analysis.solvers.BisectionSolverTest::testMath369", "test_method": "    public void testMath369() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BisectionSolver();\n        assertEquals(Math.PI, solver.solve(f, 3.0, 3.2, 3.1), solver.getAbsoluteAccuracy()); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.math.analysis.solvers.BisectionSolver.solve(BisectionSolver.java:88)\n\torg.apache.commons.math.analysis.solvers.BisectionSolver.solve(BisectionSolver.java:66)\n\torg.apache.commons.math.analysis.solvers.BisectionSolver.solve(BisectionSolver.java:72)\n\torg.apache.commons.math.analysis.solvers.BisectionSolverTest.testMath369(BisectionSolverTest.java:101)", "buggy_method": "70 public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n71         throws MaxIterationsExceededException, FunctionEvaluationException {\n72         return solve(min, max);\n73     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BisectionSolver"}, {"bug_name": "Math_71", "report_text": "> ODE integrator goes past specified end of integration range\n> \n> End of integration range in ODE solving is handled as an event.  \n> In some cases, numerical accuracy in events detection leads to error in events location.  \n> The following test case shows the end event is not handled properly and an integration that should cover a 60s range in fact covers a 160s range, more than twice the specified range.\n> ```\n>   public void testMissedEvent() throws IntegratorException, DerivativeException {\n>           final double t0 = 1878250320.0000029;\n>           final double t =  1878250379.9999986;\n>           FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n>             \n>             public int getDimension() {\n>                 return 1;\n>             }\n>             \n>             public void computeDerivatives(double t, double[] y, double[] yDot)\n>                 throws DerivativeException {\n>                 yDot[0] = y[0] * 1.0e-6;\n>             }\n>         };\n>         DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 100.0,\n>                                                                                1.0e-10, 1.0e-10);\n>         double[] y = { 1.0 };\n>         integrator.setInitialStepSize(60.0);\n>         double finalT = integrator.integrate(ode, t0, y, t, y);\n>         Assert.assertEquals(t, finalT, 1.0e-6);\n>     }\n> ```", "test_name": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest::testMissedEndEvent", "test_method": "  public void testMissedEndEvent() throws IntegratorException, DerivativeException {\n      final double   t0     = 1878250320.0000029;\n      final double   tEvent = 1878250379.9999986;\n      final double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\n      FirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\n\n          public int getDimension() {\n              return k.length;\n          }\n\n          public void computeDerivatives(double t, double[] y, double[] yDot) {\n              for (int i = 0; i < y.length; ++i) {\n                  yDot[i] = k[i] * y[i];\n              }\n          }\n      };\n\n      ClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\n\n      double[] y0   = new double[k.length];\n      for (int i = 0; i < y0.length; ++i) {\n          y0[i] = i + 1;\n      }\n      double[] y    = new double[k.length];\n\n      double finalT = integrator.integrate(ode, t0, y0, tEvent, y);\n      Assert.assertEquals(tEvent, finalT, 5.0e-6); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\n\torg.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)", "buggy_method": "191 @Override\n192   public double integrate(final FirstOrderDifferentialEquations equations,\n193                           final double t0, final double[] y0,\n194                           final double t, final double[] y)\n195   throws DerivativeException, IntegratorException {\n196 \n197     sanityChecks(equations, t0, y0, t, y);\n198     setEquations(equations);\n199     resetEvaluations();\n200     final boolean forward = t > t0;\n201 \n202     // create some internal working arrays\n203     final int stages = c.length + 1;\n204     if (y != y0) {\n205       System.arraycopy(y0, 0, y, 0, y0.length);\n206     }\n207     final double[][] yDotK = new double[stages][y0.length];\n208     final double[] yTmp = new double[y0.length];\n209 \n210     // set up an interpolator sharing the integrator arrays\n211     AbstractStepInterpolator interpolator;\n212     if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n213       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n214       rki.reinitialize(this, yTmp, yDotK, forward);\n215       interpolator = rki;\n216     } else {\n217       interpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n218     }\n219     interpolator.storeTime(t0);\n220 \n221     // set up integration control objects\n222     stepStart         = t0;\n223     double  hNew      = 0;\n224     boolean firstTime = true;\n225     for (StepHandler handler : stepHandlers) {\n226         handler.reset();\n227     }\n228     CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n229     boolean lastStep = false;\n230 \n231     // main integration loop\n232     while (!lastStep) {\n233 \n234       interpolator.shift();\n235 \n236       double error = 0;\n237       for (boolean loop = true; loop;) {\n238 \n239         if (firstTime || !fsal) {\n240           // first stage\n241           computeDerivatives(stepStart, y, yDotK[0]);\n242         }\n243 \n244         if (firstTime) {\n245           final double[] scale = new double[y0.length];\n246           if (vecAbsoluteTolerance == null) {\n247               for (int i = 0; i < scale.length; ++i) {\n248                 scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n249               }\n250             } else {\n251               for (int i = 0; i < scale.length; ++i) {\n252                 scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n253               }\n254             }\n255           hNew = initializeStep(equations, forward, getOrder(), scale,\n256                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n257           firstTime = false;\n258         }\n259 \n260         stepSize = hNew;\n261 \n262         // next stages\n263         for (int k = 1; k < stages; ++k) {\n264 \n265           for (int j = 0; j < y0.length; ++j) {\n266             double sum = a[k-1][0] * yDotK[0][j];\n267             for (int l = 1; l < k; ++l) {\n268               sum += a[k-1][l] * yDotK[l][j];\n269             }\n270             yTmp[j] = y[j] + stepSize * sum;\n271           }\n272 \n273           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n274 \n275         }\n276 \n277         // estimate the state at the end of the step\n278         for (int j = 0; j < y0.length; ++j) {\n279           double sum    = b[0] * yDotK[0][j];\n280           for (int l = 1; l < stages; ++l) {\n281             sum    += b[l] * yDotK[l][j];\n282           }\n283           yTmp[j] = y[j] + stepSize * sum;\n284         }\n285 \n286         // estimate the error at the end of the step\n287         error = estimateError(yDotK, y, yTmp, stepSize);\n288         if (error <= 1.0) {\n289 \n290           // discrete events handling\n291           interpolator.storeTime(stepStart + stepSize);\n292           if (manager.evaluateStep(interpolator)) {\n293               final double dt = manager.getEventTime() - stepStart;\n294               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n295                   // we cannot simply truncate the step, reject the current computation\n296                   // and let the loop compute another state with the truncated step.\n297                   // it is so small (much probably exactly 0 due to limited accuracy)\n298                   // that the code above would fail handling it.\n299                   // So we set up an artificial 0 size step by copying states\n300                   loop     = false;\n301               } else {\n302                   // reject the step to match exactly the next switch time\n303                   hNew = dt;\n304               }\n305           } else {\n306             // accept the step\n307             loop = false;\n308           }\n309 \n310         } else {\n311           // reject the step and attempt to reduce error by stepsize control\n312           final double factor =\n313               Math.min(maxGrowth,\n314                        Math.max(minReduction, safety * Math.pow(error, exp)));\n315           hNew = filterStep(stepSize * factor, forward, false);\n316         }\n317 \n318       }\n319 \n320       // the step has been accepted\n321       final double nextStep = stepStart + stepSize;\n322       System.arraycopy(yTmp, 0, y, 0, y0.length);\n323       manager.stepAccepted(nextStep, y);\n324       lastStep = manager.stop();\n325 \n326       // provide the step data to the step handler\n327       interpolator.storeTime(nextStep);\n328       for (StepHandler handler : stepHandlers) {\n329           handler.handleStep(interpolator, lastStep);\n330       }\n331       stepStart = nextStep;\n332 \n333       if (fsal) {\n334         // save the last evaluation for the next step\n335         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n336       }\n337 \n338       if (manager.reset(stepStart, y) && ! lastStep) {\n339         // some event handler has triggered changes that\n340         // invalidate the derivatives, we need to recompute them\n341         computeDerivatives(stepStart, y, yDotK[0]);\n342       }\n343 \n344       if (! lastStep) {\n345         // in some rare cases we may get here with stepSize = 0, for example\n346         // when an event occurs at integration start, reducing the first step\n347         // to zero; we have to reset the step to some safe non zero value\n348           stepSize = filterStep(stepSize, forward, true);\n349 \n350         // stepsize control for next step\n351         final double factor = Math.min(maxGrowth,\n352                                        Math.max(minReduction,\n353                                                 safety * Math.pow(error, exp)));\n354         final double  scaledH    = stepSize * factor;\n355         final double  nextT      = stepStart + scaledH;\n356         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n357         hNew = filterStep(scaledH, forward, nextIsLast);\n358       }\n359 \n360     }\n361 \n362     final double stopTime = stepStart;\n363     resetInternalState();\n364     return stopTime;\n365 \n366   }", "bm_classpath": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator"}, {"bug_name": "Math_72", "report_text": "> Brent solver returns the wrong value if either bracket endpoint is root\n> \n> The solve(final UnivariateRealFunction f, final double min, final double max, final double initial) function returns yMin or yMax if min or max are deemed to be roots, respectively, instead of min or max.", "test_name": "org.apache.commons.math.analysis.solvers.BrentSolverTest::testRootEndpoints", "test_method": "    public void testRootEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver();\n\n        // endpoint is root\n        double result = solver.solve(f, Math.PI, 4);\n\n        result = solver.solve(f, 3, Math.PI);\n\n        result = solver.solve(f, Math.PI, 4, 3.5);\n        assertEquals(Math.PI, result, solver.getAbsoluteAccuracy()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<3.141592653589793> but was:<1.2246467991473532E-16>\n\torg.apache.commons.math.analysis.solvers.BrentSolverTest.testRootEndpoints(BrentSolverTest.java:317)", "buggy_method": "98 public double solve(final UnivariateRealFunction f,\n99                         final double min, final double max, final double initial)\n100         throws MaxIterationsExceededException, FunctionEvaluationException {\n101 \n102         clearResult();\n103         verifySequence(min, initial, max);\n104 \n105         // return the initial guess if it is good enough\n106         double yInitial = f.value(initial);\n107         if (Math.abs(yInitial) <= functionValueAccuracy) {\n108             setResult(initial, 0);\n109             return result;\n110         }\n111 \n112         // return the first endpoint if it is good enough\n113         double yMin = f.value(min);\n114         if (Math.abs(yMin) <= functionValueAccuracy) {\n115             setResult(yMin, 0);\n116             return result;\n117         }\n118 \n119         // reduce interval if min and initial bracket the root\n120         if (yInitial * yMin < 0) {\n121             return solve(f, min, yMin, initial, yInitial, min, yMin);\n122         }\n123 \n124         // return the second endpoint if it is good enough\n125         double yMax = f.value(max);\n126         if (Math.abs(yMax) <= functionValueAccuracy) {\n127             setResult(yMax, 0);\n128             return result;\n129         }\n130 \n131         // reduce interval if initial and max bracket the root\n132         if (yInitial * yMax < 0) {\n133             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n134         }\n135 \n136         if (yMin * yMax > 0) {\n137             throw MathRuntimeException.createIllegalArgumentException(\n138                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n139         }\n140 \n141         // full Brent algorithm starting with provided initial guess\n142         return solve(f, min, yMin, max, yMax, initial, yInitial);\n143 \n144     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BrentSolver"}, {"bug_name": "Math_73", "report_text": "> Brent solver doesn't throw IllegalArgumentException when initial guess has the wrong sign\n> \n> Javadoc for \"public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\" claims that \"if the values of the function at the three points have the same sign\" an IllegalArgumentException is thrown. This case isn't even checked.", "test_name": "org.apache.commons.math.analysis.solvers.BrentSolverTest::testBadEndpoints", "test_method": "    public void testBadEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver();\n        try {  // bad interval\n            solver.solve(f, 1, -1);\n            fail(\"Expecting IllegalArgumentException - bad interval\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        try {  // no bracket\n            solver.solve(f, 1, 1.5);\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n        try {  // no bracket\n            solver.solve(f, 1, 1.5, 1.2);\n            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expecting IllegalArgumentException - non-bracketing\n\torg.apache.commons.math.analysis.solvers.BrentSolverTest.testBadEndpoints(BrentSolverTest.java:334)", "buggy_method": "98 public double solve(final UnivariateRealFunction f,\n99                         final double min, final double max, final double initial)\n100         throws MaxIterationsExceededException, FunctionEvaluationException {\n101 \n102         clearResult();\n103         verifySequence(min, initial, max);\n104 \n105         // return the initial guess if it is good enough\n106         double yInitial = f.value(initial);\n107         if (Math.abs(yInitial) <= functionValueAccuracy) {\n108             setResult(initial, 0);\n109             return result;\n110         }\n111 \n112         // return the first endpoint if it is good enough\n113         double yMin = f.value(min);\n114         if (Math.abs(yMin) <= functionValueAccuracy) {\n115             setResult(yMin, 0);\n116             return result;\n117         }\n118 \n119         // reduce interval if min and initial bracket the root\n120         if (yInitial * yMin < 0) {\n121             return solve(f, min, yMin, initial, yInitial, min, yMin);\n122         }\n123 \n124         // return the second endpoint if it is good enough\n125         double yMax = f.value(max);\n126         if (Math.abs(yMax) <= functionValueAccuracy) {\n127             setResult(yMax, 0);\n128             return result;\n129         }\n130 \n131         // reduce interval if initial and max bracket the root\n132         if (yInitial * yMax < 0) {\n133             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n134         }\n135 \n136 \n137         // full Brent algorithm starting with provided initial guess\n138         return solve(f, min, yMin, max, yMax, initial, yInitial);\n139 \n140     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.BrentSolver"}, {"bug_name": "Math_74", "report_text": "> Wrong parameter for first step size guess for Embedded Runge Kutta methods\n> \n> In a space application using DOP853 i detected what seems to be a bad parameter in the call to the method initializeStep of class AdaptiveStepsizeIntegrator.\n> Here, DormandPrince853Integrator is a subclass for EmbeddedRungeKuttaIntegrator which perform the call to initializeStep at the beginning of its method integrate(...)\n> The problem comes from the array \"scale\" that is used as a parameter in the call off initializeStep(..)\n> Following the theory described by Hairer in his book \"Solving Ordinary Differential Equations 1 : Nonstiff Problems\", the scaling should be :\n> sci = Atol i + |y0i| \\* Rtoli\n> Whereas EmbeddedRungeKuttaIntegrator uses : sci = Atoli\n> Note that the Gragg-Bulirsch-Stoer integrator uses the good implementation \"sci = Atol i + |y0i| \\* Rtoli \" when he performs the call to the same method initializeStep(..)\n> In the method initializeStep, the error leads to a wrong step size h used to perform an Euler step. Most of the time it is unvisible for the user.  \n> But in my space application the Euler step with this wrong step size h (much bigger than it should be) makes an exception occur (my satellite hits the ground...)\n> To fix the bug, one should use the same algorithm as in the rescale method in GraggBulirschStoerIntegrator  \n> For exemple :\n>  final double[] scale= new double[y0.length];;\n>  if (vecAbsoluteTolerance == null) {  \n>  for (int i = 0; i < scale.length; ++i) \n> {\n>  final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n>  scale[i] = scalAbsoluteTolerance + scalRelativeTolerance \\* yi;\n>  }\n>  } else {  \n>  for (int i = 0; i < scale.length; ++i) \n> {\n>  final double yi = Math.max(Math.abs(y0[i]), Math.abs(y0[i]));\n>  scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] \\* yi;\n>  }\n>  }\n>  hNew = initializeStep(equations, forward, getOrder(), scale,  \n>  stepStart, y, yDotK[0], yTmp, yDotK[1]);\n> Sorry for the length of this message, looking forward to hearing from you soon\n> Vincent Morand", "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest::polynomial", "test_method": "    @Test\n    public void polynomial() throws DerivativeException, IntegratorException {\n        TestProblem6 pb = new TestProblem6();\n        double range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n\n        for (int nSteps = 1; nSteps < 7; ++nSteps) {\n            AdamsMoultonIntegrator integ =\n                new AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\n            TestProblemHandler handler = new TestProblemHandler(pb, integ);\n            integ.addStepHandler(handler);\n            integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n                            pb.getFinalTime(), new double[pb.getDimension()]);\n            if (nSteps < 4) {\n                assertTrue(integ.getEvaluations() > 140);\n            } else {\n                assertTrue(integ.getEvaluations() < 90);\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)", "buggy_method": "191 @Override\n192   public double integrate(final FirstOrderDifferentialEquations equations,\n193                           final double t0, final double[] y0,\n194                           final double t, final double[] y)\n195   throws DerivativeException, IntegratorException {\n196 \n197     sanityChecks(equations, t0, y0, t, y);\n198     setEquations(equations);\n199     resetEvaluations();\n200     final boolean forward = t > t0;\n201 \n202     // create some internal working arrays\n203     final int stages = c.length + 1;\n204     if (y != y0) {\n205       System.arraycopy(y0, 0, y, 0, y0.length);\n206     }\n207     final double[][] yDotK = new double[stages][y0.length];\n208     final double[] yTmp = new double[y0.length];\n209 \n210     // set up an interpolator sharing the integrator arrays\n211     AbstractStepInterpolator interpolator;\n212     if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n213       final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n214       rki.reinitialize(this, yTmp, yDotK, forward);\n215       interpolator = rki;\n216     } else {\n217       interpolator = new DummyStepInterpolator(yTmp, forward);\n218     }\n219     interpolator.storeTime(t0);\n220 \n221     // set up integration control objects\n222     stepStart         = t0;\n223     double  hNew      = 0;\n224     boolean firstTime = true;\n225     for (StepHandler handler : stepHandlers) {\n226         handler.reset();\n227     }\n228     CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n229     boolean lastStep = false;\n230 \n231     // main integration loop\n232     while (!lastStep) {\n233 \n234       interpolator.shift();\n235 \n236       double error = 0;\n237       for (boolean loop = true; loop;) {\n238 \n239         if (firstTime || !fsal) {\n240           // first stage\n241           computeDerivatives(stepStart, y, yDotK[0]);\n242         }\n243 \n244         if (firstTime) {\n245           final double[] scale;\n246           if (vecAbsoluteTolerance == null) {\n247               scale = new double[y0.length];\n248               java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n249             } else {\n250               scale = vecAbsoluteTolerance;\n251             }\n252           hNew = initializeStep(equations, forward, getOrder(), scale,\n253                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n254           firstTime = false;\n255         }\n256 \n257         stepSize = hNew;\n258 \n259         // next stages\n260         for (int k = 1; k < stages; ++k) {\n261 \n262           for (int j = 0; j < y0.length; ++j) {\n263             double sum = a[k-1][0] * yDotK[0][j];\n264             for (int l = 1; l < k; ++l) {\n265               sum += a[k-1][l] * yDotK[l][j];\n266             }\n267             yTmp[j] = y[j] + stepSize * sum;\n268           }\n269 \n270           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n271 \n272         }\n273 \n274         // estimate the state at the end of the step\n275         for (int j = 0; j < y0.length; ++j) {\n276           double sum    = b[0] * yDotK[0][j];\n277           for (int l = 1; l < stages; ++l) {\n278             sum    += b[l] * yDotK[l][j];\n279           }\n280           yTmp[j] = y[j] + stepSize * sum;\n281         }\n282 \n283         // estimate the error at the end of the step\n284         error = estimateError(yDotK, y, yTmp, stepSize);\n285         if (error <= 1.0) {\n286 \n287           // discrete events handling\n288           interpolator.storeTime(stepStart + stepSize);\n289           if (manager.evaluateStep(interpolator)) {\n290               final double dt = manager.getEventTime() - stepStart;\n291               if (Math.abs(dt) <= Math.ulp(stepStart)) {\n292                   // rejecting the step would lead to a too small next step, we accept it\n293                   loop = false;\n294               } else {\n295                   // reject the step to match exactly the next switch time\n296                   hNew = dt;\n297               }\n298           } else {\n299             // accept the step\n300             loop = false;\n301           }\n302 \n303         } else {\n304           // reject the step and attempt to reduce error by stepsize control\n305           final double factor =\n306               Math.min(maxGrowth,\n307                        Math.max(minReduction, safety * Math.pow(error, exp)));\n308           hNew = filterStep(stepSize * factor, forward, false);\n309         }\n310 \n311       }\n312 \n313       // the step has been accepted\n314       final double nextStep = stepStart + stepSize;\n315       System.arraycopy(yTmp, 0, y, 0, y0.length);\n316       manager.stepAccepted(nextStep, y);\n317       lastStep = manager.stop();\n318 \n319       // provide the step data to the step handler\n320       interpolator.storeTime(nextStep);\n321       for (StepHandler handler : stepHandlers) {\n322           handler.handleStep(interpolator, lastStep);\n323       }\n324       stepStart = nextStep;\n325 \n326       if (fsal) {\n327         // save the last evaluation for the next step\n328         System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n329       }\n330 \n331       if (manager.reset(stepStart, y) && ! lastStep) {\n332         // some event handler has triggered changes that\n333         // invalidate the derivatives, we need to recompute them\n334         computeDerivatives(stepStart, y, yDotK[0]);\n335       }\n336 \n337       if (! lastStep) {\n338         // in some rare cases we may get here with stepSize = 0, for example\n339         // when an event occurs at integration start, reducing the first step\n340         // to zero; we have to reset the step to some safe non zero value\n341           stepSize = filterStep(stepSize, forward, true);\n342 \n343         // stepsize control for next step\n344         final double factor = Math.min(maxGrowth,\n345                                        Math.max(minReduction,\n346                                                 safety * Math.pow(error, exp)));\n347         final double  scaledH    = stepSize * factor;\n348         final double  nextT      = stepStart + scaledH;\n349         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n350         hNew = filterStep(scaledH, forward, nextIsLast);\n351       }\n352 \n353     }\n354 \n355     final double stopTime = stepStart;\n356     resetInternalState();\n357     return stopTime;\n358 \n359   }", "bm_classpath": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator"}, {"bug_name": "Math_75", "report_text": "> In stat.Frequency, getPct(Object) uses getCumPct(Comparable) instead of getPct(Comparable)\n> \n> Drop in Replacement of 1.2 with 2.0 not possible because all getPct calls will be cummulative without code change\n> Frequency.java\n>  /\\*\\*\n> * Returns the percentage of values that are equal to v\n> * @deprecated replaced by \n> {@link #getPct(Comparable)}\n>  as of 2.0  \n>  \\*/  \n>  @Deprecated  \n>  public double getPct(Object v) \n> {\n>  return getCumPct((Comparable<?>) v);\n>  }", "test_name": "org.apache.commons.math.stat.FrequencyTest::testPcts", "test_method": "    public void testPcts() {\n        f.addValue(oneL);\n        f.addValue(twoL);\n        f.addValue(oneI);\n        f.addValue(twoI);\n        f.addValue(threeL);\n        f.addValue(threeL);\n        f.addValue(3);\n        f.addValue(threeI);\n        // MATH-329\n        assertEquals(\"three (Object) pct\",0.5,f.getPct((Object) (Integer.valueOf(3))),tolerance); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: three (Object) pct expected:<0.5> but was:<1.0>\n\torg.apache.commons.math.stat.FrequencyTest.testPcts(FrequencyTest.java:148)", "buggy_method": "301 @Deprecated\n302     public double getPct(Object v) {\n303         return getCumPct((Comparable<?>) v);\n304     }", "bm_classpath": "org.apache.commons.math.stat.Frequency"}, {"bug_name": "Math_76", "report_text": "> NaN singular value from SVD\n> \n> The following jython code  \n> Start code\n> from org.apache.commons.math.linear import \\*\n> Alist = [[1.0, 2.0, 3.0],[2.0,3.0,4.0],[3.0,5.0,7.0]]\n> A = Array2DRowRealMatrix(Alist)\n> decomp = SingularValueDecompositionImpl(A)\n> print decomp.getSingularValues()\n> End code\n> prints  \n> array('d', [11.218599757513008, 0.3781791648535976, nan])  \n> The last singular value should be something very close to 0 since the matrix  \n> is rank deficient. When i use the result from getSolver() to solve a system, i end   \n> up with a bunch of NaNs in the solution. I assumed i would get back a least squares solution.\n> Does this SVD implementation require that the matrix be full rank? If so, then i would expect  \n> an exception to be thrown from the constructor or one of the methods.", "test_name": "org.apache.commons.math.linear.SingularValueSolverTest::testMath320A", "test_method": "    @Test\n    public void testMath320A() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n        });\n        double s439  = Math.sqrt(439.0);\n        double[] reference = new double[] {\n            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n        };\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n\n        // check we get the expected theoretical singular values\n        double[] singularValues = svd.getSingularValues();\n        for (int i = 0; i < reference.length; ++i) {\n            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n        }\n\n        // check the decomposition allows to recover the original matrix\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0.0> but was:<0.09336767546650937>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.linear.SingularValueSolverTest.testMath320A(SingularValueSolverTest.java:188)", "buggy_method": "153 public RealMatrix getU()\n154         throws InvalidMatrixException {\n155 \n156         if (cachedU == null) {\n157 \n158             final int p = singularValues.length;\n159             if (m >= n) {\n160                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n161                 final RealMatrix e =\n162                     eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n163                 final double[][] eData = e.getData();\n164                 final double[][] wData = new double[m][p];\n165                 double[] ei1 = eData[0];\n166                 for (int i = 0; i < p - 1; ++i) {\n167                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n168                     final double mi = mainBidiagonal[i];\n169                     final double[] ei0 = ei1;\n170                     final double[] wi  = wData[i];\n171                         ei1 = eData[i + 1];\n172                         final double si = secondaryBidiagonal[i];\n173                         for (int j = 0; j < p; ++j) {\n174                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n175                         }\n176                 }\n177                         for (int j = 0; j < p; ++j) {\n178                             wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n179                         }\n180 \n181                 for (int i = p; i < m; ++i) {\n182                     wData[i] = new double[p];\n183                 }\n184                 cachedU =\n185                     transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n186             } else {\n187                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n188                 final RealMatrix e =\n189                     eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n190                 cachedU = transformer.getU().multiply(e);\n191             }\n192 \n193         }\n194 \n195         // return the cached matrix\n196         return cachedU;\n197 \n198     }", "bm_classpath": "org.apache.commons.math.linear.SingularValueDecompositionImpl"}, {"bug_name": "Math_77", "report_text": "> getLInfNorm() uses wrong formula in both ArrayRealVector and OpenMapRealVector (in different ways)\n> \n> the L\\_infinity norm of a finite dimensional vector is just the max of the absolute value of its entries.\n> The current implementation in ArrayRealVector has a typo:\n> ```\n>     public double getLInfNorm() {\n>         double max = 0;\n>         for (double a : data) {\n>             max += Math.max(max, Math.abs(a));\n>         }\n>         return max;\n>     }\n> ```\n> the += should just be an =.\n> There is sadly a unit test assuring us that this is the correct behavior (effectively a regression-only test, not a test for correctness).\n> Worse, the implementation in OpenMapRealVector is not even positive semi-definite:\n> ```\n>    \n>     public double getLInfNorm() {\n>         double max = 0;\n>         Iterator iter = entries.iterator();\n>         while (iter.hasNext()) {\n>             iter.advance();\n>             max += iter.value();\n>         }\n>         return max;\n>     }\n> ```\n> I would suggest that this method be moved up to the AbstractRealVector superclass and implemented using the sparseIterator():\n> ```\n>   public double getLInfNorm() {\n>     double norm = 0;\n>     Iterator<Entry> it = sparseIterator();\n>     Entry e;\n>     while(it.hasNext() && (e = it.next()) != null) {\n>       norm = Math.max(norm, Math.abs(e.getValue()));\n>     }\n>     return norm;\n>   }\n> ```\n> Unit tests with negative valued vectors would be helpful to check for this kind of thing in the future.", "test_name": "org.apache.commons.math.linear.ArrayRealVectorTest::testBasicFunctions", "test_method": "    public void testBasicFunctions() {\n        ArrayRealVector v1 = new ArrayRealVector(vec1);\n        ArrayRealVector v2 = new ArrayRealVector(vec2);\n        ArrayRealVector v5 = new ArrayRealVector(vec5);\n        ArrayRealVector v_null = new ArrayRealVector(vec_null);\n\n        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] A --> 8.4261497731763586307\n        double d_getNorm = v5.getNorm();\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vN --> 17\n        double d_getL1Norm = v5.getL1Norm();\n\n        // emacs calc: [-4, 0, 3, 1, -6, 3] vn --> 6\n        double d_getLInfNorm = v5.getLInfNorm();\n        assertEquals(\"compare values  \", 6.0, d_getLInfNorm); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: compare values   expected:<6.0> but was:<128.0>\n\torg.apache.commons.math.linear.ArrayRealVectorTest.testBasicFunctions(ArrayRealVectorTest.java:1098)", "buggy_method": "717 @Override\n718     public double getLInfNorm() {\n719         double max = 0;\n720         for (double a : data) {\n721             max += Math.max(max, Math.abs(a));\n722         }\n723         return max;\n724     }", "bm_classpath": "org.apache.commons.math.linear.ArrayRealVector"}, {"bug_name": "Math_78", "report_text": "> during ODE integration, the last event in a pair of very close event may not be detected\n> \n> When an events follows a previous one very closely, it may be ignored. The occurrence of the bug depends on the side of the bracketing interval that was selected. For example consider a switching function that is increasing around first event around t = 90, reaches its maximum and is decreasing around the second event around t = 135. If an integration step spans from 67.5 and 112.5, the switching function values at start and end of step will have opposite signs, so the first event will be detected. The solver will find the event really occurs at 90.0 and will therefore truncate the step at 90.0. The next step will start from where the first step ends, i.e. it will start at 90.0. Let's say this step spans from 90.0 to 153.0. The switching function switches once again in this step.\n> If the solver for the first event converged to a value slightly before 90.0 (say 89.9999999), then the switch will not be detected because g(89.9999999) and g(153.0) are both negative.\n> This bug was introduced as of r781157 (2009-06-02) when special handling of events very close to step start was added.", "test_name": "org.apache.commons.math.ode.events.EventStateTest::closeEvents", "test_method": "    @Test\n    public void closeEvents()\n        throws EventException, ConvergenceException, DerivativeException {\n\n        final double r1  = 90.0;\n        final double r2  = 135.0;\n        final double gap = r2 - r1;\n        EventHandler closeEventsGenerator = new EventHandler() {\n            public void resetState(double t, double[] y) {\n            }\n            public double g(double t, double[] y) {\n                return (t - r1) * (r2 - t);\n            }\n            public int eventOccurred(double t, double[] y, boolean increasing) {\n                return CONTINUE;\n            }\n        };\n\n        final double tolerance = 0.1;\n        EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n\n        double t0 = r1 - 0.5 * gap;\n        es.reinitializeBegin(t0, new double[0]);\n        AbstractStepInterpolator interpolator =\n            new DummyStepInterpolator(new double[0], true);\n        interpolator.storeTime(t0);\n\n        interpolator.shift();\n        interpolator.storeTime(0.5 * (r1 + r2));\n        es.stepAccepted(es.getEventTime(), new double[0]);\n\n        interpolator.shift();\n        interpolator.storeTime(r2 + 0.4 * gap);\n        Assert.assertTrue(es.evaluateStep(interpolator)); // <-- fails here\n    }", "error_message": "org.apache.commons.math.MathRuntimeException$4: function values at endpoints do not have different signs.  Endpoints: [89.999, 153.1], Values: [-0.066, -1,142.11]\n\torg.apache.commons.math.MathRuntimeException.createIllegalArgumentException(MathRuntimeException.java:305)\n\torg.apache.commons.math.analysis.solvers.BrentSolver.solve(BrentSolver.java:178)\n\torg.apache.commons.math.ode.events.EventState.evaluateStep(EventState.java:218)\n\torg.apache.commons.math.ode.events.EventStateTest.closeEvents(EventStateTest.java:66)", "buggy_method": "167 public boolean evaluateStep(final StepInterpolator interpolator)\n168         throws DerivativeException, EventException, ConvergenceException {\n169 \n170         try {\n171 \n172             forward = interpolator.isForward();\n173             final double t1 = interpolator.getCurrentTime();\n174             final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n175             final double h  = (t1 - t0) / n;\n176 \n177             double ta = t0;\n178             double ga = g0;\n179             double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n180             for (int i = 0; i < n; ++i) {\n181 \n182                 // evaluate handler value at the end of the substep\n183                 tb += h;\n184                 interpolator.setInterpolatedTime(tb);\n185                 final double gb = handler.g(tb, interpolator.getInterpolatedState());\n186 \n187                 // check events occurrence\n188                 if (g0Positive ^ (gb >= 0)) {\n189                     // there is a sign change: an event is expected during this step\n190 \n191                         // this is a corner case:\n192                         // - there was an event near ta,\n193                         // - there is another event between ta and tb\n194                         // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n195                         // this implies that the real sign of ga is the same as gb, so we need to slightly\n196                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n197                         // about bracketing\n198                             // this should never happen\n199                          \n200                     // variation direction, with respect to the integration direction\n201                     increasing = gb >= ga;\n202 \n203                     final UnivariateRealFunction f = new UnivariateRealFunction() {\n204                         public double value(final double t) throws FunctionEvaluationException {\n205                             try {\n206                                 interpolator.setInterpolatedTime(t);\n207                                 return handler.g(t, interpolator.getInterpolatedState());\n208                             } catch (DerivativeException e) {\n209                                 throw new FunctionEvaluationException(e, t);\n210                             } catch (EventException e) {\n211                                 throw new FunctionEvaluationException(e, t);\n212                             }\n213                         }\n214                     };\n215                     final BrentSolver solver = new BrentSolver();\n216                     solver.setAbsoluteAccuracy(convergence);\n217                     solver.setMaximalIterationCount(maxIterationCount);\n218                     final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n219                     if ((Math.abs(root - ta) <= convergence) &&\n220                          (Math.abs(root - previousEventTime) <= convergence)) {\n221                         // we have either found nothing or found (again ?) a past event, we simply ignore it\n222                         ta = tb;\n223                         ga = gb;\n224                     } else if (Double.isNaN(previousEventTime) ||\n225                                (Math.abs(previousEventTime - root) > convergence)) {\n226                         pendingEventTime = root;\n227                         if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n228                             // we were already waiting for this event which was\n229                             // found during a previous call for a step that was\n230                             // rejected, this step must now be accepted since it\n231                             // properly ends exactly at the event occurrence\n232                             return false;\n233                         }\n234                         // either we were not waiting for the event or it has\n235                         // moved in such a way the step cannot be accepted\n236                         pendingEvent = true;\n237                         return true;\n238                     }\n239 \n240                 } else {\n241                     // no sign change: there is no event for now\n242                     ta = tb;\n243                     ga = gb;\n244                 }\n245 \n246             }\n247 \n248             // no event during the whole step\n249             pendingEvent     = false;\n250             pendingEventTime = Double.NaN;\n251             return false;\n252 \n253         } catch (FunctionEvaluationException e) {\n254             final Throwable cause = e.getCause();\n255             if ((cause != null) && (cause instanceof DerivativeException)) {\n256                 throw (DerivativeException) cause;\n257             } else if ((cause != null) && (cause instanceof EventException)) {\n258                 throw (EventException) cause;\n259             }\n260             throw new EventException(e);\n261         }\n262 \n263     }", "bm_classpath": "org.apache.commons.math.ode.events.EventState"}, {"bug_name": "Math_79", "report_text": "> NPE in  KMeansPlusPlusClusterer unittest\n> \n> When running this unittest, I am facing this NPE:  \n> java.lang.NullPointerException  \n>  at org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91)\n> This is the unittest:\n> package org.fao.fisheries.chronicles.calcuation.cluster;\n> import static org.junit.Assert.assertEquals;  \n> import static org.junit.Assert.assertTrue;\n> import java.util.Arrays;  \n> import java.util.List;  \n> import java.util.Random;\n> import org.apache.commons.math.stat.clustering.Cluster;  \n> import org.apache.commons.math.stat.clustering.EuclideanIntegerPoint;  \n> import org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer;  \n> import org.fao.fisheries.chronicles.input.CsvImportProcess;  \n> import org.fao.fisheries.chronicles.input.Top200Csv;  \n> import org.junit.Test;\n> public class ClusterAnalysisTest {\n>  @Test  \n>  public void testPerformClusterAnalysis2() {  \n>  KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(  \n>  new Random(1746432956321l));  \n>  EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {  \n>  new EuclideanIntegerPoint(new int[] \n> { 1959, 325100 }\n> ),  \n>  new EuclideanIntegerPoint(new int[] \n> { 1960, 373200 }\n> ), };  \n>  List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);  \n>  assertEquals(1, clusters.size());\n>  }\n> }", "test_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest::testPerformClusterAnalysisDegenerate", "test_method": "    @Test\n    public void testPerformClusterAnalysisDegenerate() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(KMeansPlusPlusClusterer.java:91)\n\torg.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.cluster(KMeansPlusPlusClusterer.java:57)\n\torg.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testPerformClusterAnalysisDegenerate(KMeansPlusPlusClustererTest.java:109)", "buggy_method": "1623 public static double distance(int[] p1, int[] p2) {\n1624       int sum = 0;\n1625       for (int i = 0; i < p1.length; i++) {\n1626           final int dp = p1[i] - p2[i];\n1627           sum += dp * dp;\n1628       }\n1629       return Math.sqrt(sum);\n1630     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_80", "report_text": "> wrong result in eigen decomposition\n> \n> Some results computed by EigenDecompositionImpl are wrong. The following case computed by Fortran Lapack fails with version 2.0\n> ```\n>     public void testMathpbx02() {\n>         double[] mainTridiagonal = {\n>         \t  7484.860960227216, 18405.28129035345, 13855.225609560746,\n>         \t 10016.708722343366, 559.8117399576674, 6750.190788301587, \n>         \t    71.21428769782159\n>         };\n>         double[] secondaryTridiagonal = {\n>         \t -4175.088570476366,1975.7955858241994,5193.178422374075, \n>         \t  1995.286659169179,75.34535882933804,-234.0808002076056\n>         };\n>         // the reference values have been computed using routine DSTEMR\n>         // from the fortran library LAPACK version 3.2.1\n>         double[] refEigenValues = {\n>         \t\t20654.744890306974412,16828.208208485466457,\n>         \t\t6893.155912634994820,6757.083016675340332,\n>         \t\t5887.799885688558788,64.309089923240379,\n>         \t\t57.992628792736340\n>         };\n>         RealVector[] refEigenVectors = {\n>         \t\tnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n>         \t\tnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n>         \t\tnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n>         \t\tnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n>         \t\tnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n>         \t\tnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n>         \t\tnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n>         };\n>         // the following line triggers the exception\n>         EigenDecomposition decomposition =\n>             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n>         double[] eigenValues = decomposition.getRealEigenvalues();\n>         for (int i = 0; i < refEigenValues.length; ++i) {\n>             assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n>             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n>                 assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n>             } else {\n>                 assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n>             }\n>         }\n>     }\n> ```", "test_name": "org.apache.commons.math.linear.EigenDecompositionImplTest::testMathpbx02", "test_method": "    public void testMathpbx02() {\n\n        double[] mainTridiagonal = {\n        \t  7484.860960227216, 18405.28129035345, 13855.225609560746,\n        \t 10016.708722343366, 559.8117399576674, 6750.190788301587, \n        \t    71.21428769782159\n        };\n        double[] secondaryTridiagonal = {\n        \t -4175.088570476366,1975.7955858241994,5193.178422374075, \n        \t  1995.286659169179,75.34535882933804,-234.0808002076056\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n        \t\t20654.744890306974412,16828.208208485466457,\n        \t\t6893.155912634994820,6757.083016675340332,\n        \t\t5887.799885688558788,64.309089923240379,\n        \t\t57.992628792736340\n        };\n        RealVector[] refEigenVectors = {\n        \t\tnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n        \t\tnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n        \t\tnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n        \t\tnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n        \t\tnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n        \t\tnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n        \t\tnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n        };\n\n        // the following line triggers the exception\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n                assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n            } else {\n                assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<16828.208208485466> but was:<20654.74511575945>\n\torg.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02(EigenDecompositionImplTest.java:181)", "buggy_method": "1132 private boolean flipIfWarranted(final int n, final int step) {\n1133         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n1134             // flip array\n1135             int j = 4 * n - 1;\n1136             for (int i = 0; i < j; i += 4) {\n1137                 for (int k = 0; k < 4; k += step) {\n1138                     final double tmp = work[i + k];\n1139                     work[i + k] = work[j - k];\n1140                     work[j - k] = tmp;\n1141                 }\n1142                 j -= 4;\n1143             }\n1144             return true;\n1145         }\n1146         return false;\n1147     }", "bm_classpath": "org.apache.commons.math.linear.EigenDecompositionImpl"}, {"bug_name": "Math_81", "report_text": "> ArrayIndexOutOfBoundException in EigenDecompositionImpl\n> \n> The following test triggers an ArrayIndexOutOfBoundException:\n> ```\n>     public void testMath308() {\n>         double[] mainTridiagonal = {\n>             22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n>         };\n>         double[] secondaryTridiagonal = {\n>             13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n>         };\n>         // the reference values have been computed using routine DSTEMR\n>         // from the fortran library LAPACK version 3.2.1\n>         double[] refEigenValues = {\n>             14.138204224043099, 18.847969733754262, 52.536278520113882, 53.456697699894512, 82.044413207204002\n>         };\n>         RealVector[] refEigenVectors = {\n>             new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 }),\n>             new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n>             new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n>             new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n>             new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 })\n>         };\n>         // the following line triggers the exception\n>         EigenDecomposition decomposition =\n>             new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n>         double[] eigenValues = decomposition.getRealEigenvalues();\n>         for (int i = 0; i < refEigenValues.length; ++i) {\n>             assertEquals(refEigenValues[i], eigenValues[i], 1.0e-6);\n>             if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n>                 assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-6);\n>             } else {\n>                 assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-6);\n>             }\n>         }\n>     }\n> ```\n> Running the previous method as a Junit test triggers the exception when the EigenDecompositionImpl instance is built. The first few lines of the stack trace are:\n> ```\n> java.lang.ArrayIndexOutOfBoundsException: -1\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(EigenDecompositionImpl.java:1545)\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.goodStep(EigenDecompositionImpl.java:1072)\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(EigenDecompositionImpl.java:894)\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues(EigenDecompositionImpl.java:658)\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.decompose(EigenDecompositionImpl.java:246)\n> \tat org.apache.commons.math.linear.EigenDecompositionImpl.<init>(EigenDecompositionImpl.java:205)\n> \tat org.apache.commons.math.linear.EigenDecompositionImplTest.testMath308(EigenDecompositionImplTest.java:136)\n> ```\n> I'm currently investigating this bug. It is not a simple index translation error between the original fortran (Lapack) and commons-math implementation.", "test_name": "org.apache.commons.math.linear.EigenDecompositionImplTest::testMath308", "test_method": "    public void testMath308() {\n\n        double[] mainTridiagonal = {\n            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n        };\n        double[] secondaryTridiagonal = {\n            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n        };\n        RealVector[] refEigenVectors = {\n            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n            new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n            new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n        };\n\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: -1\n\torg.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(EigenDecompositionImpl.java:1544)\n\torg.apache.commons.math.linear.EigenDecompositionImpl.goodStep(EigenDecompositionImpl.java:1071)\n\torg.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(EigenDecompositionImpl.java:893)\n\torg.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues(EigenDecompositionImpl.java:657)\n\torg.apache.commons.math.linear.EigenDecompositionImpl.decompose(EigenDecompositionImpl.java:246)\n\torg.apache.commons.math.linear.EigenDecompositionImpl.<init>(EigenDecompositionImpl.java:205)\n\torg.apache.commons.math.linear.EigenDecompositionImplTest.testMath308(EigenDecompositionImplTest.java:134)", "buggy_method": "569 private void computeGershgorinCircles() {\n570 \n571         final int m     = main.length;\n572         final int lowerStart = 4 * m;\n573         final int upperStart = 5 * m;\n574         lowerSpectra = Double.POSITIVE_INFINITY;\n575         upperSpectra = Double.NEGATIVE_INFINITY;\n576         double eMax = 0;\n577 \n578         double eCurrent = 0;\n579         for (int i = 0; i < m - 1; ++i) {\n580 \n581             final double dCurrent = main[i];\n582             final double ePrevious = eCurrent;\n583             eCurrent = Math.abs(secondary[i]);\n584             eMax = Math.max(eMax, eCurrent);\n585             final double radius = ePrevious + eCurrent;\n586 \n587             final double lower = dCurrent - radius;\n588             work[lowerStart + i] = lower;\n589             lowerSpectra = Math.min(lowerSpectra, lower);\n590 \n591             final double upper = dCurrent + radius;\n592             work[upperStart + i] = upper;\n593             upperSpectra = Math.max(upperSpectra, upper);\n594 \n595         }\n596 \n597         final double dCurrent = main[m - 1];\n598         final double lower = dCurrent - eCurrent;\n599         work[lowerStart + m - 1] = lower;\n600         lowerSpectra = Math.min(lowerSpectra, lower);\n601         final double upper = dCurrent + eCurrent;\n602         work[upperStart + m - 1] = upper;\n603         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n604 \n605     }", "bm_classpath": "org.apache.commons.math.linear.EigenDecompositionImpl"}, {"bug_name": "Math_82", "report_text": "> SimplexSolver not working as expected 2\n> \n> SimplexSolver didn't find the optimal solution.\n> Program for Lpsolve:  \n> =====================  \n> /\\* Objective function \\*/  \n> max: 7 a 3 b;\n> /\\* Constraints \\*/  \n> R1: +3 a -5 c <= 0;  \n> R2: +2 a -5 d <= 0;  \n> R3: +2 b -5 c <= 0;  \n> R4: +3 b -5 d <= 0;  \n> R5: +3 a +2 b <= 5;  \n> R6: +2 a +3 b <= 5;\n> /\\* Variable bounds \\*/  \n> a <= 1;  \n> b <= 1;  \n> =====================  \n> Results(correct): a = 1, b = 1, value = 10\n> Program for SimplexSolve:  \n> =====================  \n> LinearObjectiveFunction kritFcia = new LinearObjectiveFunction(new double[]\n> {7, 3, 0, 0}\n> , 0);  \n> Collection<LinearConstraint> podmienky = new ArrayList<LinearConstraint>();  \n> podmienky.add(new LinearConstraint(new double[]\n> {1, 0, 0, 0}\n> , Relationship.LEQ, 1));  \n> podmienky.add(new LinearConstraint(new double[]\n> {0, 1, 0, 0}\n> , Relationship.LEQ, 1));  \n> podmienky.add(new LinearConstraint(new double[]\n> {3, 0, -5, 0}\n> , Relationship.LEQ, 0));  \n> podmienky.add(new LinearConstraint(new double[]\n> {2, 0, 0, -5}\n> , Relationship.LEQ, 0));  \n> podmienky.add(new LinearConstraint(new double[]\n> {0, 2, -5, 0}\n> , Relationship.LEQ, 0));  \n> podmienky.add(new LinearConstraint(new double[]\n> {0, 3, 0, -5}\n> , Relationship.LEQ, 0));  \n> podmienky.add(new LinearConstraint(new double[]\n> {3, 2, 0, 0}\n> , Relationship.LEQ, 5));  \n> podmienky.add(new LinearConstraint(new double[]\n> {2, 3, 0, 0}\n> , Relationship.LEQ, 5));  \n> SimplexSolver solver = new SimplexSolver();  \n> RealPointValuePair result = solver.optimize(kritFcia, podmienky, GoalType.MAXIMIZE, true);  \n> =====================  \n> Results(incorrect): a = 1, b = 0.5, value = 8.5\n> P.S. I used the latest software from the repository (including [~~MATH-286~~](https://issues.apache.org/jira/browse/MATH-286 \"SimplexSolver not working as expected?\") fix).", "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath288", "test_method": "    @Test\n    public void testMath288() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 7, 3, 0, 0 }, 0 );\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 3, 0, -5, 0 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 2, 0, 0, -5 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 0, 3, 0, -5 }, Relationship.LEQ, 0.0));\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 0, 0 }, Relationship.LEQ, 1.0));\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0, 0 }, Relationship.LEQ, 1.0));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, true);\n        assertEquals(10.0, solution.getValue(), .0000001); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<10.0> but was:<11.5>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.linear.SimplexSolverTest.testMath288(SimplexSolverTest.java:73)", "buggy_method": "76 private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n77         double minRatio = Double.MAX_VALUE;\n78         Integer minRatioPos = null;\n79         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n80             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n81             final double entry = tableau.getEntry(i, col);\n82             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n83                 final double ratio = rhs / entry;\n84                 if (ratio < minRatio) {\n85                     minRatio = ratio;\n86                     minRatioPos = i; \n87                 }\n88             }\n89         }\n90         return minRatioPos;\n91     }", "bm_classpath": "org.apache.commons.math.optimization.linear.SimplexSolver"}, {"bug_name": "Math_83", "report_text": "> SimplexSolver not working as expected?\n> \n> I guess (but I could be wrong) that SimplexSolver does not always return the optimal solution, nor satisfies all the constraints...\n> Consider this LP:\n> max: 0.8 x0 + 0.2 x1 + 0.7 x2 + 0.3 x3 + 0.6 x4 + 0.4 x5;  \n> r1: x0 + x2 + x4 = 23.0;  \n> r2: x1 + x3 + x5 = 23.0;  \n> r3: x0 >= 10.0;  \n> r4: x2 >= 8.0;  \n> r5: x4 >= 5.0;\n> LPSolve returns 25.8, with x0 = 10.0, x1 = 0.0, x2 = 8.0, x3 = 0.0, x4 = 5.0, x5 = 23.0;\n> The same LP expressed in Apache commons math is:\n> LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] \n> { 0.8, 0.2, 0.7, 0.3, 0.6, 0.4 }\n> , 0 );  \n> Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();  \n> constraints.add(new LinearConstraint(new double[] \n> { 1, 0, 1, 0, 1, 0 }\n> , Relationship.EQ, 23.0));  \n> constraints.add(new LinearConstraint(new double[] \n> { 0, 1, 0, 1, 0, 1 }\n> , Relationship.EQ, 23.0));  \n> constraints.add(new LinearConstraint(new double[] \n> { 1, 0, 0, 0, 0, 0 }\n> , Relationship.GEQ, 10.0));  \n> constraints.add(new LinearConstraint(new double[] \n> { 0, 0, 1, 0, 0, 0 }\n> , Relationship.GEQ, 8.0));  \n> constraints.add(new LinearConstraint(new double[] \n> { 0, 0, 0, 0, 1, 0 }\n> , Relationship.GEQ, 5.0));\n> RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true);\n> that returns 22.20, with x0 = 15.0, x1 = 23.0, x2 = 8.0, x3 = 0.0, x4 = 0.0, x5 = 0.0;\n> Is it possible SimplexSolver is buggy that way? The returned value is 22.20 instead of 25.8, and the last constraint (x4 >= 5.0) is not satisfied...\n> Am I using the interface wrongly?", "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath286", "test_method": "    @Test\n    public void testMath286() throws OptimizationException {\n      LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 0.2, 0.3 }, 0 );\n      Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n      constraints.add(new LinearConstraint(new double[] { 1, 1 }, Relationship.EQ, 23.0));\n\n      RealPointValuePair solution = new SimplexSolver().optimize(f, constraints, GoalType.MAXIMIZE, true);\n      assertEquals(6.9, solution.getValue(), .0000001); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<6.9> but was:<4.6000000000000005>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.linear.SimplexSolverTest.testMath286(SimplexSolverTest.java:58)", "buggy_method": "290 private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n291         Integer row = null;\n292         int start = getNumObjectiveFunctions();\n293         for (int i = start; i < getHeight(); i++) {\n294             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n295                 row = i;\n296             } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n297                 return null;\n298             }\n299         }\n300         return row;\n301     }", "bm_classpath": "org.apache.commons.math.optimization.linear.SimplexTableau"}, {"bug_name": "Math_84", "report_text": "> MultiDirectional optimzation loops forver if started at the correct solution\n> \n> MultiDirectional.iterateSimplex loops forever if the starting point is the correct solution.\n> see the attached test case (testMultiDirectionalCorrectStart) as an example.", "test_name": "org.apache.commons.math.optimization.direct.MultiDirectionalTest::testMinimizeMaximize", "test_method": "  @Test\n  public void testMinimizeMaximize()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      Assert.assertTrue(optimizer.getEvaluations() < 150); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.apache.commons.math.optimization.direct.MultiDirectionalTest.testMinimizeMaximize(MultiDirectionalTest.java:103)", "buggy_method": "60 @Override\n61     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n62         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n63 \n64         while (true) {\n65 \n66             incrementIterationsCounter();\n67 \n68             // save the original vertex\n69             final RealPointValuePair[] original = simplex;\n70             final RealPointValuePair best = original[0];\n71 \n72             // perform a reflection step\n73             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n74             if (comparator.compare(reflected, best) < 0) {\n75 \n76                 // compute the expanded simplex\n77                 final RealPointValuePair[] reflectedSimplex = simplex;\n78                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n79                 if (comparator.compare(reflected, expanded) <= 0) {\n80                     // accept the reflected simplex\n81                     simplex = reflectedSimplex;\n82                 }\n83 \n84                 return;\n85 \n86             }\n87 \n88             // compute the contracted simplex\n89             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n90             if (comparator.compare(contracted, best) < 0) {\n91                 // accept the contracted simplex\n92 \n93             // check convergence\n94                 return;\n95             }\n96 \n97         }\n98 \n99     }", "bm_classpath": "org.apache.commons.math.optimization.direct.MultiDirectional"}, {"bug_name": "Math_85", "report_text": "> bug in inverseCumulativeProbability() for Normal Distribution\n> \n> * @version $Revision: 617953 $ $Date: 2008-02-02 22:54:00 -0700 (Sat, 02 Feb 2008) $  \n>  \\*/  \n> public class NormalDistributionImpl extends AbstractContinuousDistribution\n> * @version $Revision: 506600 $ $Date: 2007-02-12 12:35:59 -0700 (Mon, 12 Feb 2007) $  \n>  \\*/  \n> public abstract class AbstractContinuousDistribution\n> This code:\n>  DistributionFactory factory = app.getDistributionFactory();  \n>  NormalDistribution normal = factory.createNormalDistribution(0,1);  \n>  double result = normal.inverseCumulativeProbability(0.9772498680518209);\n> gives the exception below. It should return (approx) 2.0000...\n> normal.inverseCumulativeProbability(0.977249868051820); works fine\n> These also give errors:  \n> 0.9986501019683698 (should return 3.0000...)  \n> 0.9999683287581673 (should return 4.0000...)\n> org.apache.commons.math.MathException: Number of iterations=1, maximum iterations=2,147,483,647, initial=1, lower bound=0, upper bound=179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000, final a value=0, final b value=2, f(a)=-0.477, f(b)=0  \n>  at org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:103)  \n>  at org.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:145)", "test_name": "org.apache.commons.math.distribution.NormalDistributionTest::testMath280", "test_method": "    public void testMath280() throws MathException {\n        NormalDistribution normal = new NormalDistributionImpl(0,1);\n        double result = normal.inverseCumulativeProbability(0.9772498680518209); // <-- fails here\n    }", "error_message": "org.apache.commons.math.MathException: org.apache.commons.math.ConvergenceException: number of iterations=1, maximum iterations=2,147,483,647, initial=1, lower bound=0, upper bound=179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000, final a value=0, final b value=2, f(a)=-0.477, f(b)=0\n\torg.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:104)\n\torg.apache.commons.math.distribution.NormalDistributionImpl.inverseCumulativeProbability(NormalDistributionImpl.java:162)\n\torg.apache.commons.math.distribution.NormalDistributionTest.testMath280(NormalDistributionTest.java:169)", "buggy_method": "165 public static double[] bracket(UnivariateRealFunction function,\n166             double initial, double lowerBound, double upperBound, \n167             int maximumIterations) throws ConvergenceException, \n168             FunctionEvaluationException {\n169         \n170         if (function == null) {\n171             throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n172         }\n173         if (maximumIterations <= 0)  {\n174             throw MathRuntimeException.createIllegalArgumentException(\n175                   \"bad value for maximum iterations number: {0}\", maximumIterations);\n176         }\n177         if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n178             throw MathRuntimeException.createIllegalArgumentException(\n179                   \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n180                   lowerBound, initial, upperBound);\n181         }\n182         double a = initial;\n183         double b = initial;\n184         double fa;\n185         double fb;\n186         int numIterations = 0 ;\n187     \n188         do {\n189             a = Math.max(a - 1.0, lowerBound);\n190             b = Math.min(b + 1.0, upperBound);\n191             fa = function.value(a);\n192             \n193             fb = function.value(b);\n194             numIterations++ ;\n195         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n196                 ((a > lowerBound) || (b < upperBound)));\n197    \n198         if (fa * fb >= 0.0 ) {\n199             throw new ConvergenceException(\n200                       \"number of iterations={0}, maximum iterations={1}, \" +\n201                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n202                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n203                       numIterations, maximumIterations, initial,\n204                       lowerBound, upperBound, a, b, fa, fb);\n205         }\n206         \n207         return new double[]{a, b};\n208     }", "bm_classpath": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils"}, {"bug_name": "Math_86", "report_text": "> testing for symmetric positive definite matrix in CholeskyDecomposition\n> \n> I used this matrix:\n>  double[][] cv = {  \n> {0.40434286, 0.09376327, 0.30328980, 0.04909388}\n> ,  \n> {0.09376327, 0.10400408, 0.07137959, 0.04762857}\n> ,  \n> {0.30328980, 0.07137959, 0.30458776, 0.04882449},  \n>  {0.04909388, 0.04762857, 0.04882449, 0.07543265}  \n>  };  \n>   \n> And it works fine, because it is symmetric positive definite  \n>   \n> I tried this matrix:  \n>   \n>  double[][] cv = {  \n>  {0.40434286, -0.09376327, 0.30328980, 0.04909388},  \n>  {-0.09376327, 0.10400408, 0.07137959, 0.04762857},  \n>  {0.30328980, 0.07137959, 0.30458776, 0.04882449}\n> ,\n>  {0.04909388, 0.04762857, 0.04882449, 0.07543265}\n>  };\n> And it should throw an exception but it does not. I tested the matrix in R and R's cholesky decomposition method returns that the matrix is not symmetric positive definite.\n> Obviously your code is not catching this appropriately.\n> By the way (in my opinion) the use of exceptions to check these conditions is not the best design or use for exceptions. If you are going to force the use to try and catch these exceptions at least provide methods to test the conditions prior to the possibility of the exception. ", "test_name": "org.apache.commons.math.linear.CholeskyDecompositionImplTest::testMath274", "test_method": "public void testMath274() throws MathException {\n        new CholeskyDecompositionImpl(MatrixUtils.createRealMatrix(new double[][] {\n                { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },\n                {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n                { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n                { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n            \n        }));\n    }\n\n    /** test A = LLT */\n    @Test", "error_message": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math.linear.NotPositiveDefiniteMatrixException\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)", "buggy_method": "93 public CholeskyDecompositionImpl(final RealMatrix matrix,\n94                                      final double relativeSymmetryThreshold,\n95                                      final double absolutePositivityThreshold)\n96         throws NonSquareMatrixException,\n97                NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n98 \n99         if (!matrix.isSquare()) {\n100             throw new NonSquareMatrixException(matrix.getRowDimension(),\n101                                                matrix.getColumnDimension());\n102         }\n103 \n104         final int order = matrix.getRowDimension();\n105         lTData   = matrix.getData();\n106         cachedL  = null;\n107         cachedLT = null;\n108 \n109         // check the matrix before transformation\n110         for (int i = 0; i < order; ++i) {\n111 \n112             final double[] lI = lTData[i];\n113 \n114             if (lTData[i][i] < absolutePositivityThreshold) {\n115                 throw new NotPositiveDefiniteMatrixException();\n116             }\n117             // check off-diagonal elements (and reset them to 0)\n118             for (int j = i + 1; j < order; ++j) {\n119                 final double[] lJ = lTData[j];\n120                 final double lIJ = lI[j];\n121                 final double lJI = lJ[i];\n122                 final double maxDelta =\n123                     relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n124                 if (Math.abs(lIJ - lJI) > maxDelta) {\n125                     throw new NotSymmetricMatrixException();\n126                 }\n127                 lJ[i] = 0;\n128            }\n129         }\n130 \n131         // transform the matrix\n132         for (int i = 0; i < order; ++i) {\n133 \n134             final double[] ltI = lTData[i];\n135 \n136             // check diagonal element\n137 \n138             ltI[i] = Math.sqrt(ltI[i]);\n139             final double inverse = 1.0 / ltI[i];\n140 \n141             for (int q = order - 1; q > i; --q) {\n142                 ltI[q] *= inverse;\n143                 final double[] ltQ = lTData[q];\n144                 for (int p = q; p < order; ++p) {\n145                     ltQ[p] -= ltI[q] * ltI[p];\n146                 }\n147             }\n148 \n149         }\n150 \n151     }", "bm_classpath": "org.apache.commons.math.linear.CholeskyDecompositionImpl"}, {"bug_name": "Math_87", "report_text": "> Basic variable is not found correctly in simplex tableau\n> \n> The last patch to SimplexTableau caused an automated test suite I'm running at work to go down a new code path and uncover what is hopefully the last bug remaining in the Simplex code.  \n> SimplexTableau was assuming an entry in the tableau had to be nonzero to indicate a basic variable, which is incorrect - the entry should have a value equal to 1.", "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest::testSingleVariableAndConstraint", "test_method": "    @Test\n    public void testSingleVariableAndConstraint() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 3 }, 0);\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1 }, Relationship.LEQ, 10));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MAXIMIZE, false);\n        assertEquals(10.0, solution.getPoint()[0], 0.0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<10.0> but was:<0.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.linear.SimplexSolverTest.testSingleVariableAndConstraint(SimplexSolverTest.java:75)", "buggy_method": "272 private Integer getBasicRow(final int col) {\n273         Integer row = null;\n274         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n275             if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n276                 if (row == null) {\n277                 row = i;\n278                 } else {\n279                 return null;\n280                 }\n281             }\n282         }\n283         return row;\n284     }", "bm_classpath": "org.apache.commons.math.optimization.linear.SimplexTableau"}, {"bug_name": "Math_88", "report_text": "> Simplex Solver arrives at incorrect solution\n> \n> I have reduced the problem reported to me down to a minimal test case which I will attach.", "test_name": "org.apache.commons.math.optimization.linear.SimplexSolverTest::testMath272", "test_method": "    @Test\n    public void testMath272() throws OptimizationException {\n        LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 2, 2, 1 }, 0);\n        Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        constraints.add(new LinearConstraint(new double[] { 1, 1, 0 }, Relationship.GEQ,  1));\n        constraints.add(new LinearConstraint(new double[] { 1, 0, 1 }, Relationship.GEQ,  1));\n        constraints.add(new LinearConstraint(new double[] { 0, 1, 0 }, Relationship.GEQ,  1));\n\n        SimplexSolver solver = new SimplexSolver();\n        RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n        \n        assertEquals(1.0, solution.getPoint()[2], .0000001); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<1.0> but was:<0.0>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotEquals(Assert.java:743)\n\torg.junit.Assert.assertEquals(Assert.java:494)\n\torg.junit.Assert.assertEquals(Assert.java:592)\n\torg.apache.commons.math.optimization.linear.SimplexSolverTest.testMath272(SimplexSolverTest.java:47)", "buggy_method": "324 protected RealPointValuePair getSolution() {\n325         double[] coefficients = new double[getOriginalNumDecisionVariables()];\n326         Integer basicRow =\n327             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n328         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n329         for (int i = 0; i < coefficients.length; i++) {\n330             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n331                 // if multiple variables can take a given value \n332                 // then we choose the first and set the rest equal to 0\n333                 coefficients[i] =\n334                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n335                     (restrictToNonNegative ? 0 : mostNegative);\n336             if (basicRow != null) {\n337                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n338                     if (tableau.getEntry(basicRow, j) == 1) {\n339                          coefficients[i] = 0;\n340                     }\n341                 }\n342             }\n343         }\n344         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n345     }", "bm_classpath": "org.apache.commons.math.optimization.linear.SimplexTableau"}, {"bug_name": "Math_89", "report_text": "> Bugs in Frequency API\n> \n> I think the existing Frequency API has some bugs in it.\n> The addValue(Object v) method allows one to add a plain Object, but one cannot add anything further to the instance, as the second add fails with IllegalArgumentException.  \n> In fact, the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects.  \n> This could be fixed by checking that the object is Comparable.\n> Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable.\n> The getCount(Object) and getPct(Object) methods don't fail when given a non-Comparable object (because the class cast exception is caught), however they just return 0 as if the object was not present:\n> ```\n>         final Object OBJ = new Object();\n>         f.addValue(OBJ); // This ought to fail, but doesn't, causing the unexpected behaviour below\n>         System.out.println(f.getCount(OBJ)); // 0\n>         System.out.println(f.getPct(OBJ)); // 0.0\n> ```\n> Rather than adding extra checks for Comparable, it seems to me that the API would be much improved by using Comparable instead of Object.  \n> Also, it should make it easier to implement generics.\n> However, this would cause compilation failures for some programs that pass Object rather than Comparable to the class.  \n> These would need recoding, but I think they would continue to run OK against the new API.\n> It would also affect the run-time behaviour slightly, as the first attempt to add a non-Comparable object would fail, rather than the second add of a possibly valid object.  \n> But is that a viable program? It can only add one object, and any attempt to get statistics will either return 0 or an Exception, and applying the instanceof fix would also cause it to fail.", "test_name": "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable", "test_method": "    public void testAddNonComparable(){\n        try {\n            f.addValue(new Object()); // This was previously OK\n            fail(\"Expected IllegalArgumentException\");\n        } catch (IllegalArgumentException expected) {\n        } // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.Comparable\n\torg.apache.commons.math.stat.Frequency.addValue(Frequency.java:110)\n\torg.apache.commons.math.stat.FrequencyTest.testAddNonComparable(FrequencyTest.java:195)", "buggy_method": "108 @Deprecated\n109     public void addValue(Object v) {\n110             addValue((Comparable<?>) v);            \n111     }", "bm_classpath": "org.apache.commons.math.stat.Frequency"}, {"bug_name": "Math_90", "report_text": "> Bugs in Frequency API\n> \n> I think the existing Frequency API has some bugs in it.\n> The addValue(Object v) method allows one to add a plain Object, but one cannot add anything further to the instance, as the second add fails with IllegalArgumentException.  \n> In fact, the problem is with the first call to addValue(Object) which should not allow a plain Object to be added - it should only allow Comparable objects.  \n> This could be fixed by checking that the object is Comparable.\n> Similar considerations apply to the getCumFreq(Object) and getCumPct(Object) methods - they will only work with objects that implement Comparable.\n> The getCount(Object) and getPct(Object) methods don't fail when given a non-Comparable object (because the class cast exception is caught), however they just return 0 as if the object was not present:\n> ```\n>         final Object OBJ = new Object();\n>         f.addValue(OBJ); // This ought to fail, but doesn't, causing the unexpected behaviour below\n>         System.out.println(f.getCount(OBJ)); // 0\n>         System.out.println(f.getPct(OBJ)); // 0.0\n> ```\n> Rather than adding extra checks for Comparable, it seems to me that the API would be much improved by using Comparable instead of Object.  \n> Also, it should make it easier to implement generics.\n> However, this would cause compilation failures for some programs that pass Object rather than Comparable to the class.  \n> These would need recoding, but I think they would continue to run OK against the new API.\n> It would also affect the run-time behaviour slightly, as the first attempt to add a non-Comparable object would fail, rather than the second add of a possibly valid object.  \n> But is that a viable program? It can only add one object, and any attempt to get statistics will either return 0 or an Exception, and applying the instanceof fix would also cause it to fail.", "test_name": "org.apache.commons.math.stat.FrequencyTest::testAddNonComparable", "test_method": "    public void testAddNonComparable(){\n        try {\n            f.addValue(new Object()); // This was OK\n            fail(\"Expected ClassCastException\");\n        } catch (ClassCastException expected) {\n        } // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Value not comparable to existing values.\n\torg.apache.commons.math.stat.Frequency.addValue(Frequency.java:134)\n\torg.apache.commons.math.stat.FrequencyTest.testAddNonComparable(FrequencyTest.java:195)", "buggy_method": "108 @Deprecated\n109     public void addValue(Object v) {\n110     \n111     /**\n112      * Adds 1 to the frequency count for v.\n113      * <p>\n114      * If other objects have already been added to this Frequency, v must\n115      * be comparable to those that have already been added.\n116      * </p>\n117      * \n118      * @param v the value to add.\n119      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n120      */\n121         Object obj = v;\n122         if (v instanceof Integer) {\n123            obj = Long.valueOf(((Integer) v).longValue());\n124         }\n125         try {\n126             Long count = (Long) freqTable.get(obj);\n127             if (count == null) {\n128                 freqTable.put(obj, Long.valueOf(1));\n129             } else {\n130                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n131             }\n132         } catch (ClassCastException ex) {   \n133             //TreeMap will throw ClassCastException if v is not comparable\n134             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n135         }\n136     }", "bm_classpath": "org.apache.commons.math.stat.Frequency"}, {"bug_name": "Math_91", "report_text": "> Fraction.comparTo returns 0 for some differente fractions\n> \n> If two different fractions evaluate to the same double due to limited precision,  \n> the compareTo methode returns 0 as if they were identical.\n> ```\n> // value is roughly PI - 3.07e-18\n> Fraction pi1 = new Fraction(1068966896, 340262731);\n> // value is roughly PI + 1.936e-17\n> Fraction pi2 = new Fraction( 411557987, 131002976);\n> System.out.println(pi1.doubleValue() - pi2.doubleValue()); // exactly 0.0 due to limited IEEE754 precision\n> System.out.println(pi1.compareTo(pi2)); // display 0 instead of a negative value\n> ```", "test_name": "org.apache.commons.math.fraction.FractionTest::testCompareTo", "test_method": "    public void testCompareTo() {\n        Fraction first = new Fraction(1, 2);\n        Fraction second = new Fraction(1, 3);\n        Fraction third = new Fraction(1, 2);\n        \n\n        // these two values are different approximations of PI\n        // the first  one is approximately PI - 3.07e-18\n        // the second one is approximately PI + 1.936e-17\n        Fraction pi1 = new Fraction(1068966896, 340262731);\n        Fraction pi2 = new Fraction( 411557987, 131002976);\n        assertEquals(-1, pi1.compareTo(pi2)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<-1> but was:<0>\n\torg.apache.commons.math.fraction.FractionTest.testCompareTo(FractionTest.java:178)", "buggy_method": "258 public int compareTo(Fraction object) {\n259         double nOd = doubleValue();\n260         double dOn = object.doubleValue();\n261         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n262     }", "bm_classpath": "org.apache.commons.math.fraction.Fraction"}, {"bug_name": "Math_92", "report_text": "> MathUtils.binomialCoefficient(n,k) fails for large results\n> \n> Probably due to rounding errors, MathUtils.binomialCoefficient(n,k) fails for results near Long.MAX\\_VALUE.\n> The existence of failures can be demonstrated by testing the recursive property:\n> ```\n>          assertEquals(MathUtils.binomialCoefficient(65,32) + MathUtils.binomialCoefficient(65,33),\n>                  MathUtils.binomialCoefficient(66,33));\n> ```\n> Or by directly using the (externally calculated and hopefully correct) expected value:\n> ```\n>          assertEquals(7219428434016265740L, MathUtils.binomialCoefficient(66,33));\n> ```\n> I suggest a nonrecursive test implementation along the lines of\n> **MathUtilsTest.java**\n> ```\n>     /**\n>      * Exact implementation using BigInteger and the explicit formula\n>      * (n, k) == ((k-1)*...*n) / (1*...*(n-k))\n>      */\n> \tpublic static long binomialCoefficient(int n, int k) {\n> \t\tif (k == 0 || k == n)\n> \t\t\treturn 1;\n> \t\tBigInteger result = BigInteger.ONE;\n> \t\tfor (int i = k + 1; i <= n; i++) {\n> \t\t\tresult = result.multiply(BigInteger.valueOf(i));\n> \t\t}\n> \t\tfor (int i = 1; i <= n - k; i++) {\n> \t\t\tresult = result.divide(BigInteger.valueOf(i));\n> \t\t}\n> \t\tif (result.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n> \t\t\tthrow new ArithmeticException(\n>                                 \"Binomial coefficient overflow: \" + n + \", \" + k);\n> \t\t}\n> \t\treturn result.longValue();\n> \t}\n> ```\n> Which would allow you to test the expected values directly:\n> ```\n>          assertEquals(binomialCoefficient(66,33), MathUtils.binomialCoefficient(66,33));\n> ```", "test_name": "org.apache.commons.math.util.MathUtilsTest::testBinomialCoefficientLarge", "test_method": "    public void testBinomialCoefficientLarge() throws Exception {\n        // This tests all legal and illegal values for n <= 200.\n        for (int n = 0; n <= 200; n++) {\n            for (int k = 0; k <= n; k++) {\n                long ourResult = -1;\n                long exactResult = -1;\n                boolean shouldThrow = false;\n                boolean didThrow = false;\n                try {\n                    ourResult = MathUtils.binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    didThrow = true;\n                }\n                try {\n                    exactResult = binomialCoefficient(n, k);\n                } catch (ArithmeticException ex) {\n                    shouldThrow = true;\n                }\n                assertEquals(n+\",\"+k, shouldThrow, didThrow);\n                assertEquals(n+\",\"+k, exactResult, ourResult);\n                assertTrue(n+\",\"+k, (n > 66 || !didThrow));\n            }\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: 48,22 expected:<27385657281648> but was:<27385657281647>\n\torg.apache.commons.math.util.MathUtilsTest.testBinomialCoefficientLarge(MathUtilsTest.java:195)", "buggy_method": "169 public static long binomialCoefficient(final int n, final int k) {\n170         if (n < k) {\n171             throw new IllegalArgumentException(\n172                 \"must have n >= k for binomial coefficient (n,k)\");\n173         }\n174         if (n < 0) {\n175             throw new IllegalArgumentException(\n176                 \"must have n >= 0 for binomial coefficient (n,k)\");\n177         }\n178         if ((n == k) || (k == 0)) {\n179             return 1;\n180         }\n181         if ((k == 1) || (k == n - 1)) {\n182             return n;\n183         }\n184         long result = Math.round(binomialCoefficientDouble(n, k));\n185         if (result == Long.MAX_VALUE) {\n186             throw new ArithmeticException(\n187                 \"result too large to represent in a long integer\");\n188         }\n189         // Use symmetry for large k\n190         \n191         // We use the formula\n192         // (n choose k) = n! / (n-k)! / k!\n193         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n194         // which could be written\n195         // (n choose k) == (n-1 choose k-1) * n / k\n196             // For n <= 61, the naive implementation cannot overflow.\n197             // For n > 61 but n <= 66, the result cannot overflow,\n198             // but we must take care not to overflow intermediate values.\n199                 // We know that (result * i) is divisible by j,\n200                 // but (result * i) may overflow, so we split j:\n201                 // Filter out the gcd, d, so j/d and i/d are integer.\n202                 // result is divisible by (j/d) because (j/d)\n203                 // is relative prime to (i/d) and is a divisor of\n204                 // result * (i/d).\n205             // For n > 66, a result overflow might occur, so we check\n206             // the multiplication, taking care to not overflow\n207             // unnecessary.\n208         return result;\n209     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_93", "report_text": "> MathUtils.factorial(n) fails for n >= 17\n> \n> The result of MathUtils.factorial( n ) for n = 17, 18, 19 is wrong, probably because of rounding errors in the double calculations.\n> Replace the first line of MathUtilsTest.testFactorial() by\n>  for (int i = 1; i <= 20; i++) {\n> to check all valid arguments for the long result and see the failure.\n> I suggest implementing a simple loop to multiply the long result - or even using a precomputed long[] - instead of adding logarithms.", "test_name": "org.apache.commons.math.util.MathUtilsTest::testFactorial", "test_method": "    public void testFactorial() {\n        for (int i = 1; i < 21; i++) {\n            assertEquals(i + \"! \", factorial(i), MathUtils.factorial(i));\n            assertEquals(i + \"! \", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n            assertEquals(i + \"! \", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: 17!  expected:<3.55687428096E14> but was:<3.55687428096001E14>\n\torg.apache.commons.math.util.MathUtilsTest.testFactorial(MathUtilsTest.java:237)", "buggy_method": "344 public static long factorial(final int n) {\n345         long result = Math.round(factorialDouble(n));\n346         if (result == Long.MAX_VALUE) {\n347             throw new ArithmeticException(\n348                     \"factorial value is too large to fit in a long\");\n349         }\n350         return factorials[n];\n351     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_94", "report_text": "> MathUtils.gcd(u, v) fails when u and v both contain a high power of 2\n> \n> The test at the beginning of MathUtils.gcd(u, v) for arguments equal to zero fails when u and v contain high enough powers of 2 so that their product overflows to zero.\n>  assertEquals(3 \\* (1<<15), MathUtils.gcd(3 \\* (1<<20), 9 \\* (1<<15)));\n> Fix: Replace the test at the start of MathUtils.gcd()\n>  if (u \\* v == 0) {\n> by\n>  if (u == 0 || v == 0) {", "test_name": "org.apache.commons.math.util.MathUtilsTest::testGcd", "test_method": "    public void testGcd() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n\n\n\n\n        assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<98304> but was:<3440640>\n\torg.apache.commons.math.util.MathUtilsTest.testGcd(MathUtilsTest.java:295)", "buggy_method": "411 public static int gcd(int u, int v) {\n412         if (u * v == 0) {\n413             return (Math.abs(u) + Math.abs(v));\n414         }\n415         // keep u and v negative, as negative integers range down to\n416         // -2^31, while positive numbers can only be as large as 2^31-1\n417         // (i.e. we can't necessarily negate a negative number without\n418         // overflow)\n419         /* assert u!=0 && v!=0; */\n420         if (u > 0) {\n421             u = -u;\n422         } // make u negative\n423         if (v > 0) {\n424             v = -v;\n425         } // make v negative\n426         // B1. [Find power of 2]\n427         int k = 0;\n428         while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n429                                                             // both even...\n430             u /= 2;\n431             v /= 2;\n432             k++; // cast out twos.\n433         }\n434         if (k == 31) {\n435             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n436         }\n437         // B2. Initialize: u and v have been divided by 2^k and at least\n438         // one is odd.\n439         int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n440         // t negative: u was odd, v may be even (t replaces v)\n441         // t positive: u was even, v is odd (t replaces u)\n442         do {\n443             /* assert u<0 && v<0; */\n444             // B4/B3: cast out twos from t.\n445             while ((t & 1) == 0) { // while t is even..\n446                 t /= 2; // cast out twos\n447             }\n448             // B5 [reset max(u,v)]\n449             if (t > 0) {\n450                 u = -t;\n451             } else {\n452                 v = t;\n453             }\n454             // B6/B3. at this point both u and v should be odd.\n455             t = (v - u) / 2;\n456             // |u| larger: t positive (replace u)\n457             // |v| larger: t negative (replace v)\n458         } while (t != 0);\n459         return -u * (1 << k); // gcd is u*2^k\n460     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_95", "report_text": "> denominatorDegreeOfFreedom in FDistribution leads to IllegalArgumentsException in UnivariateRealSolverUtils.bracket\n> \n> We are using the FDistributionImpl from the commons.math project to do  \n> some statistical calculations, namely receiving the upper and lower  \n> boundaries of a confidence interval. Everything is working fine and the  \n> results are matching our reference calculations.\n> However, the FDistribution behaves strange if a  \n> denominatorDegreeOfFreedom of 2 is used, with an alpha-value of 0.95.  \n> This results in an IllegalArgumentsException, stating:\n> Invalid endpoint parameters: lowerBound=0.0 initial=Infinity  \n> upperBound=1.7976931348623157E308\n> coming from  \n> org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket\n> The problem is the 'initial' parameter to that function, wich is  \n> POSITIVE\\_INFINITY and therefore not within the boundaries. I already  \n> pinned down the problem to the FDistributions getInitialDomain()-method,  \n> wich goes like:\n>  return getDenominatorDegreesOfFreedom() /  \n>  (getDenominatorDegreesOfFreedom() - 2.0);\n> Obviously, in case of denominatorDegreesOfFreedom == 2, this must lead  \n> to a division-by-zero, resulting in POSTIVE\\_INFINITY. The result of this  \n> operation is then directly passed into the  \n> UnivariateRealSolverUtils.bracket() - method as second argument.", "test_name": "org.apache.commons.math.distribution.FDistributionTest::testSmallDegreesOfFreedom", "test_method": "    public void testSmallDegreesOfFreedom() throws Exception {\n        org.apache.commons.math.distribution.FDistributionImpl fd =\n            new org.apache.commons.math.distribution.FDistributionImpl(\n                1.0, 1.0);\n        double p = fd.cumulativeProbability(0.975);\n        double x = fd.inverseCumulativeProbability(p); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid endpoint parameters:  lowerBound=0.0 initial=-1.0 upperBound=1.7976931348623157E308\n\torg.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket(UnivariateRealSolverUtils.java:179)\n\torg.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket(UnivariateRealSolverUtils.java:128)\n\torg.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(AbstractContinuousDistribution.java:84)\n\torg.apache.commons.math.distribution.FDistributionImpl.inverseCumulativeProbability(FDistributionImpl.java:106)\n\torg.apache.commons.math.distribution.FDistributionTest.testSmallDegreesOfFreedom(FDistributionTest.java:114)", "buggy_method": "143 protected double getInitialDomain(double p) {\n144         double ret;\n145         double d = getDenominatorDegreesOfFreedom();\n146             // use mean\n147             ret = d / (d - 2.0);\n148         return ret;\n149     }", "bm_classpath": "org.apache.commons.math.distribution.FDistributionImpl"}, {"bug_name": "Math_96", "report_text": "> Result of multiplying and equals for complex numbers is wrong\n> \n> Hi.\n> The bug relates on complex numbers.  \n> The methods \"multiply\" and \"equals\" of the class Complex are involved.\n> mathematic background: (0,i) \\* (-1,0i) = (0,-i).\n> little java program + output that shows the bug:  \n> -----------------------------------------------------------------------\n> ```\n> import org.apache.commons.math.complex.*;\n> public class TestProg {\n>         public static void main(String[] args) {\n>                 ComplexFormat f = new ComplexFormat();\n>                 Complex c1 = new Complex(0,1);\n>                 Complex c2 = new Complex(-1,0);\n>                 Complex res = c1.multiply(c2);\n>                 Complex comp = new Complex(0,-1);\n>                 System.out.println(\"res: \"+f.format(res));\n>                 System.out.println(\"comp: \"+f.format(comp));\n>                 System.out.println(\"res=comp: \"+res.equals(comp));\n>         }\n> }\n> ```\n> -----------------------------------------------------------------------\n> res: -0 - 1i  \n> comp: 0 - 1i  \n> res=comp: false\n> -----------------------------------------------------------------------\n> I think the \"equals\" should return \"true\".  \n> The problem could either be the \"multiply\" method that gives (-0,-1i) instead of (0,-1i),  \n> or if you think thats right, the equals method has to be modified.\n> Good Luck  \n> Dieter", "test_name": "org.apache.commons.math.complex.ComplexTest::testMath221", "test_method": "    public void testMath221() {\n        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0))); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<org.apache.commons.math.complex.Complex@98b00000> but was:<org.apache.commons.math.complex.Complex@18b00000>\n\torg.apache.commons.math.complex.ComplexTest.testMath221(ComplexTest.java:696)", "buggy_method": "245 public boolean equals(Object other) {\n246         boolean ret;\n247         \n248         if (this == other) { \n249             ret = true;\n250         } else if (other == null) {\n251             ret = false;\n252         } else  {\n253             try {\n254                 Complex rhs = (Complex)other;\n255                 if (rhs.isNaN()) {\n256                     ret = this.isNaN();\n257                 } else {\n258                     ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n259                 }\n260             } catch (ClassCastException ex) {\n261                 // ignore exception\n262                 ret = false;\n263             }\n264         }\n265       \n266         return ret;\n267     }", "bm_classpath": "org.apache.commons.math.complex.Complex"}, {"bug_name": "Math_97", "report_text": "> BrentSolver throws IllegalArgumentException\n> \n> I am getting this exception:\n> java.lang.IllegalArgumentException: Function values at endpoints do not have different signs. Endpoints: [-100000.0,1.7976931348623157E308] Values: [0.0,-101945.04630982173]  \n> at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:99)  \n> at org.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:62)\n> The exception should not be thrown with values [0.0,-101945.04630982173] because 0.0 is positive.  \n> According to Brent Worden, the algorithm should stop and return 0 as the root instead of throwing an exception.\n> The problem comes from this method:  \n>  public double solve(double min, double max) throws MaxIterationsExceededException,   \n>  FunctionEvaluationException {\n>  clearResult();  \n>  verifyInterval(min, max);\n>  double yMin = f.value(min);  \n>  double yMax = f.value(max);\n>  // Verify bracketing  \n>  if (yMin \\* yMax >= 0) \n> {\n>  throw new IllegalArgumentException\n>  (\"Function values at endpoints do not have different signs.\" +\n>  \" Endpoints: [\" + min + \",\" + max + \"]\" + \n>  \" Values: [\" + yMin + \",\" + yMax + \"]\"); \n>  }\n>  // solve using only the first endpoint as initial guess  \n>  return solve(min, yMin, max, yMax, min, yMin);\n>  }\n> One way to fix it would be to add this code after the assignment of yMin and yMax:  \n>  if (yMin ==0 || yMax == 0) \n> {\n>  return 0;\n>  }\n>  ", "test_name": "org.apache.commons.math.analysis.BrentSolverTest::testRootEndpoints", "test_method": "    public void testRootEndpoints() throws Exception {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealSolver solver = new BrentSolver(f);\n        \n        // endpoint is root\n        double result = solver.solve(Math.PI, 4);\n\n        result = solver.solve(3, Math.PI); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Function values at endpoints do not have different signs.  Endpoints: [3.0,3.141592653589793]  Values: [0.1411200080598672,1.2246467991473532E-16]\n\torg.apache.commons.math.analysis.BrentSolver.solve(BrentSolver.java:141)\n\torg.apache.commons.math.analysis.BrentSolverTest.testRootEndpoints(BrentSolverTest.java:279)", "buggy_method": "125 public double solve(double min, double max) throws MaxIterationsExceededException, \n126         FunctionEvaluationException {\n127         \n128         clearResult();\n129         verifyInterval(min, max);\n130         \n131         double ret = Double.NaN;\n132         \n133         double yMin = f.value(min);\n134         double yMax = f.value(max);\n135         \n136         // Verify bracketing\n137         double sign = yMin * yMax;\n138         if (sign >= 0) {\n139             // check if either value is close to a zero\n140                 // neither value is close to zero and min and max do not bracket root.\n141                 throw new IllegalArgumentException\n142                 (\"Function values at endpoints do not have different signs.\" +\n143                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n144                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n145         } else {\n146             // solve using only the first endpoint as initial guess\n147             ret = solve(min, yMin, max, yMax, min, yMin);\n148             // either min or max is a root\n149         }\n150 \n151         return ret;\n152     }", "bm_classpath": "org.apache.commons.math.analysis.BrentSolver"}, {"bug_name": "Math_98", "report_text": "> RealMatrixImpl#operate gets result vector dimensions wrong\n> \n> org.apache.commons.math.linear.RealMatrixImpl#operate tries to create a result vector that always has the same length as the input vector. This can result in runtime exceptions if the matrix is non-square and it always yields incorrect results if the matrix is non-square. The correct behaviour would of course be to create a vector with the same length as the row dimension of the matrix.\n> Thus line 640 in RealMatrixImpl.java should read  \n> double[] out = new double[nRows];  \n> instead of  \n> double[] out = new double[v.length];", "test_name": "org.apache.commons.math.linear.BigMatrixImplTest::testMath209", "test_method": "    public void testMath209() {\n        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n                { new BigDecimal(1), new BigDecimal(2) },\n                { new BigDecimal(3), new BigDecimal(4) },\n                { new BigDecimal(5), new BigDecimal(6) }\n        }, false);\n        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) }); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 2\n\torg.apache.commons.math.linear.BigMatrixImpl.operate(BigMatrixImpl.java:997)\n\torg.apache.commons.math.linear.BigMatrixImplTest.testMath209(BigMatrixImplTest.java:446)", "buggy_method": "985 public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n986         if (v.length != this.getColumnDimension()) {\n987             throw new IllegalArgumentException(\"vector has wrong length\");\n988         }\n989         final int nRows = this.getRowDimension();\n990         final int nCols = this.getColumnDimension();\n991         final BigDecimal[] out = new BigDecimal[v.length];\n992         for (int row = 0; row < nRows; row++) {\n993             BigDecimal sum = ZERO;\n994             for (int i = 0; i < nCols; i++) {\n995                 sum = sum.add(data[row][i].multiply(v[i]));\n996             }\n997             out[row] = sum;\n998         }\n999         return out;\n1000     }", "bm_classpath": "org.apache.commons.math.linear.BigMatrixImpl"}, {"bug_name": "Math_99", "report_text": "> MathUtils.gcd(Integer.MIN_VALUE, 0) should throw an Exception instead of returning Integer.MIN_VALUE\n> \n> The gcd method should throw an Exception for gcd(Integer.MIN\\_VALUE, 0), like for gcd(Integer.MIN\\_VALUE, Integer.MIN\\_VALUE). The method should only return nonnegative results.", "test_name": "org.apache.commons.math.util.MathUtilsTest::testGcd", "test_method": "    public void testGcd() {\n        int a = 30;\n        int b = 50;\n        int c = 77;\n\n\n\n\n\n\n        try {\n            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n            MathUtils.gcd(Integer.MIN_VALUE, 0);\n            fail(\"expecting ArithmeticException\");\n        } catch (ArithmeticException expected) {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expecting ArithmeticException\n\torg.apache.commons.math.util.MathUtilsTest.testGcd(MathUtilsTest.java:437)", "buggy_method": "539 public static int gcd(final int p, final int q) {\n540         int u = p;\n541         int v = q;\n542         if ((u == 0) || (v == 0)) {\n543             return (Math.abs(u) + Math.abs(v));\n544         }\n545         // keep u and v negative, as negative integers range down to\n546         // -2^31, while positive numbers can only be as large as 2^31-1\n547         // (i.e. we can't necessarily negate a negative number without\n548         // overflow)\n549         /* assert u!=0 && v!=0; */\n550         if (u > 0) {\n551             u = -u;\n552         } // make u negative\n553         if (v > 0) {\n554             v = -v;\n555         } // make v negative\n556         // B1. [Find power of 2]\n557         int k = 0;\n558         while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n559                                                             // both even...\n560             u /= 2;\n561             v /= 2;\n562             k++; // cast out twos.\n563         }\n564         if (k == 31) {\n565             throw MathRuntimeException.createArithmeticException(\n566                     \"overflow: gcd({0}, {1}) is 2^31\",\n567                     new Object[] { p, q });\n568         }\n569         // B2. Initialize: u and v have been divided by 2^k and at least\n570         // one is odd.\n571         int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n572         // t negative: u was odd, v may be even (t replaces v)\n573         // t positive: u was even, v is odd (t replaces u)\n574         do {\n575             /* assert u<0 && v<0; */\n576             // B4/B3: cast out twos from t.\n577             while ((t & 1) == 0) { // while t is even..\n578                 t /= 2; // cast out twos\n579             }\n580             // B5 [reset max(u,v)]\n581             if (t > 0) {\n582                 u = -t;\n583             } else {\n584                 v = t;\n585             }\n586             // B6/B3. at this point both u and v should be odd.\n587             t = (v - u) / 2;\n588             // |u| larger: t positive (replace u)\n589             // |v| larger: t negative (replace v)\n590         } while (t != 0);\n591         return -u * (1 << k); // gcd is u*2^k\n592     }", "bm_classpath": "org.apache.commons.math.util.MathUtils"}, {"bug_name": "Math_100", "report_text": "> AbstractEstimator: getCovariances() and guessParametersErrors() crash when having bound parameters\n> \n> the two methods getCovariances() and guessParametersErrors() from org.apache.commons.math.estimation.AbstractEstimator crash with ArrayOutOfBounds exception when some of the parameters are bound. The reason is that the Jacobian is calculated only for the unbound parameters. in the code you loop through all parameters.\n> line #166: final int cols = problem.**getAllParameters()**.length;  \n> should be replaced by: final int cols = problem.**getUnboundParameters()**.length;  \n> (similar changes could be done in guessParametersErrors())\n> the dissadvantage of the above bug fix is that what is returned to the user is an array with smaller size than the number of all parameters. Alternatively, you can have some logic in the code which writes zeros for the elements of the covariance matrix corresponding to the bound parameters", "test_name": "org.apache.commons.math.estimation.GaussNewtonEstimatorTest::testBoundParameters", "test_method": "  public void testBoundParameters() throws EstimationException {\n      EstimatedParameter[] p = {\n        new EstimatedParameter(\"unbound0\", 2, false),\n        new EstimatedParameter(\"unbound1\", 2, false),\n        new EstimatedParameter(\"bound\",    2, true)\n      };\n      LinearProblem problem = new LinearProblem(new LinearMeasurement[] {\n        new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              3.0),\n        new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              1.0),\n        new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 },\n                              new EstimatedParameter[] { p[0], p[1], p[2] },\n                              7.0)\n      });\n\n      GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6);\n      estimator.estimate(problem);\n      double[][] covariances = estimator.getCovariances(problem); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 6\n\torg.apache.commons.math.estimation.AbstractEstimator.getCovariances(AbstractEstimator.java:173)\n\torg.apache.commons.math.estimation.GaussNewtonEstimatorTest.testBoundParameters(GaussNewtonEstimatorTest.java:472)", "buggy_method": "158 public double[][] getCovariances(EstimationProblem problem)\n159       throws EstimationException {\n160  \n161         // set up the jacobian\n162         updateJacobian();\n163 \n164         // compute transpose(J).J, avoiding building big intermediate matrices\n165         final int rows = problem.getMeasurements().length;\n166         final int cols = problem.getAllParameters().length;\n167         final int max  = cols * rows;\n168         double[][] jTj = new double[cols][cols];\n169         for (int i = 0; i < cols; ++i) {\n170             for (int j = i; j < cols; ++j) {\n171                 double sum = 0;\n172                 for (int k = 0; k < max; k += cols) {\n173                     sum += jacobian[k + i] * jacobian[k + j];\n174                 }\n175                 jTj[i][j] = sum;\n176                 jTj[j][i] = sum;\n177             }\n178         }\n179 \n180         try {\n181             // compute the covariances matrix\n182             return new RealMatrixImpl(jTj).inverse().getData();\n183         } catch (InvalidMatrixException ime) {\n184             throw new EstimationException(\"unable to compute covariances: singular problem\",\n185                                           new Object[0]);\n186         }\n187 \n188     }", "bm_classpath": "org.apache.commons.math.estimation.AbstractEstimator"}, {"bug_name": "Math_101", "report_text": "> java.lang.StringIndexOutOfBoundsException in ComplexFormat.parse(String source, ParsePosition pos)\n> \n> The parse(String source, ParsePosition pos) method in the ComplexFormat class does not check whether the imaginary character is set or not which produces StringIndexOutOfBoundsException in the substring method :\n> (line 375 of ComplexFormat)  \n> ...  \n>  // parse imaginary character  \n>  int n = getImaginaryCharacter().length();\n>  startIndex = pos.getIndex();  \n>  int endIndex = startIndex + n;  \n>  if (source.substring(startIndex, endIndex).compareTo(  \n>  getImaginaryCharacter()) != 0) {  \n> ...  \n> I encoutered this exception typing in a JTextFied with ComplexFormat set to look up an AbstractFormatter.  \n> If only the user types the imaginary part of the complex number first, he gets this exception.\n> Solution: Before setting to n length of the imaginary character, check if the source contains it. My proposal:  \n> ...  \n>  int n = 0;  \n>  if (source.contains(getImaginaryCharacter()))  \n>  n = getImaginaryCharacter().length();  \n> ... \n> F.S.", "test_name": "org.apache.commons.math.complex.ComplexFormatTest::testForgottenImaginaryCharacter", "test_method": "public void testForgottenImaginaryCharacter() {\n        ParsePosition pos = new ParsePosition(0);\n        assertNull(new ComplexFormat().parse(\"1 + 1\", pos));\n        assertEquals(5, pos.getErrorIndex());\n    }", "error_message": "java.lang.StringIndexOutOfBoundsException: String index out of range: 6\n\tjava.lang.String.substring(String.java:1963)\n\torg.apache.commons.math.complex.ComplexFormat.parse(ComplexFormat.java:377)\n\torg.apache.commons.math.complex.ComplexFormatAbstractTest.testForgottenImaginaryCharacter(ComplexFormatAbstractTest.java:355)", "buggy_method": "320 public Complex parse(String source, ParsePosition pos) {\n321         int initialIndex = pos.getIndex();\n322 \n323         // parse whitespace\n324         parseAndIgnoreWhitespace(source, pos);\n325 \n326         // parse real\n327         Number re = parseNumber(source, getRealFormat(), pos);\n328         if (re == null) {\n329             // invalid real number\n330             // set index back to initial, error index should already be set\n331             // character examined.\n332             pos.setIndex(initialIndex);\n333             return null;\n334         }\n335 \n336         // parse sign\n337         int startIndex = pos.getIndex();\n338         char c = parseNextCharacter(source, pos);\n339         int sign = 0;\n340         switch (c) {\n341         case 0 :\n342             // no sign\n343             // return real only complex number\n344             return new Complex(re.doubleValue(), 0.0);\n345         case '-' :\n346             sign = -1;\n347             break;\n348         case '+' :\n349             sign = 1;\n350             break;\n351         default :\n352             // invalid sign\n353             // set index back to initial, error index should be the last\n354             // character examined.\n355             pos.setIndex(initialIndex);\n356             pos.setErrorIndex(startIndex);\n357             return null;\n358         }\n359 \n360         // parse whitespace\n361         parseAndIgnoreWhitespace(source, pos);\n362 \n363         // parse imaginary\n364         Number im = parseNumber(source, getRealFormat(), pos);\n365         if (im == null) {\n366             // invalid imaginary number\n367             // set index back to initial, error index should already be set\n368             // character examined.\n369             pos.setIndex(initialIndex);\n370             return null;\n371         }\n372 \n373         // parse imaginary character\n374         int n = getImaginaryCharacter().length();\n375         startIndex = pos.getIndex();\n376         int endIndex = startIndex + n;\n377         if (\n378             source.substring(startIndex, endIndex).compareTo(\n379             getImaginaryCharacter()) != 0) {\n380             // set index back to initial, error index should be the start index\n381             // character examined.\n382             pos.setIndex(initialIndex);\n383             pos.setErrorIndex(startIndex);\n384             return null;\n385         }\n386         pos.setIndex(endIndex);\n387 \n388         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n389     }", "bm_classpath": "org.apache.commons.math.complex.ComplexFormat"}, {"bug_name": "Math_102", "report_text": "> chiSquare(double[] expected, long[] observed) is returning incorrect test statistic\n> \n> ChiSquareTestImpl is returning incorrect chi-squared value. An implicit assumption of public double chiSquare(double[] expected, long[] observed) is that the sum of expected and observed are equal. That is, in the code:  \n> for (int i = 0; i < observed.length; i++) \n> {\n>  dev = ((double) observed[i] - expected[i]);\n>  sumSq += dev \\* dev / expected[i];\n>  }\n> this calculation is only correct if sum(observed)==sum(expected). When they are not equal then one must rescale the expected value by sum(observed) / sum(expected) so that they are.  \n> Ironically, it is an example in the unit test ChiSquareTestTest that highlights the error:\n> long[] observed1 = \n> { 500, 623, 72, 70, 31 }\n> ;  \n>  double[] expected1 = \n> { 485, 541, 82, 61, 37 }\n> ;  \n>  assertEquals( \"chi-square test statistic\", 16.4131070362, testStatistic.chiSquare(expected1, observed1), 1E-10);  \n>  assertEquals(\"chi-square p-value\", 0.002512096, testStatistic.chiSquareTest(expected1, observed1), 1E-9);\n> 16.413 is not correct because the expected values do not make sense, they should be: 521.19403 581.37313 88.11940 65.55224 39.76119 so that the sum of expected equals 1296 which is the sum of observed.\n> Here is some R code (r-project.org) which proves it:  \n> > o1  \n> [1] 500 623 72 70 31  \n> > e1  \n> [1] 485 541 82 61 37  \n> > chisq.test(o1,p=e1,rescale.p=TRUE)\n>  Chi-squared test for given probabilities\n> data: o1   \n> X-squared = 9.0233, df = 4, p-value = 0.06052\n> > chisq.test(o1,p=e1,rescale.p=TRUE)$observed  \n> [1] 500 623 72 70 31  \n> > chisq.test(o1,p=e1,rescale.p=TRUE)$expected  \n> [1] 521.19403 581.37313 88.11940 65.55224 39.76119", "test_name": "org.apache.commons.math.stat.inference.ChiSquareFactoryTest::testChiSquareLargeTestStatistic", "test_method": "public void testChiSquareLargeTestStatistic() throws Exception {\n        double[] exp = new double[] {\n            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n            232921.0, 437665.75\n        };\n\n        long[] obs = new long[] {\n            2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n        };\n        org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n        double cst = csti.chiSquareTest(exp, obs); \n        assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n        assertEquals( \"chi-square test statistic\", \n                114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);\n    }", "error_message": "junit.framework.AssertionFailedError: chi-square test statistic expected:<114875.90421929007> but was:<3624883.3429077636>\n\torg.apache.commons.math.stat.inference.ChiSquareTestTest.testChiSquareLargeTestStatistic(ChiSquareTestTest.java:183)", "buggy_method": "64 public double chiSquare(double[] expected, long[] observed)\n65         throws IllegalArgumentException {\n66         if ((expected.length < 2) || (expected.length != observed.length)) {\n67             throw new IllegalArgumentException(\n68                     \"observed, expected array lengths incorrect\");\n69         }\n70         if (!isPositive(expected) || !isNonNegative(observed)) {\n71             throw new IllegalArgumentException(\n72                 \"observed counts must be non-negative and expected counts must be postive\");\n73         }\n74         double sumSq = 0.0d;\n75         double dev = 0.0d;\n76         for (int i = 0; i < observed.length; i++) {\n77                 dev = ((double) observed[i] - expected[i]);\n78                 sumSq += dev * dev / expected[i];\n79         }\n80         return sumSq;\n81     }", "bm_classpath": "org.apache.commons.math.stat.inference.ChiSquareTestImpl"}, {"bug_name": "Math_103", "report_text": "> ConvergenceException in normal CDF\n> \n> NormalDistributionImpl::cumulativeProbability(double x) throws ConvergenceException  \n> if x deviates too much from the mean. For example, when x=+/-100, mean=0, sd=1.  \n> Of course the value of the CDF is hard to evaluate in these cases,  \n> but effectively it should be either zero or one.", "test_name": "org.apache.commons.math.distribution.NormalDistributionTest::testExtremeValues", "test_method": "    public void testExtremeValues() throws Exception {\n        NormalDistribution distribution = (NormalDistribution) getDistribution();\n        distribution.setMean(0);\n        distribution.setStandardDeviation(1);\n        for (int i = 0; i < 100; i+=5) { // make sure no convergence exception\n            double lowerTail = distribution.cumulativeProbability((double)-i);\n            double upperTail = distribution.cumulativeProbability((double) i);\n            if (i < 10) { // make sure not top-coded\n                assertTrue(lowerTail > 0.0d);\n                assertTrue(upperTail < 1.0d);\n            }\n            else { // make sure top coding not reversed\n                assertTrue(lowerTail < 0.00001);\n                assertTrue(upperTail > 0.99999);\n            }\n        } // <-- fails here\n    }", "error_message": "org.apache.commons.math.MaxIterationsExceededException: Maximal number of iterations (10,000) exceeded\n\torg.apache.commons.math.special.Gamma.regularizedGammaP(Gamma.java:180)\n\torg.apache.commons.math.special.Erf.erf(Erf.java:56)\n\torg.apache.commons.math.distribution.NormalDistributionImpl.cumulativeProbability(NormalDistributionImpl.java:109)\n\torg.apache.commons.math.distribution.NormalDistributionTest.testExtremeValues(NormalDistributionTest.java:133)", "buggy_method": "108 public double cumulativeProbability(double x) throws MathException {\n109             return 0.5 * (1.0 + Erf.erf((x - mean) /\n110                     (standardDeviation * Math.sqrt(2.0))));\n111     }", "bm_classpath": "org.apache.commons.math.distribution.NormalDistributionImpl"}, {"bug_name": "Math_105", "report_text": "> [math]  SimpleRegression getSumSquaredErrors\n> \n> getSumSquaredErrors returns -ve value. See test below:\n> public void testSimpleRegression() {  \n>  double[] y = \n> { 8915.102, 8919.302, 8923.502}\n> ;  \n>  double[] x = \n> { 1.107178495, 1.107264895, 1.107351295}\n> ;  \n>  double[] x2 = \n> { 1.107178495E2, 1.107264895E2, 1.107351295E2}\n> ;  \n>  SimpleRegression reg = new SimpleRegression();  \n>  for (int i = 0; i < x.length; i++) \n> {\n>  reg.addData(x[i],y[i]);\n>  }\n>  assertTrue(reg.getSumSquaredErrors() >= 0.0); // OK  \n>  reg.clear();  \n>  for (int i = 0; i < x.length; i++) \n> {\n>  reg.addData(x2[i],y[i]);\n>  }\n>  assertTrue(reg.getSumSquaredErrors() >= 0.0); // FAIL\n>  }", "test_name": "org.apache.commons.math.stat.regression.SimpleRegressionTest::testSSENonNegative", "test_method": "    public void testSSENonNegative() {\n        double[] y = { 8915.102, 8919.302, 8923.502 };\n        double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 };\n        SimpleRegression reg = new SimpleRegression();\n        for (int i = 0; i < x.length; i++) {\n            reg.addData(x[i], y[i]);\n        }\n        assertTrue(reg.getSumSquaredErrors() >= 0.0); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.apache.commons.math.stat.regression.SimpleRegressionTest.testSSENonNegative(SimpleRegressionTest.java:275)", "buggy_method": "263 public double getSumSquaredErrors() {\n264         return sumYY - sumXY * sumXY / sumXX;\n265     }", "bm_classpath": "org.apache.commons.math.stat.regression.SimpleRegression"}, {"bug_name": "Math_106", "report_text": "> [math] Function math.fraction.ProperFractionFormat.parse(String, ParsePosition) return illogical result\n> \n> Hello,\n> I find illogical returned result from function \"Fraction parse(String source,   \n> ParsePostion pos)\" (in class ProperFractionFormat of the Fraction Package) of   \n> the Commons Math library. Please see the following code segment for more   \n> details:\n> \"  \n> ProperFractionFormat properFormat = new ProperFractionFormat();  \n> result = null;  \n> String source = \"1 -1 / 2\";  \n> ParsePosition pos = new ParsePosition(0);\n> //Test 1 : fail   \n> public void testParseNegative(){\n>  String source = \"-1 -2 / 3\";  \n>  ParsePosition pos = new ParsePosition(0);\n>  Fraction actual = properFormat.parse(source, pos);  \n>  assertNull(actual);  \n> }\n> // Test2: success  \n> public void testParseNegative(){\n>  String source = \"-1 -2 / 3\";  \n>  ParsePosition pos = new ParsePosition(0);\n>  Fraction actual = properFormat.parse(source, pos); // return Fraction 1/3  \n>  assertEquals(1, source.getNumerator());  \n>  assertEquals(3, source.getDenominator());  \n> }\n> \"\n> Note: Similarly, when I passed in the following inputs:   \n>  input 2: (source = \u201c1 2 / -3\u201d, pos = 0)  \n>  input 3: ( source = \u201d -1 -2 / 3\u201d, pos = 0)\n> Function \"Fraction parse(String, ParsePosition)\" returned Fraction 1/3 (means   \n> the result Fraction had numerator = 1 and denominator = 3)for all 3 inputs   \n> above.\n> I think the function does not handle parsing the numberator/ denominator   \n> properly incase input string provide invalid numerator/denominator. \n> Thank you!", "test_name": "org.apache.commons.math.fraction.FractionFormatTest::testParseProperInvalidMinus", "test_method": "    public void testParseProperInvalidMinus() {\r\n        String source = \"2 -2 / 3\";\r\n        try {\r\n            Fraction c = properFormat.parse(source);\r\n            fail(\"invalid minus in improper fraction.\");\r\n        } catch (ParseException ex) {\r\n            // expected\r\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: invalid minus in improper fraction.\n\torg.apache.commons.math.fraction.FractionFormatTest.testParseProperInvalidMinus(FractionFormatTest.java:236)", "buggy_method": "130 public Fraction parse(String source, ParsePosition pos) {\r\n131         // try to parse improper fraction\r\n132         Fraction ret = super.parse(source, pos);\r\n133         if (ret != null) {\r\n134             return ret;\r\n135         }\r\n136         \r\n137         int initialIndex = pos.getIndex();\r\n138 \r\n139         // parse whitespace\r\n140         parseAndIgnoreWhitespace(source, pos);\r\n141 \r\n142         // parse whole\r\n143         Number whole = getWholeFormat().parse(source, pos);\r\n144         if (whole == null) {\r\n145             // invalid integer number\r\n146             // set index back to initial, error index should already be set\r\n147             // character examined.\r\n148             pos.setIndex(initialIndex);\r\n149             return null;\r\n150         }\r\n151 \r\n152         // parse whitespace\r\n153         parseAndIgnoreWhitespace(source, pos);\r\n154         \r\n155         // parse numerator\r\n156         Number num = getNumeratorFormat().parse(source, pos);\r\n157         if (num == null) {\r\n158             // invalid integer number\r\n159             // set index back to initial, error index should already be set\r\n160             // character examined.\r\n161             pos.setIndex(initialIndex);\r\n162             return null;\r\n163         }\r\n164         \r\n165             // minus signs should be leading, invalid expression\r\n166 \r\n167         // parse '/'\r\n168         int startIndex = pos.getIndex();\r\n169         char c = parseNextCharacter(source, pos);\r\n170         switch (c) {\r\n171         case 0 :\r\n172             // no '/'\r\n173             // return num as a fraction\r\n174             return new Fraction(num.intValue(), 1);\r\n175         case '/' :\r\n176             // found '/', continue parsing denominator\r\n177             break;\r\n178         default :\r\n179             // invalid '/'\r\n180             // set index back to initial, error index should be the last\r\n181             // character examined.\r\n182             pos.setIndex(initialIndex);\r\n183             pos.setErrorIndex(startIndex);\r\n184             return null;\r\n185         }\r\n186 \r\n187         // parse whitespace\r\n188         parseAndIgnoreWhitespace(source, pos);\r\n189 \r\n190         // parse denominator\r\n191         Number den = getDenominatorFormat().parse(source, pos);\r\n192         if (den == null) {\r\n193             // invalid integer number\r\n194             // set index back to initial, error index should already be set\r\n195             // character examined.\r\n196             pos.setIndex(initialIndex);\r\n197             return null;\r\n198         }\r\n199         \r\n200             // minus signs must be leading, invalid\r\n201 \r\n202         int w = whole.intValue();\r\n203         int n = num.intValue();\r\n204         int d = den.intValue();\r\n205         return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\r\n206     }", "bm_classpath": "org.apache.commons.math.fraction.ProperFractionFormat"}, {"bug_name": "Mockito_1", "report_text": "> ArgumentCaptor no longer working for varargs\n> \n> I ran into the issue described here: <http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor>", "test_name": "org.mockito.internal.invocation.InvocationMatcherTest::should_capture_arguments_when_args_count_does_NOT_match", "test_method": "    @Test  // like using several time the captor in the vararg\n    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {\n        //given\n        mock.varargs();\n        Invocation invocation = getLastInvocation();\n\n        //when\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n        //then\n        invocationMatcher.captureArgumentsFrom(invocation); // <-- fails here\n    }", "error_message": "java.lang.UnsupportedOperationException\n\torg.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:123)\n\torg.mockito.internal.invocation.InvocationMatcherTest.should_capture_arguments_when_args_count_does_NOT_match(InvocationMatcherTest.java:170)", "buggy_method": "120 public void captureArgumentsFrom(Invocation invocation) {\n121         if (invocation.getMethod().isVarArgs()) {\n122             int indexOfVararg = invocation.getRawArguments().length - 1;\n123             throw new UnsupportedOperationException();\n124 \n125         } else {\n126             for (int position = 0; position < matchers.size(); position++) {\n127                 Matcher m = matchers.get(position);\n128                 if (m instanceof CapturesArguments) {\n129                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n130                 }\n131             }\n132         }\n133 \n134 //        for (int position = 0; position < matchers.size(); position++) {\n135 //            Matcher m = matchers.get(position);\n136 //            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n137 //                //TODO SF - this whole lot can be moved captureFrom implementation\n138 //                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n139 //                    Object array = invocation.getRawArguments()[position];\n140 //                    for (int i = 0; i < Array.getLength(array); i++) {\n141 //                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n142 //                    }\n143 //                    //since we've captured all varargs already, it does not make sense to process other matchers.\n144 //                    return;\n145 //                } else {\n146 //                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n147 //                }\n148 //            }\n149 //        }\n150     }", "bm_classpath": "org.mockito.internal.invocation.InvocationMatcher"}, {"bug_name": "Mockito_2", "report_text": "> Mockito.after() method accepts negative timeperiods and subsequent verifications always pass\n> \n> e.g.\n> ```\n> Runnable runnable = Mockito.mock(Runnable.class);\n> Mockito.verify(runnable, Mockito.never()).run(); // passes as expected\n> Mockito.verify(runnable, Mockito.after(1000).never()).run(); // passes as expected\n> Mockito.verify(runnable, Mockito.after(-1000).atLeastOnce()).run(); // passes incorrectly\n> ```", "test_name": "org.mockito.internal.util.TimerTest::should_throw_friendly_reminder_exception_when_duration_is_negative", "test_method": "public void should_throw_friendly_reminder_exception_when_duration_is_negative() {\n        try {\n            new Timer(-1);\n            Assert.fail(\"It is forbidden to create timer with negative value of timer's duration.\");\n        } catch (FriendlyReminderException e) {\n            Assert.assertTrue(true);\n        }\n    }", "error_message": "junit.framework.AssertionFailedError: It is forbidden to create timer with negative value of timer's duration.\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.mockito.internal.util.TimerTest.should_throw_friendly_reminder_exception_when_duration_is_negative(TimerTest.java:48)", "buggy_method": "9 public Timer(long durationMillis) {\n10         this.durationMillis = durationMillis;\n11     }", "bm_classpath": "org.mockito.internal.util.Timer"}, {"bug_name": "Mockito_3", "report_text": "> ArgumentCaptor no longer working for varargs\n> \n> I ran into the issue described here: <http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor>", "test_name": "org.mockito.internal.invocation.InvocationMatcherTest::should_capture_varargs_as_vararg", "test_method": "    @Test\n    public void should_capture_varargs_as_vararg() throws Exception {\n        //given\n        mock.mixedVarargs(1, \"a\", \"b\");\n        Invocation invocation = getLastInvocation();\n        CapturingMatcher m = new CapturingMatcher();\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m)));\n\n        //when\n        invocationMatcher.captureArgumentsFrom(invocation);\n\n        //then\n        Assertions.assertThat(m.getAllValues()).containsExactly(\"a\", \"b\"); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<[['a', 'b']]> but was:<[[1]]>\n\tsun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tsun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tsun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tjava.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\torg.fest.assertions.ConstructorInvoker.newInstance(ConstructorInvoker.java:34)\n\torg.fest.assertions.ComparisonFailureFactory.newComparisonFailure(ComparisonFailureFactory.java:60)\n\torg.fest.assertions.ComparisonFailureFactory.comparisonFailure(ComparisonFailureFactory.java:46)\n\torg.fest.assertions.Fail.comparisonFailed(Fail.java:83)\n\torg.fest.assertions.Fail.failIfNotEqual(Fail.java:71)\n\torg.fest.assertions.GenericAssert.assertEqualTo(GenericAssert.java:271)\n\torg.fest.assertions.ListAssert.isEqualTo(ListAssert.java:360)\n\torg.fest.assertions.ListAssert.containsExactly(ListAssert.java:350)\n\torg.mockito.internal.invocation.InvocationMatcherTest.should_capture_varargs_as_vararg(InvocationMatcherTest.java:154)", "buggy_method": "118 public void captureArgumentsFrom(Invocation invocation) {\n119         if (invocation.getMethod().isVarArgs()) {\n120             int indexOfVararg = invocation.getRawArguments().length - 1;\n121             for (int position = 0; position < indexOfVararg; position++) {\n122                 Matcher m = matchers.get(position);\n123                 if (m instanceof CapturesArguments) {\n124                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n125                 }\n126             }\n127             for (int position = indexOfVararg; position < matchers.size(); position++) {\n128                 Matcher m = matchers.get(position);\n129                 if (m instanceof CapturesArguments) {\n130                     ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n131                 }\n132             }\n133         } else {\n134             for (int position = 0; position < matchers.size(); position++) {\n135                 Matcher m = matchers.get(position);\n136                 if (m instanceof CapturesArguments) {\n137                     ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n138                 }\n139             }\n140         }\n141     }", "bm_classpath": "org.mockito.internal.invocation.InvocationMatcher"}, {"bug_name": "Mockito_4", "report_text": "> java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.String\n> \n> Exception throws on verifyZeroInteractions when using mock with default answer.  \n> checked on versions 1.10.5-2.0.5  \n> all ok on 1.9.5", "test_name": "org.mockito.exceptions.ReporterTest::can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order", "test_method": "    @Test(expected = VerificationInOrderFailure.class)\n    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {\n        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();\n        new Reporter().noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer); // <-- fails here\n    }", "error_message": "java.lang.Exception: Unexpected exception, expected<org.mockito.exceptions.verification.VerificationInOrderFailure> but was<java.lang.ClassCastException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\torg.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)", "buggy_method": "417 public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n418         ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n419         String scenario = scenarioPrinter.print(invocations);\n420 \n421         throw new NoInteractionsWanted(join(\n422                 \"No interactions wanted here:\",\n423                 new LocationImpl(),\n424                 \"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n425                 undesired.getLocation(),\n426                 scenario\n427         ));\n428     }", "bm_classpath": "org.mockito.exceptions.Reporter"}, {"bug_name": "Mockito_5", "report_text": "> Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)\n> \n> If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a `VerifyError` or a `NoClassDefFoundError`.\n> This issue has been reported on the [mailing list](https://groups.google.com/forum/#!topic/mockito/A6D7myKiD5k) and on [StackOverflow](http://stackoverflow.com/questions/27721621/java-lang-verifyerror-with-mockito-1-10-17)\n> A simple test like that with **TestNG** (and no JUnit in the class path of course) exposes the issue:\n> ```\n> import org.testng.annotations.Test;\n> import java.util.Observable;\n> import static org.mockito.Mockito.*;\n> public class VerifyErrorOnVerificationWithTimeoutTest {\n>     @Test public void should_not_throw_VerifyError() {\n>         verify(mock(Observable.class), timeout(500)).countObservers();\n>     }\n> }\n> ```\n> With TestNG 5.13.1, the stack trace is :\n> ```\n> java.lang.VerifyError: (class: org/mockito/internal/verification/VerificationOverTimeImpl, method: verify signature: (Lorg/mockito/internal/verification/api/VerificationData;)V) Incompatible argument to function\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n>     at org.mockito.Mockito.timeout(Mockito.java:2103)\n>     at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\n> ```\n> TestNG includes a dependency on JUnit 3.8.1, which has the `junit.framework.ComparisonFailure`, but the JVM cannot perform the linking at runtime (`VerifyError` extends `LinkageError`), probably because for the JVM there's some incompatible changes in this class between version 3.x and 4.x.  \n> Note that Mockito is compiled against JUnit 4.x. This also reveal that Mockito is not anymore compatible with JUnit 3.x.\n> With TestNG 6.8.13, the stack trace is :\n> ```\n> java.lang.NoClassDefFoundError: junit/framework/ComparisonFailure\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClassCond(ClassLoader.java:637)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:621)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)\n>     at java.net.URLClassLoader.access$000(URLClassLoader.java:58)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:197)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n>     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n>     at org.mockito.Mockito.timeout(Mockito.java:2103)\n>     at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\n> Caused by: java.lang.ClassNotFoundException: junit.framework.ComparisonFailure\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n>     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n>     ... 49 more\n> ```\n> Indeed JUnit is not anymore a dependency of TestNG.\n> In this specific case the issue is that the `Timeout` class wraps a `VerficationOverTimeImpl` that uses in try/catch block the exception `org.mockito.exceptions.verification.junit.ArgumentsAreDifferent` which extends `junit.framework.ComparisonFailure`.\n> At this time it seems to be the only place where JUnit is needed, this affect the following public API :\n> ```\n> Mockito.timeout(...)\n> Mockito.after(...)\n> ```", "test_name": "org.mockitointegration.NoJUnitDependenciesTest::pure_mockito_should_not_depend_JUnit", "test_method": "    @Test\n    public void pure_mockito_should_not_depend_JUnit() throws Exception {\n        ClassLoader classLoader_without_JUnit = ClassLoaders.excludingClassLoader()\n                .withCodeSourceUrlOf(\n                        Mockito.class,\n                        Matcher.class,\n                        Enhancer.class,\n                        Objenesis.class\n                )\n                .without(\"junit\", \"org.junit\")\n                .build();\n\n        Set<String> pureMockitoAPIClasses = ClassLoaders.in(classLoader_without_JUnit).omit(\"runners\", \"junit\", \"JUnit\").listOwnedClasses();\n\n        for (String pureMockitoAPIClass : pureMockitoAPIClasses) {\n            checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: 'org.mockito.internal.verification.VerificationOverTimeImpl' has some dependency to JUnit\n\torg.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:36)\n\torg.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit(NoJUnitDependenciesTest.java:28)", "buggy_method": "75 public void verify(VerificationData data) {\n76         AssertionError error = null;\n77 \n78         timer.start();\n79         while (timer.isCounting()) {\n80             try {\n81                 delegate.verify(data);\n82 \n83                 if (returnOnSuccess) {\n84                     return;\n85                 } else {\n86                     error = null;\n87                 }\n88             } catch (MockitoAssertionError e) {\n89                 error = handleVerifyException(e);\n90             }\n91             catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n92                 error = handleVerifyException(e);\n93             }\n94         }\n95 \n96         if (error != null) {\n97             throw error;\n98         }\n99     }", "bm_classpath": "org.mockito.internal.verification.VerificationOverTimeImpl"}, {"bug_name": "Mockito_6", "report_text": "> Argument matcher anyXxx() (i.e. anyString(), anyList()) should not match nulls\n> \n> This is a bug I'm seeing in 1.10.8 version (older version has the same issue - tested with 1.9.0).\n> Given:\n> ```\n> Function<Object, Integer> function = Mockito.mock(Function.class);\n> when(function.apply(Mockito.anyString())).thenReturn(1);\n> Integer result = function.apply(2);\n> ```\n> Expected behavior:\n> ```\n> result == null;\n> ```\n> Actual behavior:\n> ```\n> result == 1;\n> ```\n> Note that the function is called with an integer (not a string), and still the mocked function return the value which it should return only when a string is passed. The same works when using anyBoolean() or any other methof from any\\* family.", "test_name": "org.mockitousage.matchers.AnyXMatchersAcceptNullsTest::shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers", "test_method": "    @Test\r\n    public void shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers() {\r\n        when(mock.forInteger(anyInt())).thenReturn(\"0\");\r\n        when(mock.forCharacter(anyChar())).thenReturn(\"1\");\r\n        when(mock.forShort(anyShort())).thenReturn(\"2\");\r\n        when(mock.forByte(anyByte())).thenReturn(\"3\");\r\n        when(mock.forBoolean(anyBoolean())).thenReturn(\"4\");\r\n        when(mock.forLong(anyLong())).thenReturn(\"5\");\r\n        when(mock.forFloat(anyFloat())).thenReturn(\"6\");\r\n        when(mock.forDouble(anyDouble())).thenReturn(\"7\");\r\n        \r\n        assertEquals(null, mock.forInteger(null)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<null> but was:<0>\n\torg.mockitousage.matchers.AnyXMatchersAcceptNullsTest.shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers(AnyXMatchersAcceptNullsTest.java:54)", "buggy_method": "121 public static boolean anyBoolean() {\r\n122         return reportMatcher(Any.ANY).returnFalse();\r\n123     }", "bm_classpath": "org.mockito.Matchers"}, {"bug_name": "Mockito_7", "report_text": "> Deep stubbing with generic responses in the call chain is not working\n> \n> Deep stubbing will throw an Exception if multiple generics occur in the call chain. For instance, consider having a mock `myMock1` that provides a function that returns a generic `T`. If `T` also has a function that returns a generic, an Exception with the message \"Raw extraction not supported for : 'null'\" will be thrown.\n> As an example the following test will throw an Exception:\n> ```\n> public class MockitoGenericsDeepStubTest {\n>     @Test\n>     public void discoverDeepMockingOfGenerics() {\n>         MyClass1 myMock1 = mock(MyClass1.class, RETURNS\\_DEEP\\_STUBS);\n>         when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\");\n>     }\n>     public static interface MyClass1 <MC2 extends MyClass2> {\n>         public MC2 getNested();\n>     }\n>     public static interface MyClass2<MC3 extends MyClass3> {\n>         public MC3 getNested();\n>     }\n>     public static interface MyClass3 {\n>         public String returnSomething();\n>     }\n> }\n> ```\n> You can make this test run if you step into the class `ReturnsDeepStubs` and change the method `withSettingsUsing` to return `MockSettings` with `ReturnsDeepStubs` instead of `ReturnsDeepStubsSerializationFallback` as default answer:\n> ```\n> private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata, MockCreationSettings parentMockSettings) {\n>     MockSettings mockSettings = returnTypeGenericMetadata.hasRawExtraInterfaces() ?\n>             withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n>             : withSettings();\n>     return propagateSerializationSettings(mockSettings, parentMockSettings)\n>             .defaultAnswer(this);\n> }\n> ```\n> However, this breaks other tests and features.\n> I think, the issue is that further generics are not possible to be mocked by `ReturnsDeepStubsSerializationFallback` since the `GenericMetadataSupport` is \"closed\" at this point.\n> Thanks and kind regards  \n> Tobias", "test_name": "org.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest::discoverDeepMockingOfGenerics", "test_method": "  @Test\r\n  public void discoverDeepMockingOfGenerics() {\r\n    MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);\r\n    when(myMock1.getNested().getNested().returnSomething()).thenReturn(\"Hello World.\"); // <-- fails here\n    }", "error_message": "org.mockito.exceptions.base.MockitoException: Raw extraction not supported for : 'null'\n\torg.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf(GenericMetadataSupport.java:407)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType.extractRawTypeOf(GenericMetadataSupport.java:405)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType.rawType(GenericMetadataSupport.java:385)\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.answer(ReturnsDeepStubs.java:51)\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\n\torg.mockito.internal.creation.cglib.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:59)\n\torg.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest$MyClass2$$EnhancerByMockitoWithCGLIB$$3957466c.getNested(<generated>)\n\torg.mockitousage.bugs.deepstubs.DeepStubFailingWhenGenricNestedAsRawTypeTest.discoverDeepMockingOfGenerics(DeepStubFailingWhenGenricNestedAsRawTypeTest.java:26)", "buggy_method": "375 private void readTypeVariables() {\r\n376             for (Type type : typeVariable.getBounds()) {\r\n377                 registerTypeVariablesOn(type);\r\n378             }\r\n379             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\r\n380         }", "bm_classpath": "org.mockito.internal.util.reflection.GenericMetadataSupport$TypeVariableReturnType"}, {"bug_name": "Mockito_8", "report_text": "> 1.10 regression (StackOverflowError) with interface where generic type has itself as upper bound\n> \n> Add this to `GenericMetadataSupportTest`:\n> ```\n>     interface GenericsSelfReference<T extends GenericsSelfReference<T>> {\n>         T self();\n>     }\n>     @Test\n>     public void typeVariable\\_of\\_self\\_type() {\n>         GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod(\"self\", GenericsSelfReference.class));\n>         assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);\n>     }\n> ```\n> It fails on master and 1.10.8 with this:\n> ```\n> java.lang.StackOverflowError\n>     at sun.reflect.generics.reflectiveObjects.TypeVariableImpl.hashCode(TypeVariableImpl.java:201)\n>     at java.util.HashMap.hash(HashMap.java:338)\n>     at java.util.HashMap.get(HashMap.java:556)\n>     at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:193)\n>     at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:196)\n>     at org.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:196)\n> ```\n> It worked on 1.9.5. May be caused by the changes in [ab9e9f3](https://github.com/mockito/mockito/commit/ab9e9f347705bf9f4ebace4b07b085088275a256) (cc [@bric3](https://github.com/bric3)).\n> (Also note that while the above interface looks strange, it is commonly used for builder hierarchies, where base class methods want to return this with a more specific type.)", "test_name": "org.mockito.internal.util.reflection.GenericMetadataSupportTest::typeVariable_of_self_type", "test_method": "public void typeVariable_of_self_type() {\n        GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod(\"self\", GenericsSelfReference.class));\n\n        assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);\n    }\n\n    @Test", "error_message": "java.lang.StackOverflowError\n\tsun.reflect.generics.reflectiveObjects.TypeVariableImpl.hashCode(TypeVariableImpl.java:201)\n\tjava.util.HashMap.hash(HashMap.java:339)\n\tjava.util.HashMap.get(HashMap.java:557)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:182)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)\n\torg.mockito.internal.util.reflection.GenericMetadataSupport.getActualTypeArgumentFor(GenericMetadataSupport.java:185)", "buggy_method": "66 protected void registerTypeVariablesOn(Type classType) {\r\n67         if (!(classType instanceof ParameterizedType)) {\r\n68             return;\r\n69         }\r\n70         ParameterizedType parameterizedType = (ParameterizedType) classType;\r\n71         TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\r\n72         Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\r\n73         for (int i = 0; i < actualTypeArguments.length; i++) {\r\n74             TypeVariable typeParameter = typeParameters[i];\r\n75             Type actualTypeArgument = actualTypeArguments[i];\r\n76 \r\n77             if (actualTypeArgument instanceof WildcardType) {\r\n78                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\r\n79             } else {\r\n80                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\r\n81             }\r\n82             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\r\n83         }\r\n84     }", "bm_classpath": "org.mockito.internal.util.reflection.GenericMetadataSupport"}, {"bug_name": "Mockito_9", "report_text": "> Problem spying on abstract classes\n> \n> There's a problem with spying on abstract classes when the real implementation calls out to the abstract method. More details: [#121](https://github.com/mockito/mockito/pull/121)", "test_name": "org.mockitousage.constructor.CreatingMocksWithConstructorTest::abstractMethodStubbed", "test_method": "    @Test\n    public void abstractMethodStubbed() {\n    \tAbstractThing thing = spy(AbstractThing.class);\n    \twhen(thing.name()).thenReturn(\"me\"); // <-- fails here\n    }", "error_message": "org.mockito.exceptions.base.MockitoException\n\torg.mockito.exceptions.Reporter.cannotCallAbstractRealMethod(Reporter.java:583)\n\torg.mockito.internal.invocation.InvocationImpl.callRealMethod(InvocationImpl.java:110)\n\torg.mockito.internal.stubbing.answers.CallsRealMethods.answer(CallsRealMethods.java:36)\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\n\torg.mockito.internal.creation.cglib.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:59)\n\torg.mockitousage.constructor.CreatingMocksWithConstructorTest$AbstractThing$$EnhancerByMockitoWithCGLIB$$be30a00.name(<generated>)\n\torg.mockitousage.constructor.CreatingMocksWithConstructorTest.abstractMethodStubbed(CreatingMocksWithConstructorTest.java:119)", "buggy_method": "35 public Object answer(InvocationOnMock invocation) throws Throwable {\n36         return invocation.callRealMethod();\r\n37     }", "bm_classpath": "org.mockito.internal.stubbing.answers.CallsRealMethods"}, {"bug_name": "Mockito_10", "report_text": "> RETURNS_DEEP_STUBS automatically tries to create serializable mocks\n> \n> I am just migrating from mockito 1.9.5 to 1.10.5\n> The following code runs fine with version 1.9.5. but breaks now:\n> ```\n>   @Test\n>   public void test() {\n>     ToBeMocked mock = mock(ToBeMocked.class, RETURNS\\_DEEP\\_STUBS);\n>     assertThat(mock.getSomething()).isNotNull();\n>   }\n>   public static class ToBeMocked {\n>     NotSerializableReturnValue field1;\n>     public ToBeMocked(NotSerializableReturnValue field1) {\n>       this.field1 = field1;\n>     }\n>     public NotSerializableReturnValue getSomething() {\n>       return field1;\n>     }\n>   }\n>   public static class NotSerializableReturnValue {\n>     String field1 = \"\";\n>     public NotSerializableReturnValue(String field1) {\n>       this.field1 = field1;\n>     }\n>     public String getSomething2() {\n>       return field1;\n>     }\n>   }\n> ```\n> org.mockito.exceptions.base.MockitoException:  \n> You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'NotSerializableReturnValue'  \n> do not implement Serializable AND do not have a no-arg constructor.", "test_name": "org.mockitousage.bugs.DeepStubsWronglyReportsSerializationProblemsTest::should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub", "test_method": "    @Test\n    public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {\n        NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething(); // <-- fails here\n    }", "error_message": "org.mockito.exceptions.base.MockitoException\n\torg.mockito.exceptions.Reporter.serializableWontWorkForObjectsThatDontImplementSerializable(Reporter.java:760)\n\torg.mockito.internal.util.MockCreationValidator.validateSerializable(MockCreationValidator.java:63)\n\torg.mockito.internal.creation.MockSettingsImpl.validatedSettings(MockSettingsImpl.java:154)\n\torg.mockito.internal.creation.MockSettingsImpl.confirm(MockSettingsImpl.java:141)\n\torg.mockito.internal.MockitoCore.mock(MockitoCore.java:58)\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.newDeepStubMock(ReturnsDeepStubs.java:88)\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.deepStub(ReturnsDeepStubs.java:71)\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs.answer(ReturnsDeepStubs.java:55)\n\torg.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:93)\n\torg.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)\n\torg.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:38)\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:61)\n\torg.mockitousage.bugs.DeepStubsWronglyReportsSerializationProblemsTest$ToBeDeepStubbed$$EnhancerByMockitoWithCGLIB$$95a97fd6.getSomething(<generated>)\n\torg.mockitousage.bugs.DeepStubsWronglyReportsSerializationProblemsTest.should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub(DeepStubsWronglyReportsSerializationProblemsTest.java:16)", "buggy_method": "58 private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\r\n59         InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\r\n60         InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\r\n61 \r\n62         // matches invocation for verification\r\n63         for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\r\n64             if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\r\n65                 return stubbedInvocationMatcher.answer(invocation);\r\n66             }\r\n67         }\r\n68 \r\n69         // record deep stub answer\r\n70         return recordDeepStubAnswer(\r\n71                 newDeepStubMock(returnTypeGenericMetadata),\r\n72                 container\r\n73         );\r\n74     }", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs"}, {"bug_name": "Mockito_11", "report_text": "> Fixed DelegatingMethod.equals() so that it's easier to extend Mockito by custom verification modes\n> \n> Hi Szczepan,\n> Thanks for the reply, I'll simplify the methods now - do I open a new pull request, or somehow edit this one? Sorry - I'm new to GitHub and Git!\n> I haven't used a custom VerificationMode in anger yet, I'm actually writing a tutorial on Mockito and wanted to show one as an example. The one I wrote would verify that an invocation was the first invocation on a Mock, and I had a lot of hair pulling when the .equals() of my chunk and all invocations didn't evaluate to true, even though it was the same object!\n> Regards,  \n> Hugh", "test_name": "org.mockito.internal.creation.DelegatingMethodTest::equals_should_return_true_when_equal", "test_method": "    @Test\n    public void equals_should_return_true_when_equal() throws Exception {\n        DelegatingMethod equal = new DelegatingMethod(someMethod);\n        assertTrue(delegatingMethod.equals(equal)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.mockito.internal.creation.DelegatingMethodTest.equals_should_return_true_when_equal(DelegatingMethodTest.java:30)", "buggy_method": "53 @Override\n54     public boolean equals(Object o) {\n55             return method.equals(o);\n56     }", "bm_classpath": "org.mockito.internal.creation.DelegatingMethod"}, {"bug_name": "Mockito_12", "report_text": "> ArgumentCaptor no longer working for varargs\n> \n> I ran into the issue described here: <http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor>", "test_name": "org.mockito.internal.util.reflection.GenericMasterTest::shouldDealWithNestedGenerics", "test_method": "    @Test\r\n    public void shouldDealWithNestedGenerics() throws Exception {\r\n        assertEquals(Set.class, m.getGenericType(field(\"nested\"))); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl cannot be cast to java.lang.Class\n\torg.mockito.internal.util.reflection.GenericMaster.getGenericType(GenericMaster.java:20)\n\torg.mockito.internal.util.reflection.GenericMasterTest.shouldDealWithNestedGenerics(GenericMasterTest.java:38)", "buggy_method": "16 public Class getGenericType(Field field) {        \r\n17         Type generic = field.getGenericType();\r\n18         if (generic != null && generic instanceof ParameterizedType) {\r\n19             Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\r\n20                 return (Class) actual;\r\n21                 //in case of nested generics we don't go deep\r\n22         }\r\n23         \r\n24         return Object.class;\r\n25     }", "bm_classpath": "org.mockito.internal.util.reflection.GenericMaster"}, {"bug_name": "Mockito_13", "report_text": "> fix proposal for #114\n> \n> [@bric3](https://github.com/bric3), can you take a look at this one? If you don't have time I'll just merge it. All existing tests are passing.\n> Thanks for the fix!!!", "test_name": "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest::shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine", "test_method": "    @Test \n    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n        //given\n        when(mock.otherMethod()).thenReturn(\"foo\");\n        \n        //when\n        mockTwo.simpleMethod(\"foo\");\n        \n        //then\n        verify(mockTwo).simpleMethod(mock.otherMethod());\n        try {\n            verify(mockTwo, never()).simpleMethod(mock.otherMethod());\n            fail();\n        } catch (NeverWantedButInvoked e) {} // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest.shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(VerifyingWithAnExtraCallToADifferentMockTest.java:33)", "buggy_method": "58 public Object handle(Invocation invocation) throws Throwable {\r\n59         if (invocationContainerImpl.hasAnswersForStubbing()) {\r\n60             // stubbing voids with stubVoid() or doAnswer() style\r\n61             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\r\n62                             .getArgumentMatcherStorage(), invocation);\r\n63             invocationContainerImpl.setMethodForStubbing(invocationMatcher);\r\n64             return null;\r\n65         }\r\n66         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\r\n67 \r\n68         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\r\n69                         invocation);\r\n70 \r\n71         mockingProgress.validateState();\r\n72 \r\n73         //if verificationMode is not null then someone is doing verify()        \r\n74         if (verificationMode != null) {\r\n75             //We need to check if verification was started on the correct mock \r\n76             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\r\n77             if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \r\n78                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \r\n79                 verificationMode.verify(data);\r\n80                 return null;\r\n81                 // this means there is an invocation on a different mock. Re-adding verification mode \r\n82                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\r\n83             }\r\n84         }\r\n85         \r\n86         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r\n87         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\r\n88         mockingProgress.reportOngoingStubbing(ongoingStubbing);\r\n89 \r\n90         StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\r\n91 \r\n92         if (stubbedInvocation != null) {\r\n93             stubbedInvocation.captureArgumentsFrom(invocation);\r\n94             return stubbedInvocation.answer(invocation);\r\n95         } else {\r\n96             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\r\n97 \r\n98             // redo setting invocation for potential stubbing in case of partial\r\n99             // mocks / spies.\r\n100             // Without it, the real method inside 'when' might have delegated\r\n101             // to other self method and overwrite the intended stubbed method\r\n102             // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\r\n103             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\r\n104             return ret;\r\n105         }\r\n106     }", "bm_classpath": "org.mockito.internal.MockHandler"}, {"bug_name": "Mockito_14", "report_text": "> fix proposal for #114\n> \n> [@bric3](https://github.com/bric3), can you take a look at this one? If you don't have time I'll just merge it. All existing tests are passing.\n> Thanks for the fix!!!", "test_name": "org.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest::shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine", "test_method": "    @Test \n    public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {\n        //given\n        when(mock.otherMethod()).thenReturn(\"foo\");\n        \n        //when\n        mockTwo.simpleMethod(\"foo\");\n        \n        //then\n        verify(mockTwo).simpleMethod(mock.otherMethod()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.mockito.exceptions.Reporter.wantedButNotInvoked(Reporter.java:257)\n\torg.mockito.internal.verification.checkers.MissingInvocationChecker.check(MissingInvocationChecker.java:41)\n\torg.mockito.internal.verification.Times.verify(Times.java:35)\n\torg.mockito.internal.MockHandler.handle(MockHandler.java:77)\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:47)\n\torg.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$aa6ced83.otherMethod(<generated>)\n\torg.mockitousage.bugs.VerifyingWithAnExtraCallToADifferentMockTest.shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine(VerifyingWithAnExtraCallToADifferentMockTest.java:29)", "buggy_method": "57 public Object handle(Invocation invocation) throws Throwable {\r\n58         if (invocationContainerImpl.hasAnswersForStubbing()) {\r\n59             // stubbing voids with stubVoid() or doAnswer() style\r\n60             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\r\n61                             .getArgumentMatcherStorage(), invocation);\r\n62             invocationContainerImpl.setMethodForStubbing(invocationMatcher);\r\n63             return null;\r\n64         }\r\n65         VerificationMode verificationMode = mockingProgress.pullVerificationMode();\r\n66 \r\n67         InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\r\n68                         invocation);\r\n69 \r\n70         mockingProgress.validateState();\r\n71 \r\n72         //if verificationMode is not null then someone is doing verify()        \r\n73         if (verificationMode != null) {\r\n74             //We need to check if verification was started on the correct mock \r\n75             // - see VerifyingWithAnExtraCallToADifferentMockTest\r\n76                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);            \r\n77                 verificationMode.verify(data);\r\n78                 return null;\r\n79         }\r\n80         \r\n81         invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\r\n82         OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\r\n83         mockingProgress.reportOngoingStubbing(ongoingStubbing);\r\n84 \r\n85         StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\r\n86 \r\n87         if (stubbedInvocation != null) {\r\n88             stubbedInvocation.captureArgumentsFrom(invocation);\r\n89             return stubbedInvocation.answer(invocation);\r\n90         } else {\r\n91             Object ret = mockSettings.getDefaultAnswer().answer(invocation);\r\n92 \r\n93             // redo setting invocation for potential stubbing in case of partial\r\n94             // mocks / spies.\r\n95             // Without it, the real method inside 'when' might have delegated\r\n96             // to other self method and overwrite the intended stubbed method\r\n97             // with a different one.\r\n98             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\r\n99             return ret;\r\n100         }\r\n101     }", "bm_classpath": "org.mockito.internal.MockHandler"}, {"bug_name": "Mockito_15", "report_text": "> ArgumentCaptor no longer working for varargs\n> \n> Hi, thanks for the PR\n> I will take a look at it soon. And probably merge it. In the mean time, git history is fine except the merge commit, can you get rid of it ?\n> Otherwise I'll have to cherry-pick relevant commits.", "test_name": "org.mockitousage.bugs.InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest::shouldInjectUsingPropertySetterIfAvailable", "test_method": "    @Test\r\n    public void shouldInjectUsingPropertySetterIfAvailable() {\r\n        assertTrue(awaitingInjection.propertySetterUsed); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertTrue(Assert.java:52)\n\torg.mockitousage.bugs.InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.shouldInjectUsingPropertySetterIfAvailable(InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest.java:25)", "buggy_method": "18 public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\r\n19         if(mocks.size() == 1) {\r\n20             final Object matchingMock = mocks.iterator().next();\r\n21 \r\n22             return new OngoingInjecter() {\r\n23                 public boolean thenInject() {\r\n24                     try {\r\n25                             new FieldSetter(fieldInstance, field).set(matchingMock);\r\n26                     } catch (Exception e) {\r\n27                         throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\r\n28                     }\r\n29                     return true;\r\n30                 }\r\n31             };\r\n32         }\r\n33 \r\n34         return new OngoingInjecter() {\r\n35             public boolean thenInject() {\r\n36                 return false;\r\n37             }\r\n38         };\r\n39 \r\n40     }", "bm_classpath": "org.mockito.internal.configuration.injection.FinalMockCandidateFilter"}, {"bug_name": "Mockito_16", "report_text": "> Investigate why #125 did not trigger release\n> \n> Investigate why [#125](https://github.com/mockito/mockito/pull/125) did not trigger release", "test_name": "org.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest::shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS", "test_method": "    @Test\n    public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {\n        IMethods mock = mock(IMethods.class, RETURNS_MOCKS);\n        when(mock.objectReturningMethodNoArgs()).thenReturn(null); // <-- fails here\n    }", "error_message": "org.mockito.exceptions.misusing.MissingMethodInvocationException\n\torg.mockito.exceptions.Reporter.missingMethodInvocation(Reporter.java:77)\n\torg.mockito.internal.MockitoCore.stub(MockitoCore.java:43)\n\torg.mockito.internal.MockitoCore.when(MockitoCore.java:56)\n\torg.mockito.Mockito.when(Mockito.java:994)\n\torg.mockitousage.bugs.StubbingMocksThatAreConfiguredToReturnMocksTest.shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS(StubbingMocksThatAreConfiguredToReturnMocksTest.java:19)", "buggy_method": "826 public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\r\n827         return MOCKITO_CORE.mock(classToMock, mockSettings);\r\n828     }", "bm_classpath": "org.mockito.Mockito"}, {"bug_name": "Mockito_17", "report_text": "> Mockito 1.10.x timeout verification needs JUnit classes (VerifyError, NoClassDefFoundError)\n> \n> If JUnit is not on the classpath and mockito is version 1.10.x (as of now 1.10.1 up to 1.10.19) and the code is using the timeout verification which is not supposed to be related to JUnit, then the JVM may fail with a `VerifyError` or a `NoClassDefFoundError`.\n> This issue has been reported on the [mailing list](https://groups.google.com/forum/#!topic/mockito/A6D7myKiD5k) and on [StackOverflow](http://stackoverflow.com/questions/27721621/java-lang-verifyerror-with-mockito-1-10-17)\n> A simple test like that with **TestNG** (and no JUnit in the class path of course) exposes the issue:\n> ```\n> import org.testng.annotations.Test;\n> import java.util.Observable;\n> import static org.mockito.Mockito.*;\n> public class VerifyErrorOnVerificationWithTimeoutTest {\n>     @Test public void should_not_throw_VerifyError() {\n>         verify(mock(Observable.class), timeout(500)).countObservers();\n>     }\n> }\n> ```\n> With TestNG 5.13.1, the stack trace is :\n> ```\n> java.lang.VerifyError: (class: org/mockito/internal/verification/VerificationOverTimeImpl, method: verify signature: (Lorg/mockito/internal/verification/api/VerificationData;)V) Incompatible argument to function\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n>     at org.mockito.Mockito.timeout(Mockito.java:2103)\n>     at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\n> ```\n> TestNG includes a dependency on JUnit 3.8.1, which has the `junit.framework.ComparisonFailure`, but the JVM cannot perform the linking at runtime (`VerifyError` extends `LinkageError`), probably because for the JVM there's some incompatible changes in this class between version 3.x and 4.x.  \n> Note that Mockito is compiled against JUnit 4.x. This also reveal that Mockito is not anymore compatible with JUnit 3.x.\n> With TestNG 6.8.13, the stack trace is :\n> ```\n> java.lang.NoClassDefFoundError: junit/framework/ComparisonFailure\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClassCond(ClassLoader.java:637)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:621)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:141)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:283)\n>     at java.net.URLClassLoader.access$000(URLClassLoader.java:58)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:197)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n>     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:32)\n>     at org.mockito.verification.Timeout.<init>(Timeout.java:25)\n>     at org.mockito.Mockito.timeout(Mockito.java:2103)\n>     at com.example.UserServiceImplTest.test(UserServiceImplTest.java:26)\n> Caused by: java.lang.ClassNotFoundException: junit.framework.ComparisonFailure\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n>     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n>     ... 49 more\n> ```\n> Indeed JUnit is not anymore a dependency of TestNG.\n> In this specific case the issue is that the `Timeout` class wraps a `VerficationOverTimeImpl` that uses in try/catch block the exception `org.mockito.exceptions.verification.junit.ArgumentsAreDifferent` which extends `junit.framework.ComparisonFailure`.\n> At this time it seems to be the only place where JUnit is needed, this affect the following public API :\n> ```\n> Mockito.timeout(...)\n> Mockito.after(...)\n> ```", "test_name": "org.mockitousage.basicapi.MocksSerializationTest::shouldBeSerializeAndHaveExtraInterfaces", "test_method": "public void shouldBeSerializeAndHaveExtraInterfaces() throws Exception {\n        //when\n        IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));\n        IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());\n\n        //then\n        serializeAndBack((List) mock);\n        serializeAndBack((List) mockTwo);\n    }", "error_message": "java.io.NotSerializableException: org.mockitousage.IMethods$$EnhancerByMockitoWithCGLIB$$80860597\n\tjava.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)\n\tjava.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\n\torg.mockitoutil.TestBase.serializeMock(TestBase.java:160)\n\torg.mockitoutil.TestBase.serializeAndBack(TestBase.java:146)\n\torg.mockitousage.basicapi.MocksSerializationTest.shouldBeSerializeAndHaveExtraInterfaces(MocksSerializationTest.java:312)", "buggy_method": "73 public boolean isSerializable() {\r\n74         return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\r\n75     }", "bm_classpath": "org.mockito.internal.creation.MockSettingsImpl"}, {"bug_name": "Mockito_18", "report_text": "> Return empty value for Iterables\n> \n> <http://code.google.com/p/mockito/issues/detail?id=175>\n> I expect an Iterable to be mocked by default with an empty Iterable. I understand from the initial issue this behavior would be introduced in Mockito 2, but beta-8 still returns null.\n> Could we return null for Iterables ?\n> Should we have the same behavior for Iterator ?\n> Thanks", "test_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest::should_return_empty_iterable", "test_method": "    @Test\n    public void should_return_empty_iterable() throws Exception {\n        assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext()); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest.should_return_empty_iterable(ReturnsEmptyValuesTest.java:57)", "buggy_method": "82 Object returnValueFor(Class<?> type) {\n83         if (Primitives.isPrimitiveOrWrapper(type)) {\n84             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n85             //new instances are used instead of Collections.emptyList(), etc.\n86             //to avoid UnsupportedOperationException if code under test modifies returned collection\n87         } else if (type == Collection.class) {\n88             return new LinkedList<Object>();\n89         } else if (type == Set.class) {\n90             return new HashSet<Object>();\n91         } else if (type == HashSet.class) {\n92             return new HashSet<Object>();\n93         } else if (type == SortedSet.class) {\n94             return new TreeSet<Object>();\n95         } else if (type == TreeSet.class) {\n96             return new TreeSet<Object>();\n97         } else if (type == LinkedHashSet.class) {\n98             return new LinkedHashSet<Object>();\n99         } else if (type == List.class) {\n100             return new LinkedList<Object>();\n101         } else if (type == LinkedList.class) {\n102             return new LinkedList<Object>();\n103         } else if (type == ArrayList.class) {\n104             return new ArrayList<Object>();\n105         } else if (type == Map.class) {\n106             return new HashMap<Object, Object>();\n107         } else if (type == HashMap.class) {\n108             return new HashMap<Object, Object>();\n109         } else if (type == SortedMap.class) {\n110             return new TreeMap<Object, Object>();\n111         } else if (type == TreeMap.class) {\n112             return new TreeMap<Object, Object>();\n113         } else if (type == LinkedHashMap.class) {\n114             return new LinkedHashMap<Object, Object>();\n115         }\n116         //Let's not care about the rest of collections.\n117         return null;\n118     }", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues"}, {"bug_name": "Mockito_19", "report_text": "> InjectMocks injects mock into wrong field\n> \n> Using `1.10.19`.\n> When using `@InjectMocks` on some Android `TextView`s, the mock is injected into the wrong field.\n> We have two fields, `txtGateView` & `txtNextStep` in a class, and our test mocks out `txtNextStep`, then tried to inject. This field is injected wrong, see screenshot.\n> [![image](https://cloud.githubusercontent.com/assets/1404810/7410003/4f200580-ef2b-11e4-9c39-7a699dc4fefa.png)](https://cloud.githubusercontent.com/assets/1404810/7410003/4f200580-ef2b-11e4-9c39-7a699dc4fefa.png)\n> From our quick testing, the name `txtNextView` doesn't matter, that can be changed. But both `txtGateView` and `txtGateLabel` messed things up. If we mock out both fields, it works correctly.\n> Testproject: <https://github.com/SimenB/emptyandroid>\n> I don't know if it's because it's Android, but it was easiest for me to create a minimal test from existing code.", "test_name": "org.mockitousage.annotation.MockInjectionUsingSetterOrPropertyTest::shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable", "test_method": "    @Test\n\tpublic void shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable() {\n\t\tMockitoAnnotations.initMocks(this);\n\t\tassertNull(otherSuperUnderTesting.candidate1); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Expected: <null> but was: candidate2\n\torg.mockitousage.annotation.MockInjectionUsingSetterOrPropertyTest.shouldInsertFieldWithCorrectNameWhenMultipleTypesAvailable(MockInjectionUsingSetterOrPropertyTest.java:115)", "buggy_method": "111 private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n112         for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n113             Field field = it.next();\n114             Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n115             if (injected != null) {\n116                 injectionOccurred |= true;\n117                 mocks.remove(injected);\n118                 it.remove();\n119             }\n120         }\n121         return injectionOccurred;\n122     }", "bm_classpath": "org.mockito.internal.configuration.injection.PropertyAndSetterInjection"}, {"bug_name": "Mockito_20", "report_text": "> Allow convenient spying on abstract classes\n> \n> I posted this in GoogleCode and was asked to submit in github.\n> Mockito is easy to use when the test needs to provide canned values for a certain method.\n> But it gets harder when a canned value isn't sufficient.\n> ##### Example 1: Fake with trivial Logic\n> ```\n> interface UserAccount {\n>   List<String> getEmails();\n>   void addEmail(String email);\n>   // 12 other methods ...\n> }\n> ```\n> When mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\n> ##### Example 2: callback-style API\n> ```\n> interface AccountService {\n>   void getAccount(String id, AsyncCallback<UserAccount> callback);\n> }\n> ```\n> Stubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\n> ```\n> when(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n>   AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n>   ...\n> });\n> ```\n> ##### Example 3: Uninteresting parameters\n> ```\n> interface AccountRpcService {\n>   FutureAccount getAccount(RpcContext context, String id);\n> }\n> ```\n> None of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\n> If AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\n> `when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);`\n> And all other parameters are required to be wrapped in eq().\n> #### Proposal\n> I propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\n> ##### For example 1\n> ```\n> abstract class FakeUserAccount implements UserAccount {\n>   private final List<String> emails = new ArrayList<>();\n>   @Override public void addEmail(String email) {\n>     emails.add(email);\n>   }\n>   @Override List<String> getEmails() {\n>     return ImmutableList.copyOf(emails);\n>   }\n> }\n> @Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n> ```\n> ##### For example 2\n> ```\n> abstract class MockAccountService implements AccountService {\n>   @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n>     callback.onSuccess(getAccount(id));\n>   }\n>   abstract UserAccount getAccount(String id);\n> }\n> @Fake private MockAccountService service;\n> ...\n> when(service.getAccount(\"id\")).thenReturn(account);\n> ```\n> ##### For example 3\n> ```\n> abstract class MockAccountRpcService implements AccountRpcService {\n>   @Override Future<Account> getAccount(RpcContext context, String id) {\n>     checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n>     return getAccount(id);\n>   }\n>   abstract Future<Account> getAccount(String id);\n> }\n> @Fake private MockAccountRpcService service;\n> when(service.getAccount(\"id\")).thenReturn(...);\n> ```\n> My work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\n> But because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\n> If the idea sounds okay to give a try, I'll volunteer to submit a patch.\n> Thanks!", "test_name": "org.mockitousage.annotation.SpyAnnotationTest::should_spy_inner_class", "test_method": "    @Test\r\n    public void should_spy_inner_class() throws Exception {\r\n    \t \r\n     class WithMockAndSpy {\r\n    \t\t@Spy private InnerStrength strength;\r\n    \t\t@Mock private List<String> list;\r\n\r\n            abstract class InnerStrength {\r\n            \tprivate final String name;\r\n\r\n            \tInnerStrength() {\r\n            \t\t// Make sure that @Mock fields are always injected before @Spy fields.\r\n            \t\tassertNotNull(list);\r\n            \t\t// Make sure constructor is indeed called.\r\n            \t\tthis.name = \"inner\";\r\n            \t}\r\n            \t\r\n            \tabstract String strength();\r\n            \t\r\n            \tString fullStrength() {\r\n            \t\treturn name + \" \" + strength();\r\n            \t}\r\n            }\r\n    \t}\r\n\t\tWithMockAndSpy outer = new WithMockAndSpy();\r\n        MockitoAnnotations.initMocks(outer);\r\n        when(outer.strength.strength()).thenReturn(\"strength\");\r\n        assertEquals(\"inner strength\", outer.strength.fullStrength()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[inner] strength> but was:<[null] strength>\n\torg.mockitousage.annotation.SpyAnnotationTest.should_spy_inner_class(SpyAnnotationTest.java:150)", "buggy_method": "24 public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n25         if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n26             throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n27         }\n28         Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n29                 settings.getTypeToMock(),\n30                 settings.getExtraInterfaces()\n31         );\n32         T mockInstance = null;\n33         try {\n34             mockInstance = classInstantiator.instantiate(mockedProxyType);\n35             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n36             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n37 \n38             return ensureMockIsAssignableToMockedType(settings, mockInstance);\n39         } catch (ClassCastException cce) {\n40             throw new MockitoException(join(\n41                     \"ClassCastException occurred while creating the mockito mock :\",\n42                     \"  class to mock : \" + describeClass(mockedProxyType),\n43                     \"  created class : \" + describeClass(settings.getTypeToMock()),\n44                     \"  proxy instance class : \" + describeClass(mockInstance),\n45                     \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n46                     \"\",\n47                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n48                     \"\"\n49             ),cce);\n50         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n51             throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n52         }\n53     }", "bm_classpath": "org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker"}, {"bug_name": "Mockito_21", "report_text": "> Allow convenient spying on abstract classes\n> \n> I posted this in GoogleCode and was asked to submit in github.\n> Mockito is easy to use when the test needs to provide canned values for a certain method.\n> But it gets harder when a canned value isn't sufficient.\n> ##### Example 1: Fake with trivial Logic\n> ```\n> interface UserAccount {\n>   List<String> getEmails();\n>   void addEmail(String email);\n>   // 12 other methods ...\n> }\n> ```\n> When mocking such domain entity object, it's tedious to manually program getEmails()/addEmail() with when().thenReturn() and to make sure the two methods are logically consistent, that is, getEmails() returns all emails added.\n> ##### Example 2: callback-style API\n> ```\n> interface AccountService {\n>   void getAccount(String id, AsyncCallback<UserAccount> callback);\n> }\n> ```\n> Stubbing AccountService isn't easy. It'd require use of Answer, and the Answer API isn't statically type safe:\n> ```\n> when(service.getAccount(eq(id), any(AsyncCallback.class)).thenAnswer(new Answer<Void>() {\n>   AsyncCallback<UserAccount> callback = (AsyncCallback<UserAccount>) getArguments()[1];\n>   ...\n> });\n> ```\n> ##### Example 3: Uninteresting parameters\n> ```\n> interface AccountRpcService {\n>   FutureAccount getAccount(RpcContext context, String id);\n> }\n> ```\n> None of the tests care about the context object. It's an uninteresting parameter imposed by the framework.\n> If AccountRpcService were directly mocked, all tests would have to use isA() to repetitively mention this uninteresting parameter, like this:\n> `when(service.getAccount(isA(RpcContext.class), eq(\"id\")).thenReturn(...);`\n> And all other parameters are required to be wrapped in eq().\n> #### Proposal\n> I propose adding support for abstract classes to mockito to make it easier to deal with tests like above:\n> ##### For example 1\n> ```\n> abstract class FakeUserAccount implements UserAccount {\n>   private final List<String> emails = new ArrayList<>();\n>   @Override public void addEmail(String email) {\n>     emails.add(email);\n>   }\n>   @Override List<String> getEmails() {\n>     return ImmutableList.copyOf(emails);\n>   }\n> }\n> @Fake private FakeUserAccount userAccount; // Mockito instantiates abstract class.\n> ```\n> ##### For example 2\n> ```\n> abstract class MockAccountService implements AccountService {\n>   @Override public void getAccount(String id, AsyncCallback<UserAccount> callback) {\n>     callback.onSuccess(getAccount(id));\n>   }\n>   abstract UserAccount getAccount(String id);\n> }\n> @Fake private MockAccountService service;\n> ...\n> when(service.getAccount(\"id\")).thenReturn(account);\n> ```\n> ##### For example 3\n> ```\n> abstract class MockAccountRpcService implements AccountRpcService {\n>   @Override Future<Account> getAccount(RpcContext context, String id) {\n>     checkNotNull(context);  // Common sanity test. Don't have to repeat it in tests.\n>     return getAccount(id);\n>   }\n>   abstract Future<Account> getAccount(String id);\n> }\n> @Fake private MockAccountRpcService service;\n> when(service.getAccount(\"id\")).thenReturn(...);\n> ```\n> My work place internally implemented a default Answer to support abstract classes. We found that the support of abstract classes helps us to avoid overusing mocks when we should be using fakes. And in situations like above we get cleaner test code.\n> But because it's not integrated in the core Mockito, there are gotchas with our implementation (like, you can't have private/final methods in your fake).\n> If the idea sounds okay to give a try, I'll volunteer to submit a patch.\n> Thanks!", "test_name": "org.mockito.internal.creation.instance.ConstructorInstantiatorTest::creates_instances_of_inner_classes", "test_method": "    @Test public void creates_instances_of_inner_classes() {\n        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class); // <-- fails here\n    }", "error_message": "org.mockito.internal.creation.instance.InstantationException: Unable to create mock instance of 'SomeInnerClass'.\n\torg.mockito.internal.creation.instance.ConstructorInstantiator.paramsException(ConstructorInstantiator.java:33)\n\torg.mockito.internal.creation.instance.ConstructorInstantiator.withOuterClass(ConstructorInstantiator.java:27)\n\torg.mockito.internal.creation.instance.ConstructorInstantiator.newInstance(ConstructorInstantiator.java:17)\n\torg.mockito.internal.creation.instance.ConstructorInstantiatorTest.creates_instances_of_inner_classes(ConstructorInstantiatorTest.java:21)", "buggy_method": "13 public <T> T newInstance(Class<T> cls) {\n14         if (outerClassInstance == null) {\n15             return noArgConstructor(cls);\n16         }\n17         return withOuterClass(cls);\n18     }", "bm_classpath": "org.mockito.internal.creation.instance.ConstructorInstantiator"}, {"bug_name": "Mockito_22", "report_text": "> Can not Return deep stubs from generic method that returns generic type\n> \n> Hey,\n> if I try to mock a generic method which a generic returntype, where the returntype is derived from the generic type of the method using deep stubs I get a `ClassCastException` when calling `when` on it.\n> ```\n> interface I {\n>     <T> Supplier<T> m(Class<T> type);\n> }\n> @Test\n> public void test() throws Exception {\n>     I i = mock(I.class, RETURNS_DEEP_STUBS);\n>     when(i.m(Boolean.class).get()); // <- ClassCastException\n> }\n> ```\n> When you don't use deep stubs and a raw `Supplier` mock to pass around it works:\n> ```\n> I i = mock(I.class);\n> Supplier s = mock(Supplier.class);\n> when(i.m(Boolean.class)).thenReturn(s);\n> when(i.m(Boolean.class).get());\n> ```\n> The `ClassCastException`:\n> ```\n> java.lang.ClassCastException: org.mockito.internal.creation.cglib.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$cdb13154 cannot be cast to java.lang.String\n>   at MockitoGenerics.test(MockitoGenerics.java:21)\n>   at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>   at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>   at java.lang.reflect.Method.invoke(Method.java:483)\n>   at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)\n>   at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n>   at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)\n>   at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)\n>   at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n>   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n>   at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n>   at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n>   at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n>   at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n>   at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n>   at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n>   at org.junit.runners.ParentRunner.run(ParentRunner.java:309)\n>   at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>   at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>   at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> ```\n> Tested using mockito 1.10.19, jdk 1.8.0\\_20 and no Powermock", "test_name": "org.mockito.internal.matchers.EqualityTest::shouldKnowIfObjectsAreEqual", "test_method": "    @Test\r\n    public void shouldKnowIfObjectsAreEqual() throws Exception {\r\n        int[] arr = new int[] {1, 2};\r\n\tObject badequals=new BadEquals();\r\n\tassertTrue(areEqual(badequals,badequals)); // <-- fails here\n    }", "error_message": "java.lang.RuntimeException\n\torg.mockito.internal.matchers.EqualityTest$BadEquals.equals(EqualityTest.java:34)\n\torg.mockito.internal.matchers.Equality.areEqual(Equality.java:18)\n\torg.mockito.internal.matchers.EqualityTest.shouldKnowIfObjectsAreEqual(EqualityTest.java:24)", "buggy_method": "12 public static boolean areEqual(Object o1, Object o2) {\r\n13         if (o1 == null || o2 == null) {\r\n14             return o1 == null && o2 == null;\r\n15         } else if (isArray(o1)) {\r\n16             return isArray(o2) && areArraysEqual(o1, o2);\r\n17         } else {\r\n18             return o1.equals(o2);\r\n19         }\r\n20     }", "bm_classpath": "org.mockito.internal.matchers.Equality"}, {"bug_name": "Mockito_23", "report_text": "> WrongTypeOfReturnValue when abstract class have two abstract method\n> \n> Hey  \n> I found a strange problem, when i create a abstract class:\n> ```\n> abstract class AbstractClass {\n>     abstract protected Long lol();\n>     abstract protected String wow();\n>     public String give() {\n>         wow();\n>         lol();\n>         return \"give\";\n>     }\n> }\n> ```\n> and i have another class extends abstract Class:\n> ```\n> public class ClassExtendsAbstractClass extends AbstractClass {\n> @Override\n>  protected Long lol() {\n>         return 2L;\n>     }\n>     @Override\n>     protected String wow() {\n>         return \"WOW\";\n>     }\n> }\n> ```\n> and I have class:\n> ```\n> public class A {\n>   private ClassExtendsAbstractClass classExtendsAbstractClass;\n>   public A(ClassExtendsAbstractClass classExtendsAbstractClass) {\n>     this.classExtendsAbstractClass = classExtendsAbstractClass;\n>   }\n>   public String doSomeThing(){\n>     return classExtendsAbstractClass.wow();\n>   }\n> }\n> ```\n> and when i try mock method doSomeThing() from A class in test:\n> ```\n>   @Mock\n>   private ClassExtendsAbstractClass classExtendsAbstractClass;\n>   private A a;\n>   @Before\n>   public void before(){\n>     Mockito.when(classExtendsAbstractClass.give()).thenReturn(\"aaa\");\n>   }\n>   @Test\n>   public void test() {\n>     a = new A(classExtendsAbstractClass);\n>   }\n> ```\n> I get the error:\n> > \n> > org.mockito.exceptions.misusing.WrongTypeOfReturnValue:  \n> > \n> > String cannot be returned by lol()  \n> > \n> > lol() should return Long\n> > \n> > \n> > \n> This is strange behavior, because the method `lol()` should not be called, but when I delete one abstract method everything is good.", "test_name": "org.mockitousage.stubbing.DeepStubsSerializableTest::should_serialize_and_deserialize_mock_created_by_deep_stubs", "test_method": "    @Test\n    public void should_serialize_and_deserialize_mock_created_by_deep_stubs() throws Exception {\n        // given\n        SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(Mockito.RETURNS_DEEP_STUBS).serializable());\n        when(sampleClass.getSample().isSth()).thenReturn(STUBBED_BOOLEAN_VALUE);\n        when(sampleClass.getSample().getNumber()).thenReturn(STUBBED_INTEGER_VALUE);\n\n        // when\n        Object o = SimpleSerializationUtil.serializeAndBack(sampleClass); // <-- fails here\n    }", "error_message": "java.io.NotSerializableException: org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs$2\n\tjava.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)\n\tjava.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)\n\tjava.util.concurrent.ConcurrentLinkedQueue.writeObject(ConcurrentLinkedQueue.java:769)\n\tsun.reflect.GeneratedMethodAccessor46.invoke(Unknown Source)\n\tsun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tjava.lang.reflect.Method.invoke(Method.java:498)\n\tjava.io.ObjectStreamClass.invokeWriteObject(ObjectStreamClass.java:1154)\n\tjava.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1496)\n\tjava.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\n\tjava.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\n\tjava.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)\n\tjava.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)\n\tjava.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\n\tjava.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\n\tjava.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)\n\tjava.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)\n\tjava.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)\n\tjava.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)\n\tjava.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)\n\tjava.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)", "buggy_method": "93 private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\r\n94         MockSettings mockSettings =\r\n95                 returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\r\n96                 withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\r\n97                 : withSettings();\r\n98 \r\n99         return mockSettings\r\n100                 .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\r\n101     }", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs"}, {"bug_name": "Mockito_24", "report_text": "> fix some rawtype warnings in tests\n> \n> [Current coverage](https://codecov.io/gh/mockito/mockito/pull/467?src=pr) is **87.76%**\n> ---------------------------------------------------------------------------------------\n> > \n> > Merging [#467](https://codecov.io/gh/mockito/mockito/pull/467?src=pr) into [master](https://codecov.io/gh/mockito/mockito/branch/master?src=pr) will not change coverage\n> > \n> > \n> > \n> ```\n> @@ master #467 diff @@\n> ==========================================\n>   Files           263        263          \n>   Lines          4747       4747          \n>   Methods           0          0          \n>   Messages          0          0          \n>   Branches        767        767          \n> ==========================================\n>   Hits           4166       4166          \n>   Misses          416        416          \n>   Partials        165        165          \n> ```\n> [![Sunburst](https://camo.githubusercontent.com/977b5c47a26b9014e17af67cdf72511e5c4327e08169dd2f5ed0df612c2b202b/68747470733a2f2f636f6465636f762e696f2f67682f6d6f636b69746f2f6d6f636b69746f2f70756c6c2f3436372f6772617068732f73756e62757273742e7376673f7372633d70722673697a653d313530)](https://codecov.io/gh/mockito/mockito/pull/467?src=pr)\n> > \n> > Powered by [Codecov](https://codecov.io?src=pr). Last updated by [3fe0fd7...03d9a48](https://codecov.io/gh/mockito/mockito/compare/3fe0fd7b6c5d8ce41dc4040d3ab3039f8369385c...03d9a480674107305c8101384e2fb2daffc87b4e)\n> > \n> > \n> > ", "test_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest::should_return_zero_if_mock_is_compared_to_itself", "test_method": "    @Test public void should_return_zero_if_mock_is_compared_to_itself() {\n        //given\n        Date d = mock(Date.class);\n        d.compareTo(d);\n        Invocation compareTo = this.getLastInvocation();\n\n        //when\n        Object result = values.answer(compareTo);\n\n        //then\n        assertEquals(0, result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<1>\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest.should_return_zero_if_mock_is_compared_to_itself(ReturnsEmptyValuesTest.java:77)", "buggy_method": "63 public Object answer(InvocationOnMock invocation) {\n64         if (methodsGuru.isToString(invocation.getMethod())) {\n65             Object mock = invocation.getMock();\n66             MockName name = mockUtil.getMockName(mock);\n67             if (name.isDefault()) {\n68                 return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n69             } else {\n70                 return name.toString();\n71             }\n72         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n73             //see issue 184.\n74             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n75             //Only for compareTo() method by the Comparable interface\n76             return 1;\n77         }\n78         \n79         Class<?> returnType = invocation.getMethod().getReturnType();\n80         return returnValueFor(returnType);\n81     }", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues"}, {"bug_name": "Mockito_25", "report_text": "> Null Pointer when invoking Whitebox.invokeMethod() with null one of the params null\n> \n> Getting below exceptions when trying to invoke Whitebox.invokeMethod(erxProviderManager, \"setCommand\", Provider, null,retait, mail);\n> Version used 1.6.2\n> FAILED: testSetEnrollmentCommandWithUnEnrollmentWithNull  \n> java.lang.NullPointerException  \n> at java.lang.Class.isAssignableFrom(Native Method)  \n> at org.powermock.reflect.internal.WhiteboxImpl.checkIfParameterTypesAreSame(WhiteboxImpl.java:2257)  \n> at org.powermock.reflect.internal.WhiteboxImpl.getMethods(WhiteboxImpl.java:1800)  \n> at org.powermock.reflect.internal.WhiteboxImpl.getBestMethodCandidate(WhiteboxImpl.java:955)  \n> at org.powermock.reflect.internal.WhiteboxImpl.findMethodOrThrowException(WhiteboxImpl.java:832)  \n> at org.powermock.reflect.internal.WhiteboxImpl.doInvokeMethod(WhiteboxImpl.java:770)  \n> at org.powermock.reflect.internal.WhiteboxImpl.invokeMethod(WhiteboxImpl.java:638)  \n> at org.powermock.reflect.Whitebox.invokeMethod(Whitebox.java:401)", "test_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest::will_return_default_value_on_non_mockable_nested_generic", "test_method": "    @Test\r\n    public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {\r\n        GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);\r\n        ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);\r\n\r\n        assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull(); // <-- fails here\n    }", "error_message": "java.lang.ClassCastException: org.mockito.internal.creation.jmock.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$6c040935 cannot be cast to java.lang.String\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest.will_return_default_value_on_non_mockable_nested_generic(ReturnsGenericDeepStubsTest.java:97)", "buggy_method": "44 public Object answer(InvocationOnMock invocation) throws Throwable {\r\n45         GenericMetadataSupport returnTypeGenericMetadata =\r\n46                 actualParameterizedType(invocation.getMock()).resolveGenericReturnType(invocation.getMethod());\r\n47 \r\n48         Class<?> rawType = returnTypeGenericMetadata.rawType();\r\n49         if (!new MockCreationValidator().isTypeMockable(rawType)) {\r\n50             return delegate.returnValueFor(rawType);\r\n51         }\r\n52 \r\n53         return getMock(invocation);\r\n54     }", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsDeepStubs"}, {"bug_name": "Mockito_27", "report_text": "> Exception when stubbing more than once with when...thenThrow\n> \n> If I create a mock and stub a method so it throws an exception and do that twice the first exception will be thrown upon invoking the second stub instruction.\n> Example:\n> ```\n> @Test\n> public void testThrowException() {\n>     Object o = Mockito.mock(Object.class);\n>     // test behavior with Runtimeexception\n>     Mockito.when(o.toString()).thenThrow(RuntimeException.class);\n>     // ...\n>     // test behavior with another exception\n>     // this throws a RuntimeException\n>     Mockito.when(o.toString()).thenThrow(IllegalArgumentException.class);\n>     // ...\n> }\n> ```\n> I can work around this if I do it the other way around with doThrow...when. But I lose type safety then. Can you fix this?", "test_name": "org.mockitousage.bugs.ListenersLostOnResetMockTest::listener", "test_method": "    @Test\r\n    public void listener() throws Exception {\r\n        InvocationListener invocationListener = mock(InvocationListener.class);\r\n\r\n        List mockedList = mock(List.class, withSettings().invocationListeners(invocationListener));\r\n        reset(mockedList);\r\n\r\n        mockedList.clear();\r\n\r\n        verify(invocationListener).reportInvocation(any(MethodInvocationReport.class)); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.mockito.exceptions.Reporter.wantedButNotInvoked(Reporter.java:269)\n\torg.mockito.internal.verification.checkers.MissingInvocationChecker.check(MissingInvocationChecker.java:42)\n\torg.mockito.internal.verification.Times.verify(Times.java:36)\n\torg.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:22)\n\torg.mockito.internal.MockHandler.handle(MockHandler.java:81)\n\torg.mockito.internal.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)\n\torg.mockito.internal.creation.MethodInterceptorFilter.intercept(MethodInterceptorFilter.java:48)\n\torg.mockito.listeners.InvocationListener$$EnhancerByMockitoWithCGLIB$$a410022a.reportInvocation(<generated>)\n\torg.mockitousage.bugs.ListenersLostOnResetMockTest.listener(ListenersLostOnResetMockTest.java:23)", "buggy_method": "62 public <T> void resetMock(T mock) {\r\n63         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\r\n64         MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\r\n65         MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\r\n66         ((Factory) mock).setCallback(0, newFilter);\r\n67     }", "bm_classpath": "org.mockito.internal.util.MockUtil"}, {"bug_name": "Mockito_28", "report_text": "> nicer textual printing of typed parameters\n> \n> When matchers fail but yield the same toString(), Mockito prints extra type information. However, the type information is awkwardly printed for Strings. I've encountered this issue while working on removing hard dependency to hamcrest.\n> ```\n> //current:\n> someMethod(1, (Integer) 2);\n> someOther(1, \"(String) 2\");\n> //desired:\n> someOther(1, (String) \"2\");\n> ```", "test_name": "org.mockitousage.bugs.InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest::mock_should_be_injected_once_and_in_the_best_matching_type", "test_method": "    @Test\r\n    public void mock_should_be_injected_once_and_in_the_best_matching_type() {\r\n        assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected same:<java.lang.Object@9fbac3f> was not:<mockedBean>\n\torg.junit.Assert.fail(Assert.java:88)\n\torg.junit.Assert.failNotSame(Assert.java:737)\n\torg.junit.Assert.assertSame(Assert.java:680)\n\torg.junit.Assert.assertSame(Assert.java:691)\n\torg.mockitousage.bugs.InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.mock_should_be_injected_once_and_in_the_best_matching_type(InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest.java:33)", "buggy_method": "91 private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\r\n92         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\r\n93             mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\r\n94         }\r\n95     }", "bm_classpath": "org.mockito.internal.configuration.DefaultInjectionEngine"}, {"bug_name": "Mockito_29", "report_text": "> Fixes #228: fixed a verify() call example in @Captor javadoc\n> \n> Thanks for the fix :)", "test_name": "org.mockitousage.bugs.NPEWithCertainMatchersTest::shouldNotThrowNPEWhenNullPassedToSame", "test_method": "    @Test(expected = AssertionError.class)\r\n    public void shouldNotThrowNPEWhenNullPassedToSame() {\r\n        mock.objectArgMethod(\"not null\");\r\n\r\n        verify(mock).objectArgMethod(same(null)); // <-- fails here\n    }", "error_message": "java.lang.Exception: Unexpected exception, expected<java.lang.AssertionError> but was<java.lang.NullPointerException>\n\torg.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\n\torg.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\torg.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\torg.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\n\torg.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\n\torg.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\n\torg.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\n\torg.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\n\torg.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\n\torg.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\n\torg.junit.runners.ParentRunner.run(ParentRunner.java:309)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\n\torg.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\n\torg.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\n\tsun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)", "buggy_method": "26 public void describeTo(Description description) {\n27         description.appendText(\"same(\");\n28         appendQuoting(description);\n29         description.appendText(wanted.toString());\n30         appendQuoting(description);\n31         description.appendText(\")\");\n32     }", "bm_classpath": "org.mockito.internal.matchers.Same"}, {"bug_name": "Mockito_30", "report_text": "> Failing tests on Windows machine\n> \n> I just posted on the Google Forums, but someway somehow my post immediately disappeared in the void. So I am reposting it again here.\n> I have 3 failing tests on my Windows 8.1 machine.\n> 1. DefaultMockingDetailsTest.should\\_get\\_extra\\_interfaces\n> 2. NoJUnitDependenciesTest.pure\\_mockito\\_should\\_not\\_depend\\_JUnit\\_\\_\\_ByteBuddy\n> 3. ClassLoadersTest.excluding\\_class\\_loader\\_cannot\\_load\\_classes\\_when\\_no\\_correct\\_source\\_url\\_set\n> For the first test, I was able to let it pass by changing line <https://github.com/mockito/mockito/blob/master/test/org/mockito/internal/util/DefaultMockingDetailsTest.java#L56> to\n> ```\n> Bar bar = mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));\n> ```\n> I am not sure if this is indeed the correct test, so please let me know.\n> For the 2nd test, I first get the stack trace\n> ```\n> java.lang.AssertionError: 'org\\mockito\\configuration\\MockitoConfiguration' has some dependency to JUnit\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:40)\n>     at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit___ByteBuddy(NoJUnitDependenciesTest.java:32)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:497)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> Caused by: java.lang.NoClassDefFoundError: org\\mockito\\configuration\\MockitoConfiguration (wrong name: org/mockito/configuration/MockitoConfiguration)\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n>     at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n>     at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n>     at java.lang.Class.forName0(Native Method)\n>     at java.lang.Class.forName(Class.java:348)\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:38)\n>     ... 24 more\n> ```\n> When I change line <https://github.com/mockito/mockito/blob/master/test/org/mockitoutil/ClassLoaders.java#L361> to\n> ```\n> String temp = file.getAbsolutePath().substring(root.getAbsolutePath().length() + 1).replace('/', '.').replace('\\\\', '.');\n> ```\n> I get the following stack trace:\n> ```\n> java.lang.AssertionError: 'org.mockito.internal.progress.TimesTest' has some dependency to JUnit\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:40)\n>     at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit___ByteBuddy(NoJUnitDependenciesTest.java:32)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:497)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> Caused by: java.lang.NoClassDefFoundError: junit/framework/Assert\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n>     at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n>     at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)", "test_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest::shouldPrintTheParametersOnSmartNullPointerExceptionMessage", "test_method": "    @Test\r\n\tpublic void shouldPrintTheParametersOnSmartNullPointerExceptionMessage() throws Throwable {\r\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\r\n\r\n        Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\r\n\r\n        try {\r\n            smartNull.get();\r\n            fail();\r\n        } catch (SmartNullPointerException ex) {\r\n        \tString message = ex.getMessage();\r\n        \tassertTrue(\"Exception message should include oompa and lumpa, but was: \" + message,\r\n        \t\t\tmessage.contains(\"oompa, lumpa\"));\r\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: Exception message should include oompa and lumpa, but was:\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.shouldPrintTheParametersOnSmartNullPointerExceptionMessage(ReturnsSmartNullsTest.java:71)", "buggy_method": "438 public void smartNullPointerException(Location location) {\n439         throw new SmartNullPointerException(join(\n440                 \"You have a NullPointerException here:\",\n441                 new Location(),\n442                 \"Because this method was *not* stubbed correctly:\",\n443                 location,\n444                 \"\"\n445                 ));\n446     }", "bm_classpath": "org.mockito.exceptions.Reporter"}, {"bug_name": "Mockito_31", "report_text": "> Failing tests on Windows machine\n> \n> I just posted on the Google Forums, but someway somehow my post immediately disappeared in the void. So I am reposting it again here.\n> I have 3 failing tests on my Windows 8.1 machine.\n> 1. DefaultMockingDetailsTest.should\\_get\\_extra\\_interfaces\n> 2. NoJUnitDependenciesTest.pure\\_mockito\\_should\\_not\\_depend\\_JUnit\\_\\_\\_ByteBuddy\n> 3. ClassLoadersTest.excluding\\_class\\_loader\\_cannot\\_load\\_classes\\_when\\_no\\_correct\\_source\\_url\\_set\n> For the first test, I was able to let it pass by changing line <https://github.com/mockito/mockito/blob/master/test/org/mockito/internal/util/DefaultMockingDetailsTest.java#L56> to\n> ```\n> Bar bar = mock(Bar.class, withSettings().extraInterfaces(List.class, Observer.class));\n> ```\n> I am not sure if this is indeed the correct test, so please let me know.\n> For the 2nd test, I first get the stack trace\n> ```\n> java.lang.AssertionError: 'org\\mockito\\configuration\\MockitoConfiguration' has some dependency to JUnit\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:40)\n>     at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit___ByteBuddy(NoJUnitDependenciesTest.java:32)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:497)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> Caused by: java.lang.NoClassDefFoundError: org\\mockito\\configuration\\MockitoConfiguration (wrong name: org/mockito/configuration/MockitoConfiguration)\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n>     at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n>     at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n>     at java.lang.Class.forName0(Native Method)\n>     at java.lang.Class.forName(Class.java:348)\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:38)\n>     ... 24 more\n> ```\n> When I change line <https://github.com/mockito/mockito/blob/master/test/org/mockitoutil/ClassLoaders.java#L361> to\n> ```\n> String temp = file.getAbsolutePath().substring(root.getAbsolutePath().length() + 1).replace('/', '.').replace('\\\\', '.');\n> ```\n> I get the following stack trace:\n> ```\n> java.lang.AssertionError: 'org.mockito.internal.progress.TimesTest' has some dependency to JUnit\n>     at org.mockitointegration.NoJUnitDependenciesTest.checkDependency(NoJUnitDependenciesTest.java:40)\n>     at org.mockitointegration.NoJUnitDependenciesTest.pure_mockito_should_not_depend_JUnit___ByteBuddy(NoJUnitDependenciesTest.java:32)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n>     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n>     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n>     at java.lang.reflect.Method.invoke(Method.java:497)\n>     at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n>     at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n>     at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n>     at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n>     at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n>     at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n>     at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n>     at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n>     at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n>     at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n>     at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n>     at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n>     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)\n>     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)\n>     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)\n> Caused by: java.lang.NoClassDefFoundError: junit/framework/Assert\n>     at java.lang.ClassLoader.defineClass1(Native Method)\n>     at java.lang.ClassLoader.defineClass(ClassLoader.java:760)\n>     at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\n>     at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\n>     at java.net.URLClassLoader.access$100(URLClassLoader.java:73)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:368)\n>     at java.net.URLClassLoader$1.run(URLClassLoader.java:362)\n>     at java.security.AccessController.doPrivileged(Native Method)\n>     at java.net.URLClassLoader.findClass(URLClassLoader.java:361)\n>     at org.mockitoutil.ClassLoaders$LocalExcludingURLClassLoader.findClass(ClassLoaders.java:156)\n>     at java.lang.ClassLoader.loadClass(ClassLoader.java:424)", "test_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest::shouldPrintTheParametersWhenCallingAMethodWithArgs", "test_method": "    @Test\r\n    public void shouldPrintTheParametersWhenCallingAMethodWithArgs() throws Throwable {\r\n    \tAnswer<Object> answer = new ReturnsSmartNulls();\r\n\r\n    \tFoo smartNull = (Foo) answer.answer(invocationOf(Foo.class, \"withArgs\", \"oompa\", \"lumpa\"));\r\n\r\n    \tassertEquals(\"SmartNull returned by unstubbed withArgs(oompa, lumpa) method on mock\", smartNull + \"\"); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<... unstubbed withArgs([oompa, lumpa]) method on mock> but was:<... unstubbed withArgs([]) method on mock>\n\torg.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.shouldPrintTheParametersWhenCallingAMethodWithArgs(ReturnsSmartNullsTest.java:57)", "buggy_method": "59 private String formatMethodCall() {\r\n60 \t\t\treturn invocation.getMethod().getName() + \"()\";\r\n61 \t\t}", "bm_classpath": "org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNulls$ThrowingInterceptor"}, {"bug_name": "Mockito_32", "report_text": "> Mockito can't create mock on public class that extends package-private class\n> \n> I created simple project to demonstrate this:  \n> <https://github.com/astafev/mockito-package-private-class/>\n> Please take a look. Even if it can't be implemented, I think that mockito should throw some normal exception at time of creation.  \n> In my variant on first creation it returns wrong-working mock (invokes real method instead of stubbed). On second creation throws exception that doesn't really connected with problem.\n> Everything works fine if you mock package-private parent.", "test_name": "org.mockitousage.bugs.SpyShouldHaveNiceNameTest::shouldPrintNiceName", "test_method": "    @Test\n    public void shouldPrintNiceName() {\n        //when\n        veryCoolSpy.add(1);\n\n        try {\n            verify(veryCoolSpy).add(2);\n            fail();\n        } catch(AssertionError e) {\n            Assertions.assertThat(e.getMessage()).contains(\"veryCoolSpy\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: <'\n\torg.fest.assertions.Fail.failure(Fail.java:228)\n\torg.fest.assertions.Assert.failure(Assert.java:149)\n\torg.fest.assertions.StringAssert.contains(StringAssert.java:221)\n\torg.mockitousage.bugs.SpyShouldHaveNiceNameTest.shouldPrintNiceName(SpyShouldHaveNiceNameTest.java:31)", "buggy_method": "27 @SuppressWarnings(\"deprecation\")\r\n28     public void process(Class<?> context, Object testClass) {\r\n29         Field[] fields = context.getDeclaredFields();\r\n30         for (Field field : fields) {\r\n31             if (field.isAnnotationPresent(Spy.class)) {\r\n32                 assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\r\n33                 boolean wasAccessible = field.isAccessible();\r\n34                 field.setAccessible(true);\r\n35                 try {\r\n36                     Object instance = field.get(testClass);\r\n37                     if (instance == null) {\r\n38                         throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\r\n39                         \t\t  \"The instance must be created *before* initMocks();\\n\" +\r\n40                                   \"Example of correct usage of @Spy:\\n\" +\r\n41                             \t  \"   @Spy List mock = new LinkedList();\\n\" +\r\n42                             \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\r\n43 \r\n44                     }\r\n45                     if (new MockUtil().isMock(instance)) { \r\n46                         // instance has been spied earlier\r\n47                         Mockito.reset(instance);\r\n48                     } else {\r\n49                         field.set(testClass, Mockito.spy(instance));\r\n50                     }\r\n51                 } catch (IllegalAccessException e) {\r\n52                     throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\r\n53                 } finally {\r\n54                     field.setAccessible(wasAccessible);\r\n55                 }\r\n56             }\r\n57         }\r\n58     }", "bm_classpath": "org.mockito.internal.configuration.SpyAnnotationEngine"}, {"bug_name": "Mockito_33", "report_text": "> ArgumentCaptor.fromClass's return type should match a parameterized type\n> \n> `ArgumentCaptor.fromClass`'s return type should match a parameterized type. I.e. the expression `ArgumentCaptor.fromClass(Class<S>)` should be of type `ArgumentCaptor<U>` where `S` is a subtype of `U`.\n> For example:\n> ```\n> ArgumentCaptor<Consumer<String>> captor = ArgumentCaptor.fromClass(Consumer.class)\n> ```\n> does not type check (i.e. it is a compile time error). It should type check.\n> The reasons that it is desirable for `ArgumentCaptor.fromClass` to allow expressions such as the example above to type check are:\n> 1. `ArgumentCaptor.fromClass` is intended to be a convenience method to allow the user to construct an ArgumentCaptor without casting the returned value.\n> Currently, the user can devise a workaround such as:\n> ```\n> ArgumentCaptor<? extends Consumer<String>> captor \n> = ArgumentCaptor.fromClass(Consumer.class)\n> ```\n> This workaround is inconvenient, and so contrary to `ArgumentCaptor.fromClass` being a convenience method.\n> 2. It is inconsistent with `@Captor`, which can be applied to a field with a paramterized type. I.e.\n> ```\n> @Captor ArgumentCaptor<Consumer<String>> captor \n> ```\n> type checks.", "test_name": "org.mockitousage.bugs.InheritedGenericsPolimorphicCallTest::shouldStubbingWork", "test_method": "    @Test\n    public void shouldStubbingWork() {\n        Mockito.when(iterable.iterator()).thenReturn(myIterator);\n        Assert.assertNotNull(((Iterable) iterable).iterator()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.junit.Assert.fail(Assert.java:86)\n\torg.junit.Assert.assertTrue(Assert.java:41)\n\torg.junit.Assert.assertNotNull(Assert.java:621)\n\torg.junit.Assert.assertNotNull(Assert.java:631)\n\torg.mockitousage.bugs.InheritedGenericsPolimorphicCallTest.shouldStubbingWork(InheritedGenericsPolimorphicCallTest.java:39)", "buggy_method": "92 public boolean hasSameMethod(Invocation candidate) {        \n93         //not using method.equals() for 1 good reason:\n94         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n95         Method m1 = invocation.getMethod();\n96         Method m2 = candidate.getMethod();\n97         \n98         \t/* Avoid unnecessary cloning */\n99         return m1.equals(m2);\n100     }", "bm_classpath": "org.mockito.internal.invocation.InvocationMatcher"}, {"bug_name": "Mockito_34", "report_text": "> Source files should not be put in binary JAR\n> \n> Source files (`*.java`) should not be put into binary `mockito-core.jar`. It stupefies Idea to show decompiled file even when source jar is available.", "test_name": "org.mockito.internal.invocation.InvocationMatcherTest::shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch", "test_method": "    @Test\n    public void shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch() throws Exception {\n        //given\n        mock.varargs();\n        Invocation invocation = getLastInvocation();\n\n        //when\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));\n\n        //then\n        invocationMatcher.captureArgumentsFrom(invocation); // <-- fails here\n    }", "error_message": "java.lang.ArrayIndexOutOfBoundsException: 0\n\torg.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:107)\n\torg.mockito.internal.invocation.InvocationMatcherTest.shouldMatchCaptureArgumentsWhenArgsCountDoesNOTMatch(InvocationMatcherTest.java:152)", "buggy_method": "103 public void captureArgumentsFrom(Invocation i) {\n104         int k = 0;\n105         for (Matcher m : matchers) {\n106             if (m instanceof CapturesArguments) {\n107                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n108             }\n109             k++;\n110         }\n111     }", "bm_classpath": "org.mockito.internal.invocation.InvocationMatcher"}, {"bug_name": "Mockito_35", "report_text": "> possible NPE exception when class cannot be mocked via PowerMockito\n> \n> In version 1.10.5, the catch block needs to guard against a null proxyInstance:\n> java.lang.NullPointerException  \n> at org.mockito.internal.creation.jmock.ClassImposterizer.imposterise(ClassImposterizer.java:65)  \n> at org.powermock.api.mockito.internal.mockcreation.MockCreator.createMethodInvocationControl(MockCreator.java:111)  \n> at org.powermock.api.mockito.internal.mockcreation.MockCreator.mock(MockCreator.java:60)  \n> at org.powermock.api.mockito.PowerMockito.mock(PowerMockito.java:143)  \n> at com.seagullsw.appinterface.server.osgi.JCicsOsgiTestCase.executeOsgiRequest(JCicsOsgiTestCase.java:167)  \n> at com.seagullsw.appinterface.server.osgi.JCicsOsgiTestCase.executeOsgiRequest(JCicsOsgiTestCase.java:122)  \n> at com.seagullsw.appinterface.server.osgi.JCicsOsgiTestCase.checkFunctionReturnString(JCicsOsgiTestCase.java:99)  \n> at com.seagullsw.appinterface.server.osgi.JCicsOsgiTestCase.testJcicsOsgiRoundtrip(JCicsOsgiTestCase.java:230)  \n> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)  \n> at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)  \n> at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)  \n> at java.lang.reflect.Method.invoke(Method.java:606)  \n> at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:68)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.runTestMethod(PowerMockJUnit44RunnerDelegateImpl.java:310)  \n> at org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:88)  \n> at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:96)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.executeTest(PowerMockJUnit44RunnerDelegateImpl.java:294)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTestInSuper(PowerMockJUnit47RunnerDelegateImpl.java:127)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTest(PowerMockJUnit47RunnerDelegateImpl.java:82)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.runBeforesThenTestThenAfters(PowerMockJUnit44RunnerDelegateImpl.java:282)  \n> at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:86)  \n> at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:49)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.invokeTestMethod(PowerMockJUnit44RunnerDelegateImpl.java:207)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.runMethods(PowerMockJUnit44RunnerDelegateImpl.java:146)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$1.run(PowerMockJUnit44RunnerDelegateImpl.java:120)  \n> at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:33)  \n> at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:45)  \n> at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.run(PowerMockJUnit44RunnerDelegateImpl.java:122)  \n> at org.powermock.modules.junit4.common.internal.impl.JUnit4TestSuiteChunkerImpl.run(JUnit4TestSuiteChunkerImpl.java:104)  \n> at org.powermock.modules.junit4.common.internal.impl.AbstractCommonPowerMockRunner.run(AbstractCommonPowerMockRunner.java:53)  \n> at org.powermock.modules.junit4.PowerMockRunner.run(PowerMockRunner.java:53)  \n> at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)  \n> at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)  \n> at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)  \n> at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)  \n> at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)  \n> at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)", "test_name": "org.mockitousage.bugs.NPEWithCertainMatchersTest::shouldNotThrowNPEWhenIntPassed", "test_method": "    @Test\r\n    public void shouldNotThrowNPEWhenIntPassed() {\r\n        mock.intArgumentMethod(100);\r\n        \r\n        verify(mock).intArgumentMethod(isA(Integer.class)); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.mockitousage.bugs.NPEWithCertainMatchersTest.shouldNotThrowNPEWhenIntPassed(NPEWithCertainMatchersTest.java:38)", "buggy_method": "361 public static <T> T isA(Class<T> clazz) {\r\n362         return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\r\n363     }", "bm_classpath": "org.mockito.Matchers"}, {"bug_name": "Mockito_36", "report_text": "> Make Mockito JUnit rule easier to use\n> \n> * Mockito JUnit rule easier to use by avoiding the need to pass test instance\n> * Make it compatible with JUnit 4.7+ instead of 4.9+", "test_name": "org.mockito.internal.invocation.InvocationTest::shouldScreamWhenCallingRealMethodOnInterface", "test_method": "    @Test\n    public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {\n        //given\n        Invocation invocationOnInterface = new InvocationBuilder().toInvocation();\n\n        try {\n            //when\n            invocationOnInterface.callRealMethod();\n            //then\n            fail();\n        } catch(MockitoException e) {} // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.mockito.internal.invocation.Invocation.callRealMethod(Invocation.java:202)\n\torg.mockito.internal.invocation.InvocationTest.shouldScreamWhenCallingRealMethodOnInterface(InvocationTest.java:175)", "buggy_method": "201 public Object callRealMethod() throws Throwable {\n202         return realMethod.invoke(mock, rawArguments);\n203     }", "bm_classpath": "org.mockito.internal.invocation.Invocation"}, {"bug_name": "Mockito_37", "report_text": "> Make Mockito JUnit rule easier to use\n> \n> * Mockito JUnit rule easier to use by avoiding the need to pass test instance\n> * Make it compatible with JUnit 4.7+ instead of 4.9+", "test_name": "org.mockito.internal.stubbing.answers.AnswersValidatorTest::shouldFailWhenCallingRealMethodOnIterface", "test_method": "    @Test\r\n    public void shouldFailWhenCallingRealMethodOnIterface() throws Throwable {\r\n        //given\r\n        Invocation inovcationOnIterface = new InvocationBuilder().method(\"simpleMethod\").toInvocation();\r\n        try {\r\n            //when\r\n            validator.validate(new CallsRealMethods(), inovcationOnIterface);\r\n            //then\r\n            fail();\r\n        } catch (MockitoException e) {} // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.mockito.internal.stubbing.answers.AnswersValidatorTest.shouldFailWhenCallingRealMethodOnIterface(AnswersValidatorTest.java:99)", "buggy_method": "15 public void validate(Answer<?> answer, Invocation invocation) {\r\n16         if (answer instanceof ThrowsException) {\r\n17             validateException((ThrowsException) answer, invocation);\r\n18         }\r\n19         \r\n20         if (answer instanceof Returns) {\r\n21             validateReturnValue((Returns) answer, invocation);\r\n22         }\r\n23         \r\n24         if (answer instanceof DoesNothing) {\r\n25             validateDoNothing((DoesNothing) answer, invocation);\r\n26         }\r\n27         \r\n28     }", "bm_classpath": "org.mockito.internal.stubbing.answers.AnswersValidator"}, {"bug_name": "Mockito_38", "report_text": "> Generate change list separated by types using labels\n> \n> [![Coverage Status](https://camo.githubusercontent.com/857c50bfa0758ad3111b1ceaf303b69b318007970689e8e8a8afb4b6ad325959/68747470733a2f2f636f766572616c6c732e696f2f6275696c64732f313138383432302f6261646765)](https://coveralls.io/builds/1188420)\n> Changes Unknown when pulling **[47a7016](https://github.com/mockito/mockito/commit/47a701638ebf4673ed0f1c8680d4d8f9f79c4f6e) on szpak:topic/releaseLabels** into *\\* on mockito:master*\\*.", "test_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingToolTest::shouldWorkFineWhenGivenArgIsNull", "test_method": "    @Test\r\n    public void shouldWorkFineWhenGivenArgIsNull() {\r\n        //when\r\n        Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null}); // <-- fails here\n    }", "error_message": "java.lang.NullPointerException\n\torg.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(ArgumentMatchingTool.java:48)\n\torg.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(ArgumentMatchingTool.java:28)\n\torg.mockito.internal.verification.argumentmatching.ArgumentMatchingToolTest.shouldWorkFineWhenGivenArgIsNull(ArgumentMatchingToolTest.java:82)", "buggy_method": "47 private boolean toStringEquals(Matcher m, Object arg) {\r\n48         return StringDescription.toString(m).equals(arg.toString());\r\n49     }", "bm_classpath": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool"}, {"bug_name": "Time_1", "report_text": "> Partial.with fails with NPE\n> \n> With the latest master:\n> ```\n> new Partial(yearOfCentury(),  1).with(weekyear(), 1);\n> // NullPointerException\n> // org.joda.time.Partial.with (Partial.java:447)\n> ```\n> Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.", "test_name": "org.joda.time.TestPartial_Constructors::testConstructorEx7_TypeArray_intArray", "test_method": "    public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n        int[] values = new int[] {1, 1, 1};\n        DateTimeFieldType[] types = new DateTimeFieldType[] {\n            DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        }\n        \n        types = new DateTimeFieldType[] {\n            DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n        try {\n            new Partial(types, values);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.joda.time.TestPartial_Constructors.testConstructorEx7_TypeArray_intArray(TestPartial_Constructors.java:284)", "buggy_method": "189 public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n190         super();\n191         chronology = DateTimeUtils.getChronology(chronology).withUTC();\n192         iChronology = chronology;\n193         if (types == null) {\n194             throw new IllegalArgumentException(\"Types array must not be null\");\n195         }\n196         if (values == null) {\n197             throw new IllegalArgumentException(\"Values array must not be null\");\n198         }\n199         if (values.length != types.length) {\n200             throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n201         }\n202         if (types.length == 0) {\n203             iTypes = types;\n204             iValues = values;\n205             return;\n206         }\n207         for (int i = 0; i < types.length; i++) {\n208             if (types[i] == null) {\n209                 throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n210             }\n211         }\n212         DurationField lastUnitField = null;\n213         for (int i = 0; i < types.length; i++) {\n214             DateTimeFieldType loopType = types[i];\n215             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n216             if (i > 0) {\n217                 int compare = lastUnitField.compareTo(loopUnitField);\n218                 if (compare < 0) {\n219                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n220                             types[i - 1].getName() + \" < \" + loopType.getName());\n221                 } else if (compare == 0) {\n222                     if (types[i - 1].getRangeDurationType() == null) {\n223                         if (loopType.getRangeDurationType() == null) {\n224                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n225                                             types[i - 1].getName() + \" and \" + loopType.getName());\n226                         }\n227                     } else {\n228                         if (loopType.getRangeDurationType() == null) {\n229                             throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n230                                     types[i - 1].getName() + \" < \" + loopType.getName());\n231                         }\n232                         DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n233                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n234                         if (lastRangeField.compareTo(loopRangeField) < 0) {\n235                             throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n236                                     types[i - 1].getName() + \" < \" + loopType.getName());\n237                         }\n238                         if (lastRangeField.compareTo(loopRangeField) == 0) {\n239                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n240                                             types[i - 1].getName() + \" and \" + loopType.getName());\n241                         }\n242                     }\n243                 }\n244             }\n245             lastUnitField = loopUnitField;\n246         }\n247         \n248         iTypes = (DateTimeFieldType[]) types.clone();\n249         chronology.validate(this, values);\n250         iValues = (int[]) values.clone();\n251     }", "bm_classpath": "org.joda.time.Partial"}, {"bug_name": "Time_2", "report_text": "> Partial.with fails with NPE\n> \n> With the latest master:\n> ```\n> new Partial(yearOfCentury(),  1).with(weekyear(), 1);\n> // NullPointerException\n> // org.joda.time.Partial.with (Partial.java:447)\n> ```\n> Fails with yearOfCentury, year and yearOfEra. Probably because weekyear has a null range duration type.", "test_name": "org.joda.time.TestPartial_Basics::testWith_baseAndArgHaveNoRange", "test_method": "    public void testWith_baseAndArgHaveNoRange() {\n        Partial test = new Partial(DateTimeFieldType.year(), 1);\n        Partial result = test.with(DateTimeFieldType.era(), 1); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Types array must not contain duplicate: era and year\n\torg.joda.time.Partial.<init>(Partial.java:224)\n\torg.joda.time.Partial.with(Partial.java:466)\n\torg.joda.time.TestPartial_Basics.testWith_baseAndArgHaveNoRange(TestPartial_Basics.java:469)", "buggy_method": "189 public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n190         super();\n191         chronology = DateTimeUtils.getChronology(chronology).withUTC();\n192         iChronology = chronology;\n193         if (types == null) {\n194             throw new IllegalArgumentException(\"Types array must not be null\");\n195         }\n196         if (values == null) {\n197             throw new IllegalArgumentException(\"Values array must not be null\");\n198         }\n199         if (values.length != types.length) {\n200             throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n201         }\n202         if (types.length == 0) {\n203             iTypes = types;\n204             iValues = values;\n205             return;\n206         }\n207         for (int i = 0; i < types.length; i++) {\n208             if (types[i] == null) {\n209                 throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n210             }\n211         }\n212         DurationField lastUnitField = null;\n213         for (int i = 0; i < types.length; i++) {\n214             DateTimeFieldType loopType = types[i];\n215             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n216             if (i > 0) {\n217                 int compare = lastUnitField.compareTo(loopUnitField);\n218                 if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n219                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n220                             types[i - 1].getName() + \" < \" + loopType.getName());\n221                 } else if (compare == 0) {\n222                     if (types[i - 1].getRangeDurationType() == null) {\n223                         if (loopType.getRangeDurationType() == null) {\n224                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n225                                             types[i - 1].getName() + \" and \" + loopType.getName());\n226                         }\n227                     } else {\n228                         if (loopType.getRangeDurationType() == null) {\n229                             throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n230                                     types[i - 1].getName() + \" < \" + loopType.getName());\n231                         }\n232                         DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n233                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n234                         if (lastRangeField.compareTo(loopRangeField) < 0) {\n235                             throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n236                                     types[i - 1].getName() + \" < \" + loopType.getName());\n237                         }\n238                         if (lastRangeField.compareTo(loopRangeField) == 0) {\n239                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n240                                             types[i - 1].getName() + \" and \" + loopType.getName());\n241                         }\n242                     }\n243                 }\n244             }\n245             lastUnitField = loopUnitField;\n246         }\n247         \n248         iTypes = (DateTimeFieldType[]) types.clone();\n249         chronology.validate(this, values);\n250         iValues = (int[]) values.clone();\n251     }", "bm_classpath": "org.joda.time.Partial"}, {"bug_name": "Time_3", "report_text": "> addDays(0) changes value of MutableDateTime\n> \n> Upon DST transition from summer to winter time zone, adding the amount of zero days to a mutable date time object changes the value of the object.\n> The code\n> ```\n> final MutableDateTime mdt = new MutableDateTime(2011, 10, 30, 3, 0, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n> System.out.println(\"Start date: \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n> mdt.addHours(-1);\n> System.out.println(\"addHours(-1): \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n> mdt.addHours(0);\n> System.out.println(\"addHours(0): \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n> mdt.addDays(0);\n> System.out.println(\"addDays(0): \" + mdt + \" (\" + mdt.toInstant().getMillis() + \")\");\n> ```\n> prints\n> ```\n> Start date:   2011-10-30T03:00:00.000+01:00 (1319940000000)    //OK\n> addHours(-1): 2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK\n> addHours(0):  2011-10-30T02:00:00.000+01:00 (1319936400000)    //OK, no change in time\n> addDays(0):   2011-10-30T02:00:00.000+02:00 (1319932800000)    //error, time has changed by 1 hour\n> ```\n> The methods addMonths and addYears show the same problem; addSeconds, addMinutes and addHours are ok.\n> I have tested with version 2.3. However, if I repeat the test with Joda 1.5.2, the invocation of addDays(0) does not change the date's value.", "test_name": "org.joda.time.TestMutableDateTime_Adds::testAddYears_int_dstOverlapWinter_addZero", "test_method": "    public void testAddYears_int_dstOverlapWinter_addZero() {\n        MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n        test.addHours(1);\n        test.addYears(0);\n        assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...10-30T02:30:00.000+0[1]:00> but was:<...10-30T02:30:00.000+0[2]:00>\n\torg.joda.time.TestMutableDateTime_Adds.testAddYears_int_dstOverlapWinter_addZero(TestMutableDateTime_Adds.java:227)", "buggy_method": "635 public void add(DurationFieldType type, int amount) {\n636         if (type == null) {\n637             throw new IllegalArgumentException(\"Field must not be null\");\n638         }\n639             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n640     }", "bm_classpath": "org.joda.time.MutableDateTime"}, {"bug_name": "Time_4", "report_text": "> Constructing invalid Partials\n> \n> Partials can be constructed by invoking a constructor `Partial(DateTimeFieldType[], int[])` or by merging together a set of partials using `with`, each constructed by calling `Partial(DateTimeFieldType, int)`, e.g.:\n> ```\n> Partial a = new Partial(new DateTimeFieldType[] { year(), hourOfDay() }, new int[] { 1, 1});\n> Partial b = new Partial(year(), 1).with(hourOfDay(), 1);\n> assert(a == b);\n> ```\n> However, the above doesn't work in all cases:\n> ```\n> new Partial(new DateTimeFieldType[] { clockhourOfDay(), hourOfDay() }, new int[] { 1, 1}); // throws Types array must not contain duplicate\n> new Partial(clockhourOfDay(), 1).with(hourOfDay(), 1); // #<Partial [clockhourOfDay=1, hourOfDay=1]>\n> ```\n> I suppose the Partials should not allow to be constructed in either case. Is that right?\n> There's also a related issue (probably stems from the fact that the Partial is invalid):\n> ```\n> new Partial(clockhourOfDay(), 1).with(hourOfDay(), 1).isEqual(new Partial(hourOfDay() ,1).with(clockhourOfDay(), 1)) // throws objects must have matching field types\n> ```", "test_name": "org.joda.time.TestPartial_Basics::testWith3", "test_method": "    public void testWith3() {\n        Partial test = createHourMinPartial();\n        try {\n            test.with(DateTimeFieldType.clockhourOfDay(), 6);\n            fail();\n        } catch (IllegalArgumentException ex) {} // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.joda.time.TestPartial_Basics.testWith3(TestPartial_Basics.java:364)", "buggy_method": "426 public Partial with(DateTimeFieldType fieldType, int value) {\n427         if (fieldType == null) {\n428             throw new IllegalArgumentException(\"The field type must not be null\");\n429         }\n430         int index = indexOf(fieldType);\n431         if (index == -1) {\n432             DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n433             int[] newValues = new int[newTypes.length];\n434             \n435             // find correct insertion point to keep largest-smallest order\n436             int i = 0;\n437             DurationField unitField = fieldType.getDurationType().getField(iChronology);\n438             if (unitField.isSupported()) {\n439                 for (; i < iTypes.length; i++) {\n440                     DateTimeFieldType loopType = iTypes[i];\n441                     DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n442                     if (loopUnitField.isSupported()) {\n443                         int compare = unitField.compareTo(loopUnitField);\n444                         if (compare > 0) {\n445                             break;\n446                         } else if (compare == 0) {\n447                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n448                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n449                             if (rangeField.compareTo(loopRangeField) > 0) {\n450                                 break;\n451                             }\n452                         }\n453                     }\n454                 }\n455             }\n456             System.arraycopy(iTypes, 0, newTypes, 0, i);\n457             System.arraycopy(iValues, 0, newValues, 0, i);\n458             newTypes[i] = fieldType;\n459             newValues[i] = value;\n460             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n461             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n462             // use public constructor to ensure full validation\n463             // this isn't overly efficient, but is safe\n464             Partial newPartial = new Partial(iChronology, newTypes, newValues);\n465             iChronology.validate(newPartial, newValues);\n466             return newPartial;\n467         }\n468         if (value == getValue(index)) {\n469             return this;\n470         }\n471         int[] newValues = getValues();\n472         newValues = getField(index).set(this, index, newValues, value);\n473         return new Partial(this, newValues);\n474     }", "bm_classpath": "org.joda.time.Partial"}, {"bug_name": "Time_5", "report_text": "> none standard PeriodType without year throws exception\n> \n> Hi.\n> I tried to get a Period only for months and weeks with following code:\n> ```\n> Period p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()})).normalizedStandard(PeriodType.forFields(new DurationFieldType[]{DurationFieldType.months(), DurationFieldType.weeks()}));\n> return p.getMonths();\n> ```\n> This throws following exception:\n> ```\n>  10-17 14:35:50.999: E/AndroidRuntime(1350): java.lang.UnsupportedOperationException: Field is not supported\n>  10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.PeriodType.setIndexedField(PeriodType.java:690)\n>  10-17 14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.withYears(Period.java:896) 10-17\n>  14:35:50.999: E/AndroidRuntime(1350): at org.joda.time.Period.normalizedStandard(Period.java:1630)\n> ```\n> Even removing the year component with .withYearsRemoved() throws the same exception:\n> this works:\n> ```\n> Period p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard()).normalizedStandard(PeriodType.standard());\n> return p.getMonths();\n> ```\n> this fails:\n> ```\n> Period p = new Period(new DateTime(startDate.getTime()), new DateTime(endDate.getTime()), PeriodType.standard().withYearsRemoved()).normalizedStandard(PeriodType.standard().withYearsRemoved());\n> return p.getMonths();\n> ```", "test_name": "org.joda.time.TestPeriod_Basics::testNormalizedStandard_periodType_months1", "test_method": "    public void testNormalizedStandard_periodType_months1() {\n        Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n        Period result = test.normalizedStandard(PeriodType.months()); // <-- fails here\n    }", "error_message": "java.lang.UnsupportedOperationException: Field is not supported\n\torg.joda.time.PeriodType.setIndexedField(PeriodType.java:690)\n\torg.joda.time.Period.withYears(Period.java:896)\n\torg.joda.time.Period.normalizedStandard(Period.java:1631)\n\torg.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months1(TestPeriod_Basics.java:1522)", "buggy_method": "1616 public Period normalizedStandard(PeriodType type) {\n1617         type = DateTimeUtils.getPeriodType(type);\n1618         long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n1619         millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n1620         millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n1621         millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n1622         millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n1623         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n1624         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n1625         int years = getYears();\n1626         int months = getMonths();\n1627         if (years != 0 || months != 0) {\n1628             years = FieldUtils.safeAdd(years, months / 12);\n1629             months = months % 12;\n1630             if (years != 0) {\n1631                 result = result.withYears(years);\n1632             }\n1633             if (months != 0) {\n1634                 result = result.withMonths(months);\n1635             }\n1636         }\n1637         return result;\n1638     }", "bm_classpath": "org.joda.time.Period"}, {"bug_name": "Time_6", "report_text": "> Questionable behaviour of GJChronology when dates pass 1BC\n> \n> I expect the following test to pass:\n> ```\n> Chronology chronology = GJChronology.getInstance();\n> LocalDate start = new LocalDate(2013, 5, 31, chronology);\n> LocalDate expectedEnd = new LocalDate(-1, 5, 31, chronology); // 1 BC\n> assertThat(start.minusYears(2013), is(equalTo(expectedEnd)));\n> assertThat(start.plus(Period.years(-2013)), is(equalTo(expectedEnd)));\n> ```\n> The error it gives is:\n> ```\n> org.joda.time.IllegalFieldValueException: Value 0 for year is not supported\n> ```\n> However, I never provided \"0\" for the year myself. I thought it was the job of the framework to skip over non-existent year 0 for me to return 1 BC?", "test_name": "org.joda.time.chrono.TestGJDate::test_cutoverPreZero", "test_method": "    public void test_cutoverPreZero() {\n        DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC);\n        try {\n            GJChronology.getInstance(DateTimeZone.UTC, cutover);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // expected\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.joda.time.chrono.TestGJDate.test_cutoverPreZero(TestGJDate.java:132)", "buggy_method": "185 public static synchronized GJChronology getInstance(\n186             DateTimeZone zone,\n187             ReadableInstant gregorianCutover,\n188             int minDaysInFirstWeek) {\n189         \n190         zone = DateTimeUtils.getZone(zone);\n191         Instant cutoverInstant;\n192         if (gregorianCutover == null) {\n193             cutoverInstant = DEFAULT_CUTOVER;\n194         } else {\n195             cutoverInstant = gregorianCutover.toInstant();\n196         }\n197 \n198         GJChronology chrono;\n199         synchronized (cCache) {\n200             ArrayList<GJChronology> chronos = cCache.get(zone);\n201             if (chronos == null) {\n202                 chronos = new ArrayList<GJChronology>(2);\n203                 cCache.put(zone, chronos);\n204             } else {\n205                 for (int i = chronos.size(); --i >= 0;) {\n206                     chrono = chronos.get(i);\n207                     if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n208                         cutoverInstant.equals(chrono.getGregorianCutover())) {\n209                         \n210                         return chrono;\n211                     }\n212                 }\n213             }\n214             if (zone == DateTimeZone.UTC) {\n215                 chrono = new GJChronology\n216                     (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n217                      GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n218                      cutoverInstant);\n219             } else {\n220                 chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n221                 chrono = new GJChronology\n222                     (ZonedChronology.getInstance(chrono, zone),\n223                      chrono.iJulianChronology,\n224                      chrono.iGregorianChronology,\n225                      chrono.iCutoverInstant);\n226             }\n227             chronos.add(chrono);\n228         }\n229         return chrono;\n230     }", "bm_classpath": "org.joda.time.chrono.GJChronology"}, {"bug_name": "Time_7", "report_text": "> DateTimeFormat.parseInto sometimes miscalculates year (2.2)\n> \n> There appears to be a bug in the fix to <http://sourceforge.net/p/joda-time/bugs/148> (which I also reported).\n> The following code (which can be added to org.joda.time.format.TestDateTimeFormatter) breaks, because the input mutable date time's millis appear to be mishandled and the year for the parse is changed to 1999:\n> ```\n>     public void testParseInto\\_monthDay\\_feb29\\_startOfYear() {\n>         DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n>         MutableDateTime result = new MutableDateTime(2000, 1, 1, 0, 0, 0, 0, NEWYORK);\n>         assertEquals(4, f.parseInto(result, \"2 29\", 0));\n>         assertEquals(new MutableDateTime(2000, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n>     }\n> ```", "test_name": "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthDay_feb29_newYork_startOfYear", "test_method": "    public void testParseInto_monthDay_feb29_newYork_startOfYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);\n        assertEquals(4, f.parseInto(result, \"2 29\", 0)); // <-- fails here\n    }", "error_message": "org.joda.time.IllegalFieldValueException: Cannot parse \"2 29\": Value 29 for dayOfMonth must be in the range [1,28]\n\torg.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\n\torg.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n\torg.joda.time.format.DateTimeParserBucket$SavedField.set(DateTimeParserBucket.java:483)\n\torg.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:366)\n\torg.joda.time.format.DateTimeParserBucket.computeMillis(DateTimeParserBucket.java:359)\n\torg.joda.time.format.DateTimeFormatter.parseInto(DateTimeFormatter.java:715)\n\torg.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork_startOfYear(TestDateTimeFormatter.java:932)", "buggy_method": "700 public int parseInto(ReadWritableInstant instant, String text, int position) {\n701         DateTimeParser parser = requireParser();\n702         if (instant == null) {\n703             throw new IllegalArgumentException(\"Instant must not be null\");\n704         }\n705         \n706         long instantMillis = instant.getMillis();\n707         Chronology chrono = instant.getChronology();\n708         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n709         chrono = selectChronology(chrono);\n710         int defaultYear = chrono.year().get(instantLocal);\n711         \n712         DateTimeParserBucket bucket = new DateTimeParserBucket(\n713             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n714         int newPos = parser.parseInto(bucket, text, position);\n715         instant.setMillis(bucket.computeMillis(false, text));\n716         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n717             int parsedOffset = bucket.getOffsetInteger();\n718             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n719             chrono = chrono.withZone(parsedZone);\n720         } else if (bucket.getZone() != null) {\n721             chrono = chrono.withZone(bucket.getZone());\n722         }\n723         instant.setChronology(chrono);\n724         if (iZone != null) {\n725             instant.setZone(iZone);\n726         }\n727         return newPos;\n728     }", "bm_classpath": "org.joda.time.format.DateTimeFormatter"}, {"bug_name": "Time_8", "report_text": "> DateTimeZone.forOffsetHoursMinutes cannot handle negative offset < 1 hour\n> \n> `DateTimeZone.forOffsetHoursMinutes(h,m)` cannot handle negative offset < 1 hour like `-0:30` due to argument range checking. I used `forOffsetMillis()` instead.\n> This should probably be mentioned in the documentation or negative minutes be accepted.", "test_name": "org.joda.time.TestDateTimeZone::testForOffsetHoursMinutes_int_int", "test_method": "    public void testForOffsetHoursMinutes_int_int() {\n        \n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, -15);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        \n        assertEquals(DateTimeZone.forID(\"-00:15\"), DateTimeZone.forOffsetHoursMinutes(0, -15)); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Minutes out of range: -15\n\torg.joda.time.DateTimeZone.forOffsetHoursMinutes(DateTimeZone.java:280)\n\torg.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int(TestDateTimeZone.java:316)", "buggy_method": "272 public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n273         if (hoursOffset == 0 && minutesOffset == 0) {\n274             return DateTimeZone.UTC;\n275         }\n276         if (hoursOffset < -23 || hoursOffset > 23) {\n277             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n278         }\n279         if (minutesOffset < 0 || minutesOffset > 59) {\n280             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n281         }\n282         int offset = 0;\n283         try {\n284             int hoursInMinutes = hoursOffset * 60;\n285             if (hoursInMinutes < 0) {\n286                 minutesOffset = hoursInMinutes - minutesOffset;\n287             } else {\n288                 minutesOffset = hoursInMinutes + minutesOffset;\n289             }\n290             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n291         } catch (ArithmeticException ex) {\n292             throw new IllegalArgumentException(\"Offset is too large\");\n293         }\n294         return forOffsetMillis(offset);\n295     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_9", "report_text": "> Ensure there is a max/min valid offset\n> \n> `DateTimeZone` does not apply a max/min value for an offset. However the parse method is limited to 23:59. Make 23:59:59.999 the maximum.", "test_name": "org.joda.time.TestDateTimeZone::testForOffsetHoursMinutes_int_int", "test_method": "    public void testForOffsetHoursMinutes_int_int() {\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-2, 60);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(2, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(-2, -1);\n            fail();\n        } catch (IllegalArgumentException ex) {}\n        try {\n            DateTimeZone.forOffsetHoursMinutes(24, 0);\n            fail();\n        } catch (IllegalArgumentException ex) {} // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int(TestDateTimeZone.java:328)", "buggy_method": "254 public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n255         if (hoursOffset == 0 && minutesOffset == 0) {\n256             return DateTimeZone.UTC;\n257         }\n258         if (minutesOffset < 0 || minutesOffset > 59) {\n259             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n260         }\n261         int offset = 0;\n262         try {\n263             int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n264             if (hoursInMinutes < 0) {\n265                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n266             } else {\n267                 minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n268             }\n269             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n270         } catch (ArithmeticException ex) {\n271             throw new IllegalArgumentException(\"Offset is too large\");\n272         }\n273         return forOffsetMillis(offset);\n274     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_10", "report_text": "> Days#daysBetween throw exception for MonthDay with 29 February\n> \n> final LocalDate january12012 = new LocalDate(2012, 1,1);  \n> final LocalDate february292012 = new LocalDate(2012, 2, 29);  \n> // OK  \n> assertEquals(59, Days.daysBetween(january12012, february292012).getDays());\n> final MonthDay january1 = new MonthDay(1,1);  \n> final MonthDay february29 = new MonthDay(2, 29);  \n> // FAIL  \n> assertEquals(59, Days.daysBetween(january1, february29).getDays());\n> org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]  \n> at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:217)  \n> at org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)  \n> at org.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)  \n> at org.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:103)  \n> at org.joda.time.Days.daysBetween(Days.java:141)\n> Is there a way to avoid this happening? I understand fiddling around with the leap year, you're bound to get issues.\n> Thanks!", "test_name": "org.joda.time.TestDays::testFactory_daysBetween_RPartial_MonthDay", "test_method": "    public void testFactory_daysBetween_RPartial_MonthDay() {\n        MonthDay start1 = new MonthDay(2, 1);\n        MonthDay start2 = new MonthDay(2, 28);\n        MonthDay end1 = new MonthDay(2, 28);\n        MonthDay end2 = new MonthDay(2, 29);\n        \n        assertEquals(28, Days.daysBetween(start1, end2).getDays()); // <-- fails here\n    }", "error_message": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n\torg.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:220)\n\torg.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n\torg.joda.time.chrono.BaseChronology.set(BaseChronology.java:240)\n\torg.joda.time.base.BaseSingleFieldPeriod.between(BaseSingleFieldPeriod.java:104)\n\torg.joda.time.Days.daysBetween(Days.java:141)\n\torg.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay(TestDays.java:130)", "buggy_method": "88 protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n89         if (start == null || end == null) {\n90             throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n91         }\n92         if (start.size() != end.size()) {\n93             throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n94         }\n95         for (int i = 0, isize = start.size(); i < isize; i++) {\n96             if (start.getFieldType(i) != end.getFieldType(i)) {\n97                 throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n98             }\n99         }\n100         if (DateTimeUtils.isContiguous(start) == false) {\n101             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n102         }\n103         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n104         int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n105         return values[0];\n106     }", "bm_classpath": "org.joda.time.base.BaseSingleFieldPeriod"}, {"bug_name": "Time_12", "report_text": "> Check Calendar.ERA in LocalDate.fromCalendarFields\n> \n> No description provided.", "test_name": "org.joda.time.TestLocalDateTime_Constructors::testFactory_fromDateFields_beforeYearZero1", "test_method": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n        assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime())); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>\n\torg.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero1(TestLocalDateTime_Constructors.java:155)", "buggy_method": "206 public static LocalDate fromCalendarFields(Calendar calendar) {\n207         if (calendar == null) {\n208             throw new IllegalArgumentException(\"The calendar must not be null\");\n209         }\n210         int yearOfEra = calendar.get(Calendar.YEAR);\n211         return new LocalDate(\n212             yearOfEra,\n213             calendar.get(Calendar.MONTH) + 1,\n214             calendar.get(Calendar.DAY_OF_MONTH)\n215         );\n216     }", "bm_classpath": "org.joda.time.LocalDate"}, {"bug_name": "Time_13", "report_text": "> #160 Negative millis display incorrectly in Period.toString\n> \n> This code:\n> import org.joda.time.Duration;  \n> import org.joda.time.Period;  \n> public class A {  \n> public static void main(String[] args) {  \n> System.out.println(\"new Duration(-1000).getMillis() = \" + new Duration(-1000).getMillis());  \n> System.out.println(\"new Duration(-1000).toString() = \" + new Duration(-1000).toString());  \n> System.out.println(\"new Period(-1000).getSeconds() = \" + new Period(-1000).getSeconds());  \n> System.out.println(\"new Period(-1000).toString() = \" + new Period(-1000).toString());  \n> System.out.println(\"new Duration(-100).getMillis() = \" + new Duration(-100).getMillis());  \n> System.out.println(\"new Duration(-100).toString() = \" + new Duration(-100).toString());  \n> System.out.println(\"new Period(-100).getMillis() = \" + new Period(-100).getMillis());  \n> System.out.println(\"new Period(-100).toString() = \" + new Period(-100).toString());  \n> }  \n> }\n> Produces output:\n> new Duration(-1000).getMillis() = -1000  \n> new Duration(-1000).toString() = PT-1S  \n> new Period(-1000).getSeconds() = -1  \n> new Period(-1000).toString() = PT-1S  \n> new Duration(-100).getMillis() = -100  \n> new Duration(-100).toString() = PT-0.100S  \n> new Period(-100).getMillis() = -100  \n> new Period(-100).toString() = PT0.100S\n> The last line should produce \"PT-0.100S\" instead of \"PT0.100S\".", "test_name": "org.joda.time.format.TestISOPeriodFormat::testFormatStandard_negative", "test_method": "    public void testFormatStandard_negative() {\n        Period p = new Period(-1, -2, -3, -4, -5, -6, -7, -8);\n        \n        p = Period.years(-54);\n        \n        p = Period.seconds(4).withMillis(-8);\n        \n        p = Period.seconds(-4).withMillis(8);\n        \n        p = Period.seconds(-23);\n        \n        p = Period.millis(-8);\n        assertEquals(\"PT-0.008S\", ISOPeriodFormat.standard().print(p)); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<PT[-]0.008S> but was:<PT[]0.008S>\n\torg.joda.time.format.TestISOPeriodFormat.testFormatStandard_negative(TestISOPeriodFormat.java:135)", "buggy_method": "1088 public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n1089             long valueLong = getFieldValue(period);\n1090             if (valueLong == Long.MAX_VALUE) {\n1091                 return 0;\n1092             }\n1093 \n1094             int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n1095             if (iFieldType >= SECONDS_MILLIS) {\n1096                 // valueLong contains the seconds and millis fields\n1097                 // the minimum output is 0.000, which is 4 or 5 digits with a negative\n1098                 sum = Math.max(sum, 4);\n1099                 // plus one for the decimal point\n1100                 sum++;\n1101                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n1102                         (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n1103                     sum -= 4; // remove three digits and decimal point\n1104                 }\n1105                 // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n1106                 valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n1107             }\n1108             int value = (int) valueLong;\n1109 \n1110             if (iPrefix != null) {\n1111                 sum += iPrefix.calculatePrintedLength(value);\n1112             }\n1113             if (iSuffix != null) {\n1114                 sum += iSuffix.calculatePrintedLength(value);\n1115             }\n1116 \n1117             return sum;\n1118         }", "bm_classpath": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter"}, {"bug_name": "Time_14", "report_text": "> #151 Unable to add days to a MonthDay set to the ISO leap date\n> \n> It's not possible to add days to a MonthDay set to the ISO leap date (February 29th). This is even more bizarre given the exact error message thrown.\n> Sample snippet:\n> ```\n> final MonthDay isoLeap = new MonthDay(DateTimeConstants.FEBRUARY, 29, ISOChronology.getInstanceUTC());\n> System.out.println(isoLeap);\n> System.out.println(isoLeap.plusDays(2));\n> ```\n> Which generates the following combined console output and stack trace: \n> --02-29  \n> Exception in thread \"main\" org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]  \n> at org.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:215)  \n> at org.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)  \n> at org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(BasicMonthOfYearDateTimeField.java:212)  \n> at org.joda.time.field.BaseDateTimeField.add(BaseDateTimeField.java:324)  \n> at org.joda.time.MonthDay.withFieldAdded(MonthDay.java:519)  \n> at org.joda.time.MonthDay.minusDays(MonthDay.java:672)  \n> at ext.site.time.chrono.Main.m7(Main.java:191)  \n> at ext.site.time.chrono.Main.main(Main.java:27)\n> The follwing method calls and parameters also generate the same or related error: \n> ```\n> isoLeap.plusMonths(1);\n> isoLeap.plusMonths(-1);\n> isoLeap.minusMonths(1);\n> isoLeap.minusMonths(-1);\n> isoLeap.minusDays(-1);\n> ```\n> However, the following methods work: \n> ```\n> isoLeap.minusDays(1);\n> isoLeap.plusDays(-1);\n> ```\n> Performing operations on dates around the ISO leap date react as if it exists, ie:\n> ```\n> System.out.println(isoLeap.minusDays(1).plusDays(2));\n> ```\n> Prints out '--03-01' as expected.", "test_name": "org.joda.time.TestMonthDay_Basics::testPlusMonths_int_negativeFromLeap", "test_method": "    public void testPlusMonths_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(-1); // <-- fails here\n    }", "error_message": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n\torg.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:218)\n\torg.joda.time.field.PreciseDurationDateTimeField.set(PreciseDurationDateTimeField.java:78)\n\torg.joda.time.chrono.BasicMonthOfYearDateTimeField.add(BasicMonthOfYearDateTimeField.java:213)\n\torg.joda.time.MonthDay.withFieldAdded(MonthDay.java:519)\n\torg.joda.time.MonthDay.plusMonths(MonthDay.java:592)\n\torg.joda.time.TestMonthDay_Basics.testPlusMonths_int_negativeFromLeap(TestMonthDay_Basics.java:460)", "buggy_method": "203 public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n204         // overridden as superclass algorithm can't handle\n205         // 2004-02-29 + 48 months -> 2008-02-29 type dates\n206         if (valueToAdd == 0) {\n207             return values;\n208         }\n209             // month is largest field and being added to, such as month-day\n210         if (DateTimeUtils.isContiguous(partial)) {\n211             long instant = 0L;\n212             for (int i = 0, isize = partial.size(); i < isize; i++) {\n213                 instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n214             }\n215             instant = add(instant, valueToAdd);\n216             return iChronology.get(partial, instant);\n217         } else {\n218             return super.add(partial, fieldIndex, values, valueToAdd);\n219         }\n220     }", "bm_classpath": "org.joda.time.chrono.BasicMonthOfYearDateTimeField"}, {"bug_name": "Time_15", "report_text": "> #147 possibly a bug in org.joda.time.field.FieldUtils.safeMultipl\n> \n> It seems to me that as currently written in joda-time-2.1.jar  \n> org.joda.time.field.FieldUtils.safeMultiply(long val1, int scalar)  \n> doesn't detect the overflow if the long val1 == Long.MIN\\_VALUE and the int scalar == -1.\n> The attached file demonstrates what I think is the bug and suggests a patch.\n> I looked at the Joda Time bugs list in SourceForge but couldn't see anything that looked relevant: my apologies if I've missed something, or if I'm making a mistake with this bug report.\n> Colin Bartlett", "test_name": "org.joda.time.field.TestFieldUtils::testSafeMultiplyLongInt", "test_method": "    public void testSafeMultiplyLongInt() {\n        \n        \n        \n        \n        \n        try {\n            FieldUtils.safeMultiply(Long.MIN_VALUE, -1);\n            fail();\n        } catch (ArithmeticException e) {\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError\n\torg.joda.time.field.TestFieldUtils.testSafeMultiplyLongInt(TestFieldUtils.java:261)", "buggy_method": "135 public static long safeMultiply(long val1, int val2) {\n136         switch (val2) {\n137             case -1:\n138                 return -val1;\n139             case 0:\n140                 return 0L;\n141             case 1:\n142                 return val1;\n143         }\n144         long total = val1 * val2;\n145         if (total / val2 != val1) {\n146           throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n147         }\n148         return total;\n149     }", "bm_classpath": "org.joda.time.field.FieldUtils"}, {"bug_name": "Time_16", "report_text": "> #148 DateTimeFormatter.parseInto broken when no year in format\n> \n> In Joda Time 2.0, the default year was set to 2000 so that Feb 29 could be parsed correctly. However, parseInto now overwrites the given instant's year with 2000 (or whatever iDefaultYear is set to). The correct behavior would seem to be to use the given instant's year instead of iDefaultYear.  \n> This does mean that Feb 29 might not be parseable if the instant's year is not a leap year, but in this case the caller asked for that in a sense.", "test_name": "org.joda.time.format.TestDateTimeFormatter::testParseInto_monthOnly_baseStartYear", "test_method": "    public void testParseInto_monthOnly_baseStartYear() {\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n        MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);\n        assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2004-05-01T12:20:30.000+09:00> but was:<2000-05-01T12:20:30.000+09:00>\n\torg.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly_baseStartYear(TestDateTimeFormatter.java:877)", "buggy_method": "697 public int parseInto(ReadWritableInstant instant, String text, int position) {\n698         DateTimeParser parser = requireParser();\n699         if (instant == null) {\n700             throw new IllegalArgumentException(\"Instant must not be null\");\n701         }\n702         \n703         long instantMillis = instant.getMillis();\n704         Chronology chrono = instant.getChronology();\n705         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n706         chrono = selectChronology(chrono);\n707         \n708         DateTimeParserBucket bucket = new DateTimeParserBucket(\n709             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n710         int newPos = parser.parseInto(bucket, text, position);\n711         instant.setMillis(bucket.computeMillis(false, text));\n712         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n713             int parsedOffset = bucket.getOffsetInteger();\n714             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n715             chrono = chrono.withZone(parsedZone);\n716         } else if (bucket.getZone() != null) {\n717             chrono = chrono.withZone(bucket.getZone());\n718         }\n719         instant.setChronology(chrono);\n720         if (iZone != null) {\n721             instant.setZone(iZone);\n722         }\n723         return newPos;\n724     }", "bm_classpath": "org.joda.time.format.DateTimeFormatter"}, {"bug_name": "Time_17", "report_text": "> #141 Bug on withLaterOffsetAtOverlap method\n> \n> The method withLaterOffsetAtOverlap created to workaround the issue 3192457 seems to not be working at all.  \n> I won\u00b4t write many info about the problem to solve because the issue 3192457 have this info indeed.  \n> But If something is unclear I can answer on the comments.\n> Problem demonstration:  \n> TimeZone.setDefault(TimeZone.getTimeZone(\"America/Sao\\_Paulo\"));  \n> DateTimeZone.setDefault( DateTimeZone.forID(\"America/Sao\\_Paulo\") );\n> ```\n>     DateTime dtch;\n>     {\n>         dtch = new DateTime(2012,2,25,5,5,5,5).millisOfDay().withMaximumValue();\n>         System.out.println( dtch ); // prints: 2012-02-25T23:59:59.999-02:00 //Were are at the first 23:** of the day.\n>         //At this point dtch have the -03:00 offset\n>     }\n>     {\n>         dtch = dtch.plus(60001);\n>         System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-03:00 //Were are at the first minute of the second 23:** of the day. Ok its correct\n>         //At this point dtch have the -03:00 offset\n>     }\n>     {\n>         dtch = dtch.withEarlierOffsetAtOverlap();\n>         System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-02:00 //Were are at the first minute of the first 23:** of the day. Ok its correct\n>         //At this point dtch have the -02:00 offset ( because we called withEarlierOffsetAtOverlap() ) // This method is working perfectly\n>     }       \n>     {\n>         dtch = dtch.withLaterOffsetAtOverlap();\n>         System.out.println( dtch ); // prints: 2012-02-25T23:01:00.000-02:00 //Were are at the first minute of the first 23:** of the day. \n>         // Here is the problem we should have a -03:00 offset here since we called withLaterOffsetAtOverlap() expecting to change to the second 23:** of the day\n>     }\n> ```\n> On the last two brackets we can see that withLaterOffsetAtOverlap is not undoing withEarlierOffsetAtOverlap as it should ( and not even working at all )", "test_name": "org.joda.time.TestDateTimeZoneCutover::testBug3476684_adjustOffset", "test_method": "    public void testBug3476684_adjustOffset() {\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n        \n        \n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap()); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>\n\torg.joda.time.TestDateTimeZoneCutover.testBug3476684_adjustOffset(TestDateTimeZoneCutover.java:1259)", "buggy_method": "1163 public long adjustOffset(long instant, boolean earlierOrLater) {\n1164         // a bit messy, but will work in all non-pathological cases\n1165         \n1166         // evaluate 3 hours before and after to work out if anything is happening\n1167         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n1168         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n1169         if (instantBefore == instantAfter) {\n1170             return instant;  // not an overlap (less than is a gap, equal is normal case)\n1171         }\n1172         \n1173         // work out range of instants that have duplicate local times\n1174         long local = convertUTCToLocal(instant);\n1175         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n1176         \n1177         // calculate result\n1178           // currently in later offset\n1179           // currently in earlier offset\n1180     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_18", "report_text": "> #130 GJChronology rejects valid Julian dates\n> \n> Example:\n> DateTime jdt = new DateTime(1500, 2, 29, 0, 0, 0, 0, JulianChronology.getInstanceUTC()); // Valid.  \n> DateTime gjdt = new DateTime(1500, 2, 29, 0, 0, 0, 0, GJChronology.getInstanceUTC()); // Invalid.\n> The 2nd statement fails with \"org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\".\n> Given that I left the cutover date at the default (October 15, 1582), isn't 1500/02/29 a valid date in the GJChronology?", "test_name": "org.joda.time.chrono.TestGJChronology::testLeapYearRulesConstruction", "test_method": "    public void testLeapYearRulesConstruction() {\n        // 1500 not leap in Gregorian, but is leap in Julian\n        DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC()); // <-- fails here\n    }", "error_message": "org.joda.time.IllegalFieldValueException: Value 29 for dayOfMonth must be in the range [1,28]\n\torg.joda.time.field.FieldUtils.verifyValueBounds(FieldUtils.java:233)\n\torg.joda.time.chrono.BasicChronology.getDateMidnightMillis(BasicChronology.java:605)\n\torg.joda.time.chrono.BasicChronology.getDateTimeMillis(BasicChronology.java:177)\n\torg.joda.time.chrono.GregorianChronology.getDateTimeMillis(GregorianChronology.java:45)\n\torg.joda.time.chrono.GJChronology.getDateTimeMillis(GJChronology.java:364)\n\torg.joda.time.base.BaseDateTime.<init>(BaseDateTime.java:254)\n\torg.joda.time.DateMidnight.<init>(DateMidnight.java:343)\n\torg.joda.time.chrono.TestGJChronology.testLeapYearRulesConstruction(TestGJChronology.java:496)", "buggy_method": "350 public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n351                                   int hourOfDay, int minuteOfHour,\n352                                   int secondOfMinute, int millisOfSecond)\n353         throws IllegalArgumentException\n354     {\n355         Chronology base;\n356         if ((base = getBase()) != null) {\n357             return base.getDateTimeMillis\n358                 (year, monthOfYear, dayOfMonth,\n359                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n360         }\n361 \n362         // Assume date is Gregorian.\n363         long instant;\n364             instant = iGregorianChronology.getDateTimeMillis\n365                 (year, monthOfYear, dayOfMonth,\n366                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n367         if (instant < iCutoverMillis) {\n368             // Maybe it's Julian.\n369             instant = iJulianChronology.getDateTimeMillis\n370                 (year, monthOfYear, dayOfMonth,\n371                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n372             if (instant >= iCutoverMillis) {\n373                 // Okay, it's in the illegal cutover gap.\n374                 throw new IllegalArgumentException(\"Specified date does not exist\");\n375             }\n376         }\n377         return instant;\n378     }", "bm_classpath": "org.joda.time.chrono.GJChronology"}, {"bug_name": "Time_19", "report_text": "> #124 Inconsistent interpretation of ambiguous time during DST\n> \n> The inconsistency appears for timezone Europe/London.\n> Consider the following code  \n> \u2026  \n> DateTime britishDate = new DateTime(2011, 10, 30, 1, 59, 0, 0, DateTimeZone.forID(\"Europe/London\"));  \n> DateTime norwDate = new DateTime(2011, 10, 30, 2, 59, 0, 0, DateTimeZone.forID(\"Europe/Oslo\"));  \n> DateTime finnishDate = new DateTime(2011, 10, 30, 3, 59, 0, 0, DateTimeZone.forID(\"Europe/Helsinki\"));\n> ```\n>     System.out.println(britishDate);\n>     System.out.println(norwDate);\n>     System.out.println(finnishDate);\n> ```\n> \u2026  \n> These three DateTime objects should all represent the same moment in time even if they are ambiguous. And using jodatime 1.6.2 this is the case. The code produces the following output:  \n> 2011-10-30T01:59:00.000Z  \n> 2011-10-30T02:59:00.000+01:00  \n> 2011-10-30T03:59:00.000+02:00\n> Using jodatime 2.0 however, the output is:\n> 2011-10-30T01:59:00.000Z  \n> 2011-10-30T02:59:00.000+02:00  \n> 2011-10-30T03:59:00.000+03:00\n> which IMO is wrong for Europe/London. Correct output should have been   \n> 2011-10-30T01:59:00.000+01:00\n> The release notes for 2.0 states that:   \n> \"Now, it always returns the earlier instant (summer time) during an overlap. \u2026\"", "test_name": "org.joda.time.TestDateTimeZoneCutover::testDateTimeCreation_london", "test_method": "    public void testDateTimeCreation_london() {\n        DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n        DateTime base = new DateTime(2011, 10, 30, 1, 15, zone);\n        assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...1-10-30T01:15:00.000[+01:00]> but was:<...1-10-30T01:15:00.000[Z]>\n\torg.joda.time.TestDateTimeZoneCutover.testDateTimeCreation_london(TestDateTimeZoneCutover.java:1266)", "buggy_method": "880 public int getOffsetFromLocal(long instantLocal) {\n881         // get the offset at instantLocal (first estimate)\n882         final int offsetLocal = getOffset(instantLocal);\n883         // adjust instantLocal using the estimate and recalc the offset\n884         final long instantAdjusted = instantLocal - offsetLocal;\n885         final int offsetAdjusted = getOffset(instantAdjusted);\n886         // if the offsets differ, we must be near a DST boundary\n887         if (offsetLocal != offsetAdjusted) {\n888             // we need to ensure that time is always after the DST gap\n889             // this happens naturally for positive offsets, but not for negative\n890             if ((offsetLocal - offsetAdjusted) < 0) {\n891                 // if we just return offsetAdjusted then the time is pushed\n892                 // back before the transition, whereas it should be\n893                 // on or after the transition\n894                 long nextLocal = nextTransition(instantAdjusted);\n895                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n896                 if (nextLocal != nextAdjusted) {\n897                     return offsetLocal;\n898                 }\n899             }\n900         } else if (offsetLocal > 0) {\n901             long prev = previousTransition(instantAdjusted);\n902             if (prev < instantAdjusted) {\n903                 int offsetPrev = getOffset(prev);\n904                 int diff = offsetPrev - offsetLocal;\n905                 if (instantAdjusted - prev <= diff) {\n906                     return offsetPrev;\n907                 }\n908             }\n909         }\n910         return offsetAdjusted;\n911     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_20", "report_text": "> #126 Errors creating/parsing dates with specific time zones.\n> \n> Consider the following test code using Joda 2.0\n> import org.joda.time.DateTime;  \n> import org.joda.time.DateTimeZone;  \n> import org.joda.time.format.DateTimeFormat;  \n> import org.joda.time.format.DateTimeFormatter;\n> import java.util.Set;\n> public class JodaDateTimeZoneTester {\n> ```\n> private static DateTimeFormatter formatter = DateTimeFormat.forPattern(\"MM/dd/yyyy HH:mm:ss.SSS ZZZ\");\n> private static int numTimeZonesTested = 0;\n> private static int numTimeZonesPassed = 0;\n> private static int numTimeZonesFailed = 0;\n> private static int numTimeZonesException = 0;\n> private static String convertDateTimeToFormattedString(DateTime dateTime) {\n>     return formatter.print(dateTime);\n> }\n> private static DateTime parseStringToDateTime(String formattedDateTime) {\n>     return formatter.parseDateTime(formattedDateTime);\n> }\n> private static void testDateTimeFormatter(DateTime dateTime, String timeZone) {\n>     numTimeZonesTested++;\n>     final String dateTimeZoneId = dateTime.getZone().getID();\n>     if (!timeZone.equals(dateTimeZoneId)) {\n>         numTimeZonesFailed++;\n>         System.out.println(timeZone + \" failed to construct into the proper date time zone - constructed time zone = \" + dateTimeZoneId);\n>         return;\n>     }\n>     try {\n>         DateTime convertedDateTime = parseStringToDateTime(convertDateTimeToFormattedString(dateTime));\n>         if (dateTime.equals(convertedDateTime)) {\n>             numTimeZonesPassed++;\n>             //System.out.println(dateTime.getZone().getID() + \" passed.\");\n>         } else {\n>             numTimeZonesFailed++;\n>             System.out.println(\"Formatter failed for time zone ID: \" + dateTimeZoneId + \"    converted it to: \" + convertedDateTime.getZone().getID());\n>  }\n>  } catch (IllegalArgumentException iae) {\n>  numTimeZonesException++;\n>  System.out.println(\"Formatter threw exception for time zone id: \" + dateTimeZoneId);\n>  }\n> }\n> public static void main(String[] args) {\n>  Set<String> timeZones = DateTimeZone.getAvailableIDs();\n>  for (String timeZone : timeZones) {\n>  testDateTimeFormatter(DateTime.now().withZone(DateTimeZone.forID(timeZone)), timeZone);\n>  }\n>  System.out.println();\n>  System.out.println(\"Number of Time Zones tested: \" + numTimeZonesTested);\n>  System.out.println(\"Number passed:     \" + numTimeZonesPassed);\n>  System.out.println(\"Number failed:     \" + numTimeZonesFailed);\n>  System.out.println(\"Number exceptions: \" + numTimeZonesException);\n>     System.out.println();\n> }\n> ```\n> }\n> The results are out of 572 time zones 130 fail and 30 throw exceptions. \n> The failures are the most interesting. When I query DateTimeZone to get its time zone ids I will get a time zone like America/Atka. When I take that id and create a date time with it its time zone id is America/Adak. It is like there are multiple list of time zones in Joda time and they are out of sync. \n> Source code is attached. ", "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder::test_printParseZoneDawsonCreek", "test_method": "    public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n        DateTimeFormatter f = bld.toFormatter();\n        \n        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\")); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\"\n\torg.joda.time.format.DateTimeFormatter.parseDateTime(DateTimeFormatter.java:866)\n\torg.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek(TestDateTimeFormatterBuilder.java:262)", "buggy_method": "2540 public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n2541             String str = text.substring(position);\n2542             for (String id : ALL_IDS) {\n2543                 if (str.startsWith(id)) {\n2544                     bucket.setZone(DateTimeZone.forID(id));\n2545                     return position + id.length();\n2546                 }\n2547             }\n2548             return ~position;\n2549         }", "bm_classpath": "org.joda.time.format.DateTimeFormatterBuilder"}, {"bug_name": "Time_22", "report_text": "> #113 Duration.toPeriod with fixed time zones.\n> \n> I have a question concerning the conversion of a Duration to Period. I'm not sure if this is a bug, or if there is a different way to do this.\n> The basis of the problem, is that using Duration.toPeriod() uses the chronology of the default time zone to do the conversion. This can cause different results from a timezone with DST and one without. This can be reproduced easily with this test.\n> ```\n> //set default time zone with this argument -Duser.timezone=\"GMT\"\n> public void testForJodaForum()\n> {\n>     System.out.println(\"Timezone: \" + DateTimeZone.getDefault());\n>  //Duration of more than 24 hours\n>  Duration aDuration = new Duration(DateTimeConstants.MILLIS\\_PER\\_HOUR \\* 30 + DateTimeConstants.MILLIS\\_PER\\_MINUTE \\* 50\n>  + DateTimeConstants.MILLIS\\_PER\\_SECOND \\* 14);\n>  System.out.println(\"Duration before: \" + aDuration);\n>  Period period = aDuration.toPeriod();\n>  System.out.println(\"Period after: \" + period);        \n> }\n> ```\n> A fixed time zone produces this output  \n> Timezone: Etc/GMT  \n> Duration before: PT111014S  \n> Period after: P1DT6H50M14S\n> A DST time zone produces this output  \n> Timezone: America/Chicago  \n> Duration before: PT111014S  \n> Period after: PT30H50M14S\n> In the joda code, Duration.toPeriod() uses a period constructor that takes the chronology, but null is passed in, so the chronology of the default time zone is used, which leads to this behavior.\n> The javadoc of toPeriod() states that only precise fields of hours, minutes, seconds, and millis will be converted. But for a fixed timezone, days and weeks are also precise, which is stated in the javadoc for toPeriod(Chronology chrono). In our app, we need consistent behavior regardless of the default time zone, which is to have all the extra hours put into the hours bucket. Since Duration is supposed to be a 'time zone independent' length of time, I don't think we should have to do any chronology manipulation to get this to work.\n> Any help is appreciated.\n> Thanks,  \n> Cameron", "test_name": "org.joda.time.TestDuration_Basics::testToPeriod_fixedZone", "test_method": "    public void testToPeriod_fixedZone() throws Throwable {\n        DateTimeZone zone = DateTimeZone.getDefault();\n        try {\n            DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n            long length =\n                (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n                5L * DateTimeConstants.MILLIS_PER_HOUR +\n                6L * DateTimeConstants.MILLIS_PER_MINUTE +\n                7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n            Duration dur = new Duration(length);\n            Period test = dur.toPeriod();\n            assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n            assertEquals(0, test.getMonths());\n            assertEquals(0, test.getWeeks());\n            assertEquals(0, test.getDays());\n            assertEquals((450 * 24) + 5, test.getHours());\n            assertEquals(6, test.getMinutes());\n            assertEquals(7, test.getSeconds());\n            assertEquals(8, test.getMillis());\n        } finally {\n            DateTimeZone.setDefault(zone);\n        } // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<0> but was:<64>\n\torg.joda.time.TestDuration_Basics.testToPeriod_fixedZone(TestDuration_Basics.java:483)", "buggy_method": "221 protected BasePeriod(long duration) {\n222         this(duration, null, null);\n223         // bug [3264409]\n224     }", "bm_classpath": "org.joda.time.base.BasePeriod"}, {"bug_name": "Time_23", "report_text": "> #112 Incorrect mapping of the MET time zone\n> \n> This timezone is mapped to Asia/Tehran in DateTimeZone. It should be middle europena time.\n> I know that this bug has been raised before (Incorrect mapping of the MET time zone - ID: 2012274), and there is a comment stating that you won't break backward compatibility to fix this bug.\n> 1. I disagree that this is a backward compatibility argument\n> 2. No matter how you look at it, it is a bug.\n> You could very well state that ALL bugs won't be fixed, because of backward compatibility.\n> I request again that this bug be fixed.", "test_name": "org.joda.time.TestDateTimeZone::testForID_String_old", "test_method": "    public void testForID_String_old() {\n        Map<String, String> map = new LinkedHashMap<String, String>();\n        map.put(\"GMT\", \"UTC\");\n        map.put(\"WET\", \"WET\");\n        map.put(\"CET\", \"CET\");\n        map.put(\"MET\", \"CET\");\n        map.put(\"ECT\", \"CET\");\n        map.put(\"EET\", \"EET\");\n        map.put(\"MIT\", \"Pacific/Apia\");\n        map.put(\"HST\", \"Pacific/Honolulu\");\n        map.put(\"AST\", \"America/Anchorage\");\n        map.put(\"PST\", \"America/Los_Angeles\");\n        map.put(\"MST\", \"America/Denver\");\n        map.put(\"PNT\", \"America/Phoenix\");\n        map.put(\"CST\", \"America/Chicago\");\n        map.put(\"EST\", \"America/New_York\");\n        map.put(\"IET\", \"America/Indiana/Indianapolis\");\n        map.put(\"PRT\", \"America/Puerto_Rico\");\n        map.put(\"CNT\", \"America/St_Johns\");\n        map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        map.put(\"BET\", \"America/Sao_Paulo\");\n        map.put(\"ART\", \"Africa/Cairo\");\n        map.put(\"CAT\", \"Africa/Harare\");\n        map.put(\"EAT\", \"Africa/Addis_Ababa\");\n        map.put(\"NET\", \"Asia/Yerevan\");\n        map.put(\"PLT\", \"Asia/Karachi\");\n        map.put(\"IST\", \"Asia/Kolkata\");\n        map.put(\"BST\", \"Asia/Dhaka\");\n        map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n        map.put(\"CTT\", \"Asia/Shanghai\");\n        map.put(\"JST\", \"Asia/Tokyo\");\n        map.put(\"ACT\", \"Australia/Darwin\");\n        map.put(\"AET\", \"Australia/Sydney\");\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        for (String key : map.keySet()) {\n            String value = map.get(key);\n            TimeZone juZone = TimeZone.getTimeZone(key);\n            DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\n            assertEquals(value, zone.getID());\n//            System.out.println(juZone);\n//            System.out.println(juZone.getDisplayName());\n//            System.out.println(zone);\n//            System.out.println(\"------\");\n        } // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<[WET]> but was:<[Europe/London]>\n\torg.joda.time.TestDateTimeZone.testForID_String_old(TestDateTimeZone.java:282)", "buggy_method": "558 private static synchronized String getConvertedId(String id) {\n559         Map<String, String> map = cZoneIdConversion;\n560         if (map == null) {\n561             // Backwards compatibility with TimeZone.\n562             map = new HashMap<String, String>();\n563             map.put(\"GMT\", \"UTC\");\n564             map.put(\"MIT\", \"Pacific/Apia\");\n565             map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n566             map.put(\"AST\", \"America/Anchorage\");\n567             map.put(\"PST\", \"America/Los_Angeles\");\n568             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n569             map.put(\"PNT\", \"America/Phoenix\");\n570             map.put(\"CST\", \"America/Chicago\");\n571             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n572             map.put(\"IET\", \"America/Indianapolis\");\n573             map.put(\"PRT\", \"America/Puerto_Rico\");\n574             map.put(\"CNT\", \"America/St_Johns\");\n575             map.put(\"AGT\", \"America/Buenos_Aires\");\n576             map.put(\"BET\", \"America/Sao_Paulo\");\n577             map.put(\"WET\", \"Europe/London\");\n578             map.put(\"ECT\", \"Europe/Paris\");\n579             map.put(\"ART\", \"Africa/Cairo\");\n580             map.put(\"CAT\", \"Africa/Harare\");\n581             map.put(\"EET\", \"Europe/Bucharest\");\n582             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n583             map.put(\"MET\", \"Asia/Tehran\");\n584             map.put(\"NET\", \"Asia/Yerevan\");\n585             map.put(\"PLT\", \"Asia/Karachi\");\n586             map.put(\"IST\", \"Asia/Calcutta\");\n587             map.put(\"BST\", \"Asia/Dhaka\");\n588             map.put(\"VST\", \"Asia/Saigon\");\n589             map.put(\"CTT\", \"Asia/Shanghai\");\n590             map.put(\"JST\", \"Asia/Tokyo\");\n591             map.put(\"ACT\", \"Australia/Darwin\");\n592             map.put(\"AET\", \"Australia/Sydney\");\n593             map.put(\"SST\", \"Pacific/Guadalcanal\");\n594             map.put(\"NST\", \"Pacific/Auckland\");\n595             cZoneIdConversion = map;\n596         }\n597         return map.get(id);\n598     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_24", "report_text": "> #107 Incorrect date parsed when week and month used together\n> \n> I have following code snippet :\n> ```\n>     DateTimeFormatter dtf = DateTimeFormat.forPattern(\"xxxxMM'w'ww\");\n> DateTime dt = dtf.parseDateTime(\"201101w01\");       \n> System.out.println(dt);\n> ```\n> It should print 2011-01-03 but it is printing 2010-01-04.   \n> Please let me know if I am doing something wrong here. ", "test_name": "org.joda.time.format.TestDateTimeFormatter::testParseLocalDate_weekyear_month_week_2010", "test_method": "    public void testParseLocalDate_weekyear_month_week_2010() {\n        Chronology chrono = GJChronology.getInstanceUTC();\n        DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\")); // <-- fails here\n    }", "error_message": "junit.framework.AssertionFailedError: expected:<2010-01-04> but was:<2008-12-29>\n\torg.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2010(TestDateTimeFormatter.java:428)", "buggy_method": "331 public long computeMillis(boolean resetFields, String text) {\n332         SavedField[] savedFields = iSavedFields;\n333         int count = iSavedFieldsCount;\n334         if (iSavedFieldsShared) {\n335             iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n336             iSavedFieldsShared = false;\n337         }\n338         sort(savedFields, count);\n339         if (count > 0) {\n340             // alter base year for parsing if first field is month or day\n341             DurationField months = DurationFieldType.months().getField(iChrono);\n342             DurationField days = DurationFieldType.days().getField(iChrono);\n343             DurationField first = savedFields[0].iField.getDurationField();\n344             if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n345                 saveField(DateTimeFieldType.year(), iDefaultYear);\n346                 return computeMillis(resetFields, text);\n347             }\n348         }\n349 \n350         long millis = iMillis;\n351         try {\n352             for (int i = 0; i < count; i++) {\n353                 millis = savedFields[i].set(millis, resetFields);\n354             }\n355         } catch (IllegalFieldValueException e) {\n356             if (text != null) {\n357                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n358             }\n359             throw e;\n360         }\n361         \n362         if (iZone == null) {\n363             millis -= iOffset;\n364         } else {\n365             int offset = iZone.getOffsetFromLocal(millis);\n366             millis -= offset;\n367             if (offset != iZone.getOffset(millis)) {\n368                 String message =\n369                     \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n370                 if (text != null) {\n371                     message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n372                 }\n373                 throw new IllegalArgumentException(message);\n374             }\n375         }\n376         \n377         return millis;\n378     }", "bm_classpath": "org.joda.time.format.DateTimeParserBucket"}, {"bug_name": "Time_25", "report_text": "> #90 DateTimeZone.getOffsetFromLocal error during DST transition\n> \n> This may be a failure of my understanding, but the comments in DateTimeZone.getOffsetFromLocal lead me to believe that if an ambiguous local time is given, the offset corresponding to the later of the two possible UTC instants will be returned - i.e. the greater offset.\n> This doesn't appear to tally with my experience. In fall 2009, America/Los\\_Angeles changed from -7 to -8 at 2am wall time on November 11. Thus 2am became 1am - so 1:30am is ambiguous. I would therefore expect that constructing a DateTime for November 11th, 1:30am would give an instant corresponding with the later value (i.e. 9:30am UTC). This appears not to be the case:\n> import org.joda.time.DateTime;  \n> import org.joda.time.DateTimeZone;\n> public class TzTest {  \n> public static void main(String[] args) throws Exception {  \n> DateTimeZone zone = DateTimeZone.forID(\"America/Los\\_Angeles\");  \n> DateTime when1 = new DateTime(2009, 11, 1, 0, 30, 0, 0, zone);  \n> DateTime when2 = new DateTime(2009, 11, 1, 1, 30, 0, 0, zone);  \n> DateTime when3 = new DateTime(2009, 11, 1, 2, 30, 0, 0, zone);  \n> System.out.println(when1);  \n> System.out.println(when2);  \n> System.out.println(when3);  \n> }  \n> }\n> Results:\n> 2009-11-01T00:30:00.000-07:00 // Correct  \n> 2009-11-01T01:30:00.000-07:00 // Should be -08:00  \n> 2009-11-01T02:30:00.000-08:00 // Correct", "test_name": "org.joda.time.TestDateTimeZoneCutover::test_DateTime_constructor_Moscow_Autumn", "test_method": "    public void test_DateTime_constructor_Moscow_Autumn() {\r\n        DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\r\n        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...10-28T02:30:00.000+0[4]:00> but was:<...10-28T02:30:00.000+0[3]:00>\n\torg.joda.time.TestDateTimeZoneCutover.test_DateTime_constructor_Moscow_Autumn(TestDateTimeZoneCutover.java:922)", "buggy_method": "879 public int getOffsetFromLocal(long instantLocal) {\n880         // get the offset at instantLocal (first estimate)\n881         final int offsetLocal = getOffset(instantLocal);\n882         // adjust instantLocal using the estimate and recalc the offset\n883         final long instantAdjusted = instantLocal - offsetLocal;\n884         final int offsetAdjusted = getOffset(instantAdjusted);\n885         // if the offsets differ, we must be near a DST boundary\n886         if (offsetLocal != offsetAdjusted) {\n887             // we need to ensure that time is always after the DST gap\n888             // this happens naturally for positive offsets, but not for negative\n889             if ((offsetLocal - offsetAdjusted) < 0) {\n890                 // if we just return offsetAdjusted then the time is pushed\n891                 // back before the transition, whereas it should be\n892                 // on or after the transition\n893                 long nextLocal = nextTransition(instantAdjusted);\n894                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n895                 if (nextLocal != nextAdjusted) {\n896                     return offsetLocal;\n897                 }\n898             }\n899         }\n900         return offsetAdjusted;\n901     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_26", "report_text": "> #60 .withHourOfDay() sets hour inconsistantly on DST transition.\n> \n> When the hour of day is set to the ambiguous hour on the daylight to  \n> standard time transition in a given time zone the result is inconsistent for different time zones. Shoul the hour be set to the  \n> daylight hour or the standard hour for all time zones? I can't find anything  \n> that documents this behavior.\n> My test code below returns different results for different time zones.\n> / *Verify Joda converts the hour of day the same for regions north and  \n> south of the equator on the DST* daylight to standard time transition.  \n> \\*/  \n> @Test  \n> public void jodaTest ()  \n> {  \n> Chronology chronUTC =  \n> GregorianChronology.getInstance(DateTimeZone.UTC);\n> DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0,  \n> 0, chronUTC);  \n> DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0,  \n> 0, chronUTC);\n> Chronology chronUSCentral =  \n> GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n> Assert.assertTrue(\"Should be standard time\",  \n> chronUSCentral.getZone().isStandardOffset(  \n> usCentralStandardInUTC.getMillis()));  \n> Assert.assertFalse(\"Should be daylight time\",  \n> chronUSCentral.getZone().isStandardOffset(  \n> usCentralDaylightInUTC.getMillis()));\n> DateTime usCentralStandardInUSCentral =  \n> usCentralStandardInUTC.toDateTime(chronUSCentral);  \n> DateTime usCentralDaylightInUSCentral =  \n> usCentralDaylightInUTC.toDateTime(chronUSCentral);  \n> assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());  \n> assertEquals(usCentralStandardInUSCentral.getHourOfDay(),  \n> usCentralDaylightInUSCentral.getHourOfDay());  \n> Assert.assertTrue(usCentralStandardInUSCentral.getMillis() !=  \n> usCentralDaylightInUSCentral.getMillis());\n> DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0,  \n> 0, 0, chronUTC);  \n> DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0,  \n> 0, 0, chronUTC);\n> Chronology chronAusNSW =  \n> GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n> Assert.assertTrue(\"Should be standard time\",  \n> chronAusNSW.getZone().isStandardOffset(  \n> australiaNSWStandardInUTC.getMillis()));  \n> Assert.assertFalse(\"Should be daylight time\",  \n> chronAusNSW.getZone().isStandardOffset(  \n> australiaNSWDaylightInUTC.getMillis()));\n> DateTime australiaNSWStandardInAustraliaNSW =  \n> australiaNSWStandardInUTC.toDateTime(chronAusNSW);  \n> DateTime australiaNSWDaylightInAusraliaNSW =  \n> australiaNSWDaylightInUTC.toDateTime(chronAusNSW);  \n> assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());  \n> assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(),  \n> australiaNSWDaylightInAusraliaNSW.getHourOfDay());  \n> Assert.assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() !=  \n> australiaNSWDaylightInAusraliaNSW.getMillis());\n> // Verify that setting the hour of day on the DST boundary results  \n> in a daylight time for  \n> // both time zones.  \n> assertEquals(usCentralDaylightInUSCentral,  \n> usCentralStandardInUSCentral.withHourOfDay(1));  \n> assertEquals(australiaNSWDaylightInAusraliaNSW,  \n> australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n> }\n> The very last assertion fails on the Australia time zone cutover.  \n> java.lang.AssertionError: expected:<2008-04-06T02:00:00.000+11:00> but  \n> was:<2008-04-06T02:00:00.000+10:00>", "test_name": "org.joda.time.TestDateTimeZoneCutover::testWithSecondOfMinuteInDstChange", "test_method": "    public void testWithSecondOfMinuteInDstChange() {\r\n        DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\r\n        DateTime test = dateTime.withSecondOfMinute(0);\r\n        assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString()); // <-- fails here\n    }", "error_message": "junit.framework.ComparisonFailure: expected:<...10-31T02:30:00.123+0[2]:00> but was:<...10-31T02:30:00.123+0[1]:00>\n\torg.joda.time.TestDateTimeZoneCutover.testWithSecondOfMinuteInDstChange(TestDateTimeZoneCutover.java:1101)", "buggy_method": "936 public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n937         int offsetOriginal = getOffset(originalInstantUTC);\n938         long instantUTC = instantLocal - offsetOriginal;\n939         int offsetLocalFromOriginal = getOffset(instantUTC);\n940         if (offsetLocalFromOriginal == offsetOriginal) {\n941             return instantUTC;\n942         }\n943         return convertLocalToUTC(instantLocal, strict);\n944     }", "bm_classpath": "org.joda.time.DateTimeZone"}, {"bug_name": "Time_27", "report_text": "> #64 Different behaviour of PeriodFormatter\n> \n> PeriodFormatter pfmt2 = pfmtbuilder2.append(ISOPeriodFormat.standard() ).toFormatter(); is not the same as   \n> PeriodFormatterBuilder pfmtbuilder1 = new PeriodFormatterBuilder()  \n> .appendLiteral(\"P\")  \n> .appendYears()  \n> .appendSuffix(\"Y\")  \n> .appendMonths()  \n> .appendSuffix(\"M\")  \n> .appendWeeks()  \n> .appendSuffix(\"W\")  \n> .appendDays()  \n> .appendSuffix(\"D\")  \n> .appendSeparatorIfFieldsAfter(\"T\")  \n> .appendHours()  \n> .appendSuffix(\"H\")  \n> .appendMinutes()  \n> .appendSuffix(\"M\")  \n> .appendSecondsWithOptionalMillis()  \n> .appendSuffix(\"S\");\n> which is copied from ISOPeriodFormat.standard() method", "test_name": "org.joda.time.format.TestPeriodFormatterBuilder::testBug2495455", "test_method": "    public void testBug2495455() {\n        PeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n            .appendLiteral(\"P\")\n            .appendYears()\n            .appendSuffix(\"Y\")\n            .appendMonths()\n            .appendSuffix(\"M\")\n            .appendWeeks()\n            .appendSuffix(\"W\")\n            .appendDays()\n            .appendSuffix(\"D\")\n            .appendSeparatorIfFieldsAfter(\"T\")\n            .appendHours()\n            .appendSuffix(\"H\")\n            .appendMinutes()\n            .appendSuffix(\"M\")\n            .appendSecondsWithOptionalMillis()\n            .appendSuffix(\"S\")\n            .toFormatter();\n        PeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n            .append(ISOPeriodFormat.standard())\n            .toFormatter();\n        pfmt1.parsePeriod(\"PT1003199059S\");\n        pfmt2.parsePeriod(\"PT1003199059S\"); // <-- fails here\n    }", "error_message": "java.lang.IllegalArgumentException: Invalid format: \"PT1003199059S\" is malformed at \"1003199059S\"\n\torg.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:326)\n\torg.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:304)\n\torg.joda.time.format.TestPeriodFormatterBuilder.testBug2495455(TestPeriodFormatterBuilder.java:869)", "buggy_method": "794 private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n795         if (notPrinter && notParser) {\n796             throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n797         }\n798         int size = elementPairs.size();\n799         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n800             Separator sep = (Separator) elementPairs.get(0);\n801                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n802                 sep = sep.finish(f.getPrinter(), f.getParser());\n803                 return new PeriodFormatter(sep, sep);\n804         }\n805         Object[] comp = createComposite(elementPairs);\n806         if (notPrinter) {\n807             return new PeriodFormatter(null, (PeriodParser) comp[1]);\n808         } else if (notParser) {\n809             return new PeriodFormatter((PeriodPrinter) comp[0], null);\n810         } else {\n811             return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n812         }\n813     }", "bm_classpath": "org.joda.time.format.PeriodFormatterBuilder"}]